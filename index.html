<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MATEUSMUSTE // OS</title>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script src="https://cdn.tailwindcss.com"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Geist:wght@400;700;900&family=Geist+Mono:wght@400;700&display=swap"
        rel="stylesheet">

    <style>
        :root {
            --bg: #e5e5e5;
            --fg: #000000;
        }

        body {
            background-color: var(--bg);
            color: var(--fg);
            font-family: 'Geist', sans-serif;
            overflow: hidden;
            margin: 0;
            padding: 0;
            user-select: none;
            -webkit-font-smoothing: antialiased;
        }

        .font-mono {
            font-family: 'Geist Mono', monospace;
        }

        /* Brutalist Styles */
        .window-shadow {
            box-shadow: 10px 10px 0px 0px #000000;
        }

        .icon-shadow {
            box-shadow: 4px 4px 0px 0px #000000;
        }

        .btn-shadow {
            box-shadow: 2px 2px 0px 0px #000000;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }

        ::-webkit-scrollbar-track {
            background: #fff;
            border-left: 2px solid #000;
            border-top: 2px solid #000;
        }

        ::-webkit-scrollbar-thumb {
            background: #000;
            border: 2px solid #fff;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #333;
        }

        /* Background Pattern */
        .desktop-bg {
            background-color: #f0f0f0;
            background-image: radial-gradient(#aaa 1px, transparent 1px);
            background-size: 20px 20px;
        }

        canvas {
            touch-action: none;
        }
    </style>
</head>

<body>

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- PIXEL ART ICONS (64x64) ---
        const PixelIcon = ({ children, size = 64, ...props }) => (
            <svg {...props} width={size} height={size} viewBox="0 0 64 64" fill="none" style={{ imageRendering: 'pixelated' }}>
                {children}
            </svg>
        );

        const Icons = {
            // System Info - Monitor with info screen
            Terminal: (p) => (
                <PixelIcon {...p}>
                    <rect x="8" y="8" width="48" height="36" fill="#000" />
                    <rect x="12" y="12" width="40" height="28" fill="#fff" />
                    <rect x="16" y="16" width="32" height="4" fill="#000" />
                    <rect x="16" y="24" width="24" height="4" fill="#000" />
                    <rect x="16" y="32" width="16" height="4" fill="#000" />
                    <rect x="24" y="44" width="16" height="4" fill="#000" />
                    <rect x="20" y="48" width="24" height="8" fill="#000" />
                </PixelIcon>
            ),
            // Media Library - Stack of folders
            Folder: (p) => (
                <PixelIcon {...p}>
                    <rect x="8" y="20" width="48" height="36" fill="#000" />
                    <rect x="12" y="24" width="40" height="28" fill="#fff" />
                    <rect x="8" y="16" width="20" height="8" fill="#000" />
                    <rect x="12" y="12" width="12" height="8" fill="#000" />
                    <rect x="16" y="32" width="28" height="4" fill="#000" />
                    <rect x="16" y="40" width="20" height="4" fill="#000" />
                </PixelIcon>
            ),
            // Paint - Paint bucket icon
            Palette: (p) => (
                <PixelIcon {...p}>
                    {/* Bucket body */}
                    <rect x="12" y="20" width="40" height="32" fill="#000" />
                    <rect x="16" y="24" width="32" height="24" fill="#fff" />
                    {/* Handle */}
                    <rect x="8" y="8" width="4" height="16" fill="#000" />
                    <rect x="8" y="4" width="24" height="4" fill="#000" />
                    <rect x="28" y="8" width="4" height="8" fill="#000" />
                    {/* Paint drip */}
                    <rect x="44" y="28" width="8" height="12" fill="#000" />
                    <rect x="48" y="40" width="8" height="8" fill="#000" />
                    <rect x="52" y="48" width="8" height="8" fill="#000" />
                    {/* Rim */}
                    <rect x="8" y="16" width="48" height="4" fill="#000" />
                </PixelIcon>
            ),
            // Snake Game - Pixel snake
            Snek: (p) => (
                <PixelIcon {...p}>
                    <rect x="8" y="24" width="8" height="8" fill="#000" />
                    <rect x="16" y="24" width="8" height="8" fill="#000" />
                    <rect x="24" y="24" width="8" height="8" fill="#000" />
                    <rect x="32" y="24" width="8" height="8" fill="#000" />
                    <rect x="32" y="32" width="8" height="8" fill="#000" />
                    <rect x="32" y="40" width="8" height="8" fill="#000" />
                    <rect x="40" y="40" width="8" height="8" fill="#000" />
                    <rect x="48" y="40" width="8" height="8" fill="#000" />
                    <rect x="4" y="20" width="4" height="4" fill="#000" />
                    <rect x="4" y="28" width="4" height="4" fill="#000" />
                    <rect x="52" y="48" width="8" height="8" fill="#fff" stroke="#000" strokeWidth="2" />
                </PixelIcon>
            ),
            // Trash Can - Desktop trash
            TrashCan: (p) => (
                <PixelIcon {...p}>
                    <rect x="12" y="8" width="40" height="8" fill="#000" />
                    <rect x="20" y="4" width="24" height="8" fill="#000" />
                    <rect x="16" y="16" width="32" height="40" fill="#000" />
                    <rect x="20" y="20" width="24" height="32" fill="#fff" />
                    <rect x="24" y="24" width="4" height="24" fill="#000" />
                    <rect x="30" y="24" width="4" height="24" fill="#000" />
                    <rect x="36" y="24" width="4" height="24" fill="#000" />
                </PixelIcon>
            ),
            // Undo arrow
            Undo: (p) => (
                <PixelIcon {...p}>
                    <rect x="8" y="24" width="8" height="8" fill="#000" />
                    <rect x="16" y="16" width="8" height="8" fill="#000" />
                    <rect x="24" y="8" width="8" height="8" fill="#000" />
                    <rect x="16" y="32" width="32" height="8" fill="#000" />
                    <rect x="40" y="40" width="8" height="16" fill="#000" />
                </PixelIcon>
            ),
            // Redo arrow
            Redo: (p) => (
                <PixelIcon {...p}>
                    <rect x="48" y="24" width="8" height="8" fill="#000" />
                    <rect x="40" y="16" width="8" height="8" fill="#000" />
                    <rect x="32" y="8" width="8" height="8" fill="#000" />
                    <rect x="16" y="32" width="32" height="8" fill="#000" />
                    <rect x="16" y="40" width="8" height="16" fill="#000" />
                </PixelIcon>
            ),
            // File icon for trash items
            FileDoc: (p) => (
                <PixelIcon {...p}>
                    <rect x="12" y="4" width="32" height="56" fill="#000" />
                    <rect x="16" y="8" width="24" height="48" fill="#fff" />
                    <rect x="20" y="16" width="16" height="4" fill="#000" />
                    <rect x="20" y="24" width="16" height="4" fill="#000" />
                    <rect x="20" y="32" width="12" height="4" fill="#000" />
                </PixelIcon>
            ),
            X: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>,
            Minus: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line></svg>,
            Square: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect></svg>,
            Trash: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>,
            Send: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>,
            // Media folder icons
            Movies: (p) => (
                <PixelIcon {...p}>
                    <rect x="8" y="12" width="48" height="40" fill="#000" />
                    <rect x="12" y="16" width="40" height="32" fill="#fff" />
                    <rect x="8" y="8" width="12" height="8" fill="#000" />
                    <polygon points="24,24 24,40 40,32" fill="#000" />
                </PixelIcon>
            ),
            Books: (p) => (
                <PixelIcon {...p}>
                    <rect x="8" y="12" width="48" height="40" fill="#000" />
                    <rect x="12" y="16" width="40" height="32" fill="#fff" />
                    <rect x="8" y="8" width="12" height="8" fill="#000" />
                    <rect x="20" y="22" width="24" height="4" fill="#000" />
                    <rect x="20" y="30" width="16" height="4" fill="#000" />
                    <rect x="20" y="38" width="20" height="4" fill="#000" />
                </PixelIcon>
            ),
            Games: (p) => (
                <PixelIcon {...p}>
                    <rect x="8" y="12" width="48" height="40" fill="#000" />
                    <rect x="12" y="16" width="40" height="32" fill="#fff" />
                    <rect x="8" y="8" width="12" height="8" fill="#000" />
                    <rect x="20" y="24" width="8" height="8" fill="#000" />
                    <rect x="36" y="24" width="8" height="8" fill="#000" />
                    <rect x="24" y="36" width="16" height="4" fill="#000" />
                </PixelIcon>
            ),
            Music: (p) => (
                <PixelIcon {...p}>
                    <rect x="8" y="12" width="48" height="40" fill="#000" />
                    <rect x="12" y="16" width="40" height="32" fill="#fff" />
                    <rect x="8" y="8" width="12" height="8" fill="#000" />
                    <rect x="36" y="20" width="4" height="20" fill="#000" />
                    <rect x="28" y="36" width="12" height="8" fill="#000" />
                    <rect x="36" y="20" width="12" height="8" fill="#000" />
                </PixelIcon>
            ),
            Back: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M19 12H5M12 19l-7-7 7-7" /></svg>,
            // New App Icons
            Void: (p) => (
                <PixelIcon {...p}>
                    <rect x="8" y="8" width="48" height="48" fill="#000" />
                    <rect x="12" y="12" width="40" height="40" fill="#fff" />
                    <rect x="16" y="16" width="32" height="4" fill="#000" />
                    <rect x="16" y="24" width="24" height="4" fill="#333" />
                    <rect x="16" y="32" width="28" height="4" fill="#666" />
                    <rect x="16" y="40" width="16" height="4" fill="#999" />
                </PixelIcon>
            ),
            Oracle: (p) => (
                <PixelIcon {...p}>
                    <rect x="20" y="4" width="24" height="8" fill="#000" />
                    <rect x="16" y="12" width="32" height="8" fill="#000" />
                    <rect x="12" y="20" width="40" height="24" fill="#000" />
                    <rect x="16" y="24" width="32" height="16" fill="#fff" />
                    <rect x="24" y="28" width="6" height="6" fill="#000" />
                    <rect x="34" y="28" width="6" height="6" fill="#000" />
                    <rect x="12" y="44" width="12" height="12" fill="#000" />
                    <rect x="40" y="44" width="12" height="12" fill="#000" />
                </PixelIcon>
            ),
            Radio: (p) => (
                <PixelIcon {...p}>
                    <rect x="8" y="16" width="48" height="36" fill="#000" />
                    <rect x="12" y="20" width="40" height="28" fill="#fff" />
                    <rect x="16" y="24" width="16" height="16" fill="#000" />
                    <rect x="20" y="28" width="8" height="8" fill="#fff" />
                    <rect x="36" y="24" width="12" height="4" fill="#000" />
                    <rect x="36" y="32" width="12" height="4" fill="#000" />
                    <rect x="28" y="4" width="4" height="16" fill="#000" />
                    <rect x="24" y="4" width="12" height="4" fill="#000" />
                </PixelIcon>
            ),
            Dice: (p) => (
                <PixelIcon {...p}>
                    <rect x="8" y="8" width="48" height="48" fill="#000" />
                    <rect x="12" y="12" width="40" height="40" fill="#fff" />
                    <rect x="20" y="20" width="8" height="8" fill="#000" />
                    <rect x="36" y="20" width="8" height="8" fill="#000" />
                    <rect x="28" y="28" width="8" height="8" fill="#000" />
                    <rect x="20" y="36" width="8" height="8" fill="#000" />
                    <rect x="36" y="36" width="8" height="8" fill="#000" />
                </PixelIcon>
            ),
            Labyrinth: (p) => (
                <PixelIcon {...p}>
                    {/* Outer border */}
                    <rect x="4" y="4" width="56" height="56" fill="#000" />
                    <rect x="8" y="8" width="48" height="48" fill="#fff" />
                    {/* Maze walls - more complex pattern */}
                    <rect x="8" y="8" width="4" height="32" fill="#000" />
                    <rect x="8" y="8" width="24" height="4" fill="#000" />
                    <rect x="16" y="16" width="4" height="24" fill="#000" />
                    <rect x="24" y="16" width="20" height="4" fill="#000" />
                    <rect x="24" y="24" width="4" height="20" fill="#000" />
                    <rect x="32" y="28" width="16" height="4" fill="#000" />
                    <rect x="40" y="8" width="4" height="24" fill="#000" />
                    <rect x="48" y="16" width="4" height="28" fill="#000" />
                    <rect x="32" y="40" width="20" height="4" fill="#000" />
                    <rect x="8" y="48" width="28" height="4" fill="#000" />
                    {/* Player marker */}
                    <rect x="10" y="10" width="4" height="4" fill="#000" />
                    {/* Exit marker */}
                    <rect x="50" y="50" width="4" height="4" fill="#000" />
                </PixelIcon>
            ),
            Synth: (p) => (
                <PixelIcon {...p}>
                    <rect x="4" y="16" width="56" height="36" fill="#000" />
                    <rect x="8" y="20" width="48" height="28" fill="#333" />
                    <rect x="12" y="24" width="8" height="16" fill="#fff" />
                    <rect x="22" y="24" width="8" height="16" fill="#fff" />
                    <rect x="32" y="24" width="8" height="16" fill="#fff" />
                    <rect x="42" y="24" width="8" height="16" fill="#fff" />
                    <rect x="16" y="24" width="4" height="10" fill="#000" />
                    <rect x="26" y="24" width="4" height="10" fill="#000" />
                    <rect x="46" y="24" width="4" height="10" fill="#000" />
                </PixelIcon>
            ),
            Destruction: (p) => (
                <PixelIcon {...p}>
                    {/* Skull top */}
                    <rect x="16" y="4" width="32" height="8" fill="#fff" />
                    <rect x="12" y="12" width="40" height="8" fill="#fff" />
                    <rect x="8" y="20" width="48" height="16" fill="#fff" />
                    {/* Eye sockets */}
                    <rect x="14" y="22" width="12" height="10" fill="#000" />
                    <rect x="38" y="22" width="12" height="10" fill="#000" />
                    {/* Nose */}
                    <rect x="28" y="34" width="8" height="6" fill="#000" />
                    {/* Teeth */}
                    <rect x="12" y="40" width="40" height="8" fill="#fff" />
                    <rect x="16" y="42" width="4" height="6" fill="#000" />
                    <rect x="24" y="42" width="4" height="6" fill="#000" />
                    <rect x="36" y="42" width="4" height="6" fill="#000" />
                    <rect x="44" y="42" width="4" height="6" fill="#000" />
                    {/* Jaw */}
                    <rect x="16" y="48" width="32" height="8" fill="#fff" />
                    {/* Border */}
                    <rect x="8" y="4" width="4" height="48" fill="#000" />
                    <rect x="52" y="4" width="4" height="48" fill="#000" />
                    <rect x="12" y="0" width="40" height="4" fill="#000" />
                    <rect x="12" y="52" width="40" height="4" fill="#000" />
                </PixelIcon>
            ),
            Tarot: (p) => (
                <PixelIcon {...p}>
                    <rect x="16" y="4" width="32" height="56" fill="#000" />
                    <rect x="20" y="8" width="24" height="48" fill="#fff" />
                    <rect x="24" y="12" width="16" height="4" fill="#000" />
                    <rect x="28" y="20" width="8" height="8" fill="#000" />
                    <rect x="24" y="32" width="16" height="16" fill="#000" />
                    <rect x="28" y="36" width="8" height="8" fill="#fff" />
                </PixelIcon>
            ),
            Dog: (p) => (
                <PixelIcon {...p}>
                    {/* Cute dog - full black */}
                    {/* Body */}
                    <rect x="16" y="20" width="32" height="16" fill="#000" />
                    {/* Head - rounder, cuter */}
                    <rect x="4" y="16" width="16" height="16" fill="#000" />
                    {/* Floppy ears */}
                    <rect x="2" y="8" width="6" height="14" fill="#000" />
                    <rect x="14" y="8" width="6" height="14" fill="#000" />
                    {/* Eye - big cute eye */}
                    <rect x="8" y="20" width="6" height="6" fill="#fff" />
                    <rect x="10" y="22" width="3" height="3" fill="#000" />
                    {/* Nose */}
                    <rect x="4" y="26" width="4" height="4" fill="#000" />
                    {/* Tail - wagging up */}
                    <rect x="48" y="16" width="12" height="4" fill="#000" />
                    <rect x="56" y="12" width="4" height="8" fill="#000" />
                    {/* Legs */}
                    <rect x="16" y="36" width="8" height="16" fill="#000" />
                    <rect x="38" y="36" width="8" height="16" fill="#000" />
                </PixelIcon>
            ),
            // Email icon
            Email: (p) => (
                <PixelIcon {...p}>
                    {/* Envelope */}
                    <rect x="4" y="12" width="56" height="40" fill="#000" />
                    <rect x="8" y="16" width="48" height="32" fill="#fff" />
                    {/* Flap */}
                    <polygon points="8,16 32,36 56,16" fill="#000" />
                    <polygon points="12,20 32,32 52,20" fill="#fff" />
                    {/* Bottom fold */}
                    <polygon points="8,48 32,32 56,48" fill="#000" stroke="#fff" strokeWidth="2" />
                </PixelIcon>
            ),
            // Apps folder icon
            Apps: (p) => (
                <PixelIcon {...p}>
                    {/* Folder base */}
                    <rect x="4" y="16" width="56" height="40" fill="#000" />
                    <rect x="8" y="20" width="48" height="32" fill="#fff" />
                    {/* Folder tab */}
                    <rect x="4" y="12" width="24" height="8" fill="#000" />
                    {/* Grid of apps inside */}
                    <rect x="12" y="24" width="8" height="8" fill="#000" />
                    <rect x="24" y="24" width="8" height="8" fill="#000" />
                    <rect x="36" y="24" width="8" height="8" fill="#000" />
                    <rect x="12" y="36" width="8" height="8" fill="#000" />
                    <rect x="24" y="36" width="8" height="8" fill="#000" />
                    <rect x="36" y="36" width="8" height="8" fill="#000" />
                </PixelIcon>
            )
        };

        // --- DATA ---
        const MEDIA_DB = {
            "CINEMA_TV": [
                { title: "Blade Runner 2049", rating: "MASTERPIECE" },
                { title: "Mr. Robot", rating: "SYS_ADMIN_FAV" },
                { title: "True Detective S1", rating: "10/10" },
                { title: "Succession", rating: "CORP_DRAMA" },
                { title: "The Bear", rating: "HIGH_STRESS" },
                { title: "Ex Machina", rating: "AI_ETHICS" },
                { title: "Fight Club", rating: "CULT_CLASSIC" },
                { title: "Arcane", rating: "VISUAL_PEAK" },
                { title: "Interstellar", rating: "SPACE_TIME" },
                { title: "Chernobyl", rating: "SYSTEM_FAILURE" },
                { title: "Better Call Saul", rating: "LEGAL_DRAMA" },
                { title: "Blue Eye Samurai", rating: "AESTHETIC" },
                { title: "Atlanta", rating: "SURREAL" },
                { title: "Whiplash", rating: "TEMPO" },
                { title: "There Will Be Blood", rating: "OIL" },
                { title: "Sicario", rating: "TENSION" },
                { title: "Black Mirror", rating: "DYSTOPIA" },
                { title: "Rick and Morty", rating: "SCI_FI" }
            ],
            "LITERATURE": [
                { title: "Brothers Karamazov", rating: "10/10" },
                { title: "Looking for Alaska", rating: "10/10" },
                { title: "Atlas Shrugged", rating: "10/10" },
                { title: "Pale Blue Dot", rating: "10/10" },
                { title: "Crime & Punishment", rating: "8/10" },
                { title: "The Fountainhead", rating: "9/10" },
                { title: "1984", rating: "8/10" },
                { title: "Master & Margarita", rating: "8/10" },
                { title: "American Psycho", rating: "8/10" },
                { title: "Elon Musk", rating: "9/10" }
            ],
            "GAMES": [
                { title: "Dark Souls III", rating: "10/10" },
                { title: "The Last of Us Pt II", rating: "10/10" },
                { title: "Outer Wilds", rating: "10/10" },
                { title: "God of War Ragnarok", rating: "10/10" },
                { title: "Blue Prince", rating: "10/10" },
                { title: "Cyberpunk 2077", rating: "9.5/10" },
                { title: "Night in the Woods", rating: "9.5/10" },
                { title: "Silent Hill 2", rating: "8/10" },
                { title: "Returnal", rating: "8/10" },
                { title: "Hollow Knight (Silksong)", rating: "8/10" },
                { title: "Deltarune", rating: "9/10" }
            ],
            "AUDIO": [
                { title: "The Life of Pablo", artist: "Kanye West" },
                { title: "Yeezus", artist: "Kanye West" },
                { title: "Mr. Morale...", artist: "Kendrick Lamar" },
                { title: "Miss Anthropocene", artist: "Grimes" },
                { title: "The Eminem Show", artist: "Eminem" }
            ]
        };

        // --- APP COMPONENTS ---

        const PaintApp = () => {
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const [tool, setTool] = useState('brush');
            const [color, setColor] = useState('#000000');
            const [size, setSize] = useState(4);
            const [isDrawing, setIsDrawing] = useState(false);
            const [status, setStatus] = useState("READY");
            const [startPos, setStartPos] = useState({ x: 0, y: 0 });
            const [textInput, setTextInput] = useState('');
            const [showTextInput, setShowTextInput] = useState(false);
            const [textPos, setTextPos] = useState({ x: 0, y: 0 });
            const snapshotRef = useRef(null);
            const historyRef = useRef([]);
            const historyIndexRef = useRef(-1);

            // Get accurate mouse position relative to canvas
            const getMousePos = (e) => {
                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            };

            const saveToHistory = () => {
                const canvas = canvasRef.current;
                const data = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
                historyRef.current = historyRef.current.slice(0, historyIndexRef.current + 1);
                historyRef.current.push(data);
                if (historyRef.current.length > 50) historyRef.current.shift();
                historyIndexRef.current = historyRef.current.length - 1;
            };

            const undo = () => {
                if (historyIndexRef.current > 0) {
                    historyIndexRef.current--;
                    canvasRef.current.getContext('2d').putImageData(historyRef.current[historyIndexRef.current], 0, 0);
                    setStatus("UNDO");
                }
            };

            const redo = () => {
                if (historyIndexRef.current < historyRef.current.length - 1) {
                    historyIndexRef.current++;
                    canvasRef.current.getContext('2d').putImageData(historyRef.current[historyIndexRef.current], 0, 0);
                    setStatus("REDO");
                }
            };

            useEffect(() => {
                const initCanvas = () => {
                    if (!containerRef.current) return;
                    const canvas = canvasRef.current;
                    const container = containerRef.current;
                    // Set fixed canvas size for proper pixel drawing
                    canvas.width = container.clientWidth - 4;
                    canvas.height = container.clientHeight - 4;
                    const ctx = canvas.getContext("2d");
                    ctx.fillStyle = "#ffffff";
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    saveToHistory();
                };
                initCanvas();
                window.addEventListener('resize', initCanvas);
                return () => window.removeEventListener('resize', initCanvas);
            }, []);

            const floodFill = (x, y, fillColor) => {
                const ctx = canvasRef.current.getContext('2d');
                const w = ctx.canvas.width;
                const h = ctx.canvas.height;
                const imgData = ctx.getImageData(0, 0, w, h);
                const data = imgData.data;
                const r = parseInt(fillColor.slice(1, 3), 16);
                const g = parseInt(fillColor.slice(3, 5), 16);
                const b = parseInt(fillColor.slice(5, 7), 16);
                const startIdx = (y * w + x) * 4;
                const sr = data[startIdx], sg = data[startIdx + 1], sb = data[startIdx + 2];
                if (sr === r && sg === g && sb === b) return;
                const stack = [[x, y]];
                while (stack.length) {
                    const [cx, cy] = stack.pop();
                    const idx = (cy * w + cx) * 4;
                    if (cx < 0 || cx >= w || cy < 0 || cy >= h) continue;
                    if (data[idx] === sr && data[idx + 1] === sg && data[idx + 2] === sb) {
                        data[idx] = r; data[idx + 1] = g; data[idx + 2] = b; data[idx + 3] = 255;
                        stack.push([cx + 1, cy], [cx - 1, cy], [cx, cy + 1], [cx, cy - 1]);
                    }
                }
                ctx.putImageData(imgData, 0, 0);
                saveToHistory();
            };

            const saveSnapshot = () => {
                const canvas = canvasRef.current;
                snapshotRef.current = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
            };

            const restoreSnapshot = () => {
                if (snapshotRef.current) {
                    canvasRef.current.getContext('2d').putImageData(snapshotRef.current, 0, 0);
                }
            };

            const startDraw = (e) => {
                const pos = getMousePos(e);
                if (tool === 'bucket') {
                    floodFill(Math.floor(pos.x), Math.floor(pos.y), color);
                    setStatus("FILLED");
                } else if (tool === 'text') {
                    setTextPos(pos);
                    setShowTextInput(true);
                    setStatus("TYPE TEXT");
                } else if (['rect', 'circle', 'line'].includes(tool)) {
                    setIsDrawing(true);
                    setStartPos(pos);
                    saveSnapshot();
                } else {
                    setIsDrawing(true);
                    setStartPos(pos);
                    const ctx = canvasRef.current.getContext('2d');
                    ctx.beginPath();
                    ctx.moveTo(pos.x, pos.y);
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.lineWidth = size;
                    ctx.strokeStyle = tool === 'eraser' ? '#ffffff' : color;
                }
            };

            const draw = (e) => {
                if (!isDrawing) return;
                const ctx = canvasRef.current.getContext('2d');
                const pos = getMousePos(e);

                if (tool === 'brush' || tool === 'eraser') {
                    ctx.lineTo(pos.x, pos.y);
                    ctx.stroke();
                } else if (['rect', 'circle', 'line'].includes(tool)) {
                    restoreSnapshot();
                    ctx.strokeStyle = color;
                    ctx.fillStyle = color;
                    ctx.lineWidth = size;

                    if (tool === 'rect') {
                        ctx.strokeRect(startPos.x, startPos.y, pos.x - startPos.x, pos.y - startPos.y);
                    } else if (tool === 'circle') {
                        const rx = Math.abs(pos.x - startPos.x) / 2;
                        const ry = Math.abs(pos.y - startPos.y) / 2;
                        const cx = startPos.x + (pos.x - startPos.x) / 2;
                        const cy = startPos.y + (pos.y - startPos.y) / 2;
                        ctx.beginPath();
                        ctx.ellipse(cx, cy, rx, ry, 0, 0, 2 * Math.PI);
                        ctx.stroke();
                    } else if (tool === 'line') {
                        ctx.beginPath();
                        ctx.moveTo(startPos.x, startPos.y);
                        ctx.lineTo(pos.x, pos.y);
                        ctx.stroke();
                    }
                }
            };

            const endDraw = () => {
                if (isDrawing) {
                    setIsDrawing(false);
                    if (tool === 'brush' || tool === 'eraser') {
                        canvasRef.current.getContext('2d').closePath();
                    }
                    saveToHistory();
                }
            };

            const placeText = () => {
                if (textInput.trim()) {
                    const ctx = canvasRef.current.getContext('2d');
                    ctx.fillStyle = color;
                    ctx.font = `${size * 4}px 'Geist Mono', monospace`;
                    ctx.fillText(textInput, textPos.x, textPos.y);
                    setStatus("TEXT PLACED");
                    saveToHistory();
                }
                setShowTextInput(false);
                setTextInput('');
            };

            const send = () => {
                setStatus("ENCRYPTING...");
                setTimeout(() => setStatus("UPLOADING..."), 500);
                setTimeout(() => setStatus("SENT TO MATEUS"), 1200);
            };

            const clear = () => {
                const ctx = canvasRef.current.getContext('2d');
                ctx.fillStyle = "#ffffff";
                ctx.fillRect(0, 0, canvasRef.current.width, canvasRef.current.height);
                setStatus("CLEARED");
                saveToHistory();
            };

            // Pixel knob component
            const PixelKnob = ({ value, onChange, min, max }) => {
                const knobSize = 24;
                const rotation = ((value - min) / (max - min)) * 270 - 135;
                return (
                    <div
                        className="relative cursor-pointer select-none"
                        style={{ width: knobSize, height: knobSize }}
                        onMouseDown={(e) => {
                            e.preventDefault();
                            const startY = e.clientY;
                            const startVal = value;
                            const onMove = (ev) => {
                                const diff = startY - ev.clientY;
                                const newVal = Math.min(max, Math.max(min, startVal + Math.floor(diff / 5)));
                                onChange(newVal);
                            };
                            const onUp = () => {
                                window.removeEventListener('mousemove', onMove);
                                window.removeEventListener('mouseup', onUp);
                            };
                            window.addEventListener('mousemove', onMove);
                            window.addEventListener('mouseup', onUp);
                        }}
                    >
                        <svg width={knobSize} height={knobSize} viewBox="0 0 24 24" style={{ imageRendering: 'pixelated' }}>
                            <rect x="4" y="4" width="16" height="16" fill="#000" />
                            <rect x="6" y="6" width="12" height="12" fill="#fff" />
                            <rect x="10" y="6" width="4" height="6" fill="#000" transform={`rotate(${rotation}, 12, 12)`} />
                        </svg>
                    </div>
                );
            };

            const tools = ['brush', 'eraser', 'bucket', 'line', 'rect', 'circle', 'text'];
            const colors = ['#000000', '#ffffff', '#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ff8800', '#8800ff'];

            return (
                <div className="h-full flex flex-col bg-gray-100 select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex flex-wrap gap-2 items-center">
                        <div className="flex gap-1">
                            <button onClick={undo} className="p-1 border border-black hover:bg-gray-100" title="Undo"><Icons.Undo size={16} /></button>
                            <button onClick={redo} className="p-1 border border-black hover:bg-gray-100" title="Redo"><Icons.Redo size={16} /></button>
                        </div>
                        <div className="w-px h-4 bg-black"></div>
                        <div className="flex gap-1 flex-wrap">
                            {tools.map(t => (
                                <button key={t} onClick={() => setTool(t)} className={`px-2 py-1 text-[10px] font-bold border border-black uppercase ${tool === t ? 'bg-black text-white' : 'bg-white hover:bg-gray-100'}`}>{t}</button>
                            ))}
                        </div>
                        <div className="w-px h-4 bg-black"></div>
                        <div className="flex gap-1 flex-wrap">
                            {colors.map(c => (
                                <button key={c} onClick={() => setColor(c)} className={`w-5 h-5 border border-black ${color === c ? 'ring-2 ring-offset-1 ring-black' : ''}`} style={{ backgroundColor: c }} />
                            ))}
                        </div>
                        <div className="w-px h-4 bg-black"></div>
                        <div className="flex items-center gap-1">
                            <PixelKnob value={size} onChange={setSize} min={1} max={20} />
                            <span className="text-[10px] font-mono w-4">{size}</span>
                        </div>
                        <div className="flex-grow"></div>
                        <button onClick={send} className="px-2 py-1 border border-black bg-black text-white text-xs font-bold hover:invert flex items-center gap-1"><Icons.Send size={12} /> SEND</button>
                    </div>
                    <div className="flex-grow relative cursor-crosshair bg-gray-300 p-[2px] overflow-hidden" ref={containerRef}>
                        <canvas
                            ref={canvasRef}
                            onMouseDown={startDraw}
                            onMouseMove={draw}
                            onMouseUp={endDraw}
                            onMouseLeave={endDraw}
                            className="block bg-white border border-gray-400"
                            style={{ width: '100%', height: '100%' }}
                        />
                        {showTextInput && (
                            <div className="absolute top-2 left-2 bg-white border-2 border-black p-2 flex gap-2">
                                <input
                                    type="text"
                                    value={textInput}
                                    onChange={(e) => setTextInput(e.target.value)}
                                    onKeyDown={(e) => e.key === 'Enter' && placeText()}
                                    placeholder="Type text..."
                                    className="border border-black px-2 py-1 text-xs font-mono"
                                    autoFocus
                                />
                                <button onClick={placeText} className="bg-black text-white px-2 text-xs font-bold">OK</button>
                            </div>
                        )}
                        <div className="absolute bottom-1 left-1 bg-black text-white text-[10px] px-2 font-mono">{status}</div>
                    </div>
                </div>
            )
        }

        const FileExplorer = () => {
            const [selectedFolder, setSelectedFolder] = useState(null);

            const folders = [
                { key: 'CINEMA_TV', name: 'MOVIES', icon: 'Movies' },
                { key: 'LITERATURE', name: 'BOOKS', icon: 'Books' },
                { key: 'GAMES', name: 'GAMES', icon: 'Games' },
                { key: 'AUDIO', name: 'MUSIC', icon: 'Music' }
            ];

            if (selectedFolder) {
                const FolderIcon = Icons[folders.find(f => f.key === selectedFolder)?.icon || 'Folder'];
                return (
                    <div className="h-full flex flex-col bg-white select-none">
                        <div className="p-2 border-b-2 border-black bg-white flex items-center gap-3">
                            <button onClick={() => setSelectedFolder(null)} className="p-1 border-2 border-black hover:bg-black hover:text-white">
                                <Icons.Back size={16} />
                            </button>
                            <FolderIcon size={24} />
                            <span className="font-mono text-xs font-bold uppercase">{folders.find(f => f.key === selectedFolder)?.name}</span>
                            <span className="font-mono text-[10px] text-gray-500">({MEDIA_DB[selectedFolder].length} ITEMS)</span>
                        </div>
                        <div className="flex-grow overflow-auto">
                            <table className="w-full text-left border-collapse">
                                <thead className="bg-black text-white text-xs font-mono sticky top-0">
                                    <tr><th className="p-2">TITLE</th><th className="p-2 border-l border-gray-600">NOTE</th></tr>
                                </thead>
                                <tbody className="font-mono text-xs">
                                    {MEDIA_DB[selectedFolder].map((i, idx) => (
                                        <tr key={idx} className="border-b border-gray-200 hover:bg-yellow-100">
                                            <td className="p-2 font-bold">{i.title}</td>
                                            <td className="p-2 border-l border-gray-200">{i.rating || i.artist}</td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                        <div className="p-2 border-t-2 border-black bg-white text-center">
                            <span className="font-mono text-[10px] text-gray-500">CLICK TO VIEW • HOVER TO PREVIEW</span>
                        </div>
                    </div>
                );
            }

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex items-center gap-2">
                        <Icons.Folder size={24} />
                        <span className="font-mono text-xs font-bold">MEDIA_LIB</span>
                        <span className="font-mono text-[10px] text-gray-500">/ROOT/MEDIA</span>
                    </div>
                    <div className="flex-grow p-6 flex items-start justify-center bg-gray-50">
                        <div className="grid grid-cols-4 gap-8">
                            {folders.map(folder => {
                                const FolderIcon = Icons[folder.icon];
                                return (
                                    <button
                                        key={folder.key}
                                        onClick={() => setSelectedFolder(folder.key)}
                                        className="group flex flex-col items-center gap-2 p-4 hover:bg-white border-2 border-transparent hover:border-black transition-all"
                                    >
                                        <div className="bg-white border-2 border-black p-3 icon-shadow group-hover:translate-x-1 group-hover:translate-y-1 group-hover:shadow-none transition-all">
                                            <FolderIcon size={48} />
                                        </div>
                                        <span className="font-mono text-xs font-bold uppercase">{folder.name}</span>
                                        <span className="font-mono text-[10px] text-gray-500">{MEDIA_DB[folder.key].length} ITEMS</span>
                                    </button>
                                );
                            })}
                        </div>
                    </div>
                    <div className="p-2 border-t-2 border-black bg-white text-center">
                        <span className="font-mono text-[10px] text-gray-500">MOVIES • BOOKS • GAMES • MUSIC</span>
                    </div>
                </div>
            );
        }

        const SystemInfo = () => (
            <div className="p-6 md:p-12 font-sans select-text">
                <header className="mb-12 border-b-4 border-black pb-8">
                    <h1 className="text-6xl md:text-8xl font-black uppercase tracking-tighter leading-none">Mateus<br />Muste</h1>
                    <div className="mt-4 flex flex-wrap gap-4 font-mono text-sm">
                        <span className="bg-black text-white px-2 py-1">DIGITAL DESIGNER</span>
                        <span className="bg-black text-white px-2 py-1">RADICAL OPTIMIST</span>
                        <span className="border border-black px-2 py-1">ROMANIA</span>
                    </div>
                </header>
                <div className="grid md:grid-cols-2 gap-12">
                    <div className="space-y-8">
                        <section>
                            <h3 className="text-2xl font-black uppercase mb-4 border-b-2 border-black">App Stack</h3>
                            <div className="grid grid-cols-4 gap-1">
                                {[
                                    { name: 'PS', full: 'Photoshop', yrs: 8 },
                                    { name: 'PR', full: 'Premiere', yrs: 7 },
                                    { name: 'AE', full: 'After Effects', yrs: 5 },
                                    { name: 'XL', full: 'Excel', yrs: 4 },
                                    { name: 'MA', full: 'Meta Ads', yrs: 4 },
                                    { name: 'DV', full: 'DaVinci', yrs: 3 },
                                    { name: 'AC', full: 'ArchiCAD', yrs: 2 },
                                    { name: 'SQ', full: 'Squarespace', yrs: 2 },
                                    { name: 'UE', full: 'Unreal', yrs: 2 },
                                    { name: 'WF', full: 'Webflow', yrs: 2 },
                                    { name: 'MJ', full: 'Midjourney', yrs: 2 },
                                    { name: 'GA', full: 'Google Ads', yrs: 2 },
                                    { name: 'BL', full: 'Blender', yrs: 1 },
                                    { name: 'CR', full: 'Cursor', yrs: 1 },
                                    { name: 'CF', full: 'ComfyUI', yrs: 1 },
                                    { name: 'N8', full: 'n8n', yrs: 1 }
                                ].map((app, i) => (
                                    <div key={i} className="group relative border-2 border-black aspect-square flex flex-col items-center justify-center hover:bg-black hover:text-white transition-all cursor-default">
                                        <span className="font-black text-lg">{app.name}</span>
                                        <span className="font-mono text-[10px]">{app.yrs}Y</span>
                                        <div className="absolute inset-0 bg-black text-white opacity-0 group-hover:opacity-100 flex flex-col items-center justify-center transition-opacity">
                                            <span className="font-mono text-[9px] text-center px-1">{app.full}</span>
                                            <span className="font-black">{app.yrs} YRS</span>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </section>
                        <section><h3 className="text-2xl font-black uppercase mb-4 border-b-2 border-black">Metrics</h3>
                            <div className="flex gap-4">
                                <div className="p-4 border-2 border-black text-center"><div className="text-3xl font-black">C2</div><div className="font-mono text-[10px]">CAMBRIDGE</div></div>
                                <div className="p-4 border-2 border-black text-center"><div className="text-3xl font-black">1570</div><div className="font-mono text-[10px]">SAT</div></div>
                            </div>
                        </section>
                    </div>
                    <div className="space-y-4">
                        <h3 className="text-2xl font-black uppercase mb-4 border-b-2 border-black">Projects</h3>
                        {[
                            { t: "BIOBUILDS", num: "01", s: "Web / Video / Marketing", d: "Sustainable construction across Europe. Entered 3 markets." },
                            { t: "ROMANIA OLYMPICS 2024", num: "02", s: "Premiere / After Effects", d: "National contest winner. Cluj-Napoca." },
                            { t: "ULT", num: "03", s: "Documentary / Editing", d: "Self-directed channel. Skill laboratory." }
                        ].map((p, i) => (
                            <div key={i} className="group border-2 border-black p-4 hover:bg-black hover:text-white cursor-pointer">
                                <div className="flex justify-between mb-1"><h4 className="font-bold uppercase">{p.t}</h4><span className="font-mono text-xs">{p.num}</span></div>
                                <p className="font-mono text-xs opacity-70 mb-1">{p.s}</p><p className="text-sm italic">{p.d}</p>
                            </div>
                        ))}
                    </div>
                </div>
            </div>
        )

        const TrashApp = () => {
            const [shakingFile, setShakingFile] = useState(null);

            const trashFiles = [
                { name: 'MY_BITCOIN_WALLET.txt', icon: 'FileDoc' },
                { name: 'sleep_schedule.ics', icon: 'FileDoc' },
                { name: 'NYU_acceptance_letter.pdf', icon: 'FileDoc' }
            ];

            const handleFileClick = (fileName) => {
                setShakingFile(fileName);
                setTimeout(() => setShakingFile(null), 500);
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-3 border-b-2 border-black bg-gray-50 flex items-center gap-2">
                        <Icons.TrashCan size={24} />
                        <span className="font-mono text-sm font-bold uppercase">RECYCLE BIN</span>
                        <span className="font-mono text-xs text-gray-400">({trashFiles.length} items)</span>
                    </div>
                    <div className="flex-grow p-6">
                        <div className="grid grid-cols-3 gap-6">
                            {trashFiles.map(file => (
                                <button
                                    key={file.name}
                                    onClick={() => handleFileClick(file.name)}
                                    className="group flex flex-col items-center gap-2 p-4 cursor-not-allowed"
                                    style={{
                                        animation: shakingFile === file.name ? 'shake 0.5s ease-in-out' : 'none'
                                    }}
                                >
                                    <div className="bg-white border-2 border-black p-3 icon-shadow opacity-50">
                                        <Icons.FileDoc size={32} />
                                    </div>
                                    <span className="font-mono text-[10px] font-bold text-center break-all opacity-70">{file.name}</span>
                                </button>
                            ))}
                        </div>
                        <div className="mt-8 p-4 border-2 border-dashed border-gray-300 text-center">
                            <span className="font-mono text-xs text-gray-400">ITEMS CANNOT BE RECOVERED</span>
                        </div>
                    </div>
                    <style>{`
                        @keyframes shake {
                            0%, 100% { transform: translateX(0); }
                            10%, 30%, 50%, 70%, 90% { transform: translateX(-4px); }
                            20%, 40%, 60%, 80% { transform: translateX(4px); }
                        }
                    `}</style>
                </div>
            );
        }

        // --- VOID.TXT - Text encrypts then fades into the void ---
        const VoidApp = () => {
            const [lines, setLines] = useState([]);
            const [currentText, setCurrentText] = useState('');
            const inputRef = useRef(null);

            const encryptChar = (char) => {
                const chars = '▓▒░█▄▀■□●○◆◇★☆@#$%&*';
                return chars[Math.floor(Math.random() * chars.length)];
            };

            const handleKeyDown = (e) => {
                if (e.key === 'Enter' && currentText.trim()) {
                    const newLine = {
                        id: Date.now(),
                        originalText: currentText,
                        displayText: currentText,
                        opacity: 1,
                        encryptIndex: 0,
                        phase: 'visible' // visible -> encrypting -> fading
                    };
                    setLines(prev => [...prev, newLine]);
                    setCurrentText('');

                    // Start encrypting after 3 seconds
                    setTimeout(() => {
                        // Encrypt phase - encrypt one character at a time
                        let charIndex = 0;
                        const encryptInterval = setInterval(() => {
                            setLines(prev => prev.map(line => {
                                if (line.id !== newLine.id) return line;
                                if (charIndex >= line.originalText.length) return line;

                                const encrypted = line.originalText.split('').map((c, i) =>
                                    i <= charIndex ? encryptChar(c) : c
                                ).join('');

                                return { ...line, displayText: encrypted, phase: 'encrypting' };
                            }));
                            charIndex++;

                            if (charIndex >= newLine.originalText.length) {
                                clearInterval(encryptInterval);

                                // Start fading after encryption complete
                                setTimeout(() => {
                                    const fadeInterval = setInterval(() => {
                                        setLines(prev => prev.map(line =>
                                            line.id === newLine.id
                                                ? { ...line, opacity: Math.max(0, line.opacity - 0.1), phase: 'fading' }
                                                : line
                                        ).filter(line => line.opacity > 0));
                                    }, 80);
                                    setTimeout(() => clearInterval(fadeInterval), 900);
                                }, 200);
                            }
                        }, 50);
                    }, 3000);
                }
            };

            return (
                <div
                    className="h-full flex flex-col bg-black select-none cursor-text"
                    onClick={() => inputRef.current?.focus()}
                    onCopy={(e) => e.preventDefault()}
                    onCut={(e) => e.preventDefault()}
                >
                    <div className="p-2 border-b border-gray-800 bg-black flex justify-between items-center">
                        <span className="font-mono text-xs font-bold text-white">VOID.TXT</span>
                        <span className="font-mono text-[10px] text-gray-600">NO SAVE // NO COPY // JUST VOID</span>
                    </div>
                    <div className="flex-grow p-4 overflow-auto font-mono text-sm">
                        {lines.map(line => (
                            <div
                                key={line.id}
                                className="mb-1 transition-opacity duration-100"
                                style={{
                                    color: line.phase === 'encrypting' ? '#0f0' : `rgba(255,255,255,${line.opacity})`,
                                    textShadow: line.phase === 'encrypting' ? '0 0 5px #0f0' : 'none'
                                }}
                            >
                                {line.displayText}
                            </div>
                        ))}
                        <div className="flex items-center text-white">
                            <span className="mr-2 text-gray-600">{'>'}</span>
                            <input
                                ref={inputRef}
                                type="text"
                                value={currentText}
                                onChange={(e) => setCurrentText(e.target.value)}
                                onKeyDown={handleKeyDown}
                                className="bg-transparent outline-none flex-grow text-white caret-white"
                                autoFocus
                                onPaste={(e) => e.preventDefault()}
                            />
                            <span className="animate-pulse text-white">_</span>
                        </div>
                    </div>
                    <div className="p-2 border-t border-gray-800 bg-black text-center">
                        <span className="font-mono text-[10px] text-gray-600">WRITE INTO THE VOID. WATCH IT DISAPPEAR.</span>
                    </div>
                </div>
            );
        };

        // --- ORACLE.EXE - Philosophical quotes ---
        const OracleApp = () => {
            const quotes = [
                "The soul is healed by being with children.",
                "Man is condemned to be free.",
                "He who has a why to live can bear almost any how.",
                "The question isn't who is going to let me; it's who is going to stop me.",
                "One must imagine Sisyphus happy.",
                "Pain and suffering are always inevitable for a large intelligence and a deep heart.",
                "God is dead. God remains dead. And we have killed him.",
                "I swear by my life and my love of it that I will never live for the sake of another man.",
                "In the depth of winter, I finally learned that within me there lay an invincible summer.",
                "The higher we soar the smaller we appear to those who cannot fly.",
                "The soul that sees beauty may sometimes walk alone.",
                "Should I kill myself, or have a cup of coffee?",
                "To live is to suffer, to survive is to find some meaning in the suffering.",
                "The only thing I know is that I know nothing.",
                "Beauty will save the world.",
                "There is always some madness in love. But there is also always some reason in madness.",
                "Man is the only creature who refuses to be what he is.",
                "A is A. A thing is itself.",
                "What does not kill me makes me stronger.",
                "The absurd is born of the confrontation between the human call and the unreasonable silence of the world.",
                "The best way to find yourself is to lose yourself in the service of others.",
                "Every deep thinker is more afraid of being understood than of being misunderstood.",
                "Money is only a tool. It will take you wherever you wish, but it will not replace you as the driver.",
                "We are all in the gutter, but some of us are looking at the stars.",
                "The only way to deal with an unfree world is to become so absolutely free that your very existence is an act of rebellion.",
                "Above all, don't lie to yourself.",
                "Whoever fights monsters should see to it that in the process he does not become a monster.",
                "I rebel; therefore I exist.",
                "The secret of happiness is freedom, the secret of freedom is courage.",
                "There is but one truly serious philosophical problem, and that is suicide."
            ];

            const [question, setQuestion] = useState('');
            const [answer, setAnswer] = useState(null);
            const [isThinking, setIsThinking] = useState(false);

            const askOracle = () => {
                if (!question.trim()) return;
                setIsThinking(true);
                setAnswer(null);

                setTimeout(() => {
                    const randomQuote = quotes[Math.floor(Math.random() * quotes.length)];
                    setAnswer(randomQuote);
                    setIsThinking(false);
                    setQuestion('');
                }, 1500 + Math.random() * 1000);
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex justify-between items-center">
                        <span className="font-mono text-xs font-bold">ORACLE.EXE</span>
                        <span className="font-mono text-[10px] text-gray-500">ASK THE DEAD</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-8 bg-gray-50">
                        {answer && (
                            <div className="mb-8 text-center max-w-lg">
                                <div className="text-xl font-serif italic leading-relaxed mb-4 text-black">"{answer}"</div>
                                <div className="text-xs text-gray-500 font-mono">— THE ORACLE HAS SPOKEN</div>
                            </div>
                        )}
                        {isThinking && (
                            <div className="mb-8 text-center">
                                <div className="font-mono text-sm text-gray-500 animate-pulse">
                                    CONSULTING THE VOID...
                                </div>
                            </div>
                        )}
                        <div className="w-full max-w-md">
                            <input
                                type="text"
                                value={question}
                                onChange={(e) => setQuestion(e.target.value)}
                                onKeyDown={(e) => e.key === 'Enter' && askOracle()}
                                placeholder="ASK YOUR QUESTION..."
                                className="w-full bg-white border-2 border-black px-4 py-3 font-mono text-sm text-black placeholder-gray-400 focus:ring-2 focus:ring-black outline-none"
                                disabled={isThinking}
                            />
                            <button
                                onClick={askOracle}
                                disabled={isThinking}
                                className="w-full mt-2 bg-black text-white py-3 font-mono font-bold text-sm hover:invert border-2 border-black disabled:opacity-50"
                            >
                                SEEK TRUTH
                            </button>
                        </div>
                    </div>
                    <div className="p-2 border-t-2 border-black bg-white text-center">
                        <span className="font-mono text-[10px] text-gray-500">DOSTOEVSKY • NIETZSCHE • RAND • CAMUS</span>
                    </div>
                </div>
            );
        };

        // --- RADIO.WAV - Playlist link ---
        const RadioApp = () => {
            const [isPlaying, setIsPlaying] = useState(false);
            const [visualizer, setVisualizer] = useState([]);

            useEffect(() => {
                const interval = setInterval(() => {
                    if (isPlaying) {
                        setVisualizer(Array(16).fill(0).map(() => Math.random() * 100));
                    }
                }, 100);
                return () => clearInterval(interval);
            }, [isPlaying]);

            const openPlaylist = () => {
                window.open('https://music.youtube.com/playlist?list=PLeIQRsOWZUhKaD53FTvwZCxsNWzjq0lfO&si=92O5A6kAPjk8Vzmg', '_blank');
                setIsPlaying(true);
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex justify-between items-center">
                        <span className="font-mono text-xs font-bold">RADIO.WAV</span>
                        <span className="font-mono text-[10px] text-gray-500">MATEUS_PLAYLIST</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-8 bg-gray-50">
                        <div className="flex items-end justify-center gap-1 h-32 mb-8 p-4 border-2 border-black bg-white">
                            {(isPlaying ? visualizer : Array(16).fill(10)).map((h, i) => (
                                <div
                                    key={i}
                                    className="w-3 bg-black transition-all duration-100"
                                    style={{ height: `${h}%`, minHeight: '4px' }}
                                />
                            ))}
                        </div>
                        <button
                            onClick={openPlaylist}
                            className="bg-black text-white px-8 py-4 font-mono font-bold text-lg hover:invert border-2 border-black transition-all"
                        >
                            {isPlaying ? '► NOW PLAYING' : '► TUNE IN'}
                        </button>
                        <div className="mt-4 font-mono text-xs text-gray-500">
                            OPENS YOUTUBE MUSIC
                        </div>
                    </div>
                    <div className="p-2 border-t-2 border-black bg-white">
                        <div className="font-mono text-[10px] text-gray-500 text-center">
                            BROADCASTING FROM THE VOID
                        </div>
                    </div>
                </div>
            );
        };

        // --- DICE.EXE - D20 Roller with ASCII art ---
        const DiceApp = () => {
            const [result, setResult] = useState(null);
            const [isRolling, setIsRolling] = useState(false);
            const [rotation, setRotation] = useState({ x: 0, y: 0 });
            const canvasRef = useRef(null);

            const rollDice = () => {
                if (isRolling) return;
                setIsRolling(true);
                setResult(null);

                let rolls = 0;
                const maxRolls = 20;
                const rollInterval = setInterval(() => {
                    setResult(Math.floor(Math.random() * 20) + 1);
                    setRotation(r => ({
                        x: r.x + 15 + Math.random() * 10,
                        y: r.y + 20 + Math.random() * 15
                    }));
                    rolls++;

                    if (rolls >= maxRolls) {
                        clearInterval(rollInterval);
                        setResult(Math.floor(Math.random() * 20) + 1);
                        setIsRolling(false);
                    }
                }, 60);
            };

            const getResultColor = () => {
                if (!result) return 'text-black';
                if (result === 20) return 'text-green-600';
                if (result === 1) return 'text-red-600';
                return 'text-black';
            };

            // Draw 3D D20 on canvas
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                const size = 200;
                const cx = size / 2;
                const cy = size / 2;

                ctx.fillStyle = '#f5f5f5';
                ctx.fillRect(0, 0, size, size);

                // Simple 3D icosahedron projection
                const scale = 70;
                const rotX = (rotation.x * Math.PI) / 180;
                const rotY = (rotation.y * Math.PI) / 180;

                // Icosahedron vertices (simplified)
                const phi = (1 + Math.sqrt(5)) / 2;
                const vertices = [
                    [0, 1, phi], [0, -1, phi], [0, 1, -phi], [0, -1, -phi],
                    [1, phi, 0], [-1, phi, 0], [1, -phi, 0], [-1, -phi, 0],
                    [phi, 0, 1], [-phi, 0, 1], [phi, 0, -1], [-phi, 0, -1]
                ].map(v => {
                    const len = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
                    return v.map(c => c / len);
                });

                // Rotate and project
                const project = (v) => {
                    let [x, y, z] = v;
                    // Rotate Y
                    const x1 = x * Math.cos(rotY) - z * Math.sin(rotY);
                    const z1 = x * Math.sin(rotY) + z * Math.cos(rotY);
                    // Rotate X
                    const y2 = y * Math.cos(rotX) - z1 * Math.sin(rotX);
                    const z2 = y * Math.sin(rotX) + z1 * Math.cos(rotX);
                    return { x: cx + x1 * scale, y: cy + y2 * scale, z: z2 };
                };

                const projected = vertices.map(project);

                // D20 faces (triangles)
                const faces = [
                    [0,1,8], [0,8,4], [0,4,5], [0,5,9], [0,9,1],
                    [2,3,11], [2,11,5], [2,5,4], [2,4,10], [2,10,3],
                    [1,6,8], [3,6,7], [7,9,1], [6,10,8], [7,11,9],
                    [3,7,6], [1,9,7], [4,8,10], [5,11,9], [3,10,6]
                ];

                // Sort faces by depth
                const sortedFaces = faces.map((face, idx) => {
                    const avgZ = face.reduce((sum, vi) => sum + projected[vi].z, 0) / 3;
                    return { face, avgZ, idx };
                }).sort((a, b) => a.avgZ - b.avgZ);

                // Draw faces
                sortedFaces.forEach(({ face, avgZ, idx }) => {
                    const pts = face.map(vi => projected[vi]);
                    ctx.beginPath();
                    ctx.moveTo(pts[0].x, pts[0].y);
                    pts.slice(1).forEach(p => ctx.lineTo(p.x, p.y));
                    ctx.closePath();

                    // Shade based on depth
                    const shade = Math.floor(220 + avgZ * 30);
                    ctx.fillStyle = `rgb(${shade}, ${shade}, ${shade})`;
                    ctx.fill();
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });

                // Draw result number in center
                if (result) {
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 36px Geist Mono, monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(result, cx, cy);
                }
            }, [rotation, result]);

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex justify-between items-center">
                        <span className="font-mono text-xs font-bold">DICE.EXE</span>
                        <span className="font-mono text-[10px] text-gray-500">D20 ROLLER</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-6 bg-gray-50">
                        <div className="border-2 border-black bg-white p-1 mb-6">
                            <canvas ref={canvasRef} width={200} height={200} className="block" />
                        </div>
                        {result && !isRolling && (
                            <div className={`text-3xl font-black mb-4 ${getResultColor()}`}>
                                {result === 20 ? 'CRITICAL HIT!' : result === 1 ? 'CRITICAL FAIL!' : result}
                            </div>
                        )}
                        <button
                            onClick={rollDice}
                            disabled={isRolling}
                            className="bg-black text-white px-8 py-3 font-mono font-bold text-sm hover:invert disabled:opacity-50 border-2 border-black"
                        >
                            {isRolling ? 'ROLLING...' : 'ROLL D20'}
                        </button>
                    </div>
                    <div className="p-2 border-t-2 border-black bg-white text-center">
                        <span className="font-mono text-[10px] text-gray-500">CLICK TO ROLL • 20 = CRIT • 1 = FAIL</span>
                    </div>
                </div>
            );
        };

        // --- Updated SNEK.EXE with Ghost ---
        const SnakeAppNew = () => {
            const canvasRef = useRef(null);
            const [score, setScore] = useState(0);
            const [highScore, setHighScore] = useState(0);
            const [gameOver, setGameOver] = useState(false);
            const [gameStarted, setGameStarted] = useState(false);
            const snake = useRef([{ x: 15, y: 10 }]);
            const food = useRef({ x: 20, y: 10 });
            const ghost = useRef({ x: 5, y: 10 });
            const dir = useRef({ x: 1, y: 0 });
            const nextDir = useRef({ x: 1, y: 0 });
            const loopRef = useRef(null);

            const GRID_W = 30;
            const GRID_H = 20;
            const CELL = 20;

            const start = () => {
                snake.current = [{ x: 15, y: 10 }, { x: 14, y: 10 }, { x: 13, y: 10 }];
                dir.current = { x: 1, y: 0 };
                nextDir.current = { x: 1, y: 0 };
                food.current = { x: Math.floor(Math.random() * GRID_W), y: Math.floor(Math.random() * GRID_H) };
                ghost.current = { x: 2, y: 2 };
                setScore(0);
                setGameOver(false);
                setGameStarted(true);
                if (loopRef.current) clearInterval(loopRef.current);
                loopRef.current = setInterval(() => {
                    update();
                }, 100);
            };

            const update = () => {
                const ctx = canvasRef.current?.getContext('2d');
                if (!ctx) return;

                dir.current = nextDir.current;
                const head = {
                    x: snake.current[0].x + dir.current.x,
                    y: snake.current[0].y + dir.current.y
                };

                // Wall collision
                if (head.x < 0 || head.x >= GRID_W || head.y < 0 || head.y >= GRID_H) {
                    endGame();
                    return;
                }

                // Self collision
                if (snake.current.some(s => s.x === head.x && s.y === head.y)) {
                    endGame();
                    return;
                }

                // Ghost collision
                if (ghost.current.x === head.x && ghost.current.y === head.y) {
                    endGame();
                    return;
                }

                snake.current.unshift(head);

                // Eat food
                if (head.x === food.current.x && head.y === food.current.y) {
                    setScore(s => {
                        const newScore = s + 10;
                        setHighScore(h => Math.max(h, newScore));
                        return newScore;
                    });
                    food.current = {
                        x: Math.floor(Math.random() * GRID_W),
                        y: Math.floor(Math.random() * GRID_H)
                    };
                } else {
                    snake.current.pop();
                }

                // Move ghost towards snake head
                const dx = head.x - ghost.current.x;
                const dy = head.y - ghost.current.y;
                if (Math.abs(dx) > Math.abs(dy)) {
                    ghost.current.x += dx > 0 ? 1 : -1;
                } else if (dy !== 0) {
                    ghost.current.y += dy > 0 ? 1 : -1;
                }

                // Draw - light theme
                ctx.fillStyle = '#f5f5f5';
                ctx.fillRect(0, 0, GRID_W * CELL, GRID_H * CELL);

                // Grid lines (subtle)
                ctx.strokeStyle = '#e0e0e0';
                for (let i = 0; i <= GRID_W; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * CELL, 0);
                    ctx.lineTo(i * CELL, GRID_H * CELL);
                    ctx.stroke();
                }
                for (let i = 0; i <= GRID_H; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, i * CELL);
                    ctx.lineTo(GRID_W * CELL, i * CELL);
                    ctx.stroke();
                }

                // Snake - black
                snake.current.forEach((s, i) => {
                    ctx.fillStyle = i === 0 ? '#000' : '#333';
                    ctx.fillRect(s.x * CELL + 1, s.y * CELL + 1, CELL - 2, CELL - 2);
                });

                // Food - black dot
                ctx.fillStyle = '#000';
                ctx.fillRect(food.current.x * CELL + 6, food.current.y * CELL + 6, CELL - 12, CELL - 12);

                // Ghost - red circle
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(ghost.current.x * CELL + CELL/2, ghost.current.y * CELL + CELL/2, CELL/2 - 2, 0, Math.PI * 2);
                ctx.fill();
                // Ghost eyes
                ctx.fillStyle = '#fff';
                ctx.fillRect(ghost.current.x * CELL + 5, ghost.current.y * CELL + 6, 4, 4);
                ctx.fillRect(ghost.current.x * CELL + 11, ghost.current.y * CELL + 6, 4, 4);
            };

            const endGame = () => {
                setGameOver(true);
                setGameStarted(false);
                clearInterval(loopRef.current);
            };

            useEffect(() => {
                const handle = (e) => {
                    if (!gameStarted) return;
                    if (e.key === 'ArrowUp' && dir.current.y === 0) nextDir.current = { x: 0, y: -1 };
                    if (e.key === 'ArrowDown' && dir.current.y === 0) nextDir.current = { x: 0, y: 1 };
                    if (e.key === 'ArrowLeft' && dir.current.x === 0) nextDir.current = { x: -1, y: 0 };
                    if (e.key === 'ArrowRight' && dir.current.x === 0) nextDir.current = { x: 1, y: 0 };
                };
                window.addEventListener('keydown', handle);
                return () => {
                    window.removeEventListener('keydown', handle);
                    clearInterval(loopRef.current);
                };
            }, [gameStarted]);

            // Initial canvas draw - light theme
            useEffect(() => {
                const ctx = canvasRef.current?.getContext('2d');
                if (ctx) {
                    ctx.fillStyle = '#f5f5f5';
                    ctx.fillRect(0, 0, GRID_W * CELL, GRID_H * CELL);

                    // Draw grid lines
                    ctx.strokeStyle = '#e0e0e0';
                    for (let i = 0; i <= GRID_W; i++) {
                        ctx.beginPath();
                        ctx.moveTo(i * CELL, 0);
                        ctx.lineTo(i * CELL, GRID_H * CELL);
                        ctx.stroke();
                    }
                    for (let i = 0; i <= GRID_H; i++) {
                        ctx.beginPath();
                        ctx.moveTo(0, i * CELL);
                        ctx.lineTo(GRID_W * CELL, i * CELL);
                        ctx.stroke();
                    }
                }
            }, []);

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex justify-between items-center">
                        <span className="font-mono text-xs font-bold">SNEK.EXE</span>
                        <div className="flex gap-4 font-mono text-xs">
                            <span>SCORE: <span className="font-bold">{score}</span></span>
                            <span>HIGH: <span className="font-bold">{highScore}</span></span>
                            <span className={gameOver ? 'text-red-600' : gameStarted ? 'text-green-600' : 'text-gray-500'}>
                                {gameOver ? 'DEAD' : gameStarted ? 'ALIVE' : 'READY'}
                            </span>
                        </div>
                    </div>
                    <div className="flex-grow flex items-center justify-center p-4 bg-gray-50">
                        <div className="relative border-2 border-black">
                            <canvas ref={canvasRef} width={600} height={400} className="block" />
                            {!gameStarted && (
                                <div className="absolute inset-0 bg-white/95 flex flex-col items-center justify-center">
                                    <div className="text-4xl font-black mb-2 tracking-widest">SNEK</div>
                                    {gameOver && <p className="text-red-600 mb-4 font-mono text-sm">THE GHOST GOT YOU</p>}
                                    <button
                                        onClick={start}
                                        className="bg-black text-white px-6 py-3 font-mono font-bold text-sm hover:invert border-2 border-black"
                                    >
                                        {gameOver ? 'RETRY' : 'START'}
                                    </button>
                                    <p className="mt-4 text-gray-500 font-mono text-xs">ARROW KEYS TO MOVE • AVOID THE GHOST</p>
                                </div>
                            )}
                        </div>
                    </div>
                    <div className="p-2 border-t-2 border-black bg-white text-center">
                        <span className="font-mono text-[10px] text-gray-500">EAT FOOD • GROW LONGER • DON'T DIE</span>
                    </div>
                </div>
            );
        };

        // --- LABYRINTH.EXE - Procedural Maze ---
        const LabyrinthApp = () => {
            const canvasRef = useRef(null);
            const [level, setLevel] = useState(1);
            const [score, setScore] = useState(0);
            const [highScore, setHighScore] = useState(0);
            const [won, setWon] = useState(false);
            const [showingMaze, setShowingMaze] = useState(false);
            const mazeRef = useRef(null);
            const playerRef = useRef({ x: 1, y: 1 });
            const exitRef = useRef({ x: 0, y: 0 });

            const CELL_SIZE = 8; // Thinner walls

            const generateMaze = (width, height) => {
                const maze = Array(height).fill(null).map(() => Array(width).fill(1));

                const carve = (x, y) => {
                    maze[y][x] = 0;
                    const directions = [[0, -2], [0, 2], [-2, 0], [2, 0]].sort(() => Math.random() - 0.5);

                    for (const [dx, dy] of directions) {
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx > 0 && nx < width - 1 && ny > 0 && ny < height - 1 && maze[ny][nx] === 1) {
                            maze[y + dy/2][x + dx/2] = 0;
                            carve(nx, ny);
                        }
                    }
                };

                carve(1, 1);
                return maze;
            };

            const startLevel = (lvl) => {
                // Start big and get MUCH harder - exponential growth
                const size = 31 + Math.floor(lvl * lvl * 4);
                const cappedSize = Math.min(size, 151); // Cap at 151 for performance
                const maze = generateMaze(cappedSize | 1, cappedSize | 1);
                mazeRef.current = maze;
                playerRef.current = { x: 1, y: 1 };

                // Find exit (bottom-right area)
                for (let y = maze.length - 2; y > maze.length / 2; y--) {
                    for (let x = maze[0].length - 2; x > maze[0].length / 2; x--) {
                        if (maze[y][x] === 0) {
                            exitRef.current = { x, y };
                            break;
                        }
                    }
                    if (exitRef.current.x !== 0) break;
                }

                setWon(false);
                setShowingMaze(false);
                draw();
            };

            const draw = () => {
                const canvas = canvasRef.current;
                if (!canvas || !mazeRef.current) return;
                const ctx = canvas.getContext('2d');
                const maze = mazeRef.current;

                canvas.width = maze[0].length * CELL_SIZE;
                canvas.height = maze.length * CELL_SIZE;

                // Draw maze
                for (let y = 0; y < maze.length; y++) {
                    for (let x = 0; x < maze[0].length; x++) {
                        ctx.fillStyle = maze[y][x] === 1 ? '#000' : '#fff';
                        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }

                // Draw exit (flag icon)
                const ex = exitRef.current.x * CELL_SIZE;
                const ey = exitRef.current.y * CELL_SIZE;
                ctx.fillStyle = '#0f0';
                ctx.fillRect(ex + 1, ey + 1, CELL_SIZE - 2, CELL_SIZE - 2);
                ctx.fillStyle = '#000';
                ctx.fillRect(ex + 2, ey + 2, 2, CELL_SIZE - 4); // Pole
                ctx.fillRect(ex + 4, ey + 2, 3, 3); // Flag

                // Draw player (person icon)
                const px = playerRef.current.x * CELL_SIZE;
                const py = playerRef.current.y * CELL_SIZE;
                ctx.fillStyle = '#f00';
                // Head
                ctx.beginPath();
                ctx.arc(px + CELL_SIZE/2, py + 2, 2, 0, Math.PI * 2);
                ctx.fill();
                // Body
                ctx.fillRect(px + CELL_SIZE/2 - 1, py + 4, 2, 3);
                // Legs
                ctx.fillRect(px + CELL_SIZE/2 - 2, py + 6, 1, 2);
                ctx.fillRect(px + CELL_SIZE/2 + 1, py + 6, 1, 2);
            };

            const move = (dx, dy) => {
                if (won || showingMaze) return;
                const maze = mazeRef.current;
                if (!maze) return;

                const nx = playerRef.current.x + dx;
                const ny = playerRef.current.y + dy;

                if (nx >= 0 && nx < maze[0].length && ny >= 0 && ny < maze.length && maze[ny][nx] === 0) {
                    playerRef.current = { x: nx, y: ny };
                    draw();

                    if (nx === exitRef.current.x && ny === exitRef.current.y) {
                        const points = level * 100;
                        setScore(s => {
                            const newScore = s + points;
                            setHighScore(h => Math.max(h, newScore));
                            return newScore;
                        });
                        setWon(true);

                        // Show full maze then start next level
                        setTimeout(() => {
                            setShowingMaze(true);
                            setTimeout(() => {
                                setLevel(l => l + 1);
                                startLevel(level + 1);
                            }, 2000);
                        }, 1000);
                    }
                }
            };

            const giveUp = () => {
                setLevel(1);
                setScore(0);
                startLevel(1);
            };

            useEffect(() => {
                const handle = (e) => {
                    if (e.key === 'ArrowUp') move(0, -1);
                    if (e.key === 'ArrowDown') move(0, 1);
                    if (e.key === 'ArrowLeft') move(-1, 0);
                    if (e.key === 'ArrowRight') move(1, 0);
                };
                window.addEventListener('keydown', handle);
                startLevel(1);
                return () => window.removeEventListener('keydown', handle);
            }, []);

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex justify-between items-center">
                        <span className="font-mono text-xs font-bold">LABYRINTH.EXE</span>
                        <div className="flex gap-4 font-mono text-xs">
                            <span>LVL: <span className="font-bold">{level}</span></span>
                            <span>SCORE: <span className="font-bold">{score}</span></span>
                            <span>HIGH: <span className="font-bold">{highScore}</span></span>
                        </div>
                    </div>
                    <div className="flex-grow flex items-center justify-center p-4 overflow-auto relative bg-gray-50">
                        {won && !showingMaze && (
                            <div className="absolute inset-0 bg-white/95 flex items-center justify-center z-10">
                                <div className="text-center">
                                    <div className="text-2xl font-black mb-2">YOU FOUND THE WAY OUT</div>
                                    <div className="font-mono text-sm text-gray-500">+{level * 100} POINTS</div>
                                </div>
                            </div>
                        )}
                        {showingMaze && (
                            <div className="absolute inset-0 bg-white/95 flex items-center justify-center z-10">
                                <div className="text-center">
                                    <div className="text-xl font-mono font-bold mb-2">MAZE {level} COMPLETE</div>
                                    <div className="font-mono text-xs text-gray-500">GENERATING HARDER MAZE...</div>
                                </div>
                            </div>
                        )}
                        <div className="border-2 border-black bg-white p-1">
                            <canvas ref={canvasRef} className="block" style={{ imageRendering: 'pixelated' }} />
                        </div>
                    </div>
                    <div className="p-2 border-t-2 border-black bg-white flex justify-between items-center">
                        <span className="font-mono text-[10px] text-gray-500">ARROW KEYS TO MOVE</span>
                        <button
                            onClick={giveUp}
                            className="font-mono text-[10px] text-gray-500 hover:text-black italic"
                        >
                            "How will we ever get out of this labyrinth?"
                        </button>
                    </div>
                </div>
            );
        };

        // --- SYNTH_001.WAV - Brutalist Synthesizer ---
        const SynthApp = () => {
            const [tempo, setTempo] = useState(120);
            const [filter, setFilter] = useState(1000);
            const [isPlaying, setIsPlaying] = useState(false);
            const [currentStep, setCurrentStep] = useState(0);
            const [grid, setGrid] = useState(() => {
                return {
                    sine: Array(16).fill(false),
                    square: Array(16).fill(false),
                    saw: Array(16).fill(false),
                    noise: Array(16).fill(false)
                };
            });
            const audioCtxRef = useRef(null);
            const intervalRef = useRef(null);

            const oscillators = ['sine', 'square', 'saw', 'noise'];

            const toggleNote = (osc, step) => {
                setGrid(prev => ({
                    ...prev,
                    [osc]: prev[osc].map((v, i) => i === step ? !v : v)
                }));
            };

            const playSound = (type, filterFreq) => {
                if (!audioCtxRef.current) {
                    audioCtxRef.current = new (window.AudioContext || window.webkitAudioContext)();
                }
                const ctx = audioCtxRef.current;

                let osc;
                const gain = ctx.createGain();
                const filt = ctx.createBiquadFilter();
                filt.type = 'lowpass';
                filt.frequency.value = filterFreq;

                if (type === 'noise') {
                    const bufferSize = ctx.sampleRate * 0.1;
                    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        data[i] = Math.random() * 2 - 1;
                    }
                    osc = ctx.createBufferSource();
                    osc.buffer = buffer;
                } else {
                    osc = ctx.createOscillator();
                    osc.type = type === 'saw' ? 'sawtooth' : type;
                    osc.frequency.value = 220 + Math.random() * 110;
                }

                gain.gain.setValueAtTime(0.3, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);

                osc.connect(filt);
                filt.connect(gain);
                gain.connect(ctx.destination);
                osc.start(ctx.currentTime);
                osc.stop(ctx.currentTime + 0.1);
            };

            const togglePlay = () => {
                if (isPlaying) {
                    clearInterval(intervalRef.current);
                    setIsPlaying(false);
                    setCurrentStep(0);
                } else {
                    setIsPlaying(true);
                    let step = 0;
                    intervalRef.current = setInterval(() => {
                        setCurrentStep(step);
                        oscillators.forEach(osc => {
                            if (grid[osc][step]) {
                                playSound(osc, filter);
                            }
                        });
                        step = (step + 1) % 16;
                    }, (60 / tempo) * 250);
                }
            };

            useEffect(() => {
                return () => clearInterval(intervalRef.current);
            }, []);

            useEffect(() => {
                if (isPlaying) {
                    clearInterval(intervalRef.current);
                    let step = currentStep;
                    intervalRef.current = setInterval(() => {
                        setCurrentStep(step);
                        oscillators.forEach(osc => {
                            if (grid[osc][step]) {
                                playSound(osc, filter);
                            }
                        });
                        step = (step + 1) % 16;
                    }, (60 / tempo) * 250);
                }
            }, [tempo, filter, grid]);

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex justify-between items-center">
                        <span className="font-mono text-xs font-bold">SYNTH_001.WAV</span>
                        <button
                            onClick={togglePlay}
                            className={`px-4 py-1 font-mono text-xs font-bold border-2 border-black ${isPlaying ? 'bg-black text-white' : 'bg-white text-black hover:bg-black hover:text-white'}`}
                        >
                            {isPlaying ? '■ STOP' : '► PLAY'}
                        </button>
                    </div>
                    <div className="flex-grow p-4 overflow-auto bg-gray-50">
                        <div className="space-y-2">
                            {oscillators.map(osc => (
                                <div key={osc} className="flex items-center gap-2">
                                    <span className="font-mono text-[10px] w-12 text-gray-500 uppercase">{osc}</span>
                                    <div className="flex gap-1">
                                        {grid[osc].map((active, i) => (
                                            <button
                                                key={i}
                                                onClick={() => toggleNote(osc, i)}
                                                className={`w-6 h-8 border-2 transition-all ${
                                                    active
                                                        ? 'bg-black border-black'
                                                        : 'bg-white border-gray-300 hover:border-black'
                                                } ${currentStep === i && isPlaying ? 'ring-2 ring-black ring-offset-1' : ''}`}
                                            />
                                        ))}
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                    <div className="p-4 border-t-2 border-black bg-white flex gap-8">
                        <div className="flex items-center gap-2">
                            <span className="font-mono text-[10px] text-gray-500">TEMPO</span>
                            <input
                                type="range"
                                min="60"
                                max="200"
                                value={tempo}
                                onChange={(e) => setTempo(Number(e.target.value))}
                                className="w-24 accent-black"
                            />
                            <span className="font-mono text-xs w-8 text-black">{tempo}</span>
                        </div>
                        <div className="flex items-center gap-2">
                            <span className="font-mono text-[10px] text-gray-500">FILTER</span>
                            <input
                                type="range"
                                min="100"
                                max="5000"
                                value={filter}
                                onChange={(e) => setFilter(Number(e.target.value))}
                                className="w-24 accent-black"
                            />
                            <span className="font-mono text-xs w-12 text-black">{filter}Hz</span>
                        </div>
                    </div>
                </div>
            );
        };

        // --- DESTRUCTION.EXE - Screen destroyer with confirmations ---
        const DestructionApp = ({ onDogSteal }) => {
            const [confirmStep, setConfirmStep] = useState(0);
            const [buttonPos, setButtonPos] = useState({ x: 0, y: 0 });
            const [dogStealing, setDogStealing] = useState(false);
            const [dogPos, setDogPos] = useState({ x: -100, y: 200 });
            const [buttonGone, setButtonGone] = useState(false);

            const confirmMessages = [
                { prompt: "EXECUTE", response: "You want to do it?" },
                { prompt: "YES", response: "Are you sure?" },
                { prompt: "I'M SURE", response: "Really though?" },
                { prompt: "REALLY", response: "Really, really though?" },
                { prompt: "YES REALLY", response: "Like... REALLY really?" },
                { prompt: "DO IT", response: "You know this destroys EVERYTHING?" },
                { prompt: "I KNOW", response: "There's no going back..." },
                { prompt: "I DON'T CARE", response: "Final warning..." },
                { prompt: "JUST DO IT", response: "Okay... last chance to back out..." },
                { prompt: "DESTROY IT ALL", response: "..." }
            ];

            const handleClick = () => {
                if (confirmStep < 9) {
                    setConfirmStep(prev => prev + 1);
                } else {
                    // Final click - dog steals the button!
                    setDogStealing(true);

                    // Animate dog running in
                    let dogX = -100;
                    const dogRun = setInterval(() => {
                        dogX += 15;
                        setDogPos({ x: dogX, y: 150 + Math.sin(dogX / 20) * 10 });

                        if (dogX >= 120) {
                            clearInterval(dogRun);
                            setButtonGone(true);

                            // Dog runs away with button
                            const dogEscape = setInterval(() => {
                                dogX += 20;
                                setDogPos({ x: dogX, y: 150 + Math.sin(dogX / 15) * 15 });

                                if (dogX > window.innerWidth + 100) {
                                    clearInterval(dogEscape);
                                    if (onDogSteal) onDogSteal();
                                }
                            }, 30);
                        }
                    }, 30);
                }
            };

            return (
                <div className="h-full flex flex-col bg-white select-none relative overflow-hidden">
                    <div className="p-2 border-b-2 border-black bg-white flex justify-between items-center">
                        <span className="font-mono text-xs font-bold">DESTRUCTION.EXE</span>
                        <span className="font-mono text-[10px] text-gray-500">DANGER ZONE</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center bg-gray-50 relative z-10">
                        <div className="text-center">
                            <svg width="64" height="64" viewBox="0 0 64 64" className="mx-auto mb-4" style={{ imageRendering: 'pixelated' }}>
                                <rect x="16" y="4" width="32" height="8" fill="#000" />
                                <rect x="12" y="12" width="40" height="8" fill="#000" />
                                <rect x="8" y="20" width="48" height="16" fill="#000" />
                                <rect x="14" y="22" width="12" height="10" fill="#fff" />
                                <rect x="38" y="22" width="12" height="10" fill="#fff" />
                                <rect x="28" y="34" width="8" height="6" fill="#fff" />
                                <rect x="12" y="40" width="40" height="8" fill="#000" />
                                <rect x="16" y="42" width="4" height="6" fill="#fff" />
                                <rect x="24" y="42" width="4" height="6" fill="#fff" />
                                <rect x="36" y="42" width="4" height="6" fill="#fff" />
                                <rect x="44" y="42" width="4" height="6" fill="#fff" />
                                <rect x="16" y="48" width="32" height="8" fill="#000" />
                            </svg>
                            <div className="font-mono text-sm mb-2 text-black">DESTRUCTION.EXE</div>
                            <div className="font-mono text-xs text-gray-500 mb-6">
                                {confirmStep === 0 ? "WARNING: WILL DESTROY EVERYTHING" : confirmMessages[confirmStep - 1]?.response || "..."}
                            </div>
                            {!buttonGone && (
                                <button
                                    onClick={handleClick}
                                    className={`px-8 py-4 bg-black text-white font-mono font-bold text-sm hover:invert border-2 border-black transition-all ${confirmStep > 5 ? 'animate-pulse' : ''}`}
                                    style={{
                                        transform: `translate(${buttonPos.x}px, ${buttonPos.y}px)`,
                                    }}
                                >
                                    {confirmMessages[confirmStep].prompt}
                                </button>
                            )}
                            {buttonGone && !dogStealing && (
                                <div className="font-mono text-sm text-gray-500">
                                    The button is gone...
                                </div>
                            )}
                        </div>
                    </div>

                    {/* Dog stealing animation - cute dog matching the main sprite */}
                    {dogStealing && (
                        <div
                            className="absolute z-20"
                            style={{ left: dogPos.x, top: dogPos.y }}
                        >
                            <svg width="64" height="48" viewBox="0 0 64 48" style={{ imageRendering: 'pixelated' }}>
                                {/* Cute dog - full black, same as released dog */}
                                {/* Body */}
                                <rect x="16" y="16" width="32" height="16" fill="#000" />
                                {/* Head - rounder, cuter */}
                                <rect x="4" y="12" width="16" height="16" fill="#000" />
                                {/* Floppy ears */}
                                <rect x="2" y="4" width="6" height="14" fill="#000" />
                                <rect x="14" y="4" width="6" height="14" fill="#000" />
                                {/* Eye - big cute eye */}
                                <rect x="8" y="16" width="6" height="6" fill="#fff" />
                                <rect x="10" y="18" width="3" height="3" fill="#000" />
                                {/* Nose */}
                                <rect x="4" y="22" width="4" height="4" fill="#000" />
                                {/* Running legs */}
                                <rect x="16" y="32" width="6" height="12" fill="#000" />
                                <rect x="26" y="32" width="6" height="10" fill="#000" />
                                <rect x="34" y="32" width="6" height="12" fill="#000" />
                                <rect x="42" y="32" width="6" height="10" fill="#000" />
                                {/* Tail - wagging */}
                                <rect x="48" y="12" width="12" height="4" fill="#000" />
                                <rect x="58" y="8" width="4" height="6" fill="#000" />
                            </svg>
                            {buttonGone && (
                                <div className="absolute -top-4 left-10 px-2 py-1 bg-black text-white font-mono text-[8px] border-2 border-black">
                                    DESTROY
                                </div>
                            )}
                        </div>
                    )}

                    {dogStealing && buttonGone && (
                        <div className="absolute bottom-4 w-full text-center">
                            <div className="font-mono text-xs text-gray-600">
                                *dog runs away with the button*
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // --- TAROT.DAT - Tarot card pull ---
        const TarotApp = () => {
            const [card, setCard] = useState(null);
            const [revealed, setRevealed] = useState(false);
            const [alreadyPulled, setAlreadyPulled] = useState(false);
            const [isShuffling, setIsShuffling] = useState(false);
            const [shuffleFrame, setShuffleFrame] = useState(0);

            const tarotCards = [
                { name: 'THE FOOL', meaning: 'New beginnings, innocence, spontaneity', ascii: `
   ┌─────────┐
   │    ☀    │
   │   ╱│╲   │
   │    │    │
   │   ╱ ╲   │
   │  🐕     │
   │ ~~~~~~~~│
   │    0    │
   └─────────┘` },
                { name: 'THE MAGICIAN', meaning: 'Manifestation, resourcefulness, power', ascii: `
   ┌─────────┐
   │    ∞    │
   │   ╱│╲   │
   │  ☆ │ ☆  │
   │ ⚗ ⚔ 🏆 💰│
   │   ╱ ╲   │
   │    I    │
   └─────────┘` },
                { name: 'THE HIGH PRIESTESS', meaning: 'Intuition, mystery, inner knowledge', ascii: `
   ┌─────────┐
   │  ☽   ☾  │
   │    👑   │
   │   ╱│╲   │
   │  B │ J  │
   │ ═══════ │
   │   II    │
   └─────────┘` },
                { name: 'THE EMPRESS', meaning: 'Abundance, nurturing, fertility', ascii: `
   ┌─────────┐
   │   ♀     │
   │    👑   │
   │   ╱█╲   │
   │  🌾🌾🌾  │
   │ ~~~~~~~~│
   │   III   │
   └─────────┘` },
                { name: 'THE EMPEROR', meaning: 'Authority, structure, control', ascii: `
   ┌─────────┐
   │   ♂     │
   │    👑   │
   │  ╔███╗  │
   │  ║ █ ║  │
   │  ╚═══╝  │
   │   IV    │
   └─────────┘` },
                { name: 'THE HIEROPHANT', meaning: 'Tradition, conformity, spirituality', ascii: `
   ┌─────────┐
   │   ╬╬╬   │
   │    👑   │
   │   ╱█╲   │
   │  ♰ █ ♰  │
   │ ⛪⛪⛪  │
   │    V    │
   └─────────┘` },
                { name: 'THE LOVERS', meaning: 'Love, harmony, relationships', ascii: `
   ┌─────────┐
   │    ☀    │
   │   ╱█╲   │
   │  ♀   ♂  │
   │  │ ♥ │  │
   │ 🌳   🌳 │
   │   VI    │
   └─────────┘` },
                { name: 'THE CHARIOT', meaning: 'Willpower, determination, success', ascii: `
   ┌─────────┐
   │   ☆☆☆   │
   │    👑   │
   │  ╔███╗  │
   │  ╚═╦═╝  │
   │ ◀■■■■▶  │
   │   VII   │
   └─────────┘` },
                { name: 'STRENGTH', meaning: 'Courage, persuasion, inner strength', ascii: `
   ┌─────────┐
   │    ∞    │
   │   ╱│╲   │
   │    │ 🦁 │
   │   ╱ ╲   │
   │ ~~~~~~~~│
   │  VIII   │
   └─────────┘` },
                { name: 'THE HERMIT', meaning: 'Soul-searching, introspection, solitude', ascii: `
   ┌─────────┐
   │    ☆    │
   │  ╱ │    │
   │ 🏮 │    │
   │   ╱│╲   │
   │  ▲▲▲▲▲  │
   │   IX    │
   └─────────┘` },
                { name: 'WHEEL OF FORTUNE', meaning: 'Change, cycles, destiny', ascii: `
   ┌─────────┐
   │  T   ☽  │
   │ ╱─────╲ │
   │ │  ◎  │ │
   │ ╲─────╱ │
   │  ☾   A  │
   │    X    │
   └─────────┘` },
                { name: 'JUSTICE', meaning: 'Fairness, truth, law', ascii: `
   ┌─────────┐
   │    👑   │
   │   ╱│╲   │
   │ ⚖    ⚔ │
   │   ╱ ╲   │
   │ ═══════ │
   │   XI    │
   └─────────┘` },
                { name: 'THE HANGED MAN', meaning: 'Surrender, letting go, new perspective', ascii: `
   ┌─────────┐
   │ ═══════ │
   │    │    │
   │   ╱│╲   │
   │    │    │
   │   ╲ ╱   │
   │   XII   │
   └─────────┘` },
                { name: 'DEATH', meaning: 'Endings, change, transformation', ascii: `
   ┌─────────┐
   │   ☠☠☠   │
   │    │    │
   │   ╱█╲   │
   │  🏴│🏴  │
   │ ~~~~~~~~│
   │  XIII   │
   └─────────┘` },
                { name: 'TEMPERANCE', meaning: 'Balance, moderation, patience', ascii: `
   ┌─────────┐
   │    ☀    │
   │   ╱│╲   │
   │  🏺→🏺  │
   │   ╱ ╲   │
   │ ~~~~~~~~│
   │  XIV    │
   └─────────┘` },
                { name: 'THE DEVIL', meaning: 'Shadow self, attachment, addiction', ascii: `
   ┌─────────┐
   │   ⛧⛧⛧   │
   │    👿   │
   │   ╱█╲   │
   │  ⛓   ⛓  │
   │ 🔥🔥🔥  │
   │   XV    │
   └─────────┘` },
                { name: 'THE TOWER', meaning: 'Sudden change, upheaval, revelation', ascii: `
   ┌─────────┐
   │  ⚡👑⚡  │
   │   ╔█╗   │
   │   ║█║   │
   │  🔥█🔥  │
   │ ▓▓▓▓▓▓▓ │
   │  XVI    │
   └─────────┘` },
                { name: 'THE STAR', meaning: 'Hope, faith, renewal', ascii: `
   ┌─────────┐
   │  ★ ☆ ★  │
   │ ☆  ★  ☆ │
   │   ╱│╲   │
   │  🏺 🏺  │
   │ ~~~~~~~~│
   │  XVII   │
   └─────────┘` },
                { name: 'THE MOON', meaning: 'Illusion, fear, subconscious', ascii: `
   ┌─────────┐
   │   ☽☾    │
   │ ╱─────╲ │
   │ 🐺   🐺 │
   │   🦞    │
   │ ~~~~~~~~│
   │ XVIII   │
   └─────────┘` },
                { name: 'THE SUN', meaning: 'Joy, success, celebration', ascii: `
   ┌─────────┐
   │ ╲ │ │ ╱ │
   │ ──☀☀──  │
   │ ╱ │ │ ╲ │
   │   ╱│╲   │
   │  🌻🌻🌻 │
   │  XIX    │
   └─────────┘` },
                { name: 'JUDGEMENT', meaning: 'Reflection, reckoning, awakening', ascii: `
   ┌─────────┐
   │  📯📯📯 │
   │   ╱│╲   │
   │ ┌─┴─┐   │
   │ │☠☠☠│   │
   │ └───┘   │
   │   XX    │
   └─────────┘` },
                { name: 'THE WORLD', meaning: 'Completion, accomplishment, travel', ascii: `
   ┌─────────┐
   │ ◇     ◇ │
   │ ╱─────╲ │
   │ │  ♀  │ │
   │ ╲─────╱ │
   │ ◇     ◇ │
   │  XXI    │
   └─────────┘` }
            ];

            useEffect(() => {
                // Check localStorage for existing pull (simulating IP-based storage)
                const savedCard = localStorage.getItem('tarot_card');
                if (savedCard) {
                    setCard(JSON.parse(savedCard));
                    setRevealed(true);
                    setAlreadyPulled(true);
                }
            }, []);

            const shuffleCards = [
                `   ┌─────────┐
   │ ╲ ╱ ╲ ╱ │
   │  ╳   ╳  │
   │ ╱ ╲ ╱ ╲ │
   │  ╳   ╳  │
   │ ╲ ╱ ╲ ╱ │
   │ SHUFFLE │
   └─────────┘`,
                `  ┌─────────┐
   │ ╱ ╲ ╱ ╲ │
   │  ╳   ╳  │
   │ ╲ ╱ ╲ ╱ │
   │  ╳   ╳  │
   │ ╱ ╲ ╱ ╲ │
   │ SHUFFLE │
   └─────────┘`,
                `    ┌─────────┐
   │ ╲ ╱ ╲ ╱ │
   │ ╱ ╲ ╱ ╲ │
   │  ╳   ╳  │
   │ ╲ ╱ ╲ ╱ │
   │ ╱ ╲ ╱ ╲ │
   │ SHUFFLE │
   └─────────┘`
            ];

            const pullCard = () => {
                if (alreadyPulled || isShuffling) return;

                setIsShuffling(true);
                let frame = 0;
                const shuffleInterval = setInterval(() => {
                    setShuffleFrame(f => (f + 1) % 3);
                    frame++;
                    if (frame >= 12) {
                        clearInterval(shuffleInterval);
                        setIsShuffling(false);
                        const randomCard = tarotCards[Math.floor(Math.random() * tarotCards.length)];
                        setCard(randomCard);
                        localStorage.setItem('tarot_card', JSON.stringify(randomCard));
                        setTimeout(() => setRevealed(true), 500);
                        setAlreadyPulled(true);
                    }
                }, 150);
            };

            return (
                <div className="h-full flex flex-col bg-purple-950 text-white select-none">
                    <div className="p-3 border-b border-purple-800">
                        <span className="font-mono text-xs text-purple-400">TAROT.DAT // YOUR FATE AWAITS</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-4">
                        {isShuffling ? (
                            <div className="text-center">
                                <pre className="font-mono text-xs text-purple-300 mb-4 animate-pulse" style={{ transform: `rotate(${shuffleFrame * 2 - 2}deg)` }}>
                                    {shuffleCards[shuffleFrame]}
                                </pre>
                                <div className="font-mono text-xs text-purple-400">SHUFFLING THE DECK...</div>
                            </div>
                        ) : !card ? (
                            <div className="text-center">
                                <pre className="font-mono text-xs text-purple-300 mb-4">
{`   ┌─────────┐
   │ ╲     ╱ │
   │  ╲ ? ╱  │
   │   ╲ ╱   │
   │   ╱ ╲   │
   │  ╱   ╲  │
   │ ╱     ╲ │
   └─────────┘`}
                                </pre>
                                <button
                                    onClick={pullCard}
                                    className="px-6 py-3 bg-purple-800 text-white font-mono font-bold hover:bg-purple-700 border-2 border-purple-500"
                                >
                                    PULL YOUR CARD
                                </button>
                                <p className="mt-4 font-mono text-xs text-purple-500">ONE PULL PER VISITOR</p>
                            </div>
                        ) : (
                            <div className={`text-center transition-all duration-500 ${revealed ? 'opacity-100' : 'opacity-0'}`}>
                                <pre className="font-mono text-xs text-yellow-200 mb-4">{card.ascii}</pre>
                                <div className="text-xl font-black mb-2">{card.name}</div>
                                <div className="font-mono text-sm text-purple-300 max-w-xs">{card.meaning}</div>
                                {alreadyPulled && (
                                    <p className="mt-4 font-mono text-xs text-purple-600">YOUR FATE HAS BEEN SEALED</p>
                                )}
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // --- APPS Folder - Grid of all apps ---
        const AppsFolder = ({ onOpenApp }) => {
            const apps = [
                { id: 'VOID', title: 'VOID.TXT', icon: 'Void' },
                { id: 'ORACLE', title: 'ORACLE.EXE', icon: 'Oracle' },
                { id: 'RADIO', title: 'RADIO.WAV', icon: 'Radio' },
                { id: 'DICE', title: 'DICE.EXE', icon: 'Dice' },
                { id: 'SNAKE', title: 'SNEK.EXE', icon: 'Snek' },
                { id: 'LABYRINTH', title: 'LABYRINTH.EXE', icon: 'Labyrinth' },
                { id: 'SYNTH', title: 'SYNTH_001.WAV', icon: 'Synth' },
                { id: 'DESTRUCTION', title: 'DESTRUCTION.EXE', icon: 'Destruction' },
                { id: 'TAROT', title: 'TAROT.DAT', icon: 'Tarot' },
                { id: 'DOG', title: 'DOG.EXE', icon: 'Dog' },
                { id: 'PAINT', title: 'PAINT.EXE', icon: 'Palette' },
                { id: 'TRASH', title: 'TRASH.BIN', icon: 'TrashCan' }
            ];

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex items-center gap-2">
                        <Icons.Apps size={24} />
                        <span className="font-mono text-xs font-bold">APPS</span>
                        <span className="font-mono text-xs text-gray-400">({apps.length} items)</span>
                    </div>
                    <div className="flex-grow p-6 overflow-auto bg-gray-50">
                        <div className="grid grid-cols-4 gap-6">
                            {apps.map(app => {
                                const AppIcon = Icons[app.icon];
                                return (
                                    <button
                                        key={app.id}
                                        onClick={() => onOpenApp(app.id)}
                                        className="group flex flex-col items-center gap-2 p-4 hover:bg-white border-2 border-transparent hover:border-black transition-all"
                                    >
                                        <div className="bg-white border-2 border-black p-3 icon-shadow group-hover:translate-x-1 group-hover:translate-y-1 group-hover:shadow-none transition-all">
                                            <AppIcon size={32} />
                                        </div>
                                        <span className="font-mono text-[10px] font-bold uppercase text-center">{app.title}</span>
                                    </button>
                                );
                            })}
                        </div>
                    </div>
                </div>
            );
        };

        // --- CONTACT - Email via Paint ---
        const ContactApp = ({ onOpenPaint }) => {
            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex items-center gap-2">
                        <Icons.Email size={24} />
                        <span className="font-mono text-xs font-bold">CONTACT</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center bg-gray-50 p-8">
                        <Icons.Email size={64} />
                        <div className="font-mono text-lg font-bold mt-4 mb-2">GET IN TOUCH</div>
                        <div className="font-mono text-sm text-gray-500 mb-6">mateusmuste9@gmail.com</div>
                        <button
                            onClick={onOpenPaint}
                            className="px-6 py-3 bg-black text-white font-mono font-bold text-sm hover:invert border-2 border-black"
                        >
                            DRAW YOUR MESSAGE
                        </button>
                        <div className="font-mono text-[10px] text-gray-400 mt-4">
                            Opens PAINT.EXE
                        </div>
                    </div>
                </div>
            );
        };

        // --- DOG.EXE - Pixel dog pet ---
        const DogApp = ({ onClose }) => {
            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex justify-between items-center">
                        <span className="font-mono text-xs font-bold">DOG.EXE</span>
                        <span className="font-mono text-[10px] text-gray-500">GOOD BOY</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center bg-gray-50">
                        <div className="text-center p-4">
                            <svg width="96" height="72" viewBox="0 0 64 48" className="mx-auto mb-4" style={{ imageRendering: 'pixelated' }}>
                                {/* Cute dog - full black */}
                                <rect x="16" y="16" width="32" height="16" fill="#000" />
                                <rect x="4" y="12" width="16" height="16" fill="#000" />
                                <rect x="4" y="4" width="6" height="12" fill="#000" />
                                <rect x="14" y="4" width="6" height="12" fill="#000" />
                                <rect x="8" y="18" width="4" height="4" fill="#fff" />
                                <rect x="9" y="19" width="2" height="2" fill="#000" />
                                <rect x="6" y="24" width="4" height="2" fill="#000" />
                                <rect x="16" y="32" width="6" height="12" fill="#000" />
                                <rect x="38" y="32" width="6" height="12" fill="#000" />
                                <rect x="48" y="12" width="12" height="4" fill="#000" />
                                <rect x="56" y="8" width="4" height="8" fill="#000" />
                            </svg>
                            <div className="font-mono text-sm font-bold mb-2">DOG.EXE</div>
                            <div className="font-mono text-xs text-gray-500 mb-4">CLICK TO RELEASE THE DOG</div>
                            <button
                                onClick={onClose}
                                className="px-6 py-3 bg-black text-white font-mono font-bold text-sm hover:invert border-2 border-black"
                            >
                                RELEASE
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // --- OS SHELL ---

        const OS = () => {
            const [booted, setBooted] = useState(false);
            const [topZ, setTopZ] = useState(100);
            const [destructionMode, setDestructionMode] = useState(false);
            const [dogReleased, setDogReleased] = useState(false);
            const [dogPos, setDogPos] = useState({ x: 100, y: 300 });
            const [dogVel, setDogVel] = useState({ x: 4, y: 3 });
            const [dogOnGround, setDogOnGround] = useState(true);
            const [dogFacingRight, setDogFacingRight] = useState(true);
            const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
            const [carriedIcon, setCarriedIcon] = useState(null);
            const [iconPositions, setIconPositions] = useState({});
            const [destructionDogGone, setDestructionDogGone] = useState(false);

            // Physics constants
            const GRAVITY = 0.8;
            const JUMP_FORCE = -12;
            const GROUND_Y = window.innerHeight - 120;
            const FRICTION = 0.95;

            // Handle dog stealing the destruction button
            const handleDogSteal = () => {
                setDestructionDogGone(true);
                // Close the destruction window
                setWindows(prev => ({
                    ...prev,
                    DESTRUCTION: { ...prev.DESTRUCTION, isOpen: false }
                }));
            };

            // Dog AI - DVD logo style bouncing
            useEffect(() => {
                if (!dogReleased) return;

                const DOG_SPEED_X = 4;
                const DOG_SPEED_Y = 3;

                const dogInterval = setInterval(() => {
                    setDogVel(prevVel => {
                        let newVelX = prevVel.x;
                        let newVelY = prevVel.y;

                        // Initialize velocity if zero
                        if (newVelX === 0) newVelX = DOG_SPEED_X;
                        if (newVelY === 0) newVelY = DOG_SPEED_Y;

                        return { x: newVelX, y: newVelY };
                    });

                    setDogPos(prev => {
                        let newX = prev.x + dogVel.x;
                        let newY = prev.y + dogVel.y;

                        // Bounce off walls - DVD style
                        if (newX >= window.innerWidth - 80) {
                            newX = window.innerWidth - 80;
                            setDogVel(v => ({ ...v, x: -Math.abs(v.x) }));
                            setDogFacingRight(false);
                        }
                        if (newX <= 0) {
                            newX = 0;
                            setDogVel(v => ({ ...v, x: Math.abs(v.x) }));
                            setDogFacingRight(true);
                        }
                        if (newY >= window.innerHeight - 100) {
                            newY = window.innerHeight - 100;
                            setDogVel(v => ({ ...v, y: -Math.abs(v.y) }));
                        }
                        if (newY <= 60) {
                            newY = 60;
                            setDogVel(v => ({ ...v, y: Math.abs(v.y) }));
                        }

                        return { x: newX, y: newY };
                    });

                    // Randomly grab icons
                    if (!carriedIcon && Math.random() < 0.003) {
                        const iconKeys = Object.keys(windows);
                        const randomIcon = iconKeys[Math.floor(Math.random() * iconKeys.length)];
                        setCarriedIcon(randomIcon);

                        setTimeout(() => {
                            setCarriedIcon(null);
                        }, 3000 + Math.random() * 4000);
                    }
                }, 30);

                return () => clearInterval(dogInterval);
            }, [dogReleased, dogVel, carriedIcon]);

            // Desktop icons - only show main folders
            const desktopIcons = ["SYSTEM", "FILES", "APPS", "CONTACT"];

            // Window State (Position x/y added for dragging) - content rendered separately
            const [windows, setWindows] = useState({
                "SYSTEM": { id: "SYSTEM", title: "SYSTEM_INFO", icon: "Terminal", x: 50, y: 50, w: '1000px', h: '800px', isOpen: true, isMin: false, z: 10, isDesktop: true },
                "FILES": { id: "FILES", title: "MEDIA_LIB", icon: "Folder", x: 100, y: 80, w: '800px', h: '500px', isOpen: false, isMin: false, z: 11, isDesktop: true },
                "APPS": { id: "APPS", title: "APPS", icon: "Apps", x: 150, y: 110, w: '700px', h: '500px', isOpen: false, isMin: false, z: 12, isDesktop: true },
                "CONTACT": { id: "CONTACT", title: "CONTACT", icon: "Email", x: 200, y: 140, w: '400px', h: '350px', isOpen: false, isMin: false, z: 13, isDesktop: true },
                "PAINT": { id: "PAINT", title: "PAINT.EXE", icon: "Palette", x: 150, y: 110, w: '700px', h: '600px', isOpen: false, isMin: false, z: 14 },
                "SNAKE": { id: "SNAKE", title: "SNEK.EXE", icon: "Snek", x: 200, y: 140, w: '640px', h: '520px', isOpen: false, isMin: false, z: 15 },
                "TRASH": { id: "TRASH", title: "TRASH.BIN", icon: "TrashCan", x: 250, y: 170, w: '500px', h: '400px', isOpen: false, isMin: false, z: 16 },
                "VOID": { id: "VOID", title: "VOID.TXT", icon: "Void", x: 300, y: 50, w: '500px', h: '400px', isOpen: false, isMin: false, z: 17 },
                "ORACLE": { id: "ORACLE", title: "ORACLE.EXE", icon: "Oracle", x: 350, y: 80, w: '500px', h: '450px', isOpen: false, isMin: false, z: 18 },
                "RADIO": { id: "RADIO", title: "RADIO.WAV", icon: "Radio", x: 400, y: 110, w: '400px', h: '400px', isOpen: false, isMin: false, z: 19 },
                "DICE": { id: "DICE", title: "DICE.EXE", icon: "Dice", x: 450, y: 140, w: '350px', h: '450px', isOpen: false, isMin: false, z: 20 },
                "LABYRINTH": { id: "LABYRINTH", title: "LABYRINTH.EXE", icon: "Labyrinth", x: 100, y: 50, w: '600px', h: '500px', isOpen: false, isMin: false, z: 21 },
                "SYNTH": { id: "SYNTH", title: "SYNTH_001.WAV", icon: "Synth", x: 150, y: 80, w: '500px', h: '350px', isOpen: false, isMin: false, z: 22 },
                "DESTRUCTION": { id: "DESTRUCTION", title: "DESTRUCTION.EXE", icon: "Destruction", x: 200, y: 110, w: '400px', h: '400px', isOpen: false, isMin: false, z: 23 },
                "TAROT": { id: "TAROT", title: "TAROT.DAT", icon: "Tarot", x: 250, y: 140, w: '350px', h: '450px', isOpen: false, isMin: false, z: 24 },
                "DOG": { id: "DOG", title: "DOG.EXE", icon: "Dog", x: 300, y: 170, w: '300px', h: '350px', isOpen: false, isMin: false, z: 25 }
            });

            // Render window content based on ID
            const getWindowContent = (id) => {
                switch(id) {
                    case "SYSTEM": return <SystemInfo />;
                    case "FILES": return <FileExplorer />;
                    case "APPS": return <AppsFolder onOpenApp={open} />;
                    case "CONTACT": return <ContactApp onOpenPaint={() => open("PAINT")} />;
                    case "PAINT": return <PaintApp />;
                    case "SNAKE": return <SnakeAppNew />;
                    case "TRASH": return <TrashApp />;
                    case "VOID": return <VoidApp />;
                    case "ORACLE": return <OracleApp />;
                    case "RADIO": return <RadioApp />;
                    case "DICE": return <DiceApp />;
                    case "LABYRINTH": return <LabyrinthApp />;
                    case "SYNTH": return <SynthApp />;
                    case "DESTRUCTION": return <DestructionApp onDogSteal={handleDogSteal} />;
                    case "TAROT": return <TarotApp />;
                    case "DOG": return <DogApp onClose={() => { setDogReleased(true); close("DOG"); }} />;
                    default: return null;
                }
            };

            // Dragging State
            const [drag, setDrag] = useState({ id: null, offsetX: 0, offsetY: 0 });

            useEffect(() => { setTimeout(() => setBooted(true), 600); }, []);

            // Window Ops
            const focus = (id) => {
                setWindows(p => ({ ...p, [id]: { ...p[id], z: topZ + 1 } }));
                setTopZ(z => z + 1);
            }
            const open = (id) => {
                setWindows(p => ({ ...p, [id]: { ...p[id], isOpen: true, isMin: false, z: topZ + 1 } }));
                setTopZ(z => z + 1);
            }
            const close = (id) => setWindows(p => ({ ...p, [id]: { ...p[id], isOpen: false } }));
            const toggleMin = (id) => setWindows(p => ({ ...p, [id]: { ...p[id], isMin: !p[id].isMin } }));

            // Drag Handlers
            const handleMouseDown = (e, id) => {
                e.preventDefault();
                focus(id); // bring to front
                const win = windows[id];
                const rect = e.currentTarget.getBoundingClientRect(); // click target is header
                // Calculate offset from the window's top-left corner
                // However, we track window X/Y which is top/left style. 
                // Simple math: MouseX - WindowX
                setDrag({
                    id: id,
                    offsetX: e.clientX - win.x,
                    offsetY: e.clientY - win.y
                });
            };

            const handleMouseMove = (e) => {
                if (drag.id) {
                    setWindows(prev => ({
                        ...prev,
                        [drag.id]: {
                            ...prev[drag.id],
                            x: e.clientX - drag.offsetX,
                            y: e.clientY - drag.offsetY
                        }
                    }));
                }
            };

            const handleMouseUp = () => setDrag({ id: null, offsetX: 0, offsetY: 0 });

            if (!booted) return <div className="h-screen w-screen bg-black text-white font-mono flex items-center justify-center">BOOTING_KERNEL...</div>;

            // Destruction overlay
            if (destructionMode === 'black') {
                return <div className="h-screen w-screen bg-black" />;
            }
            if (destructionMode === 'reboot') {
                return (
                    <div className="h-screen w-screen bg-black text-green-500 font-mono flex flex-col items-center justify-center">
                        <pre className="text-xs mb-4">
{`
███████╗██╗   ██╗███████╗████████╗███████╗███╗   ███╗
██╔════╝╚██╗ ██╔╝██╔════╝╚══██╔══╝██╔════╝████╗ ████║
███████╗ ╚████╔╝ ███████╗   ██║   █████╗  ██╔████╔██║
╚════██║  ╚██╔╝  ╚════██║   ██║   ██╔══╝  ██║╚██╔╝██║
███████║   ██║   ███████║   ██║   ███████╗██║ ╚═╝ ██║
╚══════╝   ╚═╝   ╚══════╝   ╚═╝   ╚══════╝╚═╝     ╚═╝
`}
                        </pre>
                        <div className="animate-pulse">REBOOTING...</div>
                        <div className="mt-4 text-xs text-green-700">DESTRUCTION COMPLETE</div>
                    </div>
                );
            }

            return (
                <div
                    className={`h-screen w-screen relative overflow-hidden desktop-bg ${destructionMode ? 'animate-pulse' : ''}`}
                    onMouseMove={(e) => {
                        handleMouseMove(e);
                        setMousePos({ x: e.clientX, y: e.clientY });
                    }}
                    onMouseUp={handleMouseUp}
                    style={destructionMode ? { filter: 'hue-rotate(180deg) saturate(3)' } : {}}
                >
                    {/* DESKTOP ICONS - Only show main folders */}
                    <div className="absolute top-4 left-4 z-0 flex flex-col gap-6">
                        {desktopIcons.map(appId => {
                            const app = windows[appId];
                            if (!app) return null;
                            const IconCmp = Icons[app.icon];
                            const iconOffset = iconPositions[app.id] || { x: 0, y: 0 };

                            // Skip icon if dog is carrying it
                            if (carriedIcon === app.id) return null;

                            return (
                                <button
                                    key={app.id}
                                    onClick={() => open(app.id)}
                                    className="group flex flex-col items-center gap-2 w-24"
                                    style={{
                                        transform: `translate(${iconOffset.x}px, ${iconOffset.y}px)`,
                                        transition: 'transform 0.3s ease'
                                    }}
                                >
                                    <div className="bg-white border-2 border-black p-3 icon-shadow group-hover:translate-x-1 group-hover:translate-y-1 group-hover:shadow-none transition-all">
                                        <IconCmp size={32} />
                                    </div>
                                    <span className="bg-white border border-black px-1 text-[10px] font-mono font-bold shadow-sm">{app.title}</span>
                                </button>
                            );
                        })}
                    </div>

                    {/* WINDOWS */}
                    {Object.values(windows).map(win => (
                        win.isOpen && !win.isMin && (
                            <div
                                key={win.id}
                                onMouseDown={() => focus(win.id)}
                                className="absolute flex flex-col bg-white border-2 border-black window-shadow"
                                style={{
                                    left: win.x,
                                    top: win.y,
                                    width: win.w,
                                    height: win.h,
                                    zIndex: win.z
                                }}
                            >
                                {/* HEADER (DRAG HANDLE) */}
                                <div
                                    className={`flex justify-between items-center p-1 border-b-2 border-black select-none cursor-move ${win.z === topZ ? 'bg-black text-white' : 'bg-gray-200 text-black'}`}
                                    onMouseDown={(e) => handleMouseDown(e, win.id)}
                                >
                                    <div className="flex items-center gap-2 pl-2 pointer-events-none">
                                        <Icons.Square size={10} className="fill-current" />
                                        <span className="font-mono text-xs font-bold tracking-widest uppercase">{win.title}</span>
                                    </div>
                                    <div className="flex gap-1" onMouseDown={e => e.stopPropagation()}>
                                        <button onClick={() => toggleMin(win.id)} className="w-6 h-6 flex items-center justify-center border border-transparent hover:bg-white/20"><Icons.Minus size={14} /></button>
                                        <button onClick={() => close(win.id)} className="w-6 h-6 flex items-center justify-center border border-transparent hover:bg-red-500 hover:text-white"><Icons.X size={14} /></button>
                                    </div>
                                </div>
                                {/* CONTENT */}
                                <div className="flex-grow overflow-auto relative bg-white" onMouseDown={e => e.stopPropagation()}>
                                    {getWindowContent(win.id)}
                                </div>
                            </div>
                        )
                    ))}

                    {/* TASKBAR */}
                    <div className="mt-auto h-12 bg-white border-t-2 border-black flex items-center px-2 gap-2 z-[99999] absolute bottom-0 w-full shadow-2xl">
                        <div className="bg-black text-white px-2 py-1 font-black mr-2 select-none">MM</div>
                        {Object.values(windows).map(win => {
                            const IconCmp = Icons[win.icon];
                            return win.isOpen && (
                                <button key={win.id}
                                    onClick={() => { if (win.isMin) toggleMin(win.id); focus(win.id) }}
                                    className={`flex items-center gap-2 px-3 py-1 border-2 border-black font-mono text-xs font-bold transition-all ${win.z === topZ && !win.isMin ? 'bg-black text-white btn-shadow' : 'bg-white hover:translate-y-[-2px]'}`}
                                >
                                    <IconCmp size={14} />
                                    <span className="uppercase hidden md:inline">{win.title}</span>
                                </button>
                            );
                        })}
                        <div className="flex-grow"></div>
                        <div className="font-mono text-xs font-bold px-4 border-l-2 border-black">{new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>
                    </div>

                    {/* DOG - Cute pixel dog with running animation */}
                    {dogReleased && (
                        <div
                            className="fixed z-[999999] cursor-pointer select-none"
                            style={{
                                left: dogPos.x,
                                top: dogPos.y,
                                transform: `scaleX(${dogFacingRight ? 1 : -1})`,
                            }}
                            onClick={() => setDogReleased(false)}
                        >
                            <svg width="64" height="48" viewBox="0 0 64 48" style={{ imageRendering: 'pixelated' }}>
                                {/* Cute dog - full black, running animation */}
                                {/* Body */}
                                <rect x="16" y="16" width="32" height="16" fill="#000" />
                                {/* Head - rounder, cuter */}
                                <rect x="4" y="12" width="16" height="16" fill="#000" />
                                {/* Floppy ears */}
                                <rect x="2" y="4" width="6" height="14" fill="#000" />
                                <rect x="14" y="4" width="6" height="14" fill="#000" />
                                {/* Eye - big cute eye */}
                                <rect x="8" y="16" width="6" height="6" fill="#fff" />
                                <rect x="10" y="18" width="3" height="3" fill="#000" />
                                {/* Nose */}
                                <rect x="4" y="22" width="4" height="4" fill="#000" />
                                {/* Tongue when running */}
                                <rect x="2" y="26" width="4" height="2" fill="#000" />
                                {/* Running legs animation using frame counter */}
                                <rect x="16" y="32" width="6" height={Math.sin(Date.now() / 100) > 0 ? 10 : 14} fill="#000" />
                                <rect x="26" y="32" width="6" height={Math.sin(Date.now() / 100) > 0 ? 14 : 10} fill="#000" />
                                <rect x="34" y="32" width="6" height={Math.sin(Date.now() / 100) > 0 ? 10 : 14} fill="#000" />
                                <rect x="42" y="32" width="6" height={Math.sin(Date.now() / 100) > 0 ? 14 : 10} fill="#000" />
                                {/* Tail - wagging */}
                                <rect x="48" y={12 + Math.sin(Date.now() / 150) * 4} width="12" height="4" fill="#000" />
                                <rect x="58" y={8 + Math.sin(Date.now() / 150) * 4} width="4" height="6" fill="#000" />
                            </svg>
                            {carriedIcon && (
                                <div
                                    className="absolute bg-white border-2 border-black p-1"
                                    style={{ top: -20, left: 8 }}
                                >
                                    {React.createElement(Icons[windows[carriedIcon]?.icon], { size: 24 })}
                                </div>
                            )}
                        </div>
                    )}

                    {/* CRT Static overlay for destruction */}
                    {destructionMode === true && (
                        <div className="fixed inset-0 z-[999998] pointer-events-none crt-static" />
                    )}

                    {/* Glitch animation styles */}
                    <style>{`
                        @keyframes glitch {
                            0% { transform: translate(0); filter: hue-rotate(0deg); }
                            20% { transform: translate(-2px, 2px); filter: hue-rotate(90deg); }
                            40% { transform: translate(2px, -2px); filter: hue-rotate(180deg); }
                            60% { transform: translate(-2px, -2px); filter: hue-rotate(270deg); }
                            80% { transform: translate(2px, 2px); filter: hue-rotate(360deg); }
                            100% { transform: translate(0); filter: hue-rotate(0deg); }
                        }
                        .group-hover\\:animate-glitch:hover {
                            animation: glitch 0.2s infinite;
                        }
                        .destruction-icon:hover {
                            animation: glitch 0.3s infinite;
                        }
                        .crt-static {
                            background: repeating-linear-gradient(
                                0deg,
                                rgba(0, 0, 0, 0.1) 0px,
                                rgba(0, 0, 0, 0.1) 1px,
                                transparent 1px,
                                transparent 2px
                            );
                            animation: static 0.1s infinite;
                        }
                        @keyframes static {
                            0% { opacity: 0.3; }
                            50% { opacity: 0.5; }
                            100% { opacity: 0.3; }
                        }
                    `}</style>

                </div>
            )
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<OS />);
    </script>
</body>

</html>