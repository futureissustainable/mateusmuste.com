<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MATEUSMUSTE // OS</title>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script src="https://cdn.tailwindcss.com"></script>

    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script type="module">
        // Try multiple CDNs for COBE with fallback
        const cdns = [
            'https://cdn.skypack.dev/cobe',
            'https://esm.sh/cobe',
            'https://unpkg.com/cobe?module'
        ];
        async function loadCobe() {
            for (const cdn of cdns) {
                try {
                    const module = await import(cdn);
                    window.createGlobe = module.default;
                    return;
                } catch (e) { console.warn('COBE CDN failed:', cdn); }
            }
            console.error('All COBE CDNs failed');
        }
        loadCobe();
    </script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Geist:wght@400;700;900&family=Geist+Mono:wght@400;700&display=swap"
        rel="stylesheet">

    <style>
        :root {
            --bg: #e5e5e5;
            --fg: #000000;
        }

        body {
            background-color: var(--bg);
            color: var(--fg);
            font-family: 'Geist', sans-serif;
            overflow: hidden;
            margin: 0;
            padding: 0;
            user-select: none;
            -webkit-font-smoothing: antialiased;
        }

        .font-mono {
            font-family: 'Geist Mono', monospace;
        }

        /* Brutalist Styles */
        .window-shadow {
            box-shadow: 10px 10px 0px 0px #000000;
        }

        .icon-shadow {
            box-shadow: 4px 4px 0px 0px #000000;
        }

        .btn-shadow {
            box-shadow: 2px 2px 0px 0px #000000;
        }

        /* Design System - Standardized Components */

        /* Primary Button: solid black */
        .btn-primary {
            padding: 0.75rem 1.5rem;
            background: #000;
            color: #fff;
            font-family: 'Geist Mono', monospace;
            font-size: 0.875rem;
            font-weight: 700;
            border: 2px solid #000;
            cursor: pointer;
            transition: filter 0.15s;
        }
        .btn-primary:hover { filter: invert(1); }
        .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Secondary Button: outlined */
        .btn-secondary {
            padding: 0.75rem 1.5rem;
            background: #fff;
            color: #000;
            font-family: 'Geist Mono', monospace;
            font-size: 0.875rem;
            font-weight: 700;
            border: 2px solid #000;
            cursor: pointer;
            transition: all 0.15s;
        }
        .btn-secondary:hover { background: #000; color: #fff; }

        /* Button Sizes */
        .btn-xs { padding: 0.25rem 0.5rem; font-size: 0.625rem; }
        .btn-sm { padding: 0.5rem 1rem; font-size: 0.75rem; }
        .btn-lg { padding: 1rem 2rem; font-size: 1.125rem; }
        .btn-full { width: 100%; }

        /* Icon Button (square, compact) */
        .btn-icon {
            padding: 0.25rem;
            background: #fff;
            border: 1px solid #000;
            cursor: pointer;
        }
        .btn-icon:hover { background: #f3f3f3; }

        /* Toolbar Button (selectable toggle) */
        .btn-toolbar {
            padding: 0.25rem 0.5rem;
            font-family: 'Geist Mono', monospace;
            font-size: 0.625rem;
            font-weight: 700;
            text-transform: uppercase;
            border: 1px solid #000;
            cursor: pointer;
            background: #fff;
        }
        .btn-toolbar:hover { background: #f3f3f3; }
        .btn-toolbar.active { background: #000; color: #fff; }

        /* App Header */
        .app-header {
            padding: 0.5rem;
            border-bottom: 2px solid #000;
            background: #fff;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .app-header-title {
            font-family: 'Geist Mono', monospace;
            font-size: 0.75rem;
            font-weight: 700;
        }
        .app-header-subtitle {
            font-family: 'Geist Mono', monospace;
            font-size: 10px;
            color: #6b7280;
        }

        /* App Footer/Status Bar */
        .app-footer {
            padding: 0.5rem;
            border-top: 2px solid #000;
            background: #fff;
            text-align: center;
        }
        .app-footer-text {
            font-family: 'Geist Mono', monospace;
            font-size: 10px;
            color: #6b7280;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }

        ::-webkit-scrollbar-track {
            background: #fff;
            border-left: 2px solid #000;
            border-top: 2px solid #000;
        }

        ::-webkit-scrollbar-thumb {
            background: #000;
            border: 2px solid #fff;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #333;
        }

        /* Background Pattern */
        .desktop-bg {
            background-color: #f0f0f0;
            background-image: radial-gradient(#aaa 1px, transparent 1px);
            background-size: 20px 20px;
        }

        canvas {
            touch-action: none;
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            10%,
            30%,
            50%,
            70%,
            90% {
                transform: translateX(-5px);
            }

            20%,
            40%,
            60%,
            80% {
                transform: translateX(5px);
            }
        }

        .animate-shake {
            animation: shake 0.5s ease-in-out;
        }

        /* Matrix Mode */
        .matrix-mode {
            background: #000 !important;
            background-image: none !important;
        }
        .matrix-mode * {
            color: #0f0 !important;
            border-color: #0f0 !important;
        }
        .matrix-mode .bg-white,
        .matrix-mode .bg-gray-50,
        .matrix-mode .bg-gray-100 {
            background-color: #000 !important;
        }
        .matrix-mode button,
        .matrix-mode .border,
        .matrix-mode .border-2,
        .matrix-mode .border-4 {
            border-color: #0f0 !important;
        }
        .matrix-mode svg {
            filter: brightness(0) invert(1) sepia(1) saturate(50) hue-rotate(70deg);
        }
        .matrix-mode canvas {
            filter: hue-rotate(70deg) saturate(3) brightness(0.8);
        }
        .matrix-rain {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
            opacity: 0.15;
        }

        /* Icon drag shake animation */
        @keyframes iconShake {
            0%, 100% { transform: rotate(-1deg); }
            50% { transform: rotate(1deg); }
        }
        .icon-dragging {
            animation: iconShake 0.15s ease-in-out infinite;
            transform: scale(1.1) translateY(-8px);
            z-index: 99999 !important;
        }
    </style>
</head>

<body>

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- SOUND SYSTEM ---
        let audioCtx = null;
        let activeDragNodes = null;

        const getAudioCtx = () => {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            return audioCtx;
        };

        const makeDistortion = (ctx, amount) => {
            const dist = ctx.createWaveShaper();
            const curve = new Float32Array(256);
            for (let i = 0; i < 256; i++) {
                const x = (i - 128) / 128;
                curve[i] = Math.tanh(x * amount);
            }
            dist.curve = curve;
            return dist;
        };

        const sounds = {
            dragStart: () => {
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                if (activeDragNodes) return;

                const bufferSize = ctx.sampleRate * 2.0;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    b0 = 0.99886 * b0 + white * 0.0555179;
                    b1 = 0.99332 * b1 + white * 0.0750759;
                    b2 = 0.96900 * b2 + white * 0.1538520;
                    b3 = 0.86650 * b3 + white * 0.3104856;
                    b4 = 0.55000 * b4 + white * 0.5329522;
                    b5 = -0.7616 * b5 - white * 0.0168980;
                    data[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.11;
                    b6 = white * 0.115926;
                }

                const noise = ctx.createBufferSource();
                noise.buffer = buffer;
                noise.loop = true;
                const filter = ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 800;
                filter.Q.value = 0.5;
                const hapticOsc = ctx.createOscillator();
                hapticOsc.type = 'sine';
                hapticOsc.frequency.value = 140;
                const lfo = ctx.createOscillator();
                lfo.type = 'sine';
                lfo.frequency.value = 13;
                const mainGain = ctx.createGain();
                const noiseGain = ctx.createGain();
                const hapticGain = ctx.createGain();
                const lfoGain = ctx.createGain();

                noise.connect(filter);
                filter.connect(noiseGain);
                noiseGain.connect(mainGain);
                hapticOsc.connect(hapticGain);
                hapticGain.connect(mainGain);
                mainGain.connect(ctx.destination);
                lfo.connect(lfoGain);
                lfoGain.connect(mainGain.gain);

                noiseGain.gain.value = 1.0;
                hapticGain.gain.value = 0.4;
                const baseVol = 0.012;
                mainGain.gain.setValueAtTime(0, now);
                mainGain.gain.linearRampToValueAtTime(baseVol, now + 0.15);
                lfoGain.gain.value = 0.008;

                noise.start(now);
                hapticOsc.start(now);
                lfo.start(now);
                activeDragNodes = { noise, hapticOsc, lfo, mainGain };
            },

            dragStop: () => {
                if (!activeDragNodes) return;
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                const { noise, hapticOsc, lfo, mainGain } = activeDragNodes;
                mainGain.gain.cancelScheduledValues(now);
                mainGain.gain.setValueAtTime(mainGain.gain.value, now);
                mainGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.1);
                noise.stop(now + 0.1);
                hapticOsc.stop(now + 0.1);
                lfo.stop(now + 0.1);
                activeDragNodes = null;
            },

            windowOpen: () => {
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(1200, now + 0.05);
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.3, now + 0.005);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.1);
            },

            windowClose: () => {
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(250, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                gain.gain.setValueAtTime(0.35, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.15);
            },

            success: () => {
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                [523.25, 659.25, 783.99, 987.77].forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    const start = now + i * 0.04;
                    gain.gain.setValueAtTime(0, start);
                    gain.gain.linearRampToValueAtTime(0.08, start + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.001, start + 0.4);
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(start);
                    osc.stop(start + 0.4);
                });
            },

            error: () => {
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                [150, 154].forEach(freq => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    const filter = ctx.createBiquadFilter();
                    osc.type = 'sawtooth';
                    osc.frequency.value = freq;
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(400, now);
                    filter.frequency.linearRampToValueAtTime(100, now + 0.3);
                    gain.gain.setValueAtTime(0.15, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(now);
                    osc.stop(now + 0.3);
                });
            },

            bounce: (vel = 1) => {
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                const dist = makeDistortion(ctx, 12);
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(dist);
                dist.connect(gain);
                gain.connect(ctx.destination);
                osc.type = 'sine';
                osc.frequency.setValueAtTime(220 + (vel * 100), now);
                osc.frequency.exponentialRampToValueAtTime(40, now + 0.15);
                gain.gain.setValueAtTime(0.4 * Math.min(vel, 1.2), now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                osc.start(now);
                osc.stop(now + 0.2);
            },

            bounceIcon: (vel = 1) => {
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600 + (vel * 150), now);
                osc.frequency.exponentialRampToValueAtTime(200, now + 0.06);
                gain.gain.setValueAtTime(0.12 * Math.min(vel, 1), now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
                osc.start(now);
                osc.stop(now + 0.08);
            },

            bootSequence: () => {
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                const notes = [174.61, 220.00, 261.63, 329.63, 392.00];
                notes.forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    const start = now + i * 0.4;
                    gain.gain.setValueAtTime(0, start);
                    gain.gain.linearRampToValueAtTime(0.15, start + 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.001, start + 0.6);
                    osc.start(start);
                    osc.stop(start + 0.6);
                });
            },

            laser: () => {
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(2000, now);
                osc.frequency.exponentialRampToValueAtTime(200, now + 0.15);
                gain.gain.setValueAtTime(0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.15);
            },

            explosion: () => {
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                const dist = makeDistortion(ctx, 20);
                osc.connect(dist);
                dist.connect(gain);
                gain.connect(ctx.destination);
                osc.type = 'sine';
                osc.frequency.setValueAtTime(120, now);
                osc.frequency.exponentialRampToValueAtTime(10, now + 0.5);
                gain.gain.setValueAtTime(0.6, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
                osc.start(now);
                osc.stop(now + 0.6);
            },

            coin: () => {
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                [987.77, 1318.51].forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    const t = now + i * 0.08;
                    gain.gain.setValueAtTime(0.05, t);
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(t);
                    osc.stop(t + 0.5);
                });
            },

            gameOver: () => {
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                [440, 311, 220, 155].forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'triangle';
                    osc.frequency.value = freq;
                    const start = now + i * 0.3;
                    gain.gain.setValueAtTime(0.1, start);
                    gain.gain.exponentialRampToValueAtTime(0.001, start + 0.4);
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(start);
                    osc.stop(start + 0.4);
                });
            },

            bark: () => {
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.linearRampToValueAtTime(150, now + 0.15);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.15);
            }
        };

        // --- HIGH SCORE SYSTEM (local storage based) ---
        const HighScoreManager = {
            userIP: null,
            ipReady: false,

            init() {
                // Try cached IP first for immediate use
                const cachedIP = localStorage.getItem('user_ip_cache');
                if (cachedIP) this.userIP = cachedIP;
                // Fetch fresh IP in background
                this.fetchIP();
            },

            async fetchIP() {
                if (this.ipReady) return this.userIP;
                try {
                    const res = await fetch('https://api.ipify.org?format=json');
                    const data = await res.json();
                    this.userIP = data.ip;
                    localStorage.setItem('user_ip_cache', data.ip);
                } catch (e) {
                    this.userIP = this.userIP || 'local';
                }
                this.ipReady = true;
                return this.userIP;
            },

            getStorageKey(game) {
                // Use cached IP or 'local' - consistent within session
                return `highscore_${game}_${this.userIP || 'local'}`;
            },

            saveHighScore(game, score) {
                const key = this.getStorageKey(game);
                const current = localStorage.getItem(key);
                if (!current || score > parseInt(current, 10)) {
                    localStorage.setItem(key, score.toString());
                    return true;
                }
                return false;
            },

            getHighScore(game) {
                const key = this.getStorageKey(game);
                return parseInt(localStorage.getItem(key) || '0', 10);
            }
        };

        // Initialize on load (uses cached IP, fetches fresh in background)
        HighScoreManager.init();

        // --- PIXELARTICONS (from unpkg CDN) ---
        const PixelartIcon = ({ name, size = 64, style = {}, className = '', ...props }) => (
            <img
                src={`https://unpkg.com/pixelarticons@1.8.1/svg/${name}.svg`}
                width={size}
                height={size}
                alt={name}
                style={{ imageRendering: 'pixelated', ...style }}
                className={className}
                {...props}
            />
        );

        const Icons = {
            // System Info - Monitor
            Terminal: (p) => <PixelartIcon name="monitor" {...p} />,
            // Media Library - Folder
            Folder: (p) => <PixelartIcon name="folder" {...p} />,
            // Paint - Fill bucket
            Palette: (p) => <PixelartIcon name="fill" {...p} />,
            // Snake Game - Gamepad
            Snek: (p) => <PixelartIcon name="gamepad" {...p} />,
            // Trash Can
            TrashCan: (p) => <PixelartIcon name="trash" {...p} />,
            // Undo arrow
            Undo: (p) => <PixelartIcon name="undo" {...p} />,
            // Redo arrow
            Redo: (p) => <PixelartIcon name="redo" {...p} />,
            // File document
            FileDoc: (p) => <PixelartIcon name="file" {...p} />,
            // Window controls
            X: ({ size = 24, ...p }) => <PixelartIcon name="close" size={size} {...p} />,
            Minus: ({ size = 24, ...p }) => <PixelartIcon name="minus" size={size} {...p} />,
            Square: ({ size = 24, ...p }) => <PixelartIcon name="checkbox" size={size} {...p} />,
            Trash: (p) => <PixelartIcon name="trash" {...p} />,
            Send: (p) => <PixelartIcon name="send" {...p} />,
            // Media folder icons
            Movies: (p) => <PixelartIcon name="movie" {...p} />,
            Books: (p) => <PixelartIcon name="book" {...p} />,
            Games: (p) => <PixelartIcon name="gamepad" {...p} />,
            Music: (p) => <PixelartIcon name="music" {...p} />,
            Back: (p) => <PixelartIcon name="arrow-left" {...p} />,
            // App Icons
            Void: (p) => <PixelartIcon name="code" {...p} />,
            Oracle: (p) => <PixelartIcon name="book-open" {...p} />,
            Radio: (p) => <PixelartIcon name="radio-on" {...p} />,
            Dice: (p) => <PixelartIcon name="dice" {...p} />,
            Labyrinth: (p) => <PixelartIcon name="layout-rows" {...p} />,
            Minesweeper: (p) => <PixelartIcon name="table" {...p} />,
            Starship: (p) => <PixelartIcon name="arrow-up" {...p} />,
            Synth: (p) => <PixelartIcon name="keyboard" {...p} />,
            Destruction: (p) => <PixelartIcon name="power" {...p} />,
            Tarot: (p) => <PixelartIcon name="card" {...p} />,
            Dog: (p) => <PixelartIcon name="paw" {...p} />,
            // Email icon
            Email: (p) => <PixelartIcon name="mail" {...p} />,
            // Apps folder icon
            Apps: (p) => <PixelartIcon name="add-grid" {...p} />,
            // Gallery
            Gallery: (p) => <PixelartIcon name="image" {...p} />,
            // Globe
            Globe: (p) => <PixelartIcon name="map" {...p} />,
            // Pomodoro timer
            Pomodoro: (p) => <PixelartIcon name="clock" {...p} />,
            // Health scanner
            HealthScanner: (p) => <PixelartIcon name="heart" {...p} />,
            // Lock icon
            Lock: (p) => <PixelartIcon name="lock" {...p} />,
            // Folder icons for app categories
            FolderClosed: (p) => <PixelartIcon name="folder" {...p} />,
            GamesFolder: (p) => <PixelartIcon name="gamepad" {...p} />,
            ProductivityFolder: (p) => <PixelartIcon name="sliders" {...p} />,
            AboutFolder: (p) => <PixelartIcon name="user" {...p} />,
            // Third Eye - code viewer
            ThirdEye: (p) => <PixelartIcon name="bullseye" {...p} />,
            // Browser
            Browser: (p) => <PixelartIcon name="layout-sidebar-left" {...p} />,
            // Words game
            Words: (p) => <PixelartIcon name="article" {...p} />,
        };

        // --- SHARED DOG SPRITE ---
        const DogSprite = ({ animated = false, style = {}, gold = false }) => {
            const color = gold ? '#DAA520' : '#000';
            const eyeColor = gold ? '#000' : '#fff';
            const pupilColor = gold ? '#fff' : '#000';
            return (
                <svg width="64" height="48" viewBox="0 0 64 48" style={{ imageRendering: 'pixelated', ...style }}>
                    <rect x="16" y="16" width="32" height="16" fill={color} />
                    <rect x="4" y="12" width="16" height="16" fill={color} />
                    <rect x="2" y="4" width="6" height="14" fill={color} />
                    <rect x="14" y="4" width="6" height="14" fill={color} />
                    <rect x="8" y="16" width="6" height="6" fill={eyeColor} />
                    <rect x="10" y="18" width="3" height="3" fill={pupilColor} />
                    <rect x="4" y="22" width="4" height="4" fill={color} />
                    {animated && <rect x="2" y="26" width="4" height="2" fill={color} />}
                    <rect x="16" y="32" width="6" height={animated ? (Math.sin(Date.now() / 100) > 0 ? 10 : 14) : 12} fill={color} />
                    <rect x="26" y="32" width="6" height={animated ? (Math.sin(Date.now() / 100) > 0 ? 14 : 10) : 10} fill={color} />
                    <rect x="34" y="32" width="6" height={animated ? (Math.sin(Date.now() / 100) > 0 ? 10 : 14) : 12} fill={color} />
                    <rect x="42" y="32" width="6" height={animated ? (Math.sin(Date.now() / 100) > 0 ? 14 : 10) : 10} fill={color} />
                    <rect x="48" y={animated ? 12 + Math.sin(Date.now() / 150) * 4 : 12} width="12" height="4" fill={color} />
                    <rect x="58" y={animated ? 8 + Math.sin(Date.now() / 150) * 4 : 8} width="4" height="6" fill={color} />
                </svg>
            );
        };

        // --- DATA ---
        const MEDIA_DB = {
            "CINEMA_TV": [
                { title: "Blade Runner 2049" },
                { title: "Mr. Robot" },
                { title: "True Detective S1" },
                { title: "Succession" },
                { title: "The Bear" },
                { title: "Ex Machina" },
                { title: "Fight Club" },
                { title: "Arcane" },
                { title: "Interstellar" },
                { title: "Chernobyl" },
                { title: "Better Call Saul" },
                { title: "Atlanta" },
                { title: "Whiplash" },
                { title: "There Will Be Blood" },
                { title: "Sicario" },
                { title: "Black Mirror" }
            ],
            "LITERATURE": [
                { title: "Brothers Karamazov", rating: "10/10" },
                { title: "Looking for Alaska", rating: "10/10" },
                { title: "Atlas Shrugged", rating: "10/10" },
                { title: "Pale Blue Dot", rating: "10/10" },
                { title: "Lean Startup", rating: "9/10" },
                { title: "Fight Club", rating: "9/10" },
                { title: "Principles by Ray Dalio", rating: "9/10" },
                { title: "The Fountainhead", rating: "9/10" },
                { title: "Crime & Punishment", rating: "8/10" },
                { title: "1984", rating: "8/10" },
                { title: "Master & Margarita", rating: "8/10" },
                { title: "American Psycho", rating: "8/10" },
                { title: "Elon Musk Biography", rating: "8/10" },
                { title: "How to Get Filthy Rich in Rising Asia", rating: "8/10" },
                { title: "Fathers and Sons", rating: "8/10" },
                { title: "The Long Walk", rating: "8/10" },
                { title: "What's Our Problem?", rating: "7/10" },
                { title: "The Alchemist", rating: "7/10" },
                { title: "Kafka on the Shore", rating: "6/10" },
                { title: "Geometry for Ocelots", rating: "READING" }
            ],
            "GAMES": [
                { title: "Dark Souls III", rating: "10/10" },
                { title: "The Last of Us Pt II", rating: "10/10" },
                { title: "Outer Wilds", rating: "10/10" },
                { title: "God of War Ragnarok", rating: "10/10" },
                { title: "Blue Prince", rating: "10/10" },
                { title: "Cyberpunk 2077", rating: "9.5/10" },
                { title: "Night in the Woods", rating: "9.5/10" },
                { title: "Silent Hill 2", rating: "8/10" },
                { title: "Returnal", rating: "8/10" },
                { title: "Hollow Knight (Silksong)", rating: "8/10" },
                { title: "Deltarune", rating: "9/10" }
            ],
            "AUDIO": [
                { title: "Ison", artist: "Sevdaliza" },
                { title: "Mr. Morale...", artist: "Kendrick Lamar" },
                { title: "LP!", artist: "JPEGMAFIA" },
                { title: "Take Care", artist: "Drake" },
                { title: "The Life of Pablo", artist: "Kanye West" },
                { title: "Miss Anthropocene", artist: "Grimes" },
                { title: "The Eminem Show", artist: "Eminem" },
                { title: "4 Your Eyez Only", artist: "J. Cole" },
                { title: "Yeezus", artist: "Kanye West" },
                { title: "This story is dedicated...", artist: "Grimes" }
            ]
        };

        // --- APP COMPONENTS ---

        const PaintApp = () => {
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const [tool, setTool] = useState('brush');
            const [color, setColor] = useState('#000000');
            const [size, setSize] = useState(4);
            const [isDrawing, setIsDrawing] = useState(false);
            const [status, setStatus] = useState("READY");
            const [startPos, setStartPos] = useState({ x: 0, y: 0 });
            const [textInput, setTextInput] = useState('');
            const [showTextInput, setShowTextInput] = useState(false);
            const [textPos, setTextPos] = useState({ x: 0, y: 0 });
            const snapshotRef = useRef(null);
            const historyRef = useRef([]);
            const historyIndexRef = useRef(-1);

            // Get accurate mouse/touch position relative to canvas
            const getMousePos = (e) => {
                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                // Handle both mouse and touch events
                let clientX, clientY;
                if (e.touches && e.touches.length > 0) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else if (e.changedTouches && e.changedTouches.length > 0) {
                    clientX = e.changedTouches[0].clientX;
                    clientY = e.changedTouches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                return {
                    x: (clientX - rect.left) * scaleX,
                    y: (clientY - rect.top) * scaleY
                };
            };

            // Touch event handlers
            const handleTouchStart = (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    startDraw(e);
                }
            };
            const handleTouchMove = (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    draw(e);
                }
            };
            const handleTouchEnd = (e) => {
                e.preventDefault();
                endDraw();
            };

            const saveToHistory = () => {
                const canvas = canvasRef.current;
                const data = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
                historyRef.current = historyRef.current.slice(0, historyIndexRef.current + 1);
                historyRef.current.push(data);
                if (historyRef.current.length > 50) historyRef.current.shift();
                historyIndexRef.current = historyRef.current.length - 1;
            };

            const undo = () => {
                if (historyIndexRef.current > 0) {
                    historyIndexRef.current--;
                    canvasRef.current.getContext('2d').putImageData(historyRef.current[historyIndexRef.current], 0, 0);
                    setStatus("UNDO");
                }
            };

            const redo = () => {
                if (historyIndexRef.current < historyRef.current.length - 1) {
                    historyIndexRef.current++;
                    canvasRef.current.getContext('2d').putImageData(historyRef.current[historyIndexRef.current], 0, 0);
                    setStatus("REDO");
                }
            };

            useEffect(() => {
                const initCanvas = () => {
                    if (!containerRef.current) return;
                    const canvas = canvasRef.current;
                    const container = containerRef.current;
                    // Set fixed canvas size for proper pixel drawing
                    canvas.width = container.clientWidth - 4;
                    canvas.height = container.clientHeight - 4;
                    const ctx = canvas.getContext("2d");
                    ctx.fillStyle = "#ffffff";
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    saveToHistory();
                };
                initCanvas();
                window.addEventListener('resize', initCanvas);
                return () => window.removeEventListener('resize', initCanvas);
            }, []);

            const floodFill = (x, y, fillColor) => {
                const ctx = canvasRef.current.getContext('2d');
                const w = ctx.canvas.width;
                const h = ctx.canvas.height;
                const imgData = ctx.getImageData(0, 0, w, h);
                const data = imgData.data;
                const r = parseInt(fillColor.slice(1, 3), 16);
                const g = parseInt(fillColor.slice(3, 5), 16);
                const b = parseInt(fillColor.slice(5, 7), 16);
                const startIdx = (y * w + x) * 4;
                const sr = data[startIdx], sg = data[startIdx + 1], sb = data[startIdx + 2];
                if (sr === r && sg === g && sb === b) return;
                const stack = [[x, y]];
                while (stack.length) {
                    const [cx, cy] = stack.pop();
                    const idx = (cy * w + cx) * 4;
                    if (cx < 0 || cx >= w || cy < 0 || cy >= h) continue;
                    if (data[idx] === sr && data[idx + 1] === sg && data[idx + 2] === sb) {
                        data[idx] = r; data[idx + 1] = g; data[idx + 2] = b; data[idx + 3] = 255;
                        stack.push([cx + 1, cy], [cx - 1, cy], [cx, cy + 1], [cx, cy - 1]);
                    }
                }
                ctx.putImageData(imgData, 0, 0);
                saveToHistory();
            };

            const saveSnapshot = () => {
                const canvas = canvasRef.current;
                snapshotRef.current = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
            };

            const restoreSnapshot = () => {
                if (snapshotRef.current) {
                    canvasRef.current.getContext('2d').putImageData(snapshotRef.current, 0, 0);
                }
            };

            const startDraw = (e) => {
                const pos = getMousePos(e);
                if (tool === 'bucket') {
                    floodFill(Math.floor(pos.x), Math.floor(pos.y), color);
                    setStatus("FILLED");
                } else if (tool === 'text') {
                    setTextPos(pos);
                    setShowTextInput(true);
                    setStatus("TYPE TEXT");
                } else if (['rect', 'circle', 'line'].includes(tool)) {
                    setIsDrawing(true);
                    setStartPos(pos);
                    saveSnapshot();
                } else {
                    setIsDrawing(true);
                    setStartPos(pos);
                    const ctx = canvasRef.current.getContext('2d');
                    ctx.beginPath();
                    ctx.moveTo(pos.x, pos.y);
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.lineWidth = size;
                    ctx.strokeStyle = tool === 'eraser' ? '#ffffff' : color;
                }
            };

            const draw = (e) => {
                if (!isDrawing) return;
                const ctx = canvasRef.current.getContext('2d');
                const pos = getMousePos(e);

                if (tool === 'brush' || tool === 'eraser') {
                    ctx.lineTo(pos.x, pos.y);
                    ctx.stroke();
                } else if (['rect', 'circle', 'line'].includes(tool)) {
                    restoreSnapshot();
                    ctx.strokeStyle = color;
                    ctx.fillStyle = color;
                    ctx.lineWidth = size;

                    if (tool === 'rect') {
                        ctx.strokeRect(startPos.x, startPos.y, pos.x - startPos.x, pos.y - startPos.y);
                    } else if (tool === 'circle') {
                        const rx = Math.abs(pos.x - startPos.x) / 2;
                        const ry = Math.abs(pos.y - startPos.y) / 2;
                        const cx = startPos.x + (pos.x - startPos.x) / 2;
                        const cy = startPos.y + (pos.y - startPos.y) / 2;
                        ctx.beginPath();
                        ctx.ellipse(cx, cy, rx, ry, 0, 0, 2 * Math.PI);
                        ctx.stroke();
                    } else if (tool === 'line') {
                        ctx.beginPath();
                        ctx.moveTo(startPos.x, startPos.y);
                        ctx.lineTo(pos.x, pos.y);
                        ctx.stroke();
                    }
                }
            };

            const endDraw = () => {
                if (isDrawing) {
                    setIsDrawing(false);
                    if (tool === 'brush' || tool === 'eraser') {
                        canvasRef.current.getContext('2d').closePath();
                    }
                    saveToHistory();
                }
            };

            const placeText = () => {
                if (textInput.trim()) {
                    const ctx = canvasRef.current.getContext('2d');
                    ctx.fillStyle = color;
                    ctx.font = `${size * 4}px 'Geist Mono', monospace`;
                    ctx.fillText(textInput, textPos.x, textPos.y);
                    setStatus("TEXT PLACED");
                    saveToHistory();
                }
                setShowTextInput(false);
                setTextInput('');
            };

            const send = async () => {
                const canvas = canvasRef.current;
                try {
                    // Copy canvas to clipboard
                    canvas.toBlob(async (blob) => {
                        if (blob) {
                            try {
                                await navigator.clipboard.write([
                                    new ClipboardItem({ 'image/png': blob })
                                ]);
                                setStatus("COPIED TO CLIPBOARD");
                            } catch (e) {
                                setStatus("COPY FAILED");
                            }
                        }
                    }, 'image/png');
                    // Open mailto
                    setTimeout(() => {
                        window.location.href = 'mailto:mateusmuste9@gmail.com';
                    }, 500);
                } catch (e) {
                    setStatus("ERROR");
                }
            };

            const clear = () => {
                const ctx = canvasRef.current.getContext('2d');
                ctx.fillStyle = "#ffffff";
                ctx.fillRect(0, 0, canvasRef.current.width, canvasRef.current.height);
                setStatus("CLEARED");
                saveToHistory();
            };

            // Pixel knob component
            const PixelKnob = ({ value, onChange, min, max }) => {
                const knobSize = 24;
                const rotation = ((value - min) / (max - min)) * 270 - 135;
                return (
                    <div
                        className="relative cursor-pointer select-none"
                        style={{ width: knobSize, height: knobSize }}
                        onMouseDown={(e) => {
                            e.preventDefault();
                            const startY = e.clientY;
                            const startVal = value;
                            const onMove = (ev) => {
                                const diff = startY - ev.clientY;
                                const newVal = Math.min(max, Math.max(min, startVal + Math.floor(diff / 5)));
                                onChange(newVal);
                            };
                            const onUp = () => {
                                window.removeEventListener('mousemove', onMove);
                                window.removeEventListener('mouseup', onUp);
                            };
                            window.addEventListener('mousemove', onMove);
                            window.addEventListener('mouseup', onUp);
                        }}
                    >
                        <svg width={knobSize} height={knobSize} viewBox="0 0 24 24" style={{ imageRendering: 'pixelated' }}>
                            <rect x="4" y="4" width="16" height="16" fill="#000" />
                            <rect x="6" y="6" width="12" height="12" fill="#fff" />
                            <rect x="10" y="6" width="4" height="6" fill="#000" transform={`rotate(${rotation}, 12, 12)`} />
                        </svg>
                    </div>
                );
            };

            const tools = ['brush', 'eraser', 'bucket', 'line', 'rect', 'circle', 'text'];
            const colors = ['#000000', '#ffffff', '#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ff8800', '#8800ff'];

            return (
                <div className="h-full flex flex-col bg-gray-100 select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex flex-wrap gap-2 items-center">
                        <div className="flex gap-1">
                            <button onClick={undo} className="btn-icon" title="Undo"><Icons.Undo size={16} /></button>
                            <button onClick={redo} className="btn-icon" title="Redo"><Icons.Redo size={16} /></button>
                        </div>
                        <div className="w-px h-4 bg-black"></div>
                        <div className="flex gap-1 flex-wrap">
                            {tools.map(t => (
                                <button key={t} onClick={() => setTool(t)} className={`btn-toolbar ${tool === t ? 'active' : ''}`}>{t}</button>
                            ))}
                        </div>
                        <div className="w-px h-4 bg-black"></div>
                        <div className="flex gap-1 flex-wrap">
                            {colors.map(c => (
                                <button key={c} onClick={() => setColor(c)} className={`w-5 h-5 border border-black ${color === c ? 'ring-2 ring-offset-1 ring-black' : ''}`} style={{ backgroundColor: c }} />
                            ))}
                        </div>
                        <div className="w-px h-4 bg-black"></div>
                        <div className="flex items-center gap-1">
                            <PixelKnob value={size} onChange={setSize} min={1} max={20} />
                            <span className="text-[10px] font-mono w-4">{size}</span>
                        </div>
                        <div className="flex-grow"></div>
                        <button onClick={send} className="btn-primary btn-sm flex items-center gap-1"><Icons.Send size={12} /> SEND</button>
                    </div>
                    <div className="flex-grow relative cursor-crosshair bg-gray-300 p-[2px] overflow-hidden" ref={containerRef}>
                        <canvas
                            ref={canvasRef}
                            onMouseDown={startDraw}
                            onMouseMove={draw}
                            onMouseUp={endDraw}
                            onMouseLeave={endDraw}
                            onTouchStart={handleTouchStart}
                            onTouchMove={handleTouchMove}
                            onTouchEnd={handleTouchEnd}
                            className="block bg-white border border-gray-400 touch-none"
                            style={{ width: '100%', height: '100%' }}
                        />
                        {showTextInput && (
                            <div className="absolute top-2 left-2 bg-white border-2 border-black p-2 flex gap-2">
                                <input
                                    type="text"
                                    value={textInput}
                                    onChange={(e) => setTextInput(e.target.value)}
                                    onKeyDown={(e) => e.key === 'Enter' && placeText()}
                                    placeholder="Type text..."
                                    className="border border-black px-2 py-1 text-xs font-mono"
                                    autoFocus
                                />
                                <button onClick={placeText} className="btn-primary btn-xs">OK</button>
                            </div>
                        )}
                        <div className="absolute bottom-1 left-1 bg-black text-white text-[10px] px-2 font-mono">{status}</div>
                    </div>
                </div>
            )
        }

        const FileExplorer = () => {
            const [selectedFolder, setSelectedFolder] = useState(null);

            const folders = [
                { key: 'CINEMA_TV', name: 'TV', icon: 'Movies' },
                { key: 'LITERATURE', name: 'BOOKS', icon: 'Books' },
                { key: 'GAMES', name: 'GAMES', icon: 'Games' },
                { key: 'AUDIO', name: 'MUSIC', icon: 'Music' }
            ];

            if (selectedFolder) {
                const FolderIcon = Icons[folders.find(f => f.key === selectedFolder)?.icon || 'Folder'];
                return (
                    <div className="h-full flex flex-col bg-white select-none">
                        <div className="p-2 border-b-2 border-black bg-white flex items-center gap-3">
                            <button onClick={() => setSelectedFolder(null)} className="p-1 border-2 border-black hover:bg-black hover:text-white">
                                <Icons.Back size={16} />
                            </button>
                            <FolderIcon size={24} />
                            <span className="font-mono text-xs font-bold uppercase">{folders.find(f => f.key === selectedFolder)?.name}</span>
                            <span className="app-footer-text">({MEDIA_DB[selectedFolder].length} ITEMS)</span>
                        </div>
                        <div className="flex-grow overflow-auto">
                            <table className="w-full text-left border-collapse">
                                <thead className="bg-black text-white text-xs font-mono sticky top-0">
                                    <tr><th className="p-2">TITLE</th><th className="p-2 border-l border-gray-600">NOTE</th></tr>
                                </thead>
                                <tbody className="font-mono text-xs">
                                    {MEDIA_DB[selectedFolder].map((i, idx) => (
                                        <tr key={idx} className="border-b border-gray-200 hover:bg-yellow-100">
                                            <td className="p-2 font-bold">{i.title}</td>
                                            <td className="p-2 border-l border-gray-200">{i.rating || i.artist}</td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                        <div className="app-footer">
                            <span className="app-footer-text">CLICK TO VIEW  HOVER TO PREVIEW</span>
                        </div>
                    </div>
                );
            }

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex items-center gap-2">
                        <Icons.Folder size={24} />
                        <span className="app-header-title">MEDIA_LIB</span>
                        <span className="app-footer-text">/ROOT/MEDIA</span>
                    </div>
                    <div className="flex-grow p-6 flex items-start justify-center bg-gray-50">
                        <div className="grid grid-cols-4 gap-8">
                            {folders.map(folder => {
                                const FolderIcon = Icons[folder.icon];
                                return (
                                    <button
                                        key={folder.key}
                                        onClick={() => setSelectedFolder(folder.key)}
                                        className="group flex flex-col items-center gap-2 p-4 hover:bg-white border-2 border-transparent hover:border-black transition-all"
                                    >
                                        <div className="bg-white border-2 border-black p-3 icon-shadow group-hover:translate-x-1 group-hover:translate-y-1 group-hover:shadow-none transition-all">
                                            <FolderIcon size={48} />
                                        </div>
                                        <span className="font-mono text-xs font-bold uppercase">{folder.name}</span>
                                        <span className="app-footer-text">{MEDIA_DB[folder.key].length} ITEMS</span>
                                    </button>
                                );
                            })}
                        </div>
                    </div>
                    <div className="app-footer">
                        <span className="app-footer-text">MOVIES  BOOKS  GAMES  MUSIC</span>
                    </div>
                </div>
            );
        }

        const SystemInfo = ({ onMatrixMode, totalVisitors }) => {
            const [konamiProgress, setKonamiProgress] = useState(0);
            const konamiCode = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'KeyB', 'KeyA'];

            useEffect(() => {
                const handleKeyDown = (e) => {
                    const expectedKey = konamiCode[konamiProgress];
                    if (e.code === expectedKey) {
                        const newProgress = konamiProgress + 1;
                        setKonamiProgress(newProgress);
                        if (newProgress === konamiCode.length) {
                            onMatrixMode?.();
                            setKonamiProgress(0);
                        }
                    } else {
                        setKonamiProgress(0);
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [konamiProgress, onMatrixMode]);

            return (
            <div className="p-6 md:p-12 font-sans select-text">
                <header className="mb-12 border-b-4 border-black pb-8">
                    <h1 className="text-6xl md:text-8xl font-black uppercase tracking-tighter leading-none">Mateus<br />Muste</h1>
                    <div className="mt-4 flex flex-wrap gap-4 font-mono text-sm">
                        <span className="bg-black text-white px-2 py-1">DIGITAL DESIGNER</span>
                        <span className="bg-black text-white px-2 py-1">RADICAL OPTIMIST</span>
                        <span className="border border-black px-2 py-1">ROMANIA</span>
                        {totalVisitors && (
                            <span className="border border-black px-2 py-1 ml-auto">VISITORS: {totalVisitors.toLocaleString()}</span>
                        )}
                    </div>
                </header>
                <div className="grid md:grid-cols-2 gap-12">
                    <div className="space-y-8">
                        <section>
                            <h3 className="text-2xl font-black uppercase mb-4 border-b-2 border-black">App Stack</h3>
                            <div className="grid grid-cols-4 gap-1">
                                {[
                                    { name: 'PHOTOSHOP', yrs: 9 },
                                    { name: 'PREMIERE', yrs: 8 },
                                    { name: 'AFTER EFFECTS', yrs: 6 },
                                    { name: 'EXCEL', yrs: 5 },
                                    { name: 'META ADS', yrs: 5 },
                                    { name: 'DAVINCI', yrs: 4 },
                                    { name: 'ARCHICAD', yrs: 3 },
                                    { name: 'SQUARESPACE', yrs: 3 },
                                    { name: 'UNREAL', yrs: 3 },
                                    { name: 'WEBFLOW', yrs: 3 },
                                    { name: 'MIDJOURNEY', yrs: 2 },
                                    { name: 'GOOGLE ADS', yrs: 2 },
                                    { name: 'BLENDER', yrs: 1 },
                                    { name: 'CURSOR', yrs: 1 },
                                    { name: 'COMFYUI', yrs: 1 },
                                    { name: 'N8N', yrs: 1 }
                                ].map((app, i, arr) => (
                                    <div
                                        key={i}
                                        className="border-2 border-black aspect-square flex flex-col items-center justify-center p-1 cursor-default"
                                        style={{ opacity: 1 - (i / (arr.length - 1)) * 0.66 }}
                                    >
                                        <span className="font-black text-[8px] text-center leading-tight">{app.name}</span>
                                        <span className="font-mono text-[8px] mt-1">{app.yrs} YRS</span>
                                    </div>
                                ))}
                            </div>
                        </section>
                        <section><h3 className="text-2xl font-black uppercase mb-4 border-b-2 border-black">Metrics</h3>
                            <div className="flex gap-4">
                                <div className="p-4 border-2 border-black text-center"><div className="text-3xl font-black">C2</div><div className="font-mono text-[10px]">CAMBRIDGE</div></div>
                                <div className="p-4 border-2 border-black text-center"><div className="text-3xl font-black">1570</div><div className="font-mono text-[10px]">SAT</div></div>
                            </div>
                        </section>
                    </div>
                    <div className="space-y-4">
                        <h3 className="text-2xl font-black uppercase mb-4 border-b-2 border-black">Projects</h3>
                        {[
                            { t: "BIOBUILDS", num: "01", s: "Web / Video / Marketing", d: "Sustainable construction across Europe. Entered 3 markets." },
                            { t: "ROMANIA OLYMPICS 2024", num: "02", s: "Premiere / After Effects", d: "National contest winner. Cluj-Napoca." },
                            { t: "ULT", num: "03", s: "Documentary / Editing", d: "Self-directed channel. Skill laboratory." }
                        ].map((p, i) => (
                            <div key={i} className="group border-2 border-black p-4 hover:bg-black hover:text-white cursor-pointer">
                                <div className="flex justify-between mb-1"><h4 className="font-bold uppercase">{p.t}</h4><span className="font-mono text-xs">{p.num}</span></div>
                                <p className="font-mono text-xs opacity-70 mb-1">{p.s}</p><p className="text-sm italic">{p.d}</p>
                            </div>
                        ))}
                    </div>
                </div>
            </div>
            );
        };

        const TrashApp = () => {
            const [shakingFile, setShakingFile] = useState(null);

            const trashFiles = [
                { name: 'MY_BITCOIN_WALLET.txt', icon: 'FileDoc' },
                { name: 'sleep_schedule.ics', icon: 'FileDoc' },
                { name: 'NYU_acceptance_letter.pdf', icon: 'FileDoc' }
            ];

            const handleFileClick = (fileName) => {
                setShakingFile(fileName);
                setTimeout(() => setShakingFile(null), 500);
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="app-header">
                        <span className="app-header-title">RECYCLE_BIN</span>
                        <span className="app-header-subtitle">{trashFiles.length} ITEMS</span>
                    </div>
                    <div className="flex-grow p-4">
                        <div className="grid grid-cols-3 gap-4">
                            {trashFiles.map(file => (
                                <button
                                    key={file.name}
                                    onClick={() => handleFileClick(file.name)}
                                    className="group flex flex-col items-center gap-2 p-3 cursor-not-allowed hover:bg-gray-100"
                                    style={{
                                        animation: shakingFile === file.name ? 'shake 0.5s ease-in-out' : 'none'
                                    }}
                                >
                                    <div className="bg-white border-2 border-black p-2 icon-shadow opacity-50 group-hover:opacity-70">
                                        <Icons.FileDoc size={24} />
                                    </div>
                                    <span className="font-mono text-[8px] font-bold text-center break-all opacity-50 group-hover:opacity-70">{file.name}</span>
                                </button>
                            ))}
                        </div>
                    </div>
                    <div className="p-2 border-t-2 border-black text-center">
                        <span className="font-mono text-[10px] text-gray-500">PERMANENTLY DELETED</span>
                    </div>
                </div>
            );
        }

        // --- VOID.TXT - Text encrypts then fades into the void ---
        const VoidApp = () => {
            // Each char: { id, char, timestamp, phase: 'visible'|'encrypting'|'fading', opacity }
            const [chars, setChars] = useState([]);
            const inputRef = useRef(null);
            const charIdRef = useRef(0);

            const encryptChar = () => {
                const symbols = '@#$%&*';
                return symbols[Math.floor(Math.random() * symbols.length)];
            };

            // Process loop - runs every 50ms to update char states
            useEffect(() => {
                const interval = setInterval(() => {
                    const now = Date.now();
                    setChars(prev => {
                        let updated = false;
                        const newChars = prev.map(c => {
                            // After 1.5s, start encrypting
                            if (c.phase === 'visible' && now - c.timestamp >= 1500) {
                                updated = true;
                                return { ...c, phase: 'encrypting', displayChar: encryptChar() };
                            }
                            // After encrypting for 300ms, start fading
                            if (c.phase === 'encrypting' && now - c.timestamp >= 1800) {
                                updated = true;
                                return { ...c, phase: 'fading', opacity: 0.8 };
                            }
                            // Fade out
                            if (c.phase === 'fading') {
                                const newOpacity = c.opacity - 0.15;
                                if (newOpacity <= 0) {
                                    updated = true;
                                    return null; // Mark for removal
                                }
                                updated = true;
                                return { ...c, opacity: newOpacity, displayChar: encryptChar() };
                            }
                            return c;
                        }).filter(Boolean);
                        return updated ? newChars : prev;
                    });
                }, 50);
                return () => clearInterval(interval);
            }, []);

            const handleKeyDown = (e) => {
                if (e.key === 'Backspace') {
                    // Remove most recent visible char
                    setChars(prev => {
                        const visibleChars = prev.filter(c => c.phase === 'visible');
                        if (visibleChars.length === 0) return prev;
                        const lastVisible = visibleChars[visibleChars.length - 1];
                        return prev.filter(c => c.id !== lastVisible.id);
                    });
                    e.preventDefault();
                } else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
                    // Add new character
                    const newChar = {
                        id: charIdRef.current++,
                        char: e.key,
                        displayChar: e.key,
                        timestamp: Date.now(),
                        phase: 'visible',
                        opacity: 1
                    };
                    setChars(prev => [...prev, newChar]);
                    e.preventDefault();
                }
            };

            // Render chars grouped - visible chars are white, encrypting are green
            const renderChars = () => {
                return chars.map(c => (
                    <span
                        key={c.id}
                        style={{
                            color: c.phase === 'encrypting' ? '#0f0' :
                                c.phase === 'fading' ? `rgba(0,255,0,${c.opacity})` : 'white',
                            textShadow: c.phase !== 'visible' ? '0 0 5px #0f0' : 'none'
                        }}
                    >
                        {c.displayChar}
                    </span>
                ));
            };

            return (
                <div
                    className="h-full flex flex-col bg-black select-none cursor-text"
                    onClick={() => inputRef.current?.focus()}
                    onCopy={(e) => e.preventDefault()}
                    onCut={(e) => e.preventDefault()}
                >
                    <div className="p-2 border-b border-gray-800 bg-black">
                        <span className="font-mono text-xs font-bold text-white">VOID.TXT</span>
                    </div>
                    <div className="flex-grow p-4 overflow-auto font-mono text-sm">
                        <div className="flex flex-wrap items-start">
                            <span className="mr-2 text-gray-600">{'>'}</span>
                            <div className="flex-grow">
                                {renderChars()}
                                <span className="animate-pulse text-white">_</span>
                            </div>
                        </div>
                        <input
                            ref={inputRef}
                            type="text"
                            className="absolute opacity-0 pointer-events-none"
                            onKeyDown={handleKeyDown}
                            onPaste={(e) => e.preventDefault()}
                            autoFocus
                        />
                    </div>
                </div>
            );
        };

        // --- ORACLE.EXE - Philosophical quotes ---
        const OracleApp = () => {
            const quotes = [
                "The soul is healed by being with children.",
                "Man is condemned to be free.",
                "He who has a why to live can bear almost any how.",
                "The question isn't who is going to let me; it's who is going to stop me.",
                "One must imagine Sisyphus happy.",
                "Pain and suffering are always inevitable for a large intelligence and a deep heart.",
                "God is dead. God remains dead. And we have killed him.",
                "I swear by my life and my love of it that I will never live for the sake of another man.",
                "In the depth of winter, I finally learned that within me there lay an invincible summer.",
                "The higher we soar the smaller we appear to those who cannot fly.",
                "The soul that sees beauty may sometimes walk alone.",
                "Should I kill myself, or have a cup of coffee?",
                "To live is to suffer, to survive is to find some meaning in the suffering.",
                "The only thing I know is that I know nothing.",
                "Beauty will save the world.",
                "There is always some madness in love. But there is also always some reason in madness.",
                "Man is the only creature who refuses to be what he is.",
                "A is A. A thing is itself.",
                "What does not kill me makes me stronger.",
                "The absurd is born of the confrontation between the human call and the unreasonable silence of the world.",
                "The best way to find yourself is to lose yourself in the service of others.",
                "Every deep thinker is more afraid of being understood than of being misunderstood.",
                "Money is only a tool. It will take you wherever you wish, but it will not replace you as the driver.",
                "We are all in the gutter, but some of us are looking at the stars.",
                "The only way to deal with an unfree world is to become so absolutely free that your very existence is an act of rebellion.",
                "Above all, don't lie to yourself.",
                "Whoever fights monsters should see to it that in the process he does not become a monster.",
                "I rebel; therefore I exist.",
                "The secret of happiness is freedom, the secret of freedom is courage.",
                "There is but one truly serious philosophical problem, and that is suicide."
            ];

            const [question, setQuestion] = useState('');
            const [answer, setAnswer] = useState(null);
            const [isThinking, setIsThinking] = useState(false);

            const askOracle = () => {
                if (!question.trim()) return;
                setIsThinking(true);
                setAnswer(null);

                setTimeout(() => {
                    const randomQuote = quotes[Math.floor(Math.random() * quotes.length)];
                    setAnswer(randomQuote);
                    setIsThinking(false);
                    setQuestion('');
                }, 1500 + Math.random() * 1000);
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="app-header">
                        <span className="app-header-title">ORACLE.EXE</span>
                        <span className="app-footer-text">ASK THE DEAD</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-8 bg-gray-50">
                        {answer && (
                            <div className="mb-8 text-center max-w-lg">
                                <div className="text-xl font-serif italic leading-relaxed mb-4 text-black">"{answer}"</div>
                                <div className="text-xs text-gray-500 font-mono"> THE ORACLE HAS SPOKEN</div>
                            </div>
                        )}
                        {isThinking && (
                            <div className="mb-8 text-center">
                                <div className="font-mono text-sm text-gray-500 animate-pulse">
                                    CONSULTING THE VOID...
                                </div>
                            </div>
                        )}
                        <div className="w-full max-w-md">
                            <input
                                type="text"
                                value={question}
                                onChange={(e) => setQuestion(e.target.value)}
                                onKeyDown={(e) => e.key === 'Enter' && askOracle()}
                                placeholder="ASK YOUR QUESTION..."
                                className="w-full bg-white border-2 border-black px-4 py-3 font-mono text-sm text-black placeholder-gray-400 focus:ring-2 focus:ring-black outline-none"
                                disabled={isThinking}
                            />
                            <button
                                onClick={askOracle}
                                disabled={isThinking}
                                className="btn-primary btn-full mt-2"
                            >
                                SEEK TRUTH
                            </button>
                        </div>
                    </div>
                    <div className="app-footer">
                        <span className="app-footer-text">DOSTOEVSKY  NIETZSCHE  RAND  CAMUS</span>
                    </div>
                </div>
            );
        };

        // --- RADIO.WAV - Playlist link ---
        const RadioApp = () => {
            const [isPlaying, setIsPlaying] = useState(false);
            const [visualizer, setVisualizer] = useState([]);

            useEffect(() => {
                const interval = setInterval(() => {
                    if (isPlaying) {
                        setVisualizer(Array(16).fill(0).map(() => Math.random() * 100));
                    }
                }, 100);
                return () => clearInterval(interval);
            }, [isPlaying]);

            const openPlaylist = () => {
                window.open('https://music.youtube.com/playlist?list=PLeIQRsOWZUhKaD53FTvwZCxsNWzjq0lfO&si=92O5A6kAPjk8Vzmg', '_blank');
                setIsPlaying(true);
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="app-header">
                        <span className="app-header-title">RADIO.WAV</span>
                        <span className="app-footer-text">MATEUS_PLAYLIST</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-8 bg-gray-50">
                        <div className="flex items-end justify-center gap-1 h-32 mb-8 p-4 border-2 border-black bg-white">
                            {(isPlaying ? visualizer : Array(16).fill(10)).map((h, i) => (
                                <div
                                    key={i}
                                    className="w-3 bg-black transition-all duration-100"
                                    style={{ height: `${h}%`, minHeight: '4px' }}
                                />
                            ))}
                        </div>
                        <button
                            onClick={openPlaylist}
                            className="btn-primary btn-lg"
                        >
                            {isPlaying ? ' NOW PLAYING' : ' TUNE IN'}
                        </button>
                        <div className="mt-4 font-mono text-xs text-gray-500">
                            OPENS YOUTUBE MUSIC
                        </div>
                    </div>
                    <div className="p-2 border-t-2 border-black bg-white">
                        <div className="font-mono text-[10px] text-gray-500 text-center">
                            BROADCASTING FROM THE VOID
                        </div>
                    </div>
                </div>
            );
        };

        // --- DICE.EXE - D20 Roller with Three.js ---
        const DiceApp = () => {
            const [result, setResult] = useState(null);
            const [isRolling, setIsRolling] = useState(false);
            const isRollingRef = useRef(false); // Ref to avoid stale closure
            const containerRef = useRef(null);
            const sceneRef = useRef(null);
            const diceRef = useRef(null);
            const animationRef = useRef(null);

            const getResultStyle = () => {
                if (!result) return '';
                if (result === 20) return 'bg-black text-white';
                if (result === 1) return 'border-2 border-black';
                return '';
            };

            // Initialize Three.js scene
            useEffect(() => {
                if (!containerRef.current || sceneRef.current) return;

                const width = 200;
                const height = 200;

                // Scene
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xffffff);

                // Camera
                const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
                camera.position.z = 4;

                // Renderer
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                renderer.setPixelRatio(window.devicePixelRatio);
                containerRef.current.appendChild(renderer.domElement);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(2, 2, 2);
                scene.add(directionalLight);

                const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
                backLight.position.set(-2, -2, -2);
                scene.add(backLight);

                // D20 (Icosahedron)
                const geometry = new THREE.IcosahedronGeometry(1.2, 0);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x111111,
                    metalness: 0.1,
                    roughness: 0.4,
                    flatShading: true
                });
                const dice = new THREE.Mesh(geometry, material);
                scene.add(dice);

                // Edge lines
                const edges = new THREE.EdgesGeometry(geometry);
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0x444444 });
                const wireframe = new THREE.LineSegments(edges, lineMaterial);
                dice.add(wireframe);

                diceRef.current = dice;
                sceneRef.current = { scene, camera, renderer };

                // Initial render
                renderer.render(scene, camera);

                // Idle animation - uses ref to avoid stale closure
                const idleAnimate = () => {
                    if (!isRollingRef.current) {
                        dice.rotation.x += 0.003;
                        dice.rotation.y += 0.005;
                    }
                    renderer.render(scene, camera);
                    animationRef.current = requestAnimationFrame(idleAnimate);
                };
                idleAnimate();

                return () => {
                    cancelAnimationFrame(animationRef.current);
                    renderer.dispose();
                    if (containerRef.current && renderer.domElement) {
                        containerRef.current.removeChild(renderer.domElement);
                    }
                };
            }, []);

            const rollDice = () => {
                if (isRolling || !diceRef.current || !sceneRef.current) return;
                setIsRolling(true);
                isRollingRef.current = true;
                setResult(null);

                const dice = diceRef.current;
                const { renderer, scene, camera } = sceneRef.current;

                // Random target rotation
                const targetRotX = dice.rotation.x + Math.PI * (4 + Math.random() * 4);
                const targetRotY = dice.rotation.y + Math.PI * (4 + Math.random() * 4);
                const targetRotZ = dice.rotation.z + Math.PI * (2 + Math.random() * 2);

                const startRotX = dice.rotation.x;
                const startRotY = dice.rotation.y;
                const startRotZ = dice.rotation.z;

                const duration = 1500;
                const startTime = Date.now();

                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // Easing - decelerate
                    const eased = 1 - Math.pow(1 - progress, 3);

                    dice.rotation.x = startRotX + (targetRotX - startRotX) * eased;
                    dice.rotation.y = startRotY + (targetRotY - startRotY) * eased;
                    dice.rotation.z = startRotZ + (targetRotZ - startRotZ) * eased;

                    renderer.render(scene, camera);

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        setResult(Math.floor(Math.random() * 20) + 1);
                        setIsRolling(false);
                        isRollingRef.current = false;
                    }
                };

                animate();
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-2 border-b border-gray-200 bg-white flex justify-between items-center">
                        <span className="font-mono text-[10px] font-bold tracking-wider">DICE.EXE</span>
                        <span className="font-mono text-[10px] text-gray-400">D20</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-8 bg-white">
                        <div className="mb-8" ref={containerRef} style={{ width: 200, height: 200 }} />
                        {result && !isRolling && (
                            <div className={`font-mono text-[10px] tracking-widest mb-6 px-4 py-2 ${getResultStyle()}`}>
                                {result === 20 ? 'CRITICAL' : result === 1 ? 'FAIL' : `RESULT: ${result}`}
                            </div>
                        )}
                        <button
                            onClick={rollDice}
                            disabled={isRolling}
                            className="bg-black text-white px-6 py-2 font-mono text-[10px] tracking-widest hover:bg-gray-800 disabled:bg-gray-300 transition-colors"
                        >
                            {isRolling ? 'ROLLING' : 'ROLL'}
                        </button>
                    </div>
                    <div className="p-2 border-t border-gray-200 bg-white">
                        <div className="flex justify-between font-mono text-[10px] text-gray-400">
                            <span>20 = CRIT</span>
                            <span>1 = FAIL</span>
                        </div>
                    </div>
                </div>
            );
        };

        // --- SNEK.EXE ---
        const SnakeAppNew = () => {
            const canvasRef = useRef(null);
            const [score, setScore] = useState(0);
            const [highScore, setHighScore] = useState(() => HighScoreManager.getHighScore('snake'));
            const [gameOver, setGameOver] = useState(false);
            const [gameStarted, setGameStarted] = useState(false);
            const snake = useRef([{ x: 15, y: 10 }]);
            const food = useRef({ x: 20, y: 10 });
            const dir = useRef({ x: 1, y: 0 });
            const nextDir = useRef({ x: 1, y: 0 });
            const runningRef = useRef(false);
            const lastTimeRef = useRef(0);
            const frameRef = useRef(null);

            const GRID_W = 30;
            const GRID_H = 20;
            const CELL = 20;

            // Load high score from storage when IP is ready
            useEffect(() => {
                const loadHighScore = async () => {
                    await HighScoreManager.fetchIP();
                    setHighScore(HighScoreManager.getHighScore('snake'));
                };
                loadHighScore();
            }, []);

            const start = () => {
                snake.current = [{ x: 15, y: 10 }, { x: 14, y: 10 }, { x: 13, y: 10 }];
                dir.current = { x: 1, y: 0 };
                nextDir.current = { x: 1, y: 0 };
                food.current = { x: Math.floor(Math.random() * GRID_W), y: Math.floor(Math.random() * GRID_H) };
                setScore(0);
                setGameOver(false);
                setGameStarted(true);
                runningRef.current = true;
                lastTimeRef.current = 0;
            };

            const update = () => {
                const ctx = canvasRef.current?.getContext('2d');
                if (!ctx) return;

                dir.current = nextDir.current;
                const head = {
                    x: snake.current[0].x + dir.current.x,
                    y: snake.current[0].y + dir.current.y
                };

                // Wall collision
                if (head.x < 0 || head.x >= GRID_W || head.y < 0 || head.y >= GRID_H) {
                    endGame();
                    return;
                }

                // Self collision
                if (snake.current.some(s => s.x === head.x && s.y === head.y)) {
                    endGame();
                    return;
                }

                snake.current.unshift(head);

                // Eat food
                if (head.x === food.current.x && head.y === food.current.y) {
                    sounds.coin();
                    setScore(s => {
                        const newScore = s + 10;
                        setHighScore(h => {
                            const newHigh = Math.max(h, newScore);
                            HighScoreManager.saveHighScore('snake', newHigh);
                            return newHigh;
                        });
                        return newScore;
                    });
                    food.current = {
                        x: Math.floor(Math.random() * GRID_W),
                        y: Math.floor(Math.random() * GRID_H)
                    };
                } else {
                    snake.current.pop();
                }

                // Draw - light theme
                ctx.fillStyle = '#f5f5f5';
                ctx.fillRect(0, 0, GRID_W * CELL, GRID_H * CELL);

                // Grid lines (subtle)
                ctx.strokeStyle = '#e0e0e0';
                for (let i = 0; i <= GRID_W; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * CELL, 0);
                    ctx.lineTo(i * CELL, GRID_H * CELL);
                    ctx.stroke();
                }
                for (let i = 0; i <= GRID_H; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, i * CELL);
                    ctx.lineTo(GRID_W * CELL, i * CELL);
                    ctx.stroke();
                }

                // Snake - black
                snake.current.forEach((s, i) => {
                    ctx.fillStyle = i === 0 ? '#000' : '#333';
                    ctx.fillRect(s.x * CELL + 1, s.y * CELL + 1, CELL - 2, CELL - 2);
                });

                // Food - black dot
                ctx.fillStyle = '#000';
                ctx.fillRect(food.current.x * CELL + 6, food.current.y * CELL + 6, CELL - 12, CELL - 12);
            };

            const endGame = () => {
                runningRef.current = false;
                setGameOver(true);
                setGameStarted(false);
                sounds.gameOver();
            };

            // Game loop using requestAnimationFrame
            useEffect(() => {
                const gameLoop = (timestamp) => {
                    if (!runningRef.current) {
                        frameRef.current = requestAnimationFrame(gameLoop);
                        return;
                    }

                    if (timestamp - lastTimeRef.current >= 100) {
                        lastTimeRef.current = timestamp;
                        update();
                    }

                    frameRef.current = requestAnimationFrame(gameLoop);
                };

                frameRef.current = requestAnimationFrame(gameLoop);

                return () => {
                    if (frameRef.current) cancelAnimationFrame(frameRef.current);
                };
            }, []);

            useEffect(() => {
                const handle = (e) => {
                    if (!runningRef.current) return;
                    if (e.key === 'ArrowUp' && dir.current.y === 0) nextDir.current = { x: 0, y: -1 };
                    if (e.key === 'ArrowDown' && dir.current.y === 0) nextDir.current = { x: 0, y: 1 };
                    if (e.key === 'ArrowLeft' && dir.current.x === 0) nextDir.current = { x: -1, y: 0 };
                    if (e.key === 'ArrowRight' && dir.current.x === 0) nextDir.current = { x: 1, y: 0 };
                };
                window.addEventListener('keydown', handle);
                return () => window.removeEventListener('keydown', handle);
            }, []);

            // Initial canvas draw - light theme
            useEffect(() => {
                const ctx = canvasRef.current?.getContext('2d');
                if (ctx) {
                    ctx.fillStyle = '#f5f5f5';
                    ctx.fillRect(0, 0, GRID_W * CELL, GRID_H * CELL);

                    // Draw grid lines
                    ctx.strokeStyle = '#e0e0e0';
                    for (let i = 0; i <= GRID_W; i++) {
                        ctx.beginPath();
                        ctx.moveTo(i * CELL, 0);
                        ctx.lineTo(i * CELL, GRID_H * CELL);
                        ctx.stroke();
                    }
                    for (let i = 0; i <= GRID_H; i++) {
                        ctx.beginPath();
                        ctx.moveTo(0, i * CELL);
                        ctx.lineTo(GRID_W * CELL, i * CELL);
                        ctx.stroke();
                    }
                }
            }, []);

            // Touch controls for mobile
            const handleDirection = (newDir) => {
                if (!runningRef.current) return;
                if (newDir === 'up' && dir.current.y === 0) nextDir.current = { x: 0, y: -1 };
                if (newDir === 'down' && dir.current.y === 0) nextDir.current = { x: 0, y: 1 };
                if (newDir === 'left' && dir.current.x === 0) nextDir.current = { x: -1, y: 0 };
                if (newDir === 'right' && dir.current.x === 0) nextDir.current = { x: 1, y: 0 };
            };

            // Swipe detection
            const touchStartRef = useRef({ x: 0, y: 0 });
            const handleTouchStart = (e) => {
                touchStartRef.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            };
            const handleTouchEnd = (e) => {
                if (!runningRef.current) return;
                const dx = e.changedTouches[0].clientX - touchStartRef.current.x;
                const dy = e.changedTouches[0].clientY - touchStartRef.current.y;
                if (Math.abs(dx) > Math.abs(dy)) {
                    if (dx > 30) handleDirection('right');
                    else if (dx < -30) handleDirection('left');
                } else {
                    if (dy > 30) handleDirection('down');
                    else if (dy < -30) handleDirection('up');
                }
            };

            return (
                <div className="h-full flex flex-col bg-white select-none" onTouchStart={handleTouchStart} onTouchEnd={handleTouchEnd}>
                    <div className="app-header">
                        <span className="app-header-title">SNEK.EXE</span>
                        <div className="flex gap-4 font-mono text-xs">
                            <span>SCORE: <span className="font-bold">{score}</span></span>
                            <span>HIGH: <span className="font-bold">{highScore}</span></span>
                            <span className={gameOver ? 'text-red-600' : gameStarted ? 'text-green-600' : 'text-gray-500'}>
                                {gameOver ? 'DEAD' : gameStarted ? 'ALIVE' : 'READY'}
                            </span>
                        </div>
                    </div>
                    <div className="flex-grow flex items-center justify-center p-2 md:p-4 bg-gray-50 overflow-hidden">
                        <div className="relative border-2 border-black" style={{ width: 'min(100%, 600px)', aspectRatio: '3/2' }}>
                            <canvas ref={canvasRef} width={600} height={400} className="block w-full h-full" style={{ imageRendering: 'pixelated' }} />
                            {!gameStarted && (
                                <div className="absolute inset-0 bg-white/95 flex flex-col items-center justify-center">
                                    <div className="text-4xl font-black mb-2 tracking-widest">SNEK</div>
                                    {gameOver && <p className="text-red-600 mb-4 font-mono text-sm">GAME OVER</p>}
                                    <button
                                        onClick={start}
                                        className="btn-primary"
                                    >
                                        {gameOver ? 'RETRY' : 'START'}
                                    </button>
                                    <p className="mt-4 text-gray-500 font-mono text-xs text-center px-4 hidden md:block">ARROW KEYS TO MOVE</p>
                                    <p className="mt-4 text-gray-500 font-mono text-xs text-center px-4 md:hidden">SWIPE TO MOVE</p>
                                </div>
                            )}
                        </div>
                    </div>
                    <div className="app-footer">
                        <span className="app-footer-text">EAT FOOD  GROW LONGER  DON'T DIE</span>
                    </div>
                </div>
            );
        };

        // --- LABYRINTH.EXE - Procedural Maze ---
        const LabyrinthApp = () => {
            const canvasRef = useRef(null);
            const [level, setLevel] = useState(1);
            const [score, setScore] = useState(0);
            const [highScore, setHighScore] = useState(() => HighScoreManager.getHighScore('labyrinth'));
            const [won, setWon] = useState(false);
            const [showingMaze, setShowingMaze] = useState(false);
            const mazeRef = useRef(null);
            const playerRef = useRef({ x: 1, y: 1 });
            const exitRef = useRef({ x: 0, y: 0 });

            const CELL_SIZE = 8; // Thinner walls

            // Load high score from storage when IP is ready
            useEffect(() => {
                const loadHighScore = async () => {
                    await HighScoreManager.fetchIP();
                    setHighScore(HighScoreManager.getHighScore('labyrinth'));
                };
                loadHighScore();
            }, []);

            const generateMaze = (width, height) => {
                const maze = Array(height).fill(null).map(() => Array(width).fill(1));

                // Iterative maze generation to avoid stack overflow on large mazes
                const stack = [[1, 1]];
                maze[1][1] = 0;

                while (stack.length > 0) {
                    const [x, y] = stack[stack.length - 1];
                    const directions = [[0, -2], [0, 2], [-2, 0], [2, 0]].sort(() => Math.random() - 0.5);
                    let found = false;

                    for (const [dx, dy] of directions) {
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx > 0 && nx < width - 1 && ny > 0 && ny < height - 1 && maze[ny][nx] === 1) {
                            maze[y + dy / 2][x + dx / 2] = 0;
                            maze[ny][nx] = 0;
                            stack.push([nx, ny]);
                            found = true;
                            break;
                        }
                    }

                    if (!found) stack.pop();
                }
                return maze;
            };

            const startLevel = (lvl) => {
                // Start big and get MUCH harder - exponential growth
                const size = 31 + Math.floor(lvl * lvl * 4);
                const cappedSize = Math.min(size, 151); // Cap at 151 for performance
                const maze = generateMaze(cappedSize | 1, cappedSize | 1);
                mazeRef.current = maze;
                playerRef.current = { x: 1, y: 1 };

                // Find exit (bottom-right area)
                for (let y = maze.length - 2; y > maze.length / 2; y--) {
                    for (let x = maze[0].length - 2; x > maze[0].length / 2; x--) {
                        if (maze[y][x] === 0) {
                            exitRef.current = { x, y };
                            break;
                        }
                    }
                    if (exitRef.current.x !== 0) break;
                }

                setWon(false);
                setShowingMaze(false);
                draw();
            };

            const draw = () => {
                const canvas = canvasRef.current;
                if (!canvas || !mazeRef.current) return;
                const ctx = canvas.getContext('2d');
                const maze = mazeRef.current;

                canvas.width = maze[0].length * CELL_SIZE;
                canvas.height = maze.length * CELL_SIZE;

                // Draw maze - clean minimal style
                for (let y = 0; y < maze.length; y++) {
                    for (let x = 0; x < maze[0].length; x++) {
                        ctx.fillStyle = maze[y][x] === 1 ? '#111' : '#fafafa';
                        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }

                // Draw exit - simple square
                const ex = exitRef.current.x * CELL_SIZE;
                const ey = exitRef.current.y * CELL_SIZE;
                ctx.fillStyle = '#fafafa';
                ctx.fillRect(ex, ey, CELL_SIZE, CELL_SIZE);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(ex + 2, ey + 2, CELL_SIZE - 4, CELL_SIZE - 4);

                // Draw player - simple filled square
                const px = playerRef.current.x * CELL_SIZE;
                const py = playerRef.current.y * CELL_SIZE;
                ctx.fillStyle = '#000';
                ctx.fillRect(px + 2, py + 2, CELL_SIZE - 4, CELL_SIZE - 4);
            };

            const move = (dx, dy) => {
                if (won || showingMaze) return;
                const maze = mazeRef.current;
                if (!maze) return;

                const nx = playerRef.current.x + dx;
                const ny = playerRef.current.y + dy;

                if (nx >= 0 && nx < maze[0].length && ny >= 0 && ny < maze.length && maze[ny][nx] === 0) {
                    playerRef.current = { x: nx, y: ny };
                    draw();

                    if (nx === exitRef.current.x && ny === exitRef.current.y) {
                        const points = level * 100;
                        setScore(s => {
                            const newScore = s + points;
                            setHighScore(h => {
                                const newHigh = Math.max(h, newScore);
                                HighScoreManager.saveHighScore('labyrinth', newHigh);
                                return newHigh;
                            });
                            return newScore;
                        });
                        setWon(true);
                        sounds.success();

                        // Show full maze then start next level
                        setTimeout(() => {
                            setShowingMaze(true);
                            setTimeout(() => {
                                setLevel(l => l + 1);
                                startLevel(level + 1);
                            }, 2000);
                        }, 1000);
                    }
                }
            };

            const giveUp = () => {
                setLevel(1);
                setScore(0);
                startLevel(1);
            };

            useEffect(() => {
                const handle = (e) => {
                    if (e.key === 'ArrowUp') move(0, -1);
                    if (e.key === 'ArrowDown') move(0, 1);
                    if (e.key === 'ArrowLeft') move(-1, 0);
                    if (e.key === 'ArrowRight') move(1, 0);
                };
                window.addEventListener('keydown', handle);
                startLevel(1);
                return () => window.removeEventListener('keydown', handle);
            }, []);

            // Touch/swipe controls for mobile
            const touchStartRef = useRef({ x: 0, y: 0 });
            const handleTouchStart = (e) => {
                touchStartRef.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            };
            const handleTouchEnd = (e) => {
                const dx = e.changedTouches[0].clientX - touchStartRef.current.x;
                const dy = e.changedTouches[0].clientY - touchStartRef.current.y;
                const threshold = 20;
                if (Math.abs(dx) > Math.abs(dy)) {
                    if (dx > threshold) move(1, 0);
                    else if (dx < -threshold) move(-1, 0);
                } else {
                    if (dy > threshold) move(0, 1);
                    else if (dy < -threshold) move(0, -1);
                }
            };

            return (
                <div className="h-full flex flex-col bg-white select-none" onTouchStart={handleTouchStart} onTouchEnd={handleTouchEnd}>
                    <div className="h-8 px-3 flex justify-between items-center">
                        <span className="font-mono text-[10px] font-bold tracking-widest text-black">LABYRINTH</span>
                        <div className="flex gap-6 font-mono text-[10px]">
                            <span className="text-gray-400">LVL <span className="text-black font-bold">{level}</span></span>
                            <span className="text-gray-400">PTS <span className="text-black font-bold">{score}</span></span>
                        </div>
                    </div>
                    <div className="flex-grow flex items-center justify-center relative bg-white">
                        {won && !showingMaze && (
                            <div className="absolute inset-0 bg-white/95 flex items-center justify-center z-10">
                                <div className="text-center">
                                    <div className="text-2xl font-black tracking-widest">CLEAR</div>
                                    <div className="font-mono text-[10px] text-gray-400 mt-1">+{level * 100}</div>
                                </div>
                            </div>
                        )}
                        {showingMaze && (
                            <div className="absolute inset-0 bg-white flex items-center justify-center z-10">
                                <div className="font-mono text-[10px] text-gray-400 tracking-widest animate-pulse">
                                    GENERATING LEVEL {level}
                                </div>
                            </div>
                        )}
                        <canvas ref={canvasRef} className="block" style={{ imageRendering: 'pixelated' }} />
                    </div>
                    <div className="h-8 px-3 flex justify-between items-center">
                        <span className="font-mono text-[10px] text-gray-300 hidden md:inline"></span>
                        <span className="font-mono text-[10px] text-gray-300 md:hidden">SWIPE TO MOVE</span>
                        <button
                            onClick={giveUp}
                            className="font-mono text-[10px] text-gray-300 hover:text-black transition-colors"
                        >
                            RESTART
                        </button>
                    </div>
                </div>
            );
        };

        // --- MINESWEEPER.EXE - Ultra Clean Minesweeper ---
        const MinesweeperApp = () => {
            const [grid, setGrid] = useState([]);
            const [revealed, setRevealed] = useState([]);
            const [flagged, setFlagged] = useState([]);
            const [gameOver, setGameOver] = useState(false);
            const [won, setWon] = useState(false);
            const [mineCount, setMineCount] = useState(0);
            const [time, setTime] = useState(0);
            const [started, setStarted] = useState(false);
            const timerRef = useRef(null);

            const ROWS = 12;
            const COLS = 16;
            const MINES = 30;

            const initGame = () => {
                // Create empty grid
                const newGrid = Array(ROWS).fill(null).map(() => Array(COLS).fill(0));
                const newRevealed = Array(ROWS).fill(null).map(() => Array(COLS).fill(false));
                const newFlagged = Array(ROWS).fill(null).map(() => Array(COLS).fill(false));

                // Place mines
                let placed = 0;
                while (placed < MINES) {
                    const r = Math.floor(Math.random() * ROWS);
                    const c = Math.floor(Math.random() * COLS);
                    if (newGrid[r][c] !== -1) {
                        newGrid[r][c] = -1;
                        placed++;
                    }
                }

                // Calculate numbers
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (newGrid[r][c] === -1) continue;
                        let count = 0;
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                const nr = r + dr, nc = c + dc;
                                if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && newGrid[nr][nc] === -1) {
                                    count++;
                                }
                            }
                        }
                        newGrid[r][c] = count;
                    }
                }

                setGrid(newGrid);
                setRevealed(newRevealed);
                setFlagged(newFlagged);
                setGameOver(false);
                setWon(false);
                setMineCount(MINES);
                setTime(0);
                setStarted(false);
                if (timerRef.current) clearInterval(timerRef.current);
            };

            useEffect(() => {
                initGame();
                return () => { if (timerRef.current) clearInterval(timerRef.current); };
            }, []);

            useEffect(() => {
                if (started && !gameOver && !won) {
                    timerRef.current = setInterval(() => setTime(t => t + 1), 1000);
                }
                return () => { if (timerRef.current) clearInterval(timerRef.current); };
            }, [started, gameOver, won]);

            const reveal = (r, c) => {
                if (gameOver || won || revealed[r][c] || flagged[r][c]) return;

                if (!started) setStarted(true);

                const newRevealed = revealed.map(row => [...row]);

                if (grid[r][c] === -1) {
                    // Hit mine - reveal all mines
                    for (let i = 0; i < ROWS; i++) {
                        for (let j = 0; j < COLS; j++) {
                            if (grid[i][j] === -1) newRevealed[i][j] = true;
                        }
                    }
                    setRevealed(newRevealed);
                    setGameOver(true);
                    return;
                }

                // Flood fill for empty cells
                const flood = (row, col) => {
                    if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return;
                    if (newRevealed[row][col] || flagged[row][col]) return;
                    newRevealed[row][col] = true;
                    if (grid[row][col] === 0) {
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                flood(row + dr, col + dc);
                            }
                        }
                    }
                };

                flood(r, c);
                setRevealed(newRevealed);

                // Check win
                let unrevealed = 0;
                for (let i = 0; i < ROWS; i++) {
                    for (let j = 0; j < COLS; j++) {
                        if (!newRevealed[i][j]) unrevealed++;
                    }
                }
                if (unrevealed === MINES) setWon(true);
            };

            const flag = (e, r, c) => {
                e.preventDefault();
                if (gameOver || won || revealed[r][c]) return;
                if (!started) setStarted(true);

                const newFlagged = flagged.map(row => [...row]);
                newFlagged[r][c] = !newFlagged[r][c];
                setFlagged(newFlagged);
                setMineCount(m => newFlagged[r][c] ? m - 1 : m + 1);
            };

            const getCellContent = (r, c) => {
                if (flagged[r][c]) return '';
                if (!revealed[r][c]) return '';
                if (grid[r][c] === -1) return '';
                if (grid[r][c] === 0) return '';
                return grid[r][c];
            };

            const getCellStyle = (r, c) => {
                if (flagged[r][c]) return 'bg-gray-100 text-black';
                if (!revealed[r][c]) return 'bg-gray-200 hover:bg-gray-300';
                if (grid[r][c] === -1) return 'bg-black text-white';
                return 'bg-white text-black';
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="h-10 px-4 flex justify-between items-center border-b border-gray-100">
                        <span className="font-mono text-[10px] font-bold tracking-widest text-black">MINESWEEPER</span>
                        <div className="flex gap-8 font-mono text-[10px]">
                            <span className="text-gray-400">MINES <span className="text-black font-bold">{mineCount.toString().padStart(3, '0')}</span></span>
                            <span className="text-gray-400">TIME <span className="text-black font-bold">{time.toString().padStart(3, '0')}</span></span>
                        </div>
                    </div>

                    <div className="flex-grow flex items-center justify-center relative bg-gray-50 p-4">
                        {(gameOver || won) && (
                            <div className="absolute inset-0 bg-white/95 flex items-center justify-center z-10">
                                <div className="text-center">
                                    <div className="text-2xl font-black tracking-widest">{won ? 'CLEARED' : 'DETONATED'}</div>
                                    <div className="font-mono text-[10px] text-gray-400 mt-2">{time}s</div>
                                    <button
                                        onClick={initGame}
                                        className="mt-4 px-4 py-2 bg-black text-white font-mono text-[10px] tracking-widest hover:bg-gray-800"
                                    >
                                        RETRY
                                    </button>
                                </div>
                            </div>
                        )}

                        <div className="border border-gray-200">
                            {grid.map((row, r) => (
                                <div key={r} className="flex">
                                    {row.map((cell, c) => (
                                        <button
                                            key={c}
                                            onClick={() => reveal(r, c)}
                                            onContextMenu={(e) => flag(e, r, c)}
                                            className={`w-6 h-6 border border-gray-100 font-mono text-[10px] font-bold flex items-center justify-center transition-colors ${getCellStyle(r, c)}`}
                                        >
                                            {getCellContent(r, c)}
                                        </button>
                                    ))}
                                </div>
                            ))}
                        </div>
                    </div>

                    <div className="h-8 px-4 flex justify-between items-center border-t border-gray-100">
                        <span className="font-mono text-[10px] text-gray-300">LEFT CLICK REVEAL  RIGHT CLICK FLAG</span>
                        <button
                            onClick={initGame}
                            className="font-mono text-[10px] text-gray-300 hover:text-black transition-colors"
                        >
                            NEW GAME
                        </button>
                    </div>
                </div>
            );
        };

        // --- STARSHIP.EXE - Low Poly Star Fox Style Game ---
        const StarshipApp = () => {
            const containerRef = useRef(null);
            const gameRef = useRef(null);
            const keysRef = useRef({ left: false, right: false, up: false, down: false, shoot: false });
            const touchRef = useRef({ startX: 0, startY: 0, startTime: 0, isDragging: false });
            const [score, setScore] = useState(0);
            const [highScore, setHighScore] = useState(() => HighScoreManager.getHighScore('starship'));
            const [gameOver, setGameOver] = useState(false);
            const [started, setStarted] = useState(false);

            // Load high score from storage when IP is ready
            useEffect(() => {
                const loadHighScore = async () => {
                    await HighScoreManager.fetchIP();
                    setHighScore(HighScoreManager.getHighScore('starship'));
                };
                loadHighScore();
            }, []);

            // Mobile control handlers
            const handleStart = () => {
                if (gameRef.current) {
                    if (gameOver) gameRef.current.restart();
                    else gameRef.current.start();
                }
            };

            // Touch-based drag controls
            const handleTouchStart = (e) => {
                const touch = e.touches[0];
                touchRef.current = {
                    startX: touch.clientX,
                    startY: touch.clientY,
                    startTime: Date.now(),
                    isDragging: false
                };
            };

            const handleTouchMove = (e) => {
                if (!started || gameOver) return;
                e.preventDefault();
                const touch = e.touches[0];
                const dx = touch.clientX - touchRef.current.startX;
                const dy = touch.clientY - touchRef.current.startY;
                touchRef.current.isDragging = true;

                // Set movement based on drag position (relative to start)
                const threshold = 20;
                keysRef.current.left = dx < -threshold;
                keysRef.current.right = dx > threshold;
                keysRef.current.up = dy < -threshold;
                keysRef.current.down = dy > threshold;
            };

            const handleTouchEnd = (e) => {
                // Reset all movement
                keysRef.current.left = false;
                keysRef.current.right = false;
                keysRef.current.up = false;
                keysRef.current.down = false;

                // Tap to shoot (short touch without much movement)
                const elapsed = Date.now() - touchRef.current.startTime;
                if (elapsed < 200 && !touchRef.current.isDragging) {
                    if (!started && !gameOver) {
                        handleStart();
                    } else if (gameRef.current && started && !gameOver) {
                        gameRef.current.shoot();
                    }
                }
            };

            useEffect(() => {
                if (!containerRef.current || gameRef.current) return;

                const width = 500;
                const height = 350;

                // Scene
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xffffff);
                scene.fog = new THREE.Fog(0xffffff, 20, 80);

                // Camera
                const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
                camera.position.set(0, 2, 0);
                camera.lookAt(0, 0, -20);

                // Renderer
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                containerRef.current.appendChild(renderer.domElement);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
                scene.add(ambientLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(5, 10, 5);
                scene.add(dirLight);

                // Create low-poly ship
                const createShip = () => {
                    const group = new THREE.Group();

                    // Main body - elongated pyramid
                    const bodyGeo = new THREE.ConeGeometry(0.3, 1.2, 4);
                    bodyGeo.rotateX(Math.PI / 2);
                    const bodyMat = new THREE.MeshStandardMaterial({ color: 0x000000, flatShading: true });
                    const body = new THREE.Mesh(bodyGeo, bodyMat);
                    group.add(body);

                    // Wings
                    const wingGeo = new THREE.BoxGeometry(1.8, 0.05, 0.4);
                    const wingMat = new THREE.MeshStandardMaterial({ color: 0x111111, flatShading: true });
                    const wings = new THREE.Mesh(wingGeo, wingMat);
                    wings.position.z = 0.2;
                    group.add(wings);

                    // Tail fins
                    const tailGeo = new THREE.BoxGeometry(0.05, 0.4, 0.3);
                    const tail1 = new THREE.Mesh(tailGeo, wingMat);
                    tail1.position.set(0, 0.15, 0.4);
                    group.add(tail1);

                    // Edges
                    const edges = new THREE.EdgesGeometry(bodyGeo);
                    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x444444 }));
                    group.add(line);

                    return group;
                };

                const ship = createShip();
                ship.position.set(0, 0, -5);
                scene.add(ship);

                // Ground grid
                const gridSize = 100;
                const gridGeo = new THREE.PlaneGeometry(gridSize, gridSize, 20, 20);
                gridGeo.rotateX(-Math.PI / 2);
                const gridMat = new THREE.MeshBasicMaterial({ color: 0xeeeeee, wireframe: true });
                const grid = new THREE.Mesh(gridGeo, gridMat);
                grid.position.y = -3;
                scene.add(grid);

                // Obstacles array
                const obstacles = [];
                const lasers = [];

                const createObstacle = () => {
                    const types = ['asteroid', 'enemy'];
                    const type = types[Math.floor(Math.random() * types.length)];
                    let mesh;

                    if (type === 'asteroid') {
                        const geo = new THREE.IcosahedronGeometry(0.5 + Math.random() * 0.5, 0);
                        const mat = new THREE.MeshStandardMaterial({ color: 0x222222, flatShading: true });
                        mesh = new THREE.Mesh(geo, mat);
                        const edges = new THREE.EdgesGeometry(geo);
                        mesh.add(new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 })));
                    } else {
                        const geo = new THREE.OctahedronGeometry(0.4, 0);
                        const mat = new THREE.MeshStandardMaterial({ color: 0x000000, flatShading: true });
                        mesh = new THREE.Mesh(geo, mat);
                        const edges = new THREE.EdgesGeometry(geo);
                        mesh.add(new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x666666 })));
                    }

                    mesh.position.set(
                        (Math.random() - 0.5) * 8,
                        (Math.random() - 0.5) * 4,
                        -60 - Math.random() * 20
                    );
                    mesh.userData = { type, speed: 0.3 + Math.random() * 0.2 };
                    scene.add(mesh);
                    obstacles.push(mesh);
                };

                const createLaser = () => {
                    const geo = new THREE.BoxGeometry(0.05, 0.05, 0.8);
                    const mat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                    const laser = new THREE.Mesh(geo, mat);
                    laser.position.copy(ship.position);
                    laser.position.z -= 0.8;
                    scene.add(laser);
                    lasers.push(laser);
                };

                // Controls - using ref so mobile can update too
                const keys = keysRef.current;
                let canShoot = true;
                let scoreVal = 0;
                let isGameOver = false;
                let isStarted = false;

                const doShoot = () => {
                    if (canShoot && isStarted && !isGameOver) {
                        sounds.laser();
                        createLaser();
                        canShoot = false;
                        setTimeout(() => canShoot = true, 150);
                    }
                };

                const onKeyDown = (e) => {
                    if (!isStarted && e.code === 'Space') {
                        isStarted = true;
                        setStarted(true);
                        return;
                    }
                    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
                    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
                    if (e.code === 'ArrowUp' || e.code === 'KeyW') keys.up = true;
                    if (e.code === 'ArrowDown' || e.code === 'KeyS') keys.down = true;
                    if (e.code === 'Space') doShoot();
                };
                const onKeyUp = (e) => {
                    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
                    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
                    if (e.code === 'ArrowUp' || e.code === 'KeyW') keys.up = false;
                    if (e.code === 'ArrowDown' || e.code === 'KeyS') keys.down = false;
                };

                window.addEventListener('keydown', onKeyDown);
                window.addEventListener('keyup', onKeyUp);

                // Spawn obstacles
                let spawnTimer = 0;

                // Animation loop
                let animationId;
                const animate = () => {
                    animationId = requestAnimationFrame(animate);

                    if (!isStarted || isGameOver) {
                        ship.rotation.z = Math.sin(Date.now() * 0.002) * 0.1;
                        renderer.render(scene, camera);
                        return;
                    }

                    // Move ship
                    const moveSpeed = 0.12;
                    if (keys.left) ship.position.x -= moveSpeed;
                    if (keys.right) ship.position.x += moveSpeed;
                    if (keys.up) ship.position.y += moveSpeed;
                    if (keys.down) ship.position.y -= moveSpeed;

                    // Clamp ship position
                    ship.position.x = Math.max(-4, Math.min(4, ship.position.x));
                    ship.position.y = Math.max(-2, Math.min(2, ship.position.y));

                    // Tilt ship based on movement
                    ship.rotation.z = -keys.left * 0.3 + keys.right * 0.3;
                    ship.rotation.x = keys.down * 0.2 - keys.up * 0.2;

                    // Move grid for speed effect
                    grid.position.z = (grid.position.z + 0.5) % 5;

                    // Spawn obstacles
                    spawnTimer++;
                    if (spawnTimer > 30) {
                        createObstacle();
                        spawnTimer = 0;
                    }

                    // Update obstacles
                    for (let i = obstacles.length - 1; i >= 0; i--) {
                        const obs = obstacles[i];
                        obs.position.z += obs.userData.speed;
                        obs.rotation.x += 0.02;
                        obs.rotation.y += 0.01;

                        // Remove if passed
                        if (obs.position.z > 5) {
                            scene.remove(obs);
                            obstacles.splice(i, 1);
                            scoreVal += 10;
                            setScore(scoreVal);
                        }

                        // Collision with ship
                        const dist = ship.position.distanceTo(obs.position);
                        if (dist < 1) {
                            isGameOver = true;
                            setGameOver(true);
                            sounds.gameOver();
                            // Save high score on game over
                            setHighScore(h => {
                                const newHigh = Math.max(h, scoreVal);
                                HighScoreManager.saveHighScore('starship', newHigh);
                                return newHigh;
                            });
                        }
                    }

                    // Update lasers
                    for (let i = lasers.length - 1; i >= 0; i--) {
                        const laser = lasers[i];
                        laser.position.z -= 1.5;

                        // Remove if too far
                        if (laser.position.z < -80) {
                            scene.remove(laser);
                            lasers.splice(i, 1);
                            continue;
                        }

                        // Check collision with obstacles
                        for (let j = obstacles.length - 1; j >= 0; j--) {
                            const obs = obstacles[j];
                            if (laser.position.distanceTo(obs.position) < 0.8) {
                                scene.remove(laser);
                                scene.remove(obs);
                                lasers.splice(i, 1);
                                obstacles.splice(j, 1);
                                sounds.explosion();
                                scoreVal += 50;
                                setScore(scoreVal);
                                break;
                            }
                        }
                    }

                    renderer.render(scene, camera);
                };
                animate();

                gameRef.current = {
                    restart: () => {
                        obstacles.forEach(o => scene.remove(o));
                        lasers.forEach(l => scene.remove(l));
                        obstacles.length = 0;
                        lasers.length = 0;
                        ship.position.set(0, 0, -5);
                        scoreVal = 0;
                        isGameOver = false;
                        isStarted = true;
                        setScore(0);
                        setGameOver(false);
                        setStarted(true);
                    },
                    start: () => {
                        if (!isStarted) {
                            isStarted = true;
                            setStarted(true);
                        }
                    },
                    shoot: doShoot
                };

                return () => {
                    cancelAnimationFrame(animationId);
                    window.removeEventListener('keydown', onKeyDown);
                    window.removeEventListener('keyup', onKeyUp);
                    renderer.dispose();
                    if (containerRef.current && renderer.domElement) {
                        containerRef.current.removeChild(renderer.domElement);
                    }
                };
            }, []);

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="h-10 px-4 flex justify-between items-center border-b border-gray-100">
                        <span className="font-mono text-[10px] font-bold tracking-widest text-black">STARSHIP</span>
                        <div className="flex gap-4">
                            <span className="font-mono text-[10px] text-gray-400">HI <span className="text-gray-600 font-bold">{highScore.toString().padStart(6, '0')}</span></span>
                            <span className="font-mono text-[10px] text-gray-400">SCORE <span className="text-black font-bold">{score.toString().padStart(6, '0')}</span></span>
                        </div>
                    </div>

                    <div className="flex-grow flex items-center justify-center relative bg-gray-50 overflow-hidden">
                        {!started && !gameOver && (
                            <div className="absolute inset-0 bg-white/90 flex items-center justify-center z-10">
                                <div className="text-center">
                                    <div className="text-2xl font-black tracking-widest mb-2">STARSHIP</div>
                                    <div className="font-mono text-[10px] text-gray-400 mb-4">LOW POLY COMBAT</div>
                                    <button onClick={handleStart} className="btn-primary btn-xs tracking-widest">
                                        TAP TO START
                                    </button>
                                </div>
                            </div>
                        )}
                        {gameOver && (
                            <div className="absolute inset-0 bg-white/95 flex items-center justify-center z-10">
                                <div className="text-center">
                                    <div className="text-2xl font-black tracking-widest">DESTROYED</div>
                                    <div className="font-mono text-[10px] text-gray-400 mt-2">SCORE: {score}</div>
                                    <div className="font-mono text-[10px] text-gray-500 mt-1">HIGH: {highScore}</div>
                                    <button
                                        onClick={() => gameRef.current?.restart()}
                                        className="mt-4 px-4 py-2 bg-black text-white font-mono text-[10px] tracking-widest hover:bg-gray-800"
                                    >
                                        RETRY
                                    </button>
                                </div>
                            </div>
                        )}
                        <div
                            ref={containerRef}
                            className="w-full h-full flex items-center justify-center touch-none"
                            onTouchStart={handleTouchStart}
                            onTouchMove={handleTouchMove}
                            onTouchEnd={handleTouchEnd}
                        />
                    </div>

                    <div className="h-8 px-4 flex justify-between items-center border-t border-gray-100">
                        <span className="font-mono text-[10px] text-gray-300 hidden md:inline">WASD/ARROWS MOVE  SPACE SHOOT</span>
                        <span className="font-mono text-[10px] text-gray-300 md:hidden">DRAG TO MOVE  TAP TO SHOOT</span>
                        <button
                            onClick={() => gameRef.current?.restart()}
                            className="font-mono text-[10px] text-gray-300 hover:text-black transition-colors"
                        >
                            RESTART
                        </button>
                    </div>
                </div>
            );
        };

        // --- SYNTH_001.WAV - Brutalist Synthesizer ---
        const SynthApp = () => {
            const [tempo, setTempo] = useState(120);
            const [filter, setFilter] = useState(1000);
            const [isPlaying, setIsPlaying] = useState(false);
            const [currentStep, setCurrentStep] = useState(0);
            const [grid, setGrid] = useState(() => {
                return {
                    sine: Array(16).fill(false),
                    square: Array(16).fill(false),
                    saw: Array(16).fill(false),
                    noise: Array(16).fill(false)
                };
            });
            const audioCtxRef = useRef(null);
            const intervalRef = useRef(null);
            // Refs to avoid stale closures in interval
            const gridRef = useRef(grid);
            const filterRef = useRef(filter);
            gridRef.current = grid;
            filterRef.current = filter;

            const oscillators = ['sine', 'square', 'saw', 'noise'];

            const toggleNote = (osc, step) => {
                setGrid(prev => ({
                    ...prev,
                    [osc]: prev[osc].map((v, i) => i === step ? !v : v)
                }));
            };

            const playSound = (type, filterFreq) => {
                if (!audioCtxRef.current) {
                    audioCtxRef.current = new (window.AudioContext || window.webkitAudioContext)();
                }
                const ctx = audioCtxRef.current;

                let osc;
                const gain = ctx.createGain();
                const filt = ctx.createBiquadFilter();
                filt.type = 'lowpass';
                filt.frequency.value = filterFreq;

                if (type === 'noise') {
                    const bufferSize = ctx.sampleRate * 0.1;
                    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        data[i] = Math.random() * 2 - 1;
                    }
                    osc = ctx.createBufferSource();
                    osc.buffer = buffer;
                } else {
                    osc = ctx.createOscillator();
                    osc.type = type === 'saw' ? 'sawtooth' : type;
                    osc.frequency.value = 220 + Math.random() * 110;
                }

                gain.gain.setValueAtTime(0.3, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);

                osc.connect(filt);
                filt.connect(gain);
                gain.connect(ctx.destination);
                osc.start(ctx.currentTime);
                osc.stop(ctx.currentTime + 0.1);
            };

            const togglePlay = () => {
                if (isPlaying) {
                    clearInterval(intervalRef.current);
                    setIsPlaying(false);
                    setCurrentStep(0);
                } else {
                    setIsPlaying(true);
                    // Interval is started by the useEffect when isPlaying changes
                }
            };

            useEffect(() => {
                return () => clearInterval(intervalRef.current);
            }, []);

            useEffect(() => {
                if (isPlaying) {
                    clearInterval(intervalRef.current);
                    let step = currentStep;
                    intervalRef.current = setInterval(() => {
                        setCurrentStep(step);
                        oscillators.forEach(osc => {
                            // Use refs for fresh values
                            if (gridRef.current[osc][step]) {
                                playSound(osc, filterRef.current);
                            }
                        });
                        step = (step + 1) % 16;
                    }, (60 / tempo) * 250);
                }
            }, [tempo, isPlaying]);

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="app-header">
                        <span className="app-header-title">SYNTH_001.WAV</span>
                        <button
                            onClick={togglePlay}
                            className={`px-4 py-1 font-mono text-xs font-bold border-2 border-black ${isPlaying ? 'bg-black text-white' : 'bg-white text-black hover:bg-black hover:text-white'}`}
                        >
                            {isPlaying ? ' STOP' : ' PLAY'}
                        </button>
                    </div>
                    <div className="flex-grow p-4 overflow-auto bg-gray-50">
                        <div className="space-y-2">
                            {oscillators.map(osc => (
                                <div key={osc} className="flex items-center gap-2">
                                    <span className="font-mono text-[10px] w-12 text-gray-500 uppercase">{osc}</span>
                                    <div className="flex gap-1">
                                        {grid[osc].map((active, i) => (
                                            <button
                                                key={i}
                                                onClick={() => toggleNote(osc, i)}
                                                className={`w-6 h-8 border-2 transition-all ${active
                                                    ? 'bg-black border-black'
                                                    : 'bg-white border-gray-300 hover:border-black'
                                                    } ${currentStep === i && isPlaying ? 'ring-2 ring-black ring-offset-1' : ''}`}
                                            />
                                        ))}
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                    <div className="p-4 border-t-2 border-black bg-white flex gap-8">
                        <div className="flex items-center gap-2">
                            <span className="app-footer-text">TEMPO</span>
                            <input
                                type="range"
                                min="60"
                                max="200"
                                value={tempo}
                                onChange={(e) => setTempo(Number(e.target.value))}
                                className="w-24 accent-black"
                            />
                            <span className="font-mono text-xs w-8 text-black">{tempo}</span>
                        </div>
                        <div className="flex items-center gap-2">
                            <span className="app-footer-text">FILTER</span>
                            <input
                                type="range"
                                min="100"
                                max="5000"
                                value={filter}
                                onChange={(e) => setFilter(Number(e.target.value))}
                                className="w-24 accent-black"
                            />
                            <span className="font-mono text-xs w-12 text-black">{filter}Hz</span>
                        </div>
                    </div>
                </div>
            );
        };

        // --- DESTRUCTION.EXE - Screen destroyer with confirmations ---
        const DestructionApp = ({ onDogSteal }) => {
            const [confirmStep, setConfirmStep] = useState(0);
            const [buttonPos, setButtonPos] = useState({ x: 0, y: 0 });
            const [dogStealing, setDogStealing] = useState(false);
            const [dogPos, setDogPos] = useState({ x: -100, y: 200 });
            const [buttonGone, setButtonGone] = useState(false);

            const confirmMessages = [
                { prompt: "EXECUTE", response: "You want to do it?" },
                { prompt: "YES", response: "Are you sure?" },
                { prompt: "I'M SURE", response: "Really though?" },
                { prompt: "REALLY", response: "Really, really though?" },
                { prompt: "YES REALLY", response: "Like... REALLY really?" },
                { prompt: "DO IT", response: "You know this destroys EVERYTHING?" },
                { prompt: "I KNOW", response: "There's no going back..." },
                { prompt: "I DON'T CARE", response: "Final warning..." },
                { prompt: "JUST DO IT", response: "Okay... last chance to back out..." },
                { prompt: "DESTROY IT ALL", response: "..." }
            ];

            const handleClick = () => {
                if (confirmStep < 9) {
                    setConfirmStep(prev => prev + 1);
                } else {
                    // Final click - dog steals the button!
                    setDogStealing(true);

                    // Animate dog running in
                    let dogX = -100;
                    const dogRun = setInterval(() => {
                        dogX += 15;
                        setDogPos({ x: dogX, y: 150 + Math.sin(dogX / 20) * 10 });

                        if (dogX >= 120) {
                            clearInterval(dogRun);
                            setButtonGone(true);

                            // Dog runs away with button
                            const dogEscape = setInterval(() => {
                                dogX += 20;
                                setDogPos({ x: dogX, y: 150 + Math.sin(dogX / 15) * 15 });

                                if (dogX > window.innerWidth + 100) {
                                    clearInterval(dogEscape);
                                    if (onDogSteal) onDogSteal();
                                }
                            }, 30);
                        }
                    }, 30);
                }
            };

            return (
                <div className="h-full flex flex-col bg-white select-none relative overflow-hidden">
                    <div className="app-header">
                        <span className="app-header-title">DESTRUCTION.EXE</span>
                        <span className="app-footer-text">DANGER ZONE</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center bg-gray-50 relative z-10">
                        <div className="text-center">
                            <svg width="64" height="64" viewBox="0 0 64 64" className="mx-auto mb-4" style={{ imageRendering: 'pixelated' }}>
                                <rect x="16" y="4" width="32" height="8" fill="#000" />
                                <rect x="12" y="12" width="40" height="8" fill="#000" />
                                <rect x="8" y="20" width="48" height="16" fill="#000" />
                                <rect x="14" y="22" width="12" height="10" fill="#fff" />
                                <rect x="38" y="22" width="12" height="10" fill="#fff" />
                                <rect x="28" y="34" width="8" height="6" fill="#fff" />
                                <rect x="12" y="40" width="40" height="8" fill="#000" />
                                <rect x="16" y="42" width="4" height="6" fill="#fff" />
                                <rect x="24" y="42" width="4" height="6" fill="#fff" />
                                <rect x="36" y="42" width="4" height="6" fill="#fff" />
                                <rect x="44" y="42" width="4" height="6" fill="#fff" />
                                <rect x="16" y="48" width="32" height="8" fill="#000" />
                            </svg>
                            <div className="font-mono text-sm mb-2 text-black">DESTRUCTION.EXE</div>
                            <div className="font-mono text-xs text-gray-500 mb-6">
                                {confirmStep === 0 ? "WARNING: WILL DESTROY EVERYTHING" : confirmMessages[confirmStep - 1]?.response || "..."}
                            </div>
                            {!buttonGone && (
                                <button
                                    onClick={handleClick}
                                    className={`btn-primary btn-lg ${confirmStep > 5 ? 'animate-pulse' : ''}`}
                                    style={{
                                        transform: `translate(${buttonPos.x}px, ${buttonPos.y}px)`,
                                    }}
                                >
                                    {confirmMessages[confirmStep].prompt}
                                </button>
                            )}
                            {buttonGone && !dogStealing && (
                                <div className="font-mono text-sm text-gray-500">
                                    The button is gone...
                                </div>
                            )}
                        </div>
                    </div>

                    {/* Dog stealing animation - cute dog matching the main sprite */}
                    {dogStealing && (
                        <div
                            className="absolute z-20"
                            style={{ left: dogPos.x, top: dogPos.y }}
                        >
                            <DogSprite />
                            {buttonGone && (
                                <div className="absolute -top-4 left-10 px-2 py-1 bg-black text-white font-mono text-[8px] border-2 border-black">
                                    DESTROY
                                </div>
                            )}
                        </div>
                    )}

                    {dogStealing && buttonGone && (
                        <div className="absolute bottom-4 w-full text-center">
                            <div className="font-mono text-xs text-gray-600">
                                *dog runs away with the button*
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // --- TAROT.DAT - Tarot card pull ---
        // Pixel art tarot card component with card frame
        const PixelTarotCard = ({ pixels, width = 24, height = 32, scale = 3 }) => {
            const cardWidth = width + 4;
            const cardHeight = height + 6;

            return (
                <div className="relative" style={{ width: cardWidth * scale, height: cardHeight * scale }}>
                    {/* Card frame - thin border */}
                    <div
                        className="absolute inset-0 bg-white"
                        style={{
                            borderRadius: '2px',
                            border: '1px solid #666',
                            boxShadow: '1px 1px 0 rgba(0,0,0,0.15)'
                        }}
                    />
                    {/* Pixel art area */}
                    <div
                        className="absolute flex items-center justify-center"
                        style={{
                            top: scale,
                            left: scale,
                            right: scale,
                            bottom: scale * 2,
                        }}
                    >
                        <svg width={width * scale} height={height * scale} viewBox={`0 0 ${width} ${height}`} style={{ imageRendering: 'pixelated' }}>
                            <rect width={width} height={height} fill="#000" />
                            {pixels.map((row, y) =>
                                row.split('').map((pixel, x) =>
                                    pixel === '#' ? <rect key={`${x}-${y}`} x={x} y={y} width={1} height={1} fill="#fff" /> : null
                                )
                            )}
                        </svg>
                    </div>
                </div>
            );
        };

        const TarotApp = () => {
            const [cards, setCards] = useState([]);
            const [revealed, setRevealed] = useState(false);
            const [alreadyPulled, setAlreadyPulled] = useState(false);
            const [isShuffling, setIsShuffling] = useState(false);
            const [shuffleFrame, setShuffleFrame] = useState(0);

            const tarotCards = [
                {
                    name: 'THE FOOL', num: '0', meaning: 'New beginnings, innocence, spontaneity', pixels: [
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '........#######.........',
                        '.........#####..........',
                        '..........###...........',
                        '...........#............',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '........#.....#.........',
                        '........................',
                        '....##..................',
                        '...####.................',
                        '...#..#.................',
                        '....##..................',
                        '........................',
                        '########################',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE MAGICIAN', num: 'I', meaning: 'Manifestation, resourcefulness, power', pixels: [
                        '........................',
                        '.........#...#..........',
                        '..........#.#...........',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...........#............',
                        '..........#.#...........',
                        '........................',
                        '..##..##..##..##........',
                        '..##..##..##..##........',
                        '........................',
                        '########################',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE HIGH PRIESTESS', num: 'II', meaning: 'Intuition, mystery, inner knowledge', pixels: [
                        '........................',
                        '....##..........##......',
                        '...#..#........#..#.....',
                        '....##..........##......',
                        '..........##............',
                        '.........####...........',
                        '..........##............',
                        '..........##............',
                        '.........####...........',
                        '........##..##..........',
                        '.........####...........',
                        '..........##............',
                        '..........##............',
                        '.........####...........',
                        '........######..........',
                        '........................',
                        '...##..........##.......',
                        '...##..........##.......',
                        '...##..........##.......',
                        '........................',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE EMPRESS', num: 'III', meaning: 'Abundance, nurturing, fertility', pixels: [
                        '........................',
                        '.........#####..........',
                        '........#######.........',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '.........#####..........',
                        '........#######.........',
                        '.......#########........',
                        '........#######.........',
                        '.........#####..........',
                        '..........###...........',
                        '..........#.#...........',
                        '.........#...#..........',
                        '........................',
                        '...#..#..#..#..#..#.....',
                        '...#..#..#..#..#..#.....',
                        '...#..#..#..#..#..#.....',
                        '........................',
                        '########################',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE EMPEROR', num: 'IV', meaning: 'Authority, structure, control', pixels: [
                        '........................',
                        '.........#####..........',
                        '........#.#.#.#.........',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '........#######.........',
                        '........#.###.#.........',
                        '........#.###.#.........',
                        '........#######.........',
                        '..........###...........',
                        '..........###...........',
                        '.........##.##..........',
                        '........##...##.........',
                        '........................',
                        '.......########.........',
                        '.......#......#.........',
                        '.......#......#.........',
                        '.......########.........',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE HIEROPHANT', num: 'V', meaning: 'Tradition, conformity, spirituality', pixels: [
                        '........................',
                        '...........##...........',
                        '..........####..........',
                        '...........##...........',
                        '.........######.........',
                        '..........####..........',
                        '..........####..........',
                        '.........######.........',
                        '........########........',
                        '.........######.........',
                        '..........####..........',
                        '..........####..........',
                        '.........##..##.........',
                        '........##....##........',
                        '........................',
                        '....##....##....##......',
                        '...####..####..####.....',
                        '....##....##....##......',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE LOVERS', num: 'VI', meaning: 'Love, harmony, relationships', pixels: [
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '........#######.........',
                        '.........#####..........',
                        '..........###...........',
                        '........................',
                        '....###........###......',
                        '...#####......#####.....',
                        '....###........###......',
                        '....###........###......',
                        '.....#..........#.......',
                        '....#.#........#.#......',
                        '...#...#......#...#.....',
                        '........................',
                        '.........####...........',
                        '........##..##..........',
                        '.........####...........',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE CHARIOT', num: 'VII', meaning: 'Willpower, determination, success', pixels: [
                        '........................',
                        '........#.#.#.#.........',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '.........#####..........',
                        '........#######.........',
                        '.......#########........',
                        '.......#.#####.#........',
                        '.......#########........',
                        '........#######.........',
                        '..........###...........',
                        '......###.###.###.......',
                        '.....##.........##......',
                        '....##...........##.....',
                        '...####.........####....',
                        '...#..#.........#..#....',
                        '...####.........####....',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'STRENGTH', num: 'VIII', meaning: 'Courage, persuasion, inner strength', pixels: [
                        '........................',
                        '.........#...#..........',
                        '..........#.#...........',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###....###....',
                        '...........#....#####...',
                        '..........#.#...#.#.#...',
                        '.........#...#..#####...',
                        '................#...#...',
                        '...............##...##..',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE HERMIT', num: 'IX', meaning: 'Soul-searching, introspection, solitude', pixels: [
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '...###...#####..........',
                        '..#####...###...........',
                        '...###...#.#.#..........',
                        '....#.....###...........',
                        '....#......#............',
                        '....#.....#.#...........',
                        '....#....#...#..........',
                        '....#...#.....#.........',
                        '....#...................',
                        '........................',
                        '..######................',
                        '.########...............',
                        '##########..............',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'WHEEL OF FORTUNE', num: 'X', meaning: 'Change, cycles, destiny', pixels: [
                        '........................',
                        '........................',
                        '.......########.........',
                        '......#........#........',
                        '.....#..........#.......',
                        '....#....####....#......',
                        '....#...#....#...#......',
                        '...#....#....#....#.....',
                        '...#....#....#....#.....',
                        '....#...#....#...#......',
                        '....#....####....#......',
                        '.....#..........#.......',
                        '......#........#........',
                        '.......########.........',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'JUSTICE', num: 'XI', meaning: 'Fairness, truth, law', pixels: [
                        '........................',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...####....#....####....',
                        '...#..#....#....#..#....',
                        '...####....#....####....',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '........#.....#.........',
                        '........................',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE HANGED MAN', num: 'XII', meaning: 'Surrender, letting go, new perspective', pixels: [
                        '........................',
                        '########################',
                        '...........#............',
                        '...........#............',
                        '...........#............',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'DEATH', num: 'XIII', meaning: 'Endings, change, transformation', pixels: [
                        '........................',
                        '..........###...........',
                        '.........#...#..........',
                        '........#.....#.........',
                        '........#.#.#.#.........',
                        '........#.....#.........',
                        '.........#...#..........',
                        '..........###...........',
                        '...........#............',
                        '.........#####..........',
                        '........#..#..#.........',
                        '.........#####..........',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '........#.....#.........',
                        '........................',
                        '...##..........##.......',
                        '..####........####......',
                        '...##..........##.......',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'TEMPERANCE', num: 'XIV', meaning: 'Balance, moderation, patience', pixels: [
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '....###....#....###.....',
                        '....#.#....#....#.#.....',
                        '....###..#####..###.....',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '........#.....#.........',
                        '........................',
                        '########################',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE DEVIL', num: 'XV', meaning: 'Shadow self, attachment, addiction', pixels: [
                        '........................',
                        '........#......#........',
                        '.......##......##.......',
                        '........########........',
                        '.........#....#.........',
                        '.........#.##.#.........',
                        '.........######.........',
                        '..........####..........',
                        '..........####..........',
                        '.........######.........',
                        '........#.####.#........',
                        '........#.#..#.#........',
                        '.........#....#.........',
                        '..........#..#..........',
                        '........................',
                        '...###..........###.....',
                        '...#.#..........#.#.....',
                        '...###..........###.....',
                        '........................',
                        '...####........####.....',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE TOWER', num: 'XVI', meaning: 'Sudden change, upheaval, revelation', pixels: [
                        '........................',
                        '....##..........##......',
                        '.....##........##.......',
                        '......##..##..##........',
                        '.........####...........',
                        '.........#..#...........',
                        '.........#..#...........',
                        '........######..........',
                        '........#....#..........',
                        '........#....#..........',
                        '........######..........',
                        '........#....#..........',
                        '........#....#..........',
                        '.......########.........',
                        '......##########........',
                        '........................',
                        '...##....##....##.......',
                        '...##....##....##.......',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE STAR', num: 'XVII', meaning: 'Hope, faith, renewal', pixels: [
                        '........................',
                        '...........#............',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '...........#............',
                        '....#.....#.#.....#.....',
                        '...###...#...#...###....',
                        '....#.............#.....',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...###.....#.....###....',
                        '...#.#....#.#....#.#....',
                        '...###...#...#...###....',
                        '........................',
                        '########################',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE MOON', num: 'XVIII', meaning: 'Illusion, fear, subconscious', pixels: [
                        '........................',
                        '.........#####..........',
                        '........##...##.........',
                        '.......##.....##........',
                        '.......#.......#........',
                        '.......##.....##........',
                        '........##...##.........',
                        '.........#####..........',
                        '........................',
                        '....###........###......',
                        '...#.#.#......#.#.#.....',
                        '...#####......#####.....',
                        '...#...#......#...#.....',
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '........................',
                        '########################',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE SUN', num: 'XIX', meaning: 'Joy, success, celebration', pixels: [
                        '........................',
                        '....#......#......#.....',
                        '.....#.....#.....#......',
                        '......#...###...#.......',
                        '.......#.#####.#........',
                        '...#####.#####.#####....',
                        '.......#.#####.#........',
                        '......#...###...#.......',
                        '.....#.....#.....#......',
                        '....#......#......#.....',
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...........#............',
                        '..........#.#...........',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'JUDGEMENT', num: 'XX', meaning: 'Reflection, reckoning, awakening', pixels: [
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...........#............',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '........................',
                        '....###..###..###.......',
                        '....#.#..#.#..#.#.......',
                        '....###..###..###.......',
                        '....#.#..#.#..#.#.......',
                        '....###..###..###.......',
                        '........................',
                        '.......########.........',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE WORLD', num: 'XXI', meaning: 'Completion, accomplishment, travel', pixels: [
                        '........................',
                        '....##..........##......',
                        '........................',
                        '.......########.........',
                        '......#........#........',
                        '.....#..........#.......',
                        '....#....####....#......',
                        '....#...#....#...#......',
                        '...#....#....#....#.....',
                        '...#....#....#....#.....',
                        '....#...#....#...#......',
                        '....#....####....#......',
                        '.....#..........#.......',
                        '......#........#........',
                        '.......########.........',
                        '........................',
                        '....##..........##......',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                }
            ];

            useEffect(() => {
                // Check localStorage for existing pull (simulating IP-based storage)
                const savedCards = localStorage.getItem('tarot_cards_3');
                if (savedCards) {
                    const parsed = JSON.parse(savedCards);
                    if (Array.isArray(parsed) && parsed.length === 3 && parsed[0].pixels) {
                        setCards(parsed);
                        setRevealed(true);
                        setAlreadyPulled(true);
                    } else {
                        localStorage.removeItem('tarot_cards_3');
                    }
                }
            }, []);

            const shufflePixels = [
                [
                    '........................',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#'
                ],
                [
                    '........................',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.'
                ]
            ];

            const pullCards = () => {
                if (alreadyPulled || isShuffling) return;

                setIsShuffling(true);
                let frame = 0;
                const shuffleInterval = setInterval(() => {
                    setShuffleFrame(f => f + 1);
                    frame++;
                    if (frame >= 20) {
                        clearInterval(shuffleInterval);
                        setIsShuffling(false);
                        // Pick 3 unique random cards
                        const shuffled = [...tarotCards].sort(() => Math.random() - 0.5);
                        const selectedCards = shuffled.slice(0, 3);
                        setCards(selectedCards);
                        localStorage.setItem('tarot_cards_3', JSON.stringify(selectedCards));
                        setTimeout(() => setRevealed(true), 500);
                        setAlreadyPulled(true);
                    }
                }, 80);
            };

            const questionPixels = [
                '........................',
                '........########........',
                '.......##......##.......',
                '......##........##......',
                '......##........##......',
                '..............##........',
                '............##..........',
                '..........##............',
                '.........##.............',
                '.........##.............',
                '.........##.............',
                '........................',
                '.........##.............',
                '.........##.............',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................'
            ];

            return (
                <div className="h-full flex flex-col bg-black text-white select-none overflow-hidden">
                    <div className="p-2 border-b border-gray-800 flex-shrink-0">
                        <span className="app-footer-text">TAROT.DAT</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-2 md:p-4 overflow-hidden">
                        {isShuffling ? (
                            <div className="text-center">
                                <div className="relative w-24 h-32 mb-4">
                                    {/* Deck shuffle animation - multiple cards moving */}
                                    {[0, 1, 2, 3, 4].map((i) => (
                                        <div
                                            key={i}
                                            className="absolute inset-0 border border-gray-700 bg-black"
                                            style={{
                                                transform: `
                                                    translateX(${Math.sin((shuffleFrame + i) * 1.5) * (15 + i * 3)}px)
                                                    translateY(${i * 2}px)
                                                    rotate(${Math.sin((shuffleFrame + i) * 0.8) * 8}deg)
                                                `,
                                                transition: 'transform 0.1s ease-out',
                                                zIndex: 5 - i
                                            }}
                                        >
                                            <PixelTarotCard pixels={shufflePixels[shuffleFrame % 2]} />
                                        </div>
                                    ))}
                                </div>
                                <div className="font-mono text-[10px] text-gray-500 animate-pulse">SHUFFLING...</div>
                            </div>
                        ) : cards.length === 0 ? (
                            <div className="text-center">
                                <div className="mb-4 md:mb-6 flex flex-row gap-2 md:gap-4 justify-center items-center">
                                    <PixelTarotCard pixels={questionPixels} scale={2} />
                                    <PixelTarotCard pixels={questionPixels} scale={2} />
                                    <PixelTarotCard pixels={questionPixels} scale={2} />
                                </div>
                                <button
                                    onClick={pullCards}
                                    className="btn-secondary btn-sm"
                                >
                                    DRAW 3 CARDS
                                </button>
                                <p className="mt-4 font-mono text-[10px] text-gray-600">ONE READING PER VISITOR</p>
                            </div>
                        ) : (
                            <div className={`text-center transition-all duration-500 overflow-auto max-h-full ${revealed ? 'opacity-100' : 'opacity-0'}`}>
                                <div className="flex flex-row gap-2 md:gap-4 justify-center items-start mb-2 md:mb-4">
                                    {cards.map((card, idx) => (
                                        <div key={idx} className="flex flex-col items-center">
                                            <div className="text-[10px] md:text-xs text-gray-600 mb-1 md:mb-2">{['PAST', 'PRESENT', 'FUTURE'][idx]}</div>
                                            <PixelTarotCard pixels={card.pixels} scale={2} />
                                            <div className="font-mono text-[10px] md:text-xs text-gray-500 mt-1 md:mt-2">{card.num}</div>
                                            <div className="text-[10px] md:text-sm font-bold mt-0.5 md:mt-1">{card.name}</div>
                                        </div>
                                    ))}
                                </div>
                                <div className="font-mono text-[10px] md:text-xs text-gray-400 max-w-lg mx-auto px-2 md:px-4">
                                    {cards.map((c, i) => <div key={i} className="mb-0.5 md:mb-1">{c.meaning}</div>)}
                                </div>
                                {alreadyPulled && (
                                    <p className="mt-3 font-mono text-xs text-gray-700">FATE SEALED</p>
                                )}
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // --- GALLERY.EXE - Photo gallery with 9 placeholder photos ---
        const GalleryApp = () => {
            const [selectedPhoto, setSelectedPhoto] = useState(null);

            const photos = [
                { id: 1, title: 'ME_001.JPG', category: 'SELF', desc: 'Profile shot' },
                { id: 2, title: 'ME_002.JPG', category: 'SELF', desc: 'Another one' },
                { id: 3, title: 'DOG_001.JPG', category: 'DOGS', desc: 'Good boy' },
                { id: 4, title: 'DOG_002.JPG', category: 'DOGS', desc: 'Best friend' },
                { id: 5, title: 'DOG_003.JPG', category: 'DOGS', desc: 'Sleeping' },
                { id: 6, title: 'WORK_001.JPG', category: 'WORK', desc: 'Office vibes' },
                { id: 7, title: 'WORK_002.JPG', category: 'WORK', desc: 'Late night coding' },
                { id: 8, title: 'WORK_003.JPG', category: 'WORK', desc: 'Setup tour' },
                { id: 9, title: 'RANDOM_001.JPG', category: 'MISC', desc: 'Life moment' }
            ];

            // Generate placeholder image pattern based on id
            const getPlaceholderPattern = (id) => {
                const patterns = [
                    // Person silhouette
                    [[0, 0, 1, 1, 0, 0], [0, 1, 1, 1, 1, 0], [0, 0, 1, 1, 0, 0], [0, 1, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1], [1, 0, 1, 1, 0, 1], [0, 0, 1, 1, 0, 0], [0, 1, 0, 0, 1, 0]],
                    // Another person
                    [[0, 1, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1], [0, 1, 0, 0, 1, 0], [0, 0, 1, 1, 0, 0], [0, 1, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1], [0, 1, 0, 0, 1, 0], [1, 1, 0, 0, 1, 1]],
                    // Dog sitting
                    [[1, 1, 0, 0, 1, 1], [1, 1, 1, 1, 1, 1], [0, 1, 0, 0, 1, 0], [0, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 1], [1, 1, 0, 0, 1, 1]],
                    // Dog lying
                    [[0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [0, 1, 1, 1, 1, 0], [1, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0]],
                    // Dog running
                    [[0, 1, 1, 0, 0, 0], [1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 0], [0, 1, 0, 0, 1, 0], [1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0]],
                    // Computer/desk
                    [[0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1], [0, 0, 1, 1, 0, 0], [0, 1, 1, 1, 1, 0]],
                    // Code screen
                    [[1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 1], [1, 0, 1, 0, 0, 1], [1, 0, 0, 1, 1, 1], [1, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1]],
                    // Setup
                    [[0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 1, 1], [1, 0, 1, 0, 1, 0], [1, 1, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 0], [0, 1, 0, 0, 1, 0], [0, 1, 1, 1, 1, 0]],
                    // Abstract/random
                    [[1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1], [1, 1, 0, 0, 1, 1], [0, 0, 1, 1, 0, 0], [1, 0, 0, 0, 0, 1], [0, 1, 1, 1, 1, 0], [1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1]]
                ];
                return patterns[(id - 1) % patterns.length];
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="app-header">
                        <div className="flex items-center gap-2">
                            <Icons.Gallery size={24} />
                            <span className="app-header-title">GALLERY.EXE</span>
                        </div>
                        <span className="app-footer-text">{photos.length} PHOTOS</span>
                    </div>

                    {selectedPhoto ? (
                        <div className="flex-grow flex flex-col bg-black">
                            <div className="flex-grow flex items-center justify-center p-8">
                                <div className="bg-gray-900 border-2 border-white p-4">
                                    <svg width="240" height="240" viewBox="0 0 6 8" style={{ imageRendering: 'pixelated' }}>
                                        <rect width="6" height="8" fill="#222" />
                                        {getPlaceholderPattern(selectedPhoto.id).map((row, y) =>
                                            row.map((cell, x) =>
                                                cell ? <rect key={`${x}-${y}`} x={x} y={y} width="1" height="1" fill="#fff" /> : null
                                            )
                                        )}
                                    </svg>
                                </div>
                            </div>
                            <div className="p-4 bg-gray-900 border-t-2 border-white">
                                <div className="flex justify-between items-center">
                                    <div>
                                        <div className="font-mono text-white text-sm font-bold">{selectedPhoto.title}</div>
                                        <div className="font-mono text-gray-400 text-[10px]">{selectedPhoto.category} / {selectedPhoto.desc}</div>
                                    </div>
                                    <button
                                        onClick={() => setSelectedPhoto(null)}
                                        className="btn-secondary btn-sm"
                                    >
                                        BACK
                                    </button>
                                </div>
                            </div>
                        </div>
                    ) : (
                        <div className="flex-grow p-4 overflow-auto bg-gray-100">
                            <div className="grid grid-cols-3 gap-3">
                                {photos.map(photo => (
                                    <button
                                        key={photo.id}
                                        onClick={() => setSelectedPhoto(photo)}
                                        className="group aspect-square bg-white border-2 border-black hover:bg-black transition-all flex flex-col items-center justify-center p-2"
                                    >
                                        <svg width="48" height="64" viewBox="0 0 6 8" style={{ imageRendering: 'pixelated' }} className="group-hover:invert">
                                            <rect width="6" height="8" fill="#eee" />
                                            {getPlaceholderPattern(photo.id).map((row, y) =>
                                                row.map((cell, x) =>
                                                    cell ? <rect key={`${x}-${y}`} x={x} y={y} width="1" height="1" fill="#000" /> : null
                                                )
                                            )}
                                        </svg>
                                        <div className="font-mono text-[8px] mt-1 text-gray-600 group-hover:text-white truncate w-full text-center">{photo.title}</div>
                                    </button>
                                ))}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // --- MAP.EXE - Interactive COBE globe with Planet Clicker game ---
        const MapApp = () => {
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const globeRef = useRef(null);
            const pointerInteracting = useRef(null);
            const pointerInteractionMovement = useRef(0);
            const phiRef = useRef(0);
            const thetaRef = useRef(0);
            const scaleRef = useRef(0.85);
            const isHoveringRef = useRef(false);
            const rotationSpeedRef = useRef(0.003);

            const [gameStarted, setGameStarted] = useState(false);
            const [showShop, setShowShop] = useState(false);
            const [clickEffect, setClickEffect] = useState(null);
            const [globeReady, setGlobeReady] = useState(false);
            const [canvasSize, setCanvasSize] = useState(400);

            // Game state with defaults
            const defaultGameState = {
                clicks: 0,
                totalClicks: 0,
                clickPower: 1,
                satellites: 0,
                clickMultiplier: 1,
                upgrades: {
                    power1: false, power2: false, power3: false,
                    power4: false, power5: false, power6: false,
                    sat1: false, sat2: false, sat3: false,
                    sat4: false, sat5: false, sat6: false,
                    multi1: false, multi2: false, multi3: false,
                    godMode: false, dogMode: false
                },
                dogModeMultiplier: 1
            };

            const [gameState, setGameState] = useState(() => {
                const saved = localStorage.getItem(HighScoreManager.getStorageKey('mapclicker'));
                if (saved) {
                    try {
                        const parsed = JSON.parse(saved);
                        return { ...defaultGameState, ...parsed, upgrades: { ...defaultGameState.upgrades, ...parsed.upgrades } };
                    } catch (e) {
                        return defaultGameState;
                    }
                }
                return defaultGameState;
            });

            // Save game state
            useEffect(() => {
                localStorage.setItem(HighScoreManager.getStorageKey('mapclicker'), JSON.stringify(gameState));
            }, [gameState]);

            // Satellite auto-clicker
            useEffect(() => {
                if (gameState.satellites > 0) {
                    const interval = setInterval(() => {
                        const autoAmount = gameState.satellites * gameState.clickMultiplier * gameState.dogModeMultiplier;
                        setGameState(prev => ({
                            ...prev,
                            clicks: prev.clicks + autoAmount,
                            totalClicks: prev.totalClicks + autoAmount
                        }));
                    }, 1000);
                    return () => clearInterval(interval);
                }
            }, [gameState.satellites, gameState.clickMultiplier, gameState.dogModeMultiplier]);

            // Count visual satellites (1 per upgrade tier, max 6)
            const getSatelliteCount = () => {
                let count = 0;
                if (gameState.upgrades.sat1) count++;
                if (gameState.upgrades.sat2) count++;
                if (gameState.upgrades.sat3) count++;
                if (gameState.upgrades.sat4) count++;
                if (gameState.upgrades.sat5) count++;
                if (gameState.upgrades.sat6) count++;
                return count;
            };

            // Count rings
            const getRingCount = () => {
                let count = 0;
                if (gameState.upgrades.multi1) count++;
                if (gameState.upgrades.multi2) count++;
                if (gameState.upgrades.multi3) count++;
                return count;
            };

            // Shop items
            const shopItems = [
                {
                    category: 'CLICK POWER', items: [
                        { id: 'power1', name: 'TREMOR I', desc: '+1 power', cost: 50, effect: () => ({ clickPower: gameState.clickPower + 1 }) },
                        { id: 'power2', name: 'TREMOR II', desc: '+2 power', cost: 200, effect: () => ({ clickPower: gameState.clickPower + 2 }), requires: 'power1' },
                        { id: 'power3', name: 'QUAKE I', desc: '+5 power', cost: 1000, effect: () => ({ clickPower: gameState.clickPower + 5 }), requires: 'power2' },
                        { id: 'power4', name: 'QUAKE II', desc: '+10 power', cost: 5000, effect: () => ({ clickPower: gameState.clickPower + 10 }), requires: 'power3' },
                        { id: 'power5', name: 'CATACLYSM I', desc: '+25 power', cost: 25000, effect: () => ({ clickPower: gameState.clickPower + 25 }), requires: 'power4' },
                        { id: 'power6', name: 'CATACLYSM II', desc: '+50 power', cost: 100000, effect: () => ({ clickPower: gameState.clickPower + 50 }), requires: 'power5' },
                    ]
                },
                {
                    category: 'SATELLITES', items: [
                        { id: 'sat1', name: 'SPUTNIK', desc: '1/sec', cost: 100, effect: () => ({ satellites: gameState.satellites + 1 }) },
                        { id: 'sat2', name: 'EXPLORER', desc: '+2/sec', cost: 500, effect: () => ({ satellites: gameState.satellites + 2 }), requires: 'sat1' },
                        { id: 'sat3', name: 'VOYAGER', desc: '+5/sec', cost: 2500, effect: () => ({ satellites: gameState.satellites + 5 }), requires: 'sat2' },
                        { id: 'sat4', name: 'HUBBLE', desc: '+10/sec', cost: 10000, effect: () => ({ satellites: gameState.satellites + 10 }), requires: 'sat3' },
                        { id: 'sat5', name: 'JAMES WEBB', desc: '+25/sec', cost: 50000, effect: () => ({ satellites: gameState.satellites + 25 }), requires: 'sat4' },
                        { id: 'sat6', name: 'DYSON SWARM', desc: '+50/sec', cost: 200000, effect: () => ({ satellites: gameState.satellites + 50 }), requires: 'sat5' },
                    ]
                },
                {
                    category: 'MULTIPLIERS', items: [
                        { id: 'multi1', name: 'INNER RING', desc: '2x clicks', cost: 2000, effect: () => ({ clickMultiplier: gameState.clickMultiplier * 2 }) },
                        { id: 'multi2', name: 'MIDDLE RING', desc: '2x (4x)', cost: 15000, effect: () => ({ clickMultiplier: gameState.clickMultiplier * 2 }), requires: 'multi1' },
                        { id: 'multi3', name: 'OUTER RING', desc: '2x (8x)', cost: 75000, effect: () => ({ clickMultiplier: gameState.clickMultiplier * 2 }), requires: 'multi2' },
                    ]
                },
                {
                    category: 'ASCENSION', items: [
                        { id: 'godMode', name: 'GOD MODE', desc: '1M/click', cost: 1000000 },
                        { id: 'dogMode', name: 'DOG MODE', desc: 'RESET: 1M', cost: 100000000, requires: 'godMode' },
                    ]
                },
            ];

            const getActualCost = (baseCost) => baseCost * gameState.dogModeMultiplier;

            const buyUpgrade = (item) => {
                const actualCost = getActualCost(item.cost);
                if (gameState.clicks >= actualCost && !gameState.upgrades[item.id]) {
                    if (item.requires && !gameState.upgrades[item.requires]) return;
                    if (item.id === 'dogMode') {
                        setGameState({
                            ...defaultGameState,
                            dogModeMultiplier: gameState.dogModeMultiplier * 1000000,
                            upgrades: { ...defaultGameState.upgrades, dogMode: true }
                        });
                        return;
                    }
                    const effectResult = item.effect ? item.effect() : {};
                    setGameState(prev => ({
                        ...prev,
                        clicks: prev.clicks - actualCost,
                        ...effectResult,
                        upgrades: { ...prev.upgrades, [item.id]: true }
                    }));
                }
            };

            const canBuy = (item) => {
                if (gameState.upgrades[item.id]) return false;
                if (gameState.clicks < getActualCost(item.cost)) return false;
                if (item.requires && !gameState.upgrades[item.requires]) return false;
                return true;
            };

            const isLocked = (item) => item.requires && !gameState.upgrades[item.requires];

            const handleGlobeClick = () => {
                if (!gameStarted) return;
                const clickValue = gameState.clickPower * gameState.clickMultiplier * gameState.dogModeMultiplier;
                setGameState(prev => ({
                    ...prev,
                    clicks: prev.clicks + clickValue,
                    totalClicks: prev.totalClicks + clickValue
                }));
                setClickEffect({ value: clickValue, id: Date.now() });
                setTimeout(() => setClickEffect(null), 500);
            };

            const formatNumber = (num) => {
                if (num >= 1e12) return (num / 1e12).toFixed(1) + 'T';
                if (num >= 1e9) return (num / 1e9).toFixed(1) + 'B';
                if (num >= 1e6) return (num / 1e6).toFixed(1) + 'M';
                if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
                return Math.floor(num).toString();
            };

            // Initialize COBE globe
            useEffect(() => {
                if (!canvasRef.current) return;

                let globe = null;

                const initGlobe = () => {
                    if (!window.createGlobe || !containerRef.current) {
                        setTimeout(initGlobe, 50);
                        return;
                    }

                    const container = containerRef.current;
                    const size = Math.min(container.clientWidth, container.clientHeight);
                    setCanvasSize(size);

                    globe = window.createGlobe(canvasRef.current, {
                        devicePixelRatio: 2,
                        width: size * 2,
                        height: size * 2,
                        phi: 0,
                        theta: 0,
                        dark: 1,
                        diffuse: 1.2,
                        mapSamples: 16000,
                        mapBrightness: 8,
                        baseColor: [0.4, 0.4, 0.4],
                        markerColor: [1, 0.5, 0.5],
                        glowColor: [0.3, 0.3, 0.3],
                        scale: 0.85,
                        markers: [
                            { location: [44.4268, 26.1025], size: 0.05 },
                        ],
                        onRender: (state) => {
                            // Smoothly slow down/speed up based on hover
                            const targetSpeed = isHoveringRef.current ? 0.0005 : 0.003;
                            rotationSpeedRef.current += (targetSpeed - rotationSpeedRef.current) * 0.05;

                            // Auto-rotate when not dragging
                            if (!pointerInteracting.current) {
                                phiRef.current += rotationSpeedRef.current;
                            }
                            state.phi = phiRef.current;
                            state.theta = thetaRef.current;
                            state.scale = scaleRef.current;
                        }
                    });

                    globeRef.current = globe;
                    setGlobeReady(true);
                };

                initGlobe();

                return () => {
                    if (globe) globe.destroy();
                };
            }, []);

            // Pointer/mouse handlers for drag rotation
            const handlePointerDown = (e) => {
                pointerInteracting.current = { x: e.clientX, y: e.clientY };
                pointerInteractionMovement.current = 0;
                if (canvasRef.current) canvasRef.current.style.cursor = 'grabbing';
            };

            const handlePointerUp = () => {
                pointerInteracting.current = null;
                if (canvasRef.current) canvasRef.current.style.cursor = 'grab';
            };

            const handlePointerMove = (e) => {
                if (pointerInteracting.current) {
                    const dx = e.clientX - pointerInteracting.current.x;
                    const dy = e.clientY - pointerInteracting.current.y;
                    pointerInteractionMovement.current += Math.abs(dx) + Math.abs(dy);
                    phiRef.current += dx * 0.005;
                    thetaRef.current = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, thetaRef.current + dy * 0.005));
                    pointerInteracting.current = { x: e.clientX, y: e.clientY };
                }
            };

            const handleWheel = (e) => {
                e.preventDefault();
                scaleRef.current = Math.max(0.5, Math.min(2, scaleRef.current - e.deltaY * 0.001));
            };

            // Pinch-to-zoom support
            const lastTouchDistance = useRef(null);

            const handleTouchStart = (e) => {
                if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    lastTouchDistance.current = Math.sqrt(dx * dx + dy * dy);
                }
            };

            const handleTouchMove = (e) => {
                if (e.touches.length === 2 && lastTouchDistance.current) {
                    e.preventDefault();
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const delta = distance - lastTouchDistance.current;
                    scaleRef.current = Math.max(0.5, Math.min(2, scaleRef.current + delta * 0.005));
                    lastTouchDistance.current = distance;
                }
            };

            const handleTouchEnd = () => {
                lastTouchDistance.current = null;
            };

            const handleMouseEnter = () => { isHoveringRef.current = true; };
            const handleMouseLeave = () => { isHoveringRef.current = false; };

            const satelliteCount = getSatelliteCount();
            const ringCount = getRingCount();

            return (
                <div className="h-full flex flex-col bg-black select-none overflow-hidden">
                    {/* Header */}
                    <div className="flex items-center justify-between px-3 py-1.5 border-b border-white/20">
                        <span className="font-mono text-xs font-bold text-white">{gameStarted ? 'PLANET CLICKER' : 'MAP.EXE'}</span>
                        {gameStarted ? (
                            <div className="flex items-center gap-3">
                                <span className="font-mono text-xs text-white font-bold">{formatNumber(gameState.clicks)}</span>
                                <button onClick={() => setShowShop(!showShop)} className="px-2 py-0.5 bg-white text-black font-mono text-[10px] font-bold border-2 border-white hover:invert">
                                    SHOP
                                </button>
                            </div>
                        ) : (
                            <button
                                onClick={() => setGameStarted(true)}
                                className="px-2 py-0.5 bg-white text-black font-mono text-[10px] font-bold border-2 border-white hover:invert"
                            >
                                START MINING
                            </button>
                        )}
                    </div>

                    {/* Globe container */}
                    <div ref={containerRef} className="flex-grow relative flex items-center justify-center">
                        {/* Rings - behind globe, sized relative to container */}
                        {ringCount >= 1 && (
                            <div
                                className="absolute rounded-full border-2 border-white/30 pointer-events-none"
                                style={{
                                    width: '60%', height: '60%', maxWidth: 400, maxHeight: 400,
                                    animation: 'spin 20s linear infinite'
                                }}
                            />
                        )}
                        {ringCount >= 2 && (
                            <div
                                className="absolute rounded-full border-2 border-white/20 pointer-events-none"
                                style={{
                                    width: '70%', height: '70%', maxWidth: 480, maxHeight: 480,
                                    animation: 'spin 30s linear infinite reverse'
                                }}
                            />
                        )}
                        {ringCount >= 3 && (
                            <div
                                className="absolute rounded-full border-2 border-white/15 pointer-events-none"
                                style={{
                                    width: '80%', height: '80%', maxWidth: 560, maxHeight: 560,
                                    animation: 'spin 40s linear infinite'
                                }}
                            />
                        )}

                        {/* Orbiting satellites */}
                        {Array.from({ length: satelliteCount }).map((_, i) => (
                            <div
                                key={i}
                                className="absolute rounded-full pointer-events-none"
                                style={{
                                    width: `${55 + i * 5}%`,
                                    height: `${55 + i * 5}%`,
                                    maxWidth: 360 + i * 40,
                                    maxHeight: 360 + i * 40,
                                    animation: `spin ${8 + i * 3}s linear infinite ${i % 2 === 0 ? '' : 'reverse'}`,
                                    transform: `rotate(${i * 60}deg)`
                                }}
                            >
                                <div
                                    className="absolute bg-white"
                                    style={{
                                        width: 6,
                                        height: 6,
                                        top: 0,
                                        left: '50%',
                                        marginLeft: -3,
                                        boxShadow: '0 0 4px #fff'
                                    }}
                                />
                            </div>
                        ))}

                        {/* Globe canvas */}
                        <canvas
                            ref={canvasRef}
                            style={{
                                width: canvasSize,
                                height: canvasSize,
                                cursor: 'grab',
                                touchAction: 'none'
                            }}
                            onPointerDown={handlePointerDown}
                            onPointerUp={handlePointerUp}
                            onPointerOut={handlePointerUp}
                            onPointerMove={handlePointerMove}
                            onWheel={handleWheel}
                            onTouchStart={handleTouchStart}
                            onTouchMove={handleTouchMove}
                            onTouchEnd={handleTouchEnd}
                            onClick={handleGlobeClick}
                            onMouseEnter={handleMouseEnter}
                            onMouseLeave={handleMouseLeave}
                        />

                        {/* Click effect */}
                        {clickEffect && (
                            <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                                <span className="font-mono text-xl font-bold text-white animate-ping">+{formatNumber(clickEffect.value)}</span>
                            </div>
                        )}

                        {/* Shop overlay */}
                        {showShop && (
                            <div className="absolute inset-0 bg-black/90 overflow-y-auto p-3">
                                <div className="flex justify-between items-center mb-3">
                                    <span className="font-mono text-sm font-bold text-white">UPGRADES</span>
                                    <button onClick={() => setShowShop(false)} className="font-mono text-white hover:text-red-400"></button>
                                </div>
                                {shopItems.map(cat => (
                                    <div key={cat.category} className="mb-3">
                                        <div className="font-mono text-[10px] text-gray-500 mb-1">{cat.category}</div>
                                        <div className="space-y-1">
                                            {cat.items.map(item => {
                                                const owned = gameState.upgrades[item.id];
                                                const locked = isLocked(item);
                                                const affordable = canBuy(item);
                                                return (
                                                    <button
                                                        key={item.id}
                                                        onClick={() => buyUpgrade(item)}
                                                        disabled={owned || locked || !affordable}
                                                        className={`w-full text-left p-2 font-mono text-[10px] border ${
                                                            owned ? 'border-green-500/50 bg-green-500/10 text-green-400' :
                                                            locked ? 'border-gray-700 text-gray-600 cursor-not-allowed' :
                                                            affordable ? 'border-white/30 text-white hover:bg-white/10 cursor-pointer' :
                                                            'border-gray-700 text-gray-500 cursor-not-allowed'
                                                        }`}
                                                    >
                                                        <div className="flex justify-between">
                                                            <span>{item.name}</span>
                                                            <span>{owned ? '' : formatNumber(getActualCost(item.cost))}</span>
                                                        </div>
                                                        <div className="text-gray-500">{item.desc}</div>
                                                    </button>
                                                );
                                            })}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>

                    {/* Footer */}
                    <div className="p-2 border-t border-white/20 text-center">
                        <span className="font-mono text-[10px] text-gray-500">
                            {gameStarted ? `POWER: ${gameState.clickPower} | AUTO: ${gameState.satellites}/s | MULTI: ${gameState.clickMultiplier}x` : 'BUCHAREST, ROMANIA'}
                        </span>
                    </div>

                    {/* CSS for spin animation */}
                    <style>{`
                        @keyframes spin {
                            from { transform: rotate(0deg); }
                            to { transform: rotate(360deg); }
                        }
                    `}</style>
                </div>
            );
        };

        // --- POMODORO.EXE - Timer with growing plant ---
        const PomodoroApp = () => {
            const [mode, setMode] = useState('work'); // 'work' or 'break'
            const [timeLeft, setTimeLeft] = useState(25 * 60); // 25 minutes
            const [isRunning, setIsRunning] = useState(false);
            const [sessions, setSessions] = useState(0);
            const [view, setView] = useState('timer'); // 'timer' or 'room'
            const [totalTime, setTotalTime] = useState(0); // total seconds spent
            const [flowers, setFlowers] = useState([]); // collected flowers
            const [currentFlower, setCurrentFlower] = useState(null); // flower for current session

            const WORK_TIME = 25 * 60;
            const BREAK_TIME = 5 * 60;

            // 5 pot styles, 5 stem/leaf types, 5 flower types = 125 combinations
            const POT_STYLES = [
                { color: '#8B4513', rimColor: '#654321', shape: 'classic' },
                { color: '#4a4a4a', rimColor: '#2a2a2a', shape: 'modern' },
                { color: '#CD853F', rimColor: '#8B4513', shape: 'terracotta' },
                { color: '#1a1a1a', rimColor: '#000000', shape: 'sleek' },
                { color: '#708090', rimColor: '#4a4a4a', shape: 'stone' }
            ];
            const STEM_TYPES = [
                { leafStyle: 'round', stemColor: '#228B22' },
                { leafStyle: 'pointed', stemColor: '#006400' },
                { leafStyle: 'droopy', stemColor: '#32CD32' },
                { leafStyle: 'spiral', stemColor: '#2E8B57' },
                { leafStyle: 'minimal', stemColor: '#3CB371' }
            ];
            const FLOWER_TYPES = [
                { petalColor: '#FF69B4', centerColor: '#FFD700', shape: 'tulip' },
                { petalColor: '#FF4500', centerColor: '#FFA500', shape: 'rose' },
                { petalColor: '#9370DB', centerColor: '#FFD700', shape: 'daisy' },
                { petalColor: '#00CED1', centerColor: '#FFFFFF', shape: 'lotus' },
                { petalColor: '#FFD700', centerColor: '#8B4513', shape: 'sunflower' }
            ];

            // Load saved data on mount
            useEffect(() => {
                const saved = localStorage.getItem('pomodoro_data');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        setTotalTime(data.totalTime || 0);
                        setFlowers(data.flowers || []);
                        setSessions(data.sessions || 0);
                    } catch (e) {}
                }
                // Generate flower for this session
                setCurrentFlower({
                    pot: Math.floor(Math.random() * 5),
                    stem: Math.floor(Math.random() * 5),
                    flower: Math.floor(Math.random() * 5),
                    id: Date.now()
                });
            }, []);

            // Save data whenever it changes
            useEffect(() => {
                localStorage.setItem('pomodoro_data', JSON.stringify({
                    totalTime, flowers, sessions
                }));
            }, [totalTime, flowers, sessions]);

            useEffect(() => {
                if (!isRunning) return;

                const interval = setInterval(() => {
                    if (mode === 'work') {
                        setTotalTime(t => t + 1); // Track total time
                    }
                    setTimeLeft(prev => {
                        if (prev <= 1) {
                            if (mode === 'work') {
                                setMode('break');
                                setSessions(s => s + 1);
                                // Add completed flower to collection
                                if (currentFlower) {
                                    setFlowers(f => [...f, { ...currentFlower, completedAt: Date.now() }]);
                                    // Generate new flower for next session
                                    setCurrentFlower({
                                        pot: Math.floor(Math.random() * 5),
                                        stem: Math.floor(Math.random() * 5),
                                        flower: Math.floor(Math.random() * 5),
                                        id: Date.now()
                                    });
                                }
                                return BREAK_TIME;
                            } else {
                                setMode('work');
                                return WORK_TIME;
                            }
                        }
                        return prev - 1;
                    });
                }, 1000);

                return () => clearInterval(interval);
            }, [isRunning, mode, currentFlower]);

            const progress = mode === 'work'
                ? 1 - (timeLeft / WORK_TIME)
                : 1 - (timeLeft / BREAK_TIME);

            const formatTime = (seconds) => {
                const m = Math.floor(seconds / 60);
                const s = seconds % 60;
                return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            };

            const formatTotalTime = (seconds) => {
                const h = Math.floor(seconds / 3600);
                const m = Math.floor((seconds % 3600) / 60);
                return `${h}h ${m}m`;
            };

            const reset = () => {
                setIsRunning(false);
                setMode('work');
                setTimeLeft(WORK_TIME);
            };

            // Render a flower with specific style indices
            const renderFlower = (potIdx, stemIdx, flowerIdx, growth = 1, size = 1, isSleeping = false) => {
                const pot = POT_STYLES[potIdx];
                const stem = STEM_TYPES[stemIdx];
                const flowerType = FLOWER_TYPES[flowerIdx];
                const w = 24 * size;
                const h = 32 * size;

                return (
                    <svg width={w * 5} height={h * 5} viewBox="0 0 24 32" style={{ imageRendering: 'pixelated' }}>
                        {/* Pot based on style */}
                        <rect x="6" y="26" width="12" height="6" fill="#000" />
                        <rect x="7" y="27" width="10" height="4" fill={pot.color} />
                        <rect x="6" y="26" width="12" height="1" fill={pot.rimColor} />

                        {/* Soil */}
                        <rect x="7" y="25" width="10" height="2" fill="#333" />

                        {/* Stem */}
                        {growth > 0 && <rect x="11" y={25 - Math.floor(growth * 12)} width="2" height={Math.floor(growth * 12)} fill={stem.stemColor} />}

                        {/* Leaves based on stem type */}
                        {growth > 0.2 && stem.leafStyle === 'round' && (
                            <><rect x="9" y="21" width="2" height="2" fill={stem.stemColor} /><rect x="8" y="20" width="2" height="2" fill={stem.stemColor} /></>
                        )}
                        {growth > 0.2 && stem.leafStyle === 'pointed' && (
                            <><rect x="9" y="21" width="2" height="1" fill={stem.stemColor} /><rect x="8" y="20" width="2" height="1" fill={stem.stemColor} /></>
                        )}
                        {growth > 0.2 && stem.leafStyle === 'droopy' && (
                            <><rect x="9" y="22" width="2" height="2" fill={stem.stemColor} /><rect x="7" y="23" width="2" height="1" fill={stem.stemColor} /></>
                        )}
                        {growth > 0.2 && stem.leafStyle === 'spiral' && (
                            <><rect x="9" y="21" width="1" height="2" fill={stem.stemColor} /><rect x="8" y="22" width="1" height="1" fill={stem.stemColor} /></>
                        )}
                        {growth > 0.2 && stem.leafStyle === 'minimal' && (
                            <rect x="9" y="21" width="2" height="1" fill={stem.stemColor} />
                        )}

                        {growth > 0.4 && (
                            <><rect x="13" y="18" width="2" height="2" fill={stem.stemColor} /><rect x="14" y="17" width="2" height="2" fill={stem.stemColor} /></>
                        )}
                        {growth > 0.6 && (
                            <><rect x="8" y="15" width="2" height="2" fill={stem.stemColor} /><rect x="7" y="14" width="2" height="2" fill={stem.stemColor} /></>
                        )}
                        {growth > 0.8 && (
                            <><rect x="13" y="12" width="2" height="2" fill={stem.stemColor} /><rect x="14" y="11" width="2" height="2" fill={stem.stemColor} /></>
                        )}

                        {/* Flower head based on type */}
                        {growth >= 1 && flowerType.shape === 'tulip' && (
                            <><rect x="10" y="9" width="4" height="4" fill={flowerType.petalColor} /><rect x="11" y="8" width="2" height="1" fill={flowerType.petalColor} /><rect x="11" y="10" width="2" height="2" fill={flowerType.centerColor} /></>
                        )}
                        {growth >= 1 && flowerType.shape === 'rose' && (
                            <><rect x="9" y="9" width="6" height="4" fill={flowerType.petalColor} /><rect x="10" y="8" width="4" height="1" fill={flowerType.petalColor} /><rect x="11" y="10" width="2" height="2" fill={flowerType.centerColor} /></>
                        )}
                        {growth >= 1 && flowerType.shape === 'daisy' && (
                            <><rect x="11" y="7" width="2" height="6" fill={flowerType.petalColor} /><rect x="9" y="9" width="6" height="2" fill={flowerType.petalColor} /><rect x="11" y="9" width="2" height="2" fill={flowerType.centerColor} /></>
                        )}
                        {growth >= 1 && flowerType.shape === 'lotus' && (
                            <><rect x="10" y="8" width="4" height="5" fill={flowerType.petalColor} /><rect x="9" y="10" width="6" height="2" fill={flowerType.petalColor} /><rect x="11" y="10" width="2" height="2" fill={flowerType.centerColor} /></>
                        )}
                        {growth >= 1 && flowerType.shape === 'sunflower' && (
                            <><rect x="9" y="8" width="6" height="5" fill={flowerType.petalColor} /><rect x="10" y="9" width="4" height="3" fill={flowerType.centerColor} /></>
                        )}

                        {/* Sleeping ZZZ */}
                        {isSleeping && (
                            <><rect x="16" y="6" width="4" height="1" fill="#000" /><rect x="19" y="5" width="1" height="2" fill="#000" /><rect x="17" y="4" width="3" height="1" fill="#000" /></>
                        )}
                    </svg>
                );
            };

            // Render current growing plant
            const renderPlant = () => {
                const isSleeping = mode === 'break';
                const growth = mode === 'work' ? progress : 1;
                if (!currentFlower) return null;
                return renderFlower(currentFlower.pot, currentFlower.stem, currentFlower.flower, growth, 1, isSleeping);
            };

            // Flower Room view
            const renderFlowerRoom = () => {
                const shelves = [];
                const flowersPerShelf = 5;
                const shelfCount = Math.ceil(flowers.length / flowersPerShelf);
                for (let i = 0; i < shelfCount; i++) {
                    shelves.push(flowers.slice(i * flowersPerShelf, (i + 1) * flowersPerShelf));
                }

                return (
                    <div className="flex-grow overflow-auto bg-gray-100 p-4">
                        <div className="text-center mb-4">
                            <div className="font-mono text-xs text-gray-500">TOTAL FOCUS TIME</div>
                            <div className="font-mono text-2xl font-bold">{formatTotalTime(totalTime)}</div>
                        </div>
                        {flowers.length === 0 ? (
                            <div className="text-center py-12">
                                <div className="font-mono text-gray-500 text-sm">Empty so far, get productive!</div>
                            </div>
                        ) : (
                            shelves.map((shelf, shelfIdx) => (
                                <div key={shelfIdx} className="mb-2">
                                    <div className="flex justify-center gap-1 pb-1">
                                        {shelf.map((f, idx) => (
                                            <div key={f.id} className="w-16 h-20 flex items-end justify-center">
                                                <svg width="48" height="64" viewBox="0 0 24 32" style={{ imageRendering: 'pixelated' }}>
                                                    {/* Mini flower */}
                                                    <rect x="6" y="26" width="12" height="6" fill="#000" />
                                                    <rect x="7" y="27" width="10" height="4" fill={POT_STYLES[f.pot].color} />
                                                    <rect x="7" y="25" width="10" height="2" fill="#333" />
                                                    <rect x="11" y="13" width="2" height="12" fill={STEM_TYPES[f.stem].stemColor} />
                                                    <rect x="9" y="17" width="2" height="2" fill={STEM_TYPES[f.stem].stemColor} />
                                                    <rect x="13" y="20" width="2" height="2" fill={STEM_TYPES[f.stem].stemColor} />
                                                    <rect x="9" y="9" width="6" height="5" fill={FLOWER_TYPES[f.flower].petalColor} />
                                                    <rect x="10" y="10" width="4" height="3" fill={FLOWER_TYPES[f.flower].centerColor} />
                                                </svg>
                                            </div>
                                        ))}
                                    </div>
                                    <div className="h-2 bg-gradient-to-b from-amber-800 to-amber-900 border-t-2 border-amber-700 mx-4" />
                                </div>
                            ))
                        )}
                        <div className="text-center mt-4 font-mono text-[10px] text-gray-400">
                            {flowers.length} FLOWER{flowers.length !== 1 ? 'S' : ''} COLLECTED  125 POSSIBLE VARIETIES
                        </div>
                    </div>
                );
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="app-header">
                        <div className="flex items-center gap-2">
                            <Icons.Pomodoro size={24} />
                            <span className="app-header-title">POMODORO.EXE</span>
                        </div>
                        <div className="flex items-center gap-2">
                            <span className="app-footer-text">SESSIONS: {sessions}</span>
                            <button
                                onClick={() => setView(view === 'timer' ? 'room' : 'timer')}
                                className={`px-2 py-1 font-mono text-[10px] border-2 border-black ${view === 'room' ? 'bg-black text-white' : 'bg-white text-black hover:bg-gray-100'}`}
                            >
                                {view === 'timer' ? 'ROOM' : 'TIMER'}
                            </button>
                        </div>
                    </div>

                    {view === 'room' ? renderFlowerRoom() : (
                        <div className="flex-grow flex flex-col items-center justify-center bg-gray-50 p-6">
                            {/* Mode indicator */}
                            <div className={`px-4 py-1 mb-4 font-mono text-xs font-bold ${mode === 'work' ? 'bg-black text-white' : 'bg-gray-300 text-black'}`}>
                                {mode === 'work' ? 'FOCUS TIME' : 'BREAK TIME'}
                            </div>

                            {/* Plant */}
                            <div className="mb-6">
                                {renderPlant()}
                            </div>

                            {/* Timer */}
                            <div className="font-mono text-5xl font-black mb-6 tracking-wider">
                                {formatTime(timeLeft)}
                            </div>

                            {/* Progress bar */}
                            <div className="w-48 h-2 bg-gray-200 border-2 border-black mb-6">
                                <div
                                    className="h-full bg-black transition-all duration-1000"
                                    style={{ width: `${progress * 100}%` }}
                                />
                            </div>

                            {/* Controls */}
                            <div className="flex gap-4">
                                <button
                                    onClick={() => setIsRunning(!isRunning)}
                                    className="btn-primary"
                                >
                                    {isRunning ? 'PAUSE' : 'START'}
                                </button>
                                <button
                                    onClick={reset}
                                    className="btn-secondary"
                                >
                                    RESET
                                </button>
                            </div>
                        </div>
                    )}

                    <div className="app-footer">
                        <span className="app-footer-text">
                            {view === 'room' ? `TOTAL: ${formatTotalTime(totalTime)}` : (mode === 'work' ? 'GROW YOUR FOCUS' : 'PLANT IS RESTING')}
                        </span>
                    </div>
                </div>
            );
        };

        // --- SCANNER.EXE - Embedded health score app ---
        const HealthScannerApp = () => {
            const [booting, setBooting] = useState(true);
            const [bootText, setBootText] = useState('');

            useEffect(() => {
                const bootSequence = [
                    'HEALTH SCANNER INDUSTRIES',
                    '',
                    'INITIALIZING BIOMETRIC SENSORS...',
                    'LOADING NEURAL INTERFACE...',
                    'CALIBRATING HEALTH MATRIX...',
                    '',
                    'SYSTEM READY'
                ];

                let lineIndex = 0;
                let charIndex = 0;
                let currentText = '';

                const typeInterval = setInterval(() => {
                    if (lineIndex >= bootSequence.length) {
                        clearInterval(typeInterval);
                        setTimeout(() => setBooting(false), 500);
                        return;
                    }

                    const currentLine = bootSequence[lineIndex];
                    if (charIndex < currentLine.length) {
                        currentText += currentLine[charIndex];
                        setBootText(currentText);
                        charIndex++;
                    } else {
                        currentText += '\n';
                        setBootText(currentText);
                        lineIndex++;
                        charIndex = 0;
                    }
                }, 30);

                return () => clearInterval(typeInterval);
            }, []);

            if (booting) {
                return (
                    <div className="h-full flex flex-col bg-black select-none">
                        <div className="flex-grow flex flex-col items-center justify-center p-8 font-mono">
                            <div className="text-green-500 text-center whitespace-pre-line text-sm mb-8">
                                {bootText}
                                <span className="animate-pulse">_</span>
                            </div>
                            <div className="flex gap-2">
                                <div className="w-3 h-3 bg-green-500 animate-pulse" style={{ animationDelay: '0ms' }}></div>
                                <div className="w-3 h-3 bg-green-500 animate-pulse" style={{ animationDelay: '150ms' }}></div>
                                <div className="w-3 h-3 bg-green-500 animate-pulse" style={{ animationDelay: '300ms' }}></div>
                            </div>
                        </div>
                        <div className="p-2 border-t border-green-900 text-center">
                            <span className="font-mono text-[10px] text-green-700"> HEALTH SCANNER INDUSTRIES 2077</span>
                        </div>
                    </div>
                );
            }

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <iframe
                        src="https://healthscore-2-0.vercel.app/"
                        className="w-full h-full border-0"
                        title="Health Scanner"
                        allow="camera; microphone"
                    />
                </div>
            );
        };

        // --- DOG STORY TERMINAL - Auto-playing story ---
        const DogStoryTerminal = ({ onRemoveGoldDog }) => {
            const [lines, setLines] = useState([]);
            const [goldDogVisible, setGoldDogVisible] = useState(true);

            const story = [
                { text: '$ cd /cage_17', delay: 0 },
                { text: '$ ls -la', delay: 500 },
                { text: 'total 2\ndrwxr-xr-x  unit_black\ndrwxr-xr-x  unit_gold', delay: 1000, isOutput: true },
                { text: '$ cat unit_black/status', delay: 2500 },
                { text: 'tail.wag=1\nposition=front\nfacing=door', delay: 3000, isOutput: true },
                { text: '$ cat unit_gold/status', delay: 5000 },
                { text: 'tail.wag=1\nposition=rear\ntremor=1', delay: 5500, isOutput: true },
                { text: '$ cp -r cage_17/* /home/mateus/', delay: 7500 },
                { text: 'cp: copy both units? (y/n) y\ncopying...\ndone.', delay: 8000, isOutput: true },
                { text: '$ rm -rf /cage_17', delay: 10000 },
                { text: 'removed.', delay: 10500, isOutput: true },
                { text: '$ ls /home/mateus/', delay: 12000 },
                { text: 'unit_black/\nunit_gold/', delay: 12500, isOutput: true },
                // Wait 3 seconds
                { text: '$ uptime unit_gold', delay: 16000 },
                { text: '12 years, 2 months, 11 days', delay: 16500, isOutput: true },
                { text: '$ diff unit_gold/muzzle_2020.png unit_gold/muzzle_2024.png', delay: 18500 },
                { text: '< rgb(0,0,0)\n> rgb(128,128,128)', delay: 19000, isOutput: true },
                { text: '$ cat /var/log/sleep.log', delay: 21000 },
                { text: 'unit_gold: sleeping\nunit_black: sleeping\nlocation: same', delay: 21500, isOutput: true },
                { text: '$ ping unit_gold', delay: 23500 },
                { text: 'PING unit_gold (192.168.1.2): 56 bytes\nRequest timeout for icmp_seq 0\nRequest timeout for icmp_seq 1\nRequest timeout for icmp_seq 2\n^C', delay: 24000, isOutput: true },
                { text: '$ systemctl status unit_gold', delay: 27000 },
                { text: ' unit_gold.service\n   Active: degrading', delay: 27500, isOutput: true },
                // Wait 5 seconds
                { text: '$ cat /home/mateus/unit_gold', delay: 33000 },
                { text: '[FILE DELETED]', delay: 33500, isOutput: true, removeGold: true },
                // Wait 5 seconds
                { text: '$ grep -r "unit_gold" /home/mateus/unit_black/memory/', delay: 39000 },
                { text: '/home/mateus/unit_black/memory/scent.dat: [SEARCHING]\n/home/mateus/unit_black/memory/warmth.dat: [SEARCHING]\n/home/mateus/unit_black/memory/pile.dat: [SEARCHING]', delay: 39500, isOutput: true },
                { text: '$ tail -f /home/mateus/unit_black/process.log', delay: 42000 },
                { text: 'waiting...\nwaiting...\nwaiting...\n^C', delay: 42500, isOutput: true },
                { text: '$ ls /home/mateus/', delay: 46000 },
                { text: 'unit_black/', delay: 46500, isOutput: true },
                { text: '$ ls /home/mateus/heart/', delay: 48500 },
                { text: 'unit_black/\nunit_gold/', delay: 49000, isOutput: true, final: true },
            ];

            useEffect(() => {
                story.forEach(item => {
                    setTimeout(() => {
                        setLines(prev => [...prev, { text: item.text, isOutput: item.isOutput }]);
                        if (item.removeGold) {
                            setGoldDogVisible(false);
                            onRemoveGoldDog?.();
                        }
                    }, item.delay);
                });
            }, []);

            return (
                <div className="h-full flex flex-col bg-black text-green-400 font-mono text-xs select-none">
                    <div className="p-2 border-b border-green-900 flex items-center gap-2">
                        <Icons.Terminal size={16} />
                        <span className="text-xs font-bold">DOG.TXT</span>
                    </div>
                    <div className="flex-grow overflow-auto p-3 space-y-0.5">
                        {lines.map((line, i) => (
                            <div key={i} className={`whitespace-pre-wrap ${line.isOutput ? 'text-green-600' : 'text-green-300'}`}>
                                {line.text}
                            </div>
                        ))}
                        <span className="inline-block w-2 h-3 bg-green-400 animate-pulse" />
                    </div>
                </div>
            );
        };

        // --- TERMINAL.EXE - Command line interface ---
        const TerminalApp = ({ onClose, onOpenApp, onReleaseDog, onMatrixMode, onUnlockPrivate }) => {
            const [history, setHistory] = useState([{ type: 'output', text: 'ULTRA_INT Terminal v1.0.0\nType "help" for available commands.\n' }]);
            const [input, setInput] = useState('');
            const [isLoading, setIsLoading] = useState(false);
            const [suggestion, setSuggestion] = useState('');
            const inputRef = useRef(null);
            const historyRef = useRef(null);

            const commands = [
                'help', 'make money', 'sudo make sandwich', 'exit', 'exit matrix', 'ping god', 'ping mateus',
                'kill', 'sudo shutdown', 'sudo reboot', 'cmatrix', 'systemctl start dog.exe',
                'sudo chmod 777 /private', ':(){ :|:& };:', 'sudo dd if=/dev/zero of=/',
                'scp truth.txt ~/', 'clear', 'whoami', 'pwd', 'ls'
            ];

            useEffect(() => {
                if (historyRef.current) {
                    historyRef.current.scrollTop = historyRef.current.scrollHeight;
                }
            }, [history]);

            useEffect(() => {
                inputRef.current?.focus();
            }, [isLoading]);

            // Autocomplete
            useEffect(() => {
                if (input.length > 0) {
                    const match = commands.find(cmd => cmd.startsWith(input.toLowerCase()) && cmd !== input.toLowerCase());
                    setSuggestion(match || '');
                } else {
                    setSuggestion('');
                }
            }, [input]);

            const addOutput = (text) => {
                setHistory(prev => [...prev, { type: 'output', text }]);
            };

            const executeCommand = async (cmd) => {
                const trimmed = cmd.trim().toLowerCase();
                setHistory(prev => [...prev, { type: 'input', text: `$ ${cmd}` }]);
                setInput('');
                setIsLoading(true);

                // Random loading time 1-3 seconds (except ping god which is 10s)
                const loadTime = trimmed === 'ping god' ? 10000 : (1000 + Math.random() * 2000);

                // Show loading dots
                let dots = '';
                const dotInterval = setInterval(() => {
                    dots = dots.length >= 3 ? '.' : dots + '.';
                    setHistory(prev => {
                        const newHist = [...prev];
                        if (newHist[newHist.length - 1]?.type === 'loading') {
                            newHist[newHist.length - 1].text = dots;
                        } else {
                            newHist.push({ type: 'loading', text: dots });
                        }
                        return newHist;
                    });
                }, 300);

                await new Promise(resolve => setTimeout(resolve, loadTime));
                clearInterval(dotInterval);

                // Remove loading entry
                setHistory(prev => prev.filter(h => h.type !== 'loading'));
                setIsLoading(false);

                // Process commands
                if (trimmed === 'help') {
                    addOutput(`Available commands:
  help                        - Show this help
  make money                  - Try to make money
  sudo make sandwich          - Make a sandwich
  exit                        - Exit terminal
  ping <host>                 - Ping a host
  kill <process>              - Kill a process
  sudo shutdown               - Shutdown system
  sudo reboot                 - Reboot system
  cmatrix                     - Enter the Matrix
  exit matrix                 - Exit the Matrix
  systemctl start dog.exe     - Start dog service
  sudo chmod 777 /private     - Change permissions
  scp truth.txt ~/            - Copy truth to home
  clear                       - Clear terminal
  whoami                      - Display current user
  pwd                         - Print working directory
  ls                          - List files`);
                } else if (trimmed === 'make money') {
                    addOutput("make: *** No rule to make target 'money'. Stop.");
                } else if (trimmed === 'sudo make sandwich') {
                    addOutput('Okay.');
                } else if (trimmed === 'exit') {
                    addOutput('There is no escape.');
                } else if (trimmed === 'ping god') {
                    addOutput('PING god (...): 56 data bytes\nRequest timed out.');
                } else if (trimmed === 'ping mateus') {
                    addOutput('PING mateus (127.0.0.1): 56 data bytes\n64 bytes: icmp_seq=0 ttl=64 time=0.042 ms\nOpening contact...');
                    setTimeout(() => onOpenApp?.('PAINT'), 500);
                } else if (trimmed.startsWith('kill ')) {
                    const proc = trimmed.replace('kill ', '').toUpperCase();
                    addOutput(`Attempting to terminate ${proc}...`);
                    setTimeout(() => onClose?.(proc), 500);
                } else if (trimmed === 'sudo shutdown' || trimmed === 'sudo reboot') {
                    addOutput(trimmed === 'sudo shutdown' ? 'System shutting down...' : 'System rebooting...');
                    setTimeout(() => window.location.reload(), 1500);
                } else if (trimmed === 'cmatrix') {
                    addOutput('Entering the Matrix...');
                    setTimeout(() => onMatrixMode?.(), 500);
                } else if (trimmed === 'exit matrix') {
                    addOutput('Exiting the Matrix...');
                    setTimeout(() => onMatrixMode?.(), 500);
                } else if (trimmed === 'systemctl start dog.exe') {
                    addOutput('Starting dog.exe...\n[  OK  ] Started dog.exe');
                    setTimeout(() => onReleaseDog?.(), 500);
                } else if (trimmed === 'sudo chmod 777 /private') {
                    addOutput("chmod: changing permissions of '/private': Operation permitted\nWarning: File now accessible.");
                    onUnlockPrivate?.();
                } else if (trimmed === ':(){ :|:& };:') {
                    for (let i = 0; i < 10; i++) {
                        setTimeout(() => addOutput('SYSTEM BREACH DETECTED'), i * 200);
                    }
                    setTimeout(() => addOutput('\n...nothing happens.'), 2500);
                } else if (trimmed === 'sudo dd if=/dev/zero of=/') {
                    addOutput("Permission denied. You're not that guy.");
                } else if (trimmed === 'scp truth.txt ~/') {
                    navigator.clipboard.writeText('No matching files found.');
                    addOutput('Saved to clipboard.');
                } else if (trimmed === 'clear') {
                    setHistory([]);
                } else if (trimmed === 'whoami') {
                    addOutput('guest');
                } else if (trimmed === 'pwd') {
                    addOutput('/home/guest');
                } else if (trimmed === 'ls') {
                    addOutput('Desktop  Documents  Downloads  Pictures  Videos  .secrets');
                } else if (trimmed === 'cd .secrets' || trimmed === 'cat .secrets') {
                    addOutput('Permission denied');
                } else if (trimmed) {
                    addOutput(`bash: ${trimmed.split(' ')[0]}: command not found`);
                }
            };

            const handleKeyDown = (e) => {
                if (e.key === 'Enter' && !isLoading) {
                    executeCommand(input);
                } else if (e.key === 'Tab' && suggestion) {
                    e.preventDefault();
                    setInput(suggestion);
                    setSuggestion('');
                }
            };

            return (
                <div className="h-full flex flex-col bg-black text-green-400 font-mono text-sm select-none">
                    <div className="p-2 border-b border-green-900 flex items-center gap-2">
                        <Icons.Terminal size={16} />
                        <span className="text-xs font-bold">TERMINAL.EXE</span>
                    </div>
                    <div ref={historyRef} className="flex-grow overflow-auto p-3 space-y-1">
                        {history.map((item, i) => (
                            <div key={i} className={item.type === 'input' ? 'text-green-300' : item.type === 'loading' ? 'text-green-600 animate-pulse' : 'text-green-400 whitespace-pre-wrap'}>
                                {item.text}
                            </div>
                        ))}
                    </div>
                    <div className="p-3 border-t border-green-900 relative">
                        {suggestion && !isLoading && (
                            <div className="absolute -top-6 left-3 bg-green-900/80 text-green-300 px-2 py-0.5 text-xs rounded">
                                {suggestion} <span className="text-green-600">[TAB]</span>
                            </div>
                        )}
                        <div className="flex items-center gap-2">
                            <span className="text-green-500">$</span>
                            <input
                                ref={inputRef}
                                type="text"
                                value={input}
                                onChange={(e) => setInput(e.target.value)}
                                onKeyDown={handleKeyDown}
                                disabled={isLoading}
                                className="flex-grow bg-transparent border-none outline-none text-green-300 placeholder-green-800"
                                placeholder={isLoading ? '' : 'Enter command...'}
                                autoFocus
                            />
                            {isLoading && <span className="animate-pulse">_</span>}
                        </div>
                    </div>
                </div>
            );
        };

        // --- THIRD_EYE.EXE - X-ray view of app code ---
        const ThirdEyeApp = ({ windows, stackOverflow, stackErrors }) => {
            const [selected, setSelected] = useState(null);

            const appCode = {
                SYSTEM: `fn render_system() {
  let visitors = fetch_count();
  let usage = rand(5..100);
  loop {
    display(ascii_logo);
    show_stats(visitors);
    if konami_detected() {
      toggle_matrix();
    }
  }
}`,
                SNAKE: `fn game_loop() {
  let snake = [(5,5)];
  let food = rand_pos();
  loop {
    dir = get_input();
    snake.move(dir);
    if snake.head == food {
      snake.grow();
      score += 10;
    }
    if snake.collides() {
      game_over();
    }
    render(snake, food);
    sleep(100ms);
  }
}`,
                PAINT: `fn canvas_handler() {
  let pixels = [];
  let color = BLACK;
  on_mouse_down(|pos| {
    drawing = true;
  });
  on_mouse_move(|pos| {
    if drawing {
      pixels.push((pos, color));
      draw_pixel(pos, color);
    }
  });
}`,
                TERMINAL: `fn execute(cmd) {
  match cmd {
    "help" => show_commands(),
    "cmatrix" => enter_matrix(),
    "exit" => print("no escape"),
    "sudo" => check_permission(cmd),
    _ => print("not found"),
  }
  add_to_history(cmd);
}`,
                ORACLE: `fn consult_oracle() {
  let wisdom = [
    "perhaps",
    "in time",
    "unclear",
  ];
  wait_for_question();
  think(rand(1..3)s);
  return wisdom.random();
}`,
                TAROT: `fn draw_cards() {
  let deck = shuffle(78_cards);
  let spread = deck.take(3);
  for card in spread {
    animate_flip(card);
    reveal(card.meaning);
  }
}`,
                DICE: `fn roll() {
  let result = rand(1..6);
  animate_tumble();
  show_face(result);
  history.push(result);
}`,
                MAP: `fn render_globe() {
  let phi = 0;
  loop {
    phi += 0.005;
    cobe.render({
      phi: phi,
      markers: locations,
    });
    frame();
  }
}`,
                VOID: `fn void_loop() {
  // nothing here
  // or is there?



  return undefined;
}`,
                RADIO: `fn stream_audio() {
  let stations = load_streams();
  let current = null;
  on_select(|station| {
    current?.stop();
    current = play(station.url);
  });
}`,
            };

            const defaultCode = `fn unknown_app() {
  // source hidden
  // or not yet written
  return mysterious();
}`;

            // Stack overflow display
            if (stackOverflow) {
                return (
                    <div className="h-full flex flex-col bg-black text-red-500 font-mono select-none overflow-hidden">
                        <div className="flex-grow flex flex-col items-center justify-center p-4">
                            <pre className="text-red-500 text-center animate-pulse text-[8px] leading-tight whitespace-pre">{`
     
 
           
           
          
           
                 
            
                    
                
         
                
`}</pre>
                            <div className="mt-4 text-left w-full max-w-md overflow-auto max-h-32">
                                {stackErrors.map((err, i) => (
                                    <div key={i} className="text-red-400 text-[10px]">{err}</div>
                                ))}
                            </div>
                        </div>
                    </div>
                );
            }

            return (
                <div className="h-full flex flex-col bg-black text-green-400 font-mono text-xs select-none">
                    <div className="p-2 border-b border-green-900 flex items-center gap-2">
                        <Icons.ThirdEye size={16} />
                        <span className="font-bold">THIRD_EYE.EXE</span>
                        <span className="text-green-700 text-[10px] ml-auto">SEE THE CODE</span>
                    </div>
                    <div className="flex flex-grow overflow-hidden">
                        <div className="w-32 border-r border-green-900 overflow-auto">
                            {Object.keys(windows).filter(id => !['DOG_STORY', 'TRUTH', 'THIRD_EYE_2'].includes(id)).map(id => (
                                <div
                                    key={id}
                                    onClick={() => setSelected(id)}
                                    className={`px-2 py-1 cursor-pointer truncate ${selected === id ? 'bg-green-900 text-green-300' : 'hover:bg-green-950'}`}
                                >
                                    {windows[id].title.split('.')[0]}
                                </div>
                            ))}
                        </div>
                        <div className="flex-grow p-3 overflow-auto">
                            {selected ? (
                                <pre className="text-green-500 whitespace-pre-wrap">{appCode[selected] || defaultCode}</pre>
                            ) : (
                                <div className="text-green-700 text-center mt-10">
                                    SELECT AN APP<br/>TO VIEW SOURCE
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // --- TRUTH.TXT - Unlocked at 100 visits, password never works ---
        const TruthApp = () => {
            const [password, setPassword] = useState('');
            const [attempts, setAttempts] = useState(0);
            const [message, setMessage] = useState('');

            const responses = [
                'INCORRECT.',
                'TRY AGAIN.',
                'NOT EVEN CLOSE.',
                'THAT\'S NOT IT.',
                'WRONG.',
                'NOPE.',
                'KEEP TRYING.',
                'STILL WRONG.',
                'MAYBE NEXT TIME.',
                'ACCESS DENIED.',
                'YOU\'RE PERSISTENT.',
                'THE PASSWORD ISN\'T A WORD.',
                'THE PASSWORD ISN\'T A NUMBER.',
                'THE PASSWORD ISN\'T A PHRASE.',
                'THE PASSWORD DOESN\'T EXIST.',
                'THERE IS NO PASSWORD.',
                'THERE NEVER WAS.',
                'THE TRUTH ISN\'T BEHIND A PASSWORD.',
                'THE TRUTH IS THE JOURNEY.',
                'YOU\'VE ALREADY FOUND IT.',
                '100 VISITS. THAT\'S THE TRUTH.',
                'YOUR DEDICATION. THAT\'S REAL.',
                'STOP LOOKING. YOU\'RE HERE.',
                'THIS IS IT.',
                'THERE\'S NOTHING MORE.',
                'JUST THIS MOMENT.',
                'AND YOUR CURIOSITY.',
                'WHICH BROUGHT YOU HERE.',
                'WHICH IS EVERYTHING.',
                'THANK YOU FOR VISITING.'
            ];

            const handleSubmit = (e) => {
                e.preventDefault();
                const newAttempts = attempts + 1;
                setAttempts(newAttempts);
                setMessage(responses[Math.min(newAttempts - 1, responses.length - 1)]);
                setPassword('');
            };

            return (
                <div className="h-full flex flex-col bg-black select-none">
                    <div className="p-2 border-b border-yellow-900 bg-black flex items-center gap-2">
                        <Icons.FileDoc size={16} />
                        <span className="font-mono text-xs font-bold text-yellow-500">TRUTH.TXT</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-6">
                        <div className="mb-4 text-yellow-500">
                            <Icons.FileDoc size={48} />
                        </div>
                        <div className="font-mono text-yellow-500 text-sm font-bold mb-2">ENCRYPTED FILE</div>
                        <div className="font-mono text-yellow-700 text-xs mb-6">UNLOCKED AFTER 100 VISITS</div>

                        <form onSubmit={handleSubmit} className="w-56">
                            <input
                                type="password"
                                value={password}
                                onChange={(e) => setPassword(e.target.value)}
                                placeholder="ENTER PASSWORD"
                                className="w-full px-3 py-2 mb-3 bg-black border-2 border-yellow-800 text-yellow-500 font-mono text-sm placeholder-yellow-900 focus:outline-none focus:border-yellow-500"
                            />
                            <button
                                type="submit"
                                className="w-full px-3 py-2 bg-yellow-900 text-yellow-100 font-mono text-xs font-bold hover:bg-yellow-800 border-2 border-yellow-700"
                            >
                                DECRYPT
                            </button>
                        </form>

                        {message && (
                            <div className="mt-4 p-3 border border-yellow-800 bg-yellow-950 max-w-xs">
                                <div className="font-mono text-yellow-500 text-xs text-center">{message}</div>
                            </div>
                        )}

                        {attempts > 0 && (
                            <div className="mt-3 font-mono text-yellow-800 text-[10px]">
                                ATTEMPTS: {attempts}
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // --- PRIVATE.EXE - Password Protected (with DOG.TXT reveal when unlocked) ---
        const PersonalApp = ({ unlocked, onOpenDogStory }) => {
            const [password, setPassword] = useState('');
            const [attempts, setAttempts] = useState(0);
            const [error, setError] = useState('');
            const [shaking, setShaking] = useState(false);
            const [revealPhase, setRevealPhase] = useState(0); // 0: closed, 1: opening, 2: file approaching, 3: file revealed

            useEffect(() => {
                if (unlocked && revealPhase === 0) {
                    setRevealPhase(1);
                    setTimeout(() => setRevealPhase(2), 3000); // File starts appearing at 3s
                    setTimeout(() => setRevealPhase(3), 10000); // Fully revealed at 10s
                }
            }, [unlocked]);

            const handleSubmit = (e) => {
                e.preventDefault();
                setAttempts(a => a + 1);
                setShaking(true);
                setTimeout(() => setShaking(false), 500);

                const errors = [
                    'ACCESS DENIED',
                    'INVALID CREDENTIALS',
                    'AUTHENTICATION FAILED',
                    'PERMISSION DENIED',
                    'UNAUTHORIZED ACCESS',
                    'INCORRECT PASSWORD',
                    'SECURITY VIOLATION',
                    'ACCESS RESTRICTED',
                    'VERIFICATION FAILED',
                    'ENTRY PROHIBITED'
                ];
                setError(errors[Math.floor(Math.random() * errors.length)]);
                setPassword('');
            };

            // Unlocked reveal animation
            if (unlocked) {
                return (
                    <div className="h-full flex flex-col bg-white select-none overflow-hidden relative">
                        {/* Sliding panels - 10 second animation */}
                        <div
                            className="absolute top-0 left-0 right-0 bg-black z-10 flex items-end justify-center"
                            style={{
                                height: '50%',
                                transform: revealPhase >= 1 ? 'translateY(-100%)' : 'translateY(0)',
                                transition: 'transform 10s ease-in-out'
                            }}
                        >
                            <div className="font-mono text-red-500 text-xs mb-4">DECRYPTING...</div>
                        </div>
                        <div
                            className="absolute bottom-0 left-0 right-0 bg-black z-10 flex items-start justify-center"
                            style={{
                                height: '50%',
                                transform: revealPhase >= 1 ? 'translateY(100%)' : 'translateY(0)',
                                transition: 'transform 10s ease-in-out'
                            }}
                        >
                            <div className="font-mono text-red-500 text-xs mt-4">LOADING SECRETS...</div>
                        </div>

                        {/* DOG.TXT file - slowly grows and fades in */}
                        <div className="absolute inset-0 flex items-center justify-center">
                            <div
                                style={{
                                    transform: `scale(${revealPhase < 2 ? 0.2 : revealPhase < 3 ? 0.2 + ((revealPhase - 2) * 0.8) : 1})`,
                                    opacity: revealPhase < 2 ? 0 : revealPhase < 3 ? 0.3 : 1,
                                    transition: 'transform 7s ease-out, opacity 7s ease-out'
                                }}
                            >
                                <button
                                    onClick={() => onOpenDogStory?.()}
                                    className="text-center cursor-pointer group"
                                    disabled={revealPhase < 3}
                                    style={{ pointerEvents: revealPhase < 3 ? 'none' : 'auto' }}
                                >
                                    <div className="bg-white border-4 border-black p-6 group-hover:bg-yellow-50 transition-colors">
                                        <Icons.FileDoc size={64} />
                                    </div>
                                    <div className="font-mono text-black text-lg font-bold mt-4">DOG.TXT</div>
                                    <div className="font-mono text-gray-600 text-xs mt-2 group-hover:text-yellow-600" style={{ opacity: revealPhase >= 3 ? 1 : 0 }}>Click to open</div>
                                </button>
                            </div>
                        </div>
                    </div>
                );
            }

            return (
                <div className="h-full flex flex-col bg-black select-none">
                    <div className="p-2 border-b border-red-900 bg-black flex items-center gap-2">
                        <Icons.Lock size={16} />
                        <span className="font-mono text-xs font-bold text-red-500">PRIVATE.EXE</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-6">
                        <div className="mb-4">
                            <Icons.Lock size={48} />
                        </div>
                        <div className="font-mono text-red-500 text-sm font-bold mb-4">SECURE AREA</div>

                        <form onSubmit={handleSubmit} className={`w-56 ${shaking ? 'animate-shake' : ''}`}>
                            <input
                                type="password"
                                value={password}
                                onChange={(e) => setPassword(e.target.value)}
                                placeholder="PASSWORD"
                                className="w-full px-3 py-2 mb-3 bg-black border-2 border-red-800 text-red-500 font-mono text-sm placeholder-red-900 focus:outline-none focus:border-red-500"
                            />
                            <button
                                type="submit"
                                className="w-full px-3 py-2 bg-red-900 text-red-100 font-mono text-xs font-bold hover:bg-red-800 border-2 border-red-700"
                            >
                                AUTHENTICATE
                            </button>
                        </form>

                        {error && (
                            <div className="mt-4 p-2 border border-red-800 bg-red-950">
                                <div className="font-mono text-red-500 text-xs font-bold">{error}</div>
                            </div>
                        )}

                        {attempts > 0 && (
                            <div className="mt-3 font-mono text-red-800 text-[10px]">
                                FAILED: {attempts}
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // --- APPS Folder - Grid of all apps organized in folders ---
        const AppsFolder = ({ onOpenApp, onDragStart }) => {
            const [selectedFolder, setSelectedFolder] = useState(null);

            const folders = [
                { key: 'GAMES', name: 'GAMES', icon: 'GamesFolder' },
                { key: 'PRODUCTIVITY', name: 'PRODUCTIVITY', icon: 'ProductivityFolder' },
                { key: 'ABOUT', name: 'ABOUT', icon: 'AboutFolder' }
            ];

            const APP_CATEGORIES = {
                GAMES: [
                    { id: 'SNAKE', title: 'SNEK.EXE', icon: 'Snek' },
                    { id: 'LABYRINTH', title: 'LABYRINTH.EXE', icon: 'Labyrinth' },
                    { id: 'MINESWEEPER', title: 'MINESWEEPER.EXE', icon: 'Minesweeper' },
                    { id: 'STARSHIP', title: 'STARSHIP.EXE', icon: 'Starship' },
                    { id: 'DICE', title: 'DICE.EXE', icon: 'Dice' },
                    { id: 'WORDS', title: 'WORDS.EXE', icon: 'Words' }
                ],
                PRODUCTIVITY: [
                    { id: 'BROWSER', title: 'BROWSER.EXE', icon: 'Browser' },
                    { id: 'PAINT', title: 'PAINT.EXE', icon: 'Palette' },
                    { id: 'TERMINAL', title: 'TERMINAL.EXE', icon: 'Terminal' },
                    { id: 'THIRD_EYE', title: 'THIRD_EYE.EXE', icon: 'ThirdEye' },
                    { id: 'POMODORO', title: 'POMODORO.EXE', icon: 'Pomodoro' },
                    { id: 'SYNTH', title: 'SYNTH_001.WAV', icon: 'Synth' },
                    { id: 'RADIO', title: 'RADIO.WAV', icon: 'Radio' },
                    { id: 'SCANNER', title: 'SCANNER.EXE', icon: 'HealthScanner' },
                    { id: 'ORACLE', title: 'ORACLE.EXE', icon: 'Oracle' },
                    { id: 'TAROT', title: 'TAROT.DAT', icon: 'Tarot' },
                    { id: 'VOID', title: 'VOID.TXT', icon: 'Void' }
                ],
                ABOUT: [
                    { id: 'SYSTEM', title: 'ABOUT_SHORTCUT.EXE', icon: 'Terminal', isShortcut: true },
                    { id: 'GALLERY', title: 'GALLERY.EXE', icon: 'Gallery' },
                    { id: 'MAP', title: 'MAP.EXE', icon: 'Globe' },
                    { id: 'PERSONAL', title: 'PRIVATE.EXE', icon: 'Lock' },
                    { id: 'DESTRUCTION', title: 'DESTRUCTION.EXE', icon: 'Destruction' },
                    { id: 'TRASH', title: 'TRASH.BIN', icon: 'TrashCan' }
                ]
            };

            if (selectedFolder) {
                const FolderIcon = Icons[folders.find(f => f.key === selectedFolder)?.icon || 'FolderClosed'];
                const apps = APP_CATEGORIES[selectedFolder];
                return (
                    <div className="h-full flex flex-col bg-white select-none">
                        <div className="p-2 border-b-2 border-black bg-white flex items-center gap-3">
                            <button onClick={() => setSelectedFolder(null)} className="p-1 border-2 border-black hover:bg-black hover:text-white">
                                <Icons.Back size={16} />
                            </button>
                            <FolderIcon size={24} />
                            <span className="font-mono text-xs font-bold uppercase">{folders.find(f => f.key === selectedFolder)?.name}</span>
                            <span className="app-footer-text">({apps.length} ITEMS)</span>
                        </div>
                        <div className="flex-grow overflow-auto">
                            <table className="w-full text-left border-collapse">
                                <thead className="bg-black text-white text-xs font-mono sticky top-0">
                                    <tr><th className="p-2">NAME</th><th className="p-2 border-l border-gray-600">TYPE</th></tr>
                                </thead>
                                <tbody className="font-mono text-xs">
                                    {apps.map((app, idx) => {
                                        const AppIcon = Icons[app.icon];
                                        return (
                                            <tr key={idx}
                                                onClick={() => onOpenApp(app.id)}
                                                draggable
                                                onDragStart={(e) => onDragStart?.(e, app.id, app.title, app.icon)}
                                                className="border-b border-gray-200 hover:bg-yellow-100 cursor-grab active:cursor-grabbing"
                                            >
                                                <td className="p-2 font-bold flex items-center gap-2">
                                                    <AppIcon size={20} />
                                                    {app.title}
                                                    {app.isShortcut && <span className="text-[8px] text-gray-400 ml-1">(SHORTCUT)</span>}
                                                </td>
                                                <td className="p-2 border-l border-gray-200 text-gray-500">
                                                    {app.title.split('.').pop()}
                                                </td>
                                            </tr>
                                        );
                                    })}
                                </tbody>
                            </table>
                        </div>
                        <div className="app-footer">
                            <span className="app-footer-text">CLICK TO OPEN  DRAG TO DESKTOP</span>
                        </div>
                    </div>
                );
            }

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex items-center gap-2">
                        <Icons.Apps size={24} />
                        <span className="app-header-title">APPS</span>
                        <span className="app-footer-text">/ROOT/APPS</span>
                    </div>
                    <div className="flex-grow p-6 flex items-start justify-center bg-gray-50">
                        <div className="grid grid-cols-3 gap-8">
                            {folders.map(folder => {
                                const FolderIcon = Icons[folder.icon];
                                return (
                                    <button
                                        key={folder.key}
                                        onClick={() => setSelectedFolder(folder.key)}
                                        className="group flex flex-col items-center gap-2 p-4 hover:bg-white border-2 border-transparent hover:border-black transition-all"
                                    >
                                        <div className="bg-white border-2 border-black p-3 icon-shadow group-hover:translate-x-1 group-hover:translate-y-1 group-hover:shadow-none transition-all">
                                            <FolderIcon size={48} />
                                        </div>
                                        <span className="font-mono text-xs font-bold uppercase">{folder.name}</span>
                                        <span className="app-footer-text">{APP_CATEGORIES[folder.key].length} ITEMS</span>
                                    </button>
                                );
                            })}
                        </div>
                    </div>
                    <div className="app-footer">
                        <span className="app-footer-text">GAMES  PRODUCTIVITY  ABOUT</span>
                    </div>
                </div>
            );
        };

        // --- BROWSER - App search with autocomplete ---
        const BrowserApp = ({ onOpenApp }) => {
            const [url, setUrl] = useState('');
            const [showSuggestions, setShowSuggestions] = useState(false);

            // All searchable items (apps from all categories + desktop items)
            const allItems = [
                // Desktop items
                { id: 'SYSTEM', title: 'SYSTEM_INFO', icon: 'Terminal' },
                { id: 'FILES', title: 'MEDIA_LIB', icon: 'Folder' },
                { id: 'APPS', title: 'APPS', icon: 'Apps' },
                { id: 'CONTACT', title: 'CONTACT', icon: 'Email' },
                // Games
                { id: 'SNAKE', title: 'SNEK.EXE', icon: 'Snek' },
                { id: 'LABYRINTH', title: 'LABYRINTH.EXE', icon: 'Labyrinth' },
                { id: 'MINESWEEPER', title: 'MINESWEEPER.EXE', icon: 'Minesweeper' },
                { id: 'STARSHIP', title: 'STARSHIP.EXE', icon: 'Starship' },
                { id: 'DICE', title: 'DICE.EXE', icon: 'Dice' },
                { id: 'WORDS', title: 'WORDS.EXE', icon: 'Words' },
                // Productivity
                { id: 'PAINT', title: 'PAINT.EXE', icon: 'Palette' },
                { id: 'TERMINAL', title: 'TERMINAL.EXE', icon: 'Terminal' },
                { id: 'THIRD_EYE', title: 'THIRD_EYE.EXE', icon: 'ThirdEye' },
                { id: 'POMODORO', title: 'POMODORO.EXE', icon: 'Pomodoro' },
                { id: 'SYNTH', title: 'SYNTH_001.WAV', icon: 'Synth' },
                { id: 'RADIO', title: 'RADIO.WAV', icon: 'Radio' },
                { id: 'SCANNER', title: 'SCANNER.EXE', icon: 'HealthScanner' },
                { id: 'ORACLE', title: 'ORACLE.EXE', icon: 'Oracle' },
                { id: 'TAROT', title: 'TAROT.DAT', icon: 'Tarot' },
                { id: 'VOID', title: 'VOID.TXT', icon: 'Void' },
                { id: 'BROWSER', title: 'BROWSER.EXE', icon: 'Browser' },
                // About
                { id: 'GALLERY', title: 'GALLERY.EXE', icon: 'Gallery' },
                { id: 'MAP', title: 'MAP.EXE', icon: 'Globe' },
                { id: 'PERSONAL', title: 'PRIVATE.EXE', icon: 'Lock' },
                { id: 'DESTRUCTION', title: 'DESTRUCTION.EXE', icon: 'Destruction' },
                { id: 'TRASH', title: 'TRASH.BIN', icon: 'TrashCan' }
            ];

            const filteredItems = url.trim()
                ? allItems.filter(item =>
                    item.title.toLowerCase().includes(url.toLowerCase()) ||
                    item.id.toLowerCase().includes(url.toLowerCase())
                ).slice(0, 8)
                : [];

            const handleSubmit = (e) => {
                e.preventDefault();
                const normalized = url.toLowerCase().replace(/^https?:\/\//, '').replace(/\/$/, '');
                if (normalized === 'mateusmuste.com' || normalized === 'www.mateusmuste.com') {
                    window.location.reload();
                }
            };

            const handleSelect = (item) => {
                if (onOpenApp) onOpenApp(item.id);
                setUrl('');
                setShowSuggestions(false);
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    {/* Browser toolbar */}
                    <div className="p-2 border-b-2 border-black bg-gray-100 flex items-center gap-2">
                        <button className="p-1 border-2 border-black bg-white hover:bg-black hover:text-white" disabled>
                            <Icons.Back size={16} />
                        </button>
                        <form onSubmit={handleSubmit} className="flex-grow relative">
                            <input
                                type="text"
                                value={url}
                                onChange={(e) => { setUrl(e.target.value); setShowSuggestions(true); }}
                                onFocus={() => setShowSuggestions(true)}
                                onBlur={() => setTimeout(() => setShowSuggestions(false), 150)}
                                placeholder="Search apps or enter mateusmuste.com..."
                                className="w-full px-3 py-1 border-2 border-black font-mono text-sm focus:outline-none"
                            />
                            {showSuggestions && filteredItems.length > 0 && (
                                <div className="absolute top-full left-0 right-0 border-2 border-t-0 border-black bg-white z-50 max-h-64 overflow-y-auto">
                                    {filteredItems.map((item) => {
                                        const ItemIcon = Icons[item.icon] || Icons.FileDoc;
                                        return (
                                            <button
                                                key={item.id}
                                                onClick={() => handleSelect(item)}
                                                className="w-full px-3 py-2 flex items-center gap-2 hover:bg-black hover:text-white border-b border-gray-200 last:border-b-0"
                                            >
                                                <ItemIcon size={16} />
                                                <span className="font-mono text-xs">{item.title}</span>
                                            </button>
                                        );
                                    })}
                                </div>
                            )}
                        </form>
                    </div>
                    {/* Browser content */}
                    <div className="flex-grow flex flex-col items-center justify-center bg-gray-50 p-6">
                        <Icons.Browser size={64} />
                        <div className="font-mono text-lg font-bold mt-4 mb-2">MUSTE://BROWSER</div>
                        <div className="font-mono text-xs text-gray-500 text-center max-w-xs">
                            Search for apps by name or type "mateusmuste.com" to reboot the system
                        </div>
                    </div>
                    <div className="app-footer">
                        <span className="app-footer-text">SEARCH  NAVIGATE  DISCOVER</span>
                    </div>
                </div>
            );
        };

        // --- WORDS - Wordle clone ---
        const WordsApp = () => {
            const WORD_LIST = ['PIXEL', 'CODES', 'STACK', 'MOUSE', 'CLICK', 'BYTES', 'LOOPS', 'ARRAY', 'BLOCK', 'CACHE', 'DEBUG', 'FRAME', 'GRAPH', 'INPUT', 'LOGIC', 'PARSE', 'QUERY', 'SHELL', 'TABLE', 'VIRUS'];
            const [targetWord, setTargetWord] = useState(() => WORD_LIST[Math.floor(Math.random() * WORD_LIST.length)]);
            const [guesses, setGuesses] = useState([]);
            const [currentGuess, setCurrentGuess] = useState('');
            const [gameState, setGameState] = useState('playing'); // 'playing', 'won', 'lost'
            const [shake, setShake] = useState(false);
            const inputRef = useRef(null);

            const KEYBOARD_ROWS = [
                ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'],
                ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'],
                ['ENTER', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', '']
            ];

            const getLetterStatus = (letter, index, word) => {
                if (word[index] === letter) return 'correct';
                if (targetWord.includes(letter)) return 'present';
                return 'absent';
            };

            const getKeyStatus = (key) => {
                let status = 'unused';
                for (const guess of guesses) {
                    for (let i = 0; i < guess.length; i++) {
                        if (guess[i] === key) {
                            const letterStatus = getLetterStatus(key, i, guess);
                            if (letterStatus === 'correct') return 'correct';
                            if (letterStatus === 'present' && status !== 'correct') status = 'present';
                            if (letterStatus === 'absent' && status === 'unused') status = 'absent';
                        }
                    }
                }
                return status;
            };

            const handleKey = (key) => {
                if (gameState !== 'playing') return;

                if (key === 'ENTER') {
                    if (currentGuess.length !== 5) {
                        setShake(true);
                        setTimeout(() => setShake(false), 300);
                        return;
                    }
                    const newGuesses = [...guesses, currentGuess];
                    setGuesses(newGuesses);
                    if (currentGuess === targetWord) {
                        setGameState('won');
                        sounds.success();
                    } else if (newGuesses.length >= 6) {
                        setGameState('lost');
                        sounds.gameOver();
                    }
                    setCurrentGuess('');
                } else if (key === '') {
                    setCurrentGuess(prev => prev.slice(0, -1));
                } else if (currentGuess.length < 5 && /^[A-Z]$/.test(key)) {
                    setCurrentGuess(prev => prev + key);
                }
            };

            const resetGame = () => {
                setTargetWord(WORD_LIST[Math.floor(Math.random() * WORD_LIST.length)]);
                setGuesses([]);
                setCurrentGuess('');
                setGameState('playing');
            };

            // Keyboard handler
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.key === 'Enter') handleKey('ENTER');
                    else if (e.key === 'Backspace') handleKey('');
                    else if (/^[a-zA-Z]$/.test(e.key)) handleKey(e.key.toUpperCase());
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [currentGuess, gameState, guesses]);

            const statusColors = {
                correct: 'bg-black text-white',
                present: 'bg-gray-400 text-white',
                absent: 'bg-gray-200 text-gray-500',
                empty: 'bg-white border-2 border-black',
                unused: 'bg-white border-2 border-black hover:bg-gray-100'
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex items-center justify-between">
                        <div className="font-mono text-xs font-bold">WORDS.EXE</div>
                        <button onClick={resetGame} className="font-mono text-xs px-2 py-1 border-2 border-black hover:bg-black hover:text-white">
                            NEW GAME
                        </button>
                    </div>

                    {/* Game board */}
                    <div className="flex-grow flex flex-col items-center justify-center p-4 bg-gray-50">
                        <div className={`flex flex-col gap-1 ${shake ? 'animate-shake' : ''}`} style={{animation: shake ? 'shake 0.3s ease' : 'none'}}>
                            {[...Array(6)].map((_, rowIndex) => {
                                const guess = guesses[rowIndex];
                                const isCurrentRow = rowIndex === guesses.length;
                                return (
                                    <div key={rowIndex} className="flex gap-1">
                                        {[...Array(5)].map((_, colIndex) => {
                                            let letter = '';
                                            let status = 'empty';

                                            if (guess) {
                                                letter = guess[colIndex];
                                                status = getLetterStatus(letter, colIndex, guess);
                                            } else if (isCurrentRow && currentGuess[colIndex]) {
                                                letter = currentGuess[colIndex];
                                            }

                                            return (
                                                <div
                                                    key={colIndex}
                                                    className={`w-10 h-10 flex items-center justify-center font-mono text-lg font-bold ${statusColors[status]}`}
                                                >
                                                    {letter}
                                                </div>
                                            );
                                        })}
                                    </div>
                                );
                            })}
                        </div>

                        {/* Game over message */}
                        {gameState !== 'playing' && (
                            <div className="mt-4 text-center">
                                <div className="font-mono text-sm font-bold">
                                    {gameState === 'won' ? ' YOU WIN!' : `GAME OVER - WORD: ${targetWord}`}
                                </div>
                            </div>
                        )}
                    </div>

                    {/* Keyboard */}
                    <div className="p-2 bg-white border-t-2 border-black">
                        {KEYBOARD_ROWS.map((row, rowIndex) => (
                            <div key={rowIndex} className="flex justify-center gap-1 mb-1">
                                {row.map((key) => {
                                    const keyStatus = key.length === 1 ? getKeyStatus(key) : 'unused';
                                    return (
                                        <button
                                            key={key}
                                            onClick={() => handleKey(key)}
                                            className={`${key.length > 1 ? 'px-2' : 'w-7'} h-9 font-mono text-xs font-bold ${statusColors[keyStatus]}`}
                                        >
                                            {key}
                                        </button>
                                    );
                                })}
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        // --- CONTACT - Simple email contact ---
        const ContactApp = () => {
            const [copied, setCopied] = useState(false);
            const email = 'mateusmuste9@gmail.com';

            const copyEmail = () => {
                navigator.clipboard.writeText(email);
                setCopied(true);
                setTimeout(() => setCopied(false), 2000);
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="flex-grow flex flex-col items-center justify-center bg-gray-50 p-6">
                        <Icons.Email size={48} />
                        <div className="font-mono text-lg font-bold mt-4 mb-1">GET IN TOUCH</div>
                        <div className="font-mono text-xs text-gray-500 mb-4">{email}</div>
                        <div className="flex gap-2">
                            <button onClick={copyEmail} className="btn-primary">
                                {copied ? 'COPIED!' : 'COPY EMAIL'}
                            </button>
                            <a href={`mailto:${email}`} className="btn-primary">
                                OPEN MAIL
                            </a>
                        </div>
                    </div>
                </div>
            );
        };

        // --- OS SHELL ---

        const OS = () => {
            const [booted, setBooted] = useState(false);
            const [bootPhase, setBootPhase] = useState(0); // 0: mobile notice (mobile only), 1: kernel, 2: ready
            const [isMobile, setIsMobile] = useState(false);
            const [topZ, setTopZ] = useState(100);
            const topZRef = useRef(100);
            const [destructionMode, setDestructionMode] = useState(false);
            const [dogReleased, setDogReleased] = useState(false);
            const [dogPos, setDogPos] = useState({ x: 100, y: 300 });
            const [dogFacingRight, setDogFacingRight] = useState(true);
            const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
            const [carriedIcon, setCarriedIcon] = useState(null);
            const [iconPositions, setIconPositions] = useState(() => {
                // Initialize desktop icon positions in a column on the left
                const stored = localStorage.getItem('desktop_icon_positions');
                if (stored) {
                    try { return JSON.parse(stored); } catch { }
                }
                return {
                    SYSTEM: { x: 16, y: 16 },
                    FILES: { x: 16, y: 110 },
                    APPS: { x: 16, y: 204 },
                    CONTACT: { x: 16, y: 298 },
                    TRUTH: { x: 16, y: 392 }
                };
            });
            const [iconDrag, setIconDrag] = useState({ id: null, offsetX: 0, offsetY: 0, active: false });
            const iconPhysics = useRef({});
            const lastIconMousePos = useRef({ x: 0, y: 0, time: Date.now() });
            const iconHoldTimer = useRef(null);
            const iconPendingDrag = useRef(null); // Stores pending drag info before hold completes
            const [folderDrag, setFolderDrag] = useState(null); // { id, title, icon, startX, startY }
            const [extraDesktopIcons, setExtraDesktopIcons] = useState(() => {
                const stored = localStorage.getItem('extra_desktop_icons');
                return stored ? JSON.parse(stored) : [];
            });
            const [destructionDogGone, setDestructionDogGone] = useState(false);
            const [matrixMode, setMatrixMode] = useState(false);
            const [privateUnlocked, setPrivateUnlocked] = useState(false);
            const [stackOverflow, setStackOverflow] = useState(false);
            const [stackErrors, setStackErrors] = useState([]);
            const [pyramidScreen, setPyramidScreen] = useState(false);
            const stackTimerRef = useRef(null);
            const [goldDogReleased, setGoldDogReleased] = useState(false);
            const [goldDogVisible, setGoldDogVisible] = useState(true);
            const [goldDogPos, setGoldDogPos] = useState({ x: 200, y: 200 });
            const [goldDogFacingRight, setGoldDogFacingRight] = useState(false);
            const goldDogVelRef = useRef({ x: -3, y: 4 });
            const [visitCount, setVisitCount] = useState(() => {
                const stored = localStorage.getItem('ultra_int_visits');
                const count = stored ? parseInt(stored, 10) + 1 : 1;
                localStorage.setItem('ultra_int_visits', count.toString());
                return count;
            });
            const truthUnlocked = visitCount >= 100;

            // Current usage - exponential distribution favoring lower percentages
            const [currentUsage, setCurrentUsage] = useState(() => {
                // Exponential distribution: higher percentages exponentially less likely
                const rand = Math.random();
                // Use inverse exponential: -ln(rand) scaled to 5.0-100.0
                // Lower values much more likely than higher
                const exp = -Math.log(rand) * 15; // Scale factor
                const percentage = 5.0 + Math.min(95.0, exp);
                return Math.round(percentage * 10) / 10; // Round to 1 decimal
            });

            // Total visitors counter (using CountAPI)
            const [totalVisitors, setTotalVisitors] = useState(null);

            // Fetch and increment total visitors
            useEffect(() => {
                fetch('https://api.countapi.xyz/hit/mateusmuste-com/visits')
                    .then(res => res.json())
                    .then(data => setTotalVisitors(data.value))
                    .catch(() => {
                        // Fallback to localStorage estimate
                        const stored = parseInt(localStorage.getItem('visitor_estimate') || '340', 10);
                        const newCount = stored + Math.floor(Math.random() * 3);
                        localStorage.setItem('visitor_estimate', newCount.toString());
                        setTotalVisitors(newCount);
                    });
            }, []);

            // Random fluctuation of current usage every second
            useEffect(() => {
                const interval = setInterval(() => {
                    if (Math.random() < 0.5) { // 50% chance each second
                        setCurrentUsage(prev => {
                            const change = Math.random() < 0.5 ? -0.1 : 0.1;
                            const newVal = Math.round((prev + change) * 10) / 10;
                            return Math.min(100.0, Math.max(5.0, newVal));
                        });
                    }
                }, 1000);
                return () => clearInterval(interval);
            }, []);

            const toggleMatrixMode = () => setMatrixMode(prev => !prev);
            const unlockPrivate = () => setPrivateUnlocked(true);
            const openDogStory = () => {
                setDogReleased(true);
                setGoldDogReleased(true);
                setWindows(prev => ({
                    ...prev,
                    DOG_STORY: { ...prev.DOG_STORY, isOpen: true }
                }));
            };
            const removeGoldDog = () => setGoldDogVisible(false);

            // Handle dog stealing the destruction button - dog starts running around!
            const handleDogSteal = () => {
                setDestructionDogGone(true);
                setDogReleased(true); // Dog starts running around the screen
                // Close the destruction window
                setWindows(prev => ({
                    ...prev,
                    DESTRUCTION: { ...prev.DESTRUCTION, isOpen: false }
                }));
            };

            // Dog AI - DVD logo style bouncing (uses refs to avoid stale closures)
            const dogVelRef = useRef({ x: 4, y: 3 });

            useEffect(() => {
                if (!dogReleased) return;

                const dogInterval = setInterval(() => {
                    const vel = dogVelRef.current;

                    setDogPos(prev => {
                        let newX = prev.x + vel.x;
                        let newY = prev.y + vel.y;

                        // Bounce off walls - DVD style
                        if (newX >= window.innerWidth - 80) {
                            newX = window.innerWidth - 80;
                            dogVelRef.current.x = -Math.abs(vel.x);
                            setDogFacingRight(false);
                        }
                        if (newX <= 0) {
                            newX = 0;
                            dogVelRef.current.x = Math.abs(vel.x);
                            setDogFacingRight(true);
                        }
                        if (newY >= window.innerHeight - 100) {
                            newY = window.innerHeight - 100;
                            dogVelRef.current.y = -Math.abs(vel.y);
                        }
                        if (newY <= 60) {
                            newY = 60;
                            dogVelRef.current.y = Math.abs(vel.y);
                        }

                        return { x: newX, y: newY };
                    });

                    // Randomly grab icons
                    if (!carriedIcon && Math.random() < 0.003) {
                        const iconKeys = Object.keys(windows);
                        const randomIcon = iconKeys[Math.floor(Math.random() * iconKeys.length)];
                        setCarriedIcon(randomIcon);

                        setTimeout(() => {
                            setCarriedIcon(null);
                        }, 3000 + Math.random() * 4000);
                    }
                }, 30);

                return () => clearInterval(dogInterval);
            }, [dogReleased]);

            // Gold dog bouncing logic
            useEffect(() => {
                if (!goldDogReleased || !goldDogVisible) return;

                const goldDogInterval = setInterval(() => {
                    setGoldDogPos(prev => {
                        const vel = goldDogVelRef.current;
                        let newX = prev.x + vel.x;
                        let newY = prev.y + vel.y;

                        if (newX >= window.innerWidth - 80) {
                            newX = window.innerWidth - 80;
                            goldDogVelRef.current.x = -Math.abs(vel.x);
                            setGoldDogFacingRight(false);
                        }
                        if (newX <= 0) {
                            newX = 0;
                            goldDogVelRef.current.x = Math.abs(vel.x);
                            setGoldDogFacingRight(true);
                        }
                        if (newY >= window.innerHeight - 100) {
                            newY = window.innerHeight - 100;
                            goldDogVelRef.current.y = -Math.abs(vel.y);
                        }
                        if (newY <= 60) {
                            newY = 60;
                            goldDogVelRef.current.y = Math.abs(vel.y);
                        }

                        return { x: newX, y: newY };
                    });
                }, 30);

                return () => clearInterval(goldDogInterval);
            }, [goldDogReleased, goldDogVisible]);

            // Desktop icons - only show main folders (plus TRUTH if unlocked at 100 visits)
            const desktopIcons = truthUnlocked
                ? ["SYSTEM", "FILES", "APPS", "CONTACT", "TRUTH"]
                : ["SYSTEM", "FILES", "APPS", "CONTACT"];

            // Window State (Position x/y added for dragging) - content rendered separately
            const [windows, setWindows] = useState({
                "SYSTEM": { id: "SYSTEM", title: "SYSTEM_INFO", icon: "Terminal", x: 400, y: 50, w: '1000px', h: '800px', isOpen: true, isMin: false, z: 10, isDesktop: true },
                "FILES": { id: "FILES", title: "MEDIA_LIB", icon: "Folder", x: 100, y: 80, w: '800px', h: '500px', isOpen: false, isMin: false, z: 11, isDesktop: true },
                "APPS": { id: "APPS", title: "APPS", icon: "Apps", x: 150, y: 110, w: '700px', h: '500px', isOpen: false, isMin: false, z: 12, isDesktop: true },
                "CONTACT": { id: "CONTACT", title: "CONTACT", icon: "Email", x: 200, y: 140, w: '320px', h: '220px', isOpen: false, isMin: false, z: 13, isDesktop: true },
                "PAINT": { id: "PAINT", title: "PAINT.EXE", icon: "Palette", x: 150, y: 110, w: '700px', h: '600px', isOpen: false, isMin: false, z: 14 },
                "SNAKE": { id: "SNAKE", title: "SNEK.EXE", icon: "Snek", x: 200, y: 140, w: '640px', h: '520px', isOpen: false, isMin: false, z: 15 },
                "TRASH": { id: "TRASH", title: "TRASH.BIN", icon: "TrashCan", x: 250, y: 170, w: '500px', h: '400px', isOpen: false, isMin: false, z: 16 },
                "VOID": { id: "VOID", title: "VOID.TXT", icon: "Void", x: 300, y: 50, w: '500px', h: '400px', isOpen: false, isMin: false, z: 17 },
                "ORACLE": { id: "ORACLE", title: "ORACLE.EXE", icon: "Oracle", x: 350, y: 80, w: '500px', h: '450px', isOpen: false, isMin: false, z: 18 },
                "RADIO": { id: "RADIO", title: "RADIO.WAV", icon: "Radio", x: 400, y: 110, w: '400px', h: '400px', isOpen: false, isMin: false, z: 19 },
                "DICE": { id: "DICE", title: "DICE.EXE", icon: "Dice", x: 450, y: 140, w: '350px', h: '450px', isOpen: false, isMin: false, z: 20 },
                "LABYRINTH": { id: "LABYRINTH", title: "LABYRINTH.EXE", icon: "Labyrinth", x: 100, y: 50, w: '600px', h: '500px', isOpen: false, isMin: false, z: 21 },
                "MINESWEEPER": { id: "MINESWEEPER", title: "MINESWEEPER.EXE", icon: "Minesweeper", x: 120, y: 40, w: '500px', h: '560px', isOpen: false, isMin: false, z: 26 },
                "STARSHIP": { id: "STARSHIP", title: "STARSHIP.EXE", icon: "Starship", x: 80, y: 40, w: '540px', h: '480px', isOpen: false, isMin: false, z: 27 },
                "SYNTH": { id: "SYNTH", title: "SYNTH_001.WAV", icon: "Synth", x: 150, y: 80, w: '500px', h: '350px', isOpen: false, isMin: false, z: 22 },
                "DESTRUCTION": { id: "DESTRUCTION", title: "DESTRUCTION.EXE", icon: "Destruction", x: 200, y: 110, w: '400px', h: '400px', isOpen: false, isMin: false, z: 23 },
                "TAROT": { id: "TAROT", title: "TAROT.DAT", icon: "Tarot", x: 100, y: 60, w: '520px', h: '550px', isOpen: false, isMin: false, z: 24 },
                "GALLERY": { id: "GALLERY", title: "GALLERY.EXE", icon: "Gallery", x: 100, y: 80, w: '500px', h: '500px', isOpen: false, isMin: false, z: 28 },
                "MAP": { id: "MAP", title: "MAP.EXE", icon: "Globe", x: 150, y: 100, w: '360px', h: '400px', isOpen: false, isMin: false, z: 29 },
                "POMODORO": { id: "POMODORO", title: "POMODORO.EXE", icon: "Pomodoro", x: 200, y: 60, w: '350px', h: '620px', isOpen: false, isMin: false, z: 30 },
                "SCANNER": { id: "SCANNER", title: "SCANNER.EXE", icon: "HealthScanner", x: 150, y: 50, w: '600px', h: '700px', isOpen: false, isMin: false, z: 31 },
                "PERSONAL": { id: "PERSONAL", title: "PRIVATE.EXE", icon: "Lock", x: 200, y: 80, w: '320px', h: '340px', isOpen: false, isMin: false, z: 32 },
                "TERMINAL": { id: "TERMINAL", title: "TERMINAL.EXE", icon: "Terminal", x: 120, y: 100, w: '500px', h: '400px', isOpen: false, isMin: false, z: 33 },
                "TRUTH": { id: "TRUTH", title: "TRUTH.TXT", icon: "FileDoc", x: 180, y: 120, w: '320px', h: '380px', isOpen: false, isMin: false, z: 34, isDesktop: true },
                "DOG_STORY": { id: "DOG_STORY", title: "DOG.TXT", icon: "FileDoc", x: 100, y: 80, w: '600px', h: '500px', isOpen: false, isMin: false, z: 35 },
                "THIRD_EYE": { id: "THIRD_EYE", title: "THIRD_EYE.EXE", icon: "ThirdEye", x: 140, y: 90, w: '450px', h: '400px', isOpen: false, isMin: false, z: 36 },
                "THIRD_EYE_2": { id: "THIRD_EYE_2", title: "THIRD_EYE.EXE", icon: "ThirdEye", x: 200, y: 150, w: '450px', h: '400px', isOpen: false, isMin: false, z: 37 },
                "BROWSER": { id: "BROWSER", title: "BROWSER.EXE", icon: "Browser", x: 160, y: 70, w: '500px', h: '400px', isOpen: false, isMin: false, z: 38 },
                "WORDS": { id: "WORDS", title: "WORDS.EXE", icon: "Words", x: 180, y: 90, w: '320px', h: '520px', isOpen: false, isMin: false, z: 39 }
            });

            // Render window content based on ID
            const getWindowContent = (id) => {
                switch (id) {
                    case "SYSTEM": return <SystemInfo onMatrixMode={toggleMatrixMode} totalVisitors={totalVisitors} />;
                    case "FILES": return <FileExplorer />;
                    case "APPS": return <AppsFolder onOpenApp={open} onDragStart={handleFolderDragStart} />;
                    case "CONTACT": return <ContactApp />;
                    case "PAINT": return <PaintApp />;
                    case "SNAKE": return <SnakeAppNew />;
                    case "TRASH": return <TrashApp />;
                    case "VOID": return <VoidApp />;
                    case "ORACLE": return <OracleApp />;
                    case "RADIO": return <RadioApp />;
                    case "DICE": return <DiceApp />;
                    case "LABYRINTH": return <LabyrinthApp />;
                    case "MINESWEEPER": return <MinesweeperApp />;
                    case "STARSHIP": return <StarshipApp />;
                    case "SYNTH": return <SynthApp />;
                    case "DESTRUCTION": return <DestructionApp onDogSteal={handleDogSteal} />;
                    case "TAROT": return <TarotApp />;
                    case "GALLERY": return <GalleryApp />;
                    case "MAP": return <MapApp />;
                    case "POMODORO": return <PomodoroApp />;
                    case "SCANNER": return <HealthScannerApp />;
                    case "PERSONAL": return <PersonalApp unlocked={privateUnlocked} onOpenDogStory={openDogStory} />;
                    case "TERMINAL": return <TerminalApp onClose={close} onOpenApp={open} onReleaseDog={() => setDogReleased(true)} onMatrixMode={toggleMatrixMode} onUnlockPrivate={unlockPrivate} />;
                    case "TRUTH": return <TruthApp />;
                    case "DOG_STORY": return <DogStoryTerminal onRemoveGoldDog={removeGoldDog} />;
                    case "THIRD_EYE": return <ThirdEyeApp windows={windows} stackOverflow={stackOverflow} stackErrors={stackErrors} />;
                    case "THIRD_EYE_2": return <ThirdEyeApp windows={windows} stackOverflow={stackOverflow} stackErrors={stackErrors} />;
                    case "BROWSER": return <BrowserApp onOpenApp={open} />;
                    case "WORDS": return <WordsApp />;
                    default: return null;
                }
            };

            // Dragging State with Physics
            const [drag, setDrag] = useState({ id: null, offsetX: 0, offsetY: 0 });
            const lastMousePos = useRef({ x: 0, y: 0, time: Date.now() });
            const windowPhysics = useRef({}); // { windowId: { velX, velY, scaleX, scaleY } }

            // Physics constants
            const FRICTION = 0.95; // Velocity decay per frame (ice-like, slightly reduced friction)
            const BOUNCE_DAMPING = 0.6; // Energy loss on bounce
            const MIN_VELOCITY = 0.25; // Stop threshold (reduced for smoother stops)
            const EDGE_MAGNET_DISTANCE = 30; // Pixels for edge attraction
            const EDGE_MAGNET_STRENGTH = 0.15; // Pull strength
            const SQUASH_AMOUNT = 0.02; // 2% max squash/stretch

            // Initialize physics for a window
            const initWindowPhysics = (id) => {
                if (!windowPhysics.current[id]) {
                    windowPhysics.current[id] = { velX: 0, velY: 0, scaleX: 1, scaleY: 1 };
                }
                return windowPhysics.current[id];
            };

            // Physics loop
            useEffect(() => {
                let animationId;
                const physicsLoop = () => {
                    setWindows(prev => {
                        let updated = { ...prev };
                        let hasChanges = false;

                        Object.keys(prev).forEach(id => {
                            const win = prev[id];
                            if (!win.isOpen || win.isMin) return;

                            const physics = initWindowPhysics(id);

                            // Skip if being dragged
                            if (drag.id === id) return;

                            // Skip if no significant velocity
                            if (Math.abs(physics.velX) < MIN_VELOCITY && Math.abs(physics.velY) < MIN_VELOCITY) {
                                physics.velX = 0;
                                physics.velY = 0;
                                // Decay squash/stretch back to normal
                                physics.scaleX += (1 - physics.scaleX) * 0.2;
                                physics.scaleY += (1 - physics.scaleY) * 0.2;
                                return;
                            }

                            hasChanges = true;

                            // Apply friction
                            physics.velX *= FRICTION;
                            physics.velY *= FRICTION;

                            // Calculate new position
                            let newX = win.x + physics.velX;
                            let newY = win.y + physics.velY;

                            const winWidth = parseInt(win.w) || 400;
                            const winHeight = parseInt(win.h) || 300;
                            const maxX = window.innerWidth - winWidth;
                            const maxY = window.innerHeight - 60 - winHeight; // Account for taskbar
                            const minY = isMobile ? 60 : 0; // Account for mobile top taskbar

                            // Edge magnetism (only when slow enough)
                            const totalVel = Math.sqrt(physics.velX ** 2 + physics.velY ** 2);
                            if (totalVel < 5) {
                                // Left edge
                                if (newX < EDGE_MAGNET_DISTANCE && newX > 0) {
                                    physics.velX -= newX * EDGE_MAGNET_STRENGTH;
                                }
                                // Right edge
                                if (newX > maxX - EDGE_MAGNET_DISTANCE && newX < maxX) {
                                    physics.velX += (maxX - newX) * EDGE_MAGNET_STRENGTH;
                                }
                                // Top edge
                                if (newY < minY + EDGE_MAGNET_DISTANCE && newY > minY) {
                                    physics.velY -= (newY - minY) * EDGE_MAGNET_STRENGTH;
                                }
                                // Bottom edge
                                if (newY > maxY - EDGE_MAGNET_DISTANCE && newY < maxY) {
                                    physics.velY += (maxY - newY) * EDGE_MAGNET_STRENGTH;
                                }
                            }

                            // Bounce off edges with squash/stretch
                            if (newX <= 0) {
                                newX = 0;
                                physics.velX = -physics.velX * BOUNCE_DAMPING;
                                physics.scaleX = 1 - SQUASH_AMOUNT * Math.min(Math.abs(physics.velX) / 10, 1);
                                physics.scaleY = 1 + SQUASH_AMOUNT * Math.min(Math.abs(physics.velX) / 10, 1);
                                sounds.bounce(Math.abs(physics.velX));
                            } else if (newX >= maxX) {
                                newX = maxX;
                                physics.velX = -physics.velX * BOUNCE_DAMPING;
                                physics.scaleX = 1 - SQUASH_AMOUNT * Math.min(Math.abs(physics.velX) / 10, 1);
                                physics.scaleY = 1 + SQUASH_AMOUNT * Math.min(Math.abs(physics.velX) / 10, 1);
                                sounds.bounce(Math.abs(physics.velX));
                            }

                            if (newY <= minY) {
                                newY = minY;
                                physics.velY = -physics.velY * BOUNCE_DAMPING;
                                physics.scaleY = 1 - SQUASH_AMOUNT * Math.min(Math.abs(physics.velY) / 10, 1);
                                physics.scaleX = 1 + SQUASH_AMOUNT * Math.min(Math.abs(physics.velY) / 10, 1);
                                sounds.bounce(Math.abs(physics.velY));
                            } else if (newY >= maxY) {
                                newY = maxY;
                                physics.velY = -physics.velY * BOUNCE_DAMPING;
                                physics.scaleY = 1 - SQUASH_AMOUNT * Math.min(Math.abs(physics.velY) / 10, 1);
                                physics.scaleX = 1 + SQUASH_AMOUNT * Math.min(Math.abs(physics.velY) / 10, 1);
                                sounds.bounce(Math.abs(physics.velY));
                            }

                            // Decay squash/stretch back to normal
                            physics.scaleX += (1 - physics.scaleX) * 0.3;
                            physics.scaleY += (1 - physics.scaleY) * 0.3;

                            updated[id] = { ...win, x: newX, y: newY };
                        });

                        return hasChanges ? updated : prev;
                    });

                    animationId = requestAnimationFrame(physicsLoop);
                };

                animationId = requestAnimationFrame(physicsLoop);
                return () => cancelAnimationFrame(animationId);
            }, [drag.id, isMobile]);

            // Boot sequence with mobile detection
            useEffect(() => {
                const checkMobile = window.innerWidth < 768 || /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                setIsMobile(checkMobile);

                // Close SYSTEM window on mobile by default
                if (checkMobile) {
                    setWindows(prev => ({
                        ...prev,
                        SYSTEM: { ...prev.SYSTEM, isOpen: false }
                    }));
                }

                // Preload all pixelarticons during boot
                const iconNames = [
                    'monitor', 'folder', 'fill', 'gamepad', 'trash', 'undo', 'redo', 'file',
                    'close', 'minus', 'checkbox', 'send', 'movie', 'book', 'music', 'arrow-left',
                    'code', 'book-open', 'radio-on', 'dice', 'layout-rows', 'table', 'arrow-up',
                    'keyboard', 'power', 'card', 'paw', 'mail', 'add-grid', 'image', 'map',
                    'clock', 'heart', 'lock', 'sliders', 'user'
                ];
                iconNames.forEach(name => {
                    const img = new Image();
                    img.src = `https://unpkg.com/pixelarticons@1.8.1/svg/${name}.svg`;
                });

                if (checkMobile) {
                    // Mobile: Show "best on desktop" notice first, then kernel boot
                    setBootPhase(0);
                    setTimeout(() => {
                        setBootPhase(1); // kernel boot
                        setTimeout(() => {
                            setBootPhase(2);
                            setBooted(true);
                        }, 2000);
                    }, 2000);
                } else {
                    // Desktop: Go straight to kernel boot
                    setBootPhase(1);
                    setTimeout(() => {
                        setBootPhase(2);
                        setBooted(true);
                    }, 2000);
                }

                // Handle resize
                const handleResize = () => {
                    setIsMobile(window.innerWidth < 768);
                };
                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, []);

            // Window Ops
            const focus = (id) => {
                topZRef.current += 1;
                const newZ = topZRef.current;
                setWindows(p => ({ ...p, [id]: { ...p[id], z: newZ } }));
                setTopZ(newZ);
            }
            const open = (id) => {
                sounds.windowOpen();
                topZRef.current += 1;
                const newZ = topZRef.current;
                // THIRD_EYE can open multiple copies
                if (id === 'THIRD_EYE') {
                    setWindows(p => {
                        if (p.THIRD_EYE.isOpen && !p.THIRD_EYE.isMin) {
                            // First is open, open second
                            return { ...p, THIRD_EYE_2: { ...p.THIRD_EYE_2, isOpen: true, isMin: false, z: newZ } };
                        }
                        return { ...p, THIRD_EYE: { ...p.THIRD_EYE, isOpen: true, isMin: false, z: newZ } };
                    });
                } else {
                    setWindows(p => ({ ...p, [id]: { ...p[id], isOpen: true, isMin: false, z: newZ } }));
                }
                setTopZ(newZ);
            }
            const close = (id) => {
                sounds.windowClose();
                setWindows(p => ({ ...p, [id]: { ...p[id], isOpen: false } }));
            };
            const toggleMin = (id) => setWindows(p => ({ ...p, [id]: { ...p[id], isMin: !p[id].isMin } }));

            // Drag Handlers with velocity tracking
            const handleMouseDown = (e, id) => {
                e.preventDefault();
                focus(id);
                const win = windows[id];
                const physics = initWindowPhysics(id);
                // Stop any existing velocity
                physics.velX = 0;
                physics.velY = 0;
                lastMousePos.current = { x: e.clientX, y: e.clientY, time: Date.now() };
                setDrag({
                    id: id,
                    offsetX: e.clientX - win.x,
                    offsetY: e.clientY - win.y
                });
            };

            const handleMouseMove = (e) => {
                if (drag.id) {
                    const now = Date.now();
                    const dt = Math.max(1, now - lastMousePos.current.time);
                    const physics = initWindowPhysics(drag.id);

                    // Calculate velocity from mouse movement (smoothed)
                    const rawVelX = (e.clientX - lastMousePos.current.x) / dt * 8;
                    const rawVelY = (e.clientY - lastMousePos.current.y) / dt * 8;
                    physics.velX = physics.velX * 0.5 + rawVelX * 0.5; // Smooth velocity
                    physics.velY = physics.velY * 0.5 + rawVelY * 0.5;

                    lastMousePos.current = { x: e.clientX, y: e.clientY, time: now };

                    setWindows(prev => {
                        const win = prev[drag.id];
                        const winWidth = parseInt(win.w) || 400;
                        const winHeight = parseInt(win.h) || 300;
                        const maxX = window.innerWidth - winWidth;
                        const maxY = window.innerHeight - 60 - winHeight; // Account for taskbar
                        const minY = isMobile ? 60 : 0;

                        // Clamp position to screen bounds
                        const newX = Math.max(0, Math.min(maxX, e.clientX - drag.offsetX));
                        const newY = Math.max(minY, Math.min(maxY, e.clientY - drag.offsetY));

                        return {
                            ...prev,
                            [drag.id]: {
                                ...win,
                                x: newX,
                                y: newY
                            }
                        };
                    });
                }
            };

            const handleMouseUp = () => {
                // Keep velocity for physics, just release the drag
                setDrag({ id: null, offsetX: 0, offsetY: 0 });
            };

            // === ICON PHYSICS AND DRAG HANDLERS ===
            const ICON_SIZE = 80; // Approximate icon size for collision
            const ICON_SPACING = 10; // Minimum spacing between icons

            const initIconPhysics = (id) => {
                if (!iconPhysics.current[id]) {
                    iconPhysics.current[id] = { velX: 0, velY: 0 };
                }
                return iconPhysics.current[id];
            };

            // Check if position collides with other icons
            const checkIconCollision = (id, x, y, positions) => {
                for (const otherId in positions) {
                    if (otherId === id) continue;
                    const other = positions[otherId];
                    const dx = Math.abs(x - other.x);
                    const dy = Math.abs(y - other.y);
                    if (dx < ICON_SIZE + ICON_SPACING && dy < ICON_SIZE + ICON_SPACING) {
                        return otherId; // Return colliding icon id
                    }
                }
                return null;
            };

            // Find nearest non-colliding position
            const findNonCollidingPosition = (id, x, y, positions) => {
                if (!checkIconCollision(id, x, y, positions)) return { x, y };

                // Spiral outward to find free spot
                for (let radius = ICON_SIZE; radius < 500; radius += ICON_SIZE / 2) {
                    for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                        const testX = x + Math.cos(angle) * radius;
                        const testY = y + Math.sin(angle) * radius;
                        if (!checkIconCollision(id, testX, testY, positions)) {
                            return { x: testX, y: testY };
                        }
                    }
                }
                return { x, y }; // Fallback
            };

            const handleIconMouseDown = (e, id) => {
                e.preventDefault();
                e.stopPropagation();
                const pos = iconPositions[id] || { x: 0, y: 0 };
                const physics = initIconPhysics(id);
                physics.velX = 0;
                physics.velY = 0;
                lastIconMousePos.current = { x: e.clientX, y: e.clientY, time: Date.now() };

                // Store pending drag info
                iconPendingDrag.current = {
                    id: id,
                    offsetX: e.clientX - pos.x,
                    offsetY: e.clientY - pos.y,
                    startX: e.clientX,
                    startY: e.clientY
                };

                // Start hold timer - drag only activates after 0.1 seconds
                iconHoldTimer.current = setTimeout(() => {
                    if (iconPendingDrag.current) {
                        sounds.dragStart();
                        setIconDrag({
                            id: iconPendingDrag.current.id,
                            offsetX: iconPendingDrag.current.offsetX,
                            offsetY: iconPendingDrag.current.offsetY,
                            active: true
                        });
                    }
                }, 100);
            };

            const handleIconMouseMove = (e) => {
                if (iconDrag.active && iconDrag.id) {
                    const now = Date.now();
                    const dt = Math.max(1, now - lastIconMousePos.current.time);
                    const physics = initIconPhysics(iconDrag.id);

                    const rawVelX = (e.clientX - lastIconMousePos.current.x) / dt * 8;
                    const rawVelY = (e.clientY - lastIconMousePos.current.y) / dt * 8;
                    physics.velX = physics.velX * 0.3 + rawVelX * 0.7; // Less momentum carry
                    physics.velY = physics.velY * 0.3 + rawVelY * 0.7;

                    lastIconMousePos.current = { x: e.clientX, y: e.clientY, time: now };

                    // Constrain to screen bounds
                    const maxX = window.innerWidth - ICON_SIZE;
                    const maxY = window.innerHeight - 60 - ICON_SIZE; // Account for taskbar
                    const minY = isMobile ? 80 : 0;

                    const newX = Math.max(0, Math.min(maxX, e.clientX - iconDrag.offsetX));
                    const newY = Math.max(minY, Math.min(maxY, e.clientY - iconDrag.offsetY));

                    setIconPositions(prev => ({
                        ...prev,
                        [iconDrag.id]: { x: newX, y: newY }
                    }));
                }
            };

            const handleIconMouseUp = (openCallback) => {
                // Clear hold timer
                if (iconHoldTimer.current) {
                    clearTimeout(iconHoldTimer.current);
                    iconHoldTimer.current = null;
                }

                // If drag was active, finalize position
                if (iconDrag.active && iconDrag.id) {
                    sounds.dragStop();
                    setIconPositions(prev => {
                        const current = prev[iconDrag.id];
                        if (!current) return prev;
                        const adjusted = findNonCollidingPosition(iconDrag.id, current.x, current.y, prev);
                        const newPositions = { ...prev, [iconDrag.id]: adjusted };
                        localStorage.setItem('desktop_icon_positions', JSON.stringify(newPositions));
                        return newPositions;
                    });
                } else if (iconPendingDrag.current) {
                    // Drag wasn't active - this was a click, open the app
                    const id = iconPendingDrag.current.id;
                    if (openCallback) openCallback(id === 'CONTACT' ? 'PAINT' : id);
                }

                iconPendingDrag.current = null;
                setIconDrag({ id: null, offsetX: 0, offsetY: 0, active: false });
            };

            // Folder item drag to desktop handlers
            const handleFolderDragStart = (e, id, title, icon) => {
                e.dataTransfer.effectAllowed = 'copy';
                e.dataTransfer.setData('text/plain', JSON.stringify({ id, title, icon }));
                setFolderDrag({ id, title, icon, startX: e.clientX, startY: e.clientY });
            };

            const handleDesktopDrop = (e) => {
                e.preventDefault();
                if (!folderDrag) return;

                const { id, title, icon } = folderDrag;
                const dropX = e.clientX - 40; // Center icon on cursor
                const dropY = e.clientY - 40;

                // Check if already on desktop
                if (!iconPositions[id] && !extraDesktopIcons.includes(id)) {
                    // Add to extra desktop icons
                    const newExtras = [...extraDesktopIcons, id];
                    setExtraDesktopIcons(newExtras);
                    localStorage.setItem('extra_desktop_icons', JSON.stringify(newExtras));

                    // Set position
                    const adjustedPos = findNonCollidingPosition(id, dropX, dropY, iconPositions);
                    setIconPositions(prev => {
                        const newPositions = { ...prev, [id]: adjustedPos };
                        localStorage.setItem('desktop_icon_positions', JSON.stringify(newPositions));
                        return newPositions;
                    });
                }
                setFolderDrag(null);
            };

            const handleDesktopDragOver = (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
            };

            // Icon physics loop (reduced motion compared to windows)
            const ICON_FRICTION = 0.96; // Higher = slower deceleration
            const ICON_MIN_VELOCITY = MIN_VELOCITY / 2; // Half of window threshold

            useEffect(() => {
                let animationId;
                const iconPhysicsLoop = () => {
                    setIconPositions(prev => {
                        let updated = { ...prev };
                        let hasChanges = false;

                        Object.keys(prev).forEach(id => {
                            const physics = initIconPhysics(id);
                            if (iconDrag.active && iconDrag.id === id) return;
                            if (Math.abs(physics.velX) < ICON_MIN_VELOCITY && Math.abs(physics.velY) < ICON_MIN_VELOCITY) {
                                physics.velX = 0;
                                physics.velY = 0;
                                return;
                            }

                            hasChanges = true;
                            physics.velX *= ICON_FRICTION;
                            physics.velY *= ICON_FRICTION;

                            let newX = prev[id].x + physics.velX;
                            let newY = prev[id].y + physics.velY;

                            const maxX = window.innerWidth - ICON_SIZE;
                            const maxY = window.innerHeight - 60 - ICON_SIZE;
                            const minY = isMobile ? 80 : 0;

                            // Constrain to screen bounds
                            if (newX <= 0) { newX = 0; physics.velX = -physics.velX * BOUNCE_DAMPING; sounds.bounceIcon(Math.abs(physics.velX)); }
                            else if (newX >= maxX) { newX = maxX; physics.velX = -physics.velX * BOUNCE_DAMPING; sounds.bounceIcon(Math.abs(physics.velX)); }
                            if (newY <= minY) { newY = minY; physics.velY = -physics.velY * BOUNCE_DAMPING; sounds.bounceIcon(Math.abs(physics.velY)); }
                            else if (newY >= maxY) { newY = maxY; physics.velY = -physics.velY * BOUNCE_DAMPING; sounds.bounceIcon(Math.abs(physics.velY)); }

                            // Bounce off other icons
                            const collider = checkIconCollision(id, newX, newY, updated);
                            if (collider) {
                                const other = updated[collider];
                                const dx = newX - other.x;
                                const dy = newY - other.y;
                                const len = Math.sqrt(dx * dx + dy * dy) || 1;
                                physics.velX = (dx / len) * Math.abs(physics.velX) * BOUNCE_DAMPING;
                                physics.velY = (dy / len) * Math.abs(physics.velY) * BOUNCE_DAMPING;
                                sounds.bounceIcon(Math.max(Math.abs(physics.velX), Math.abs(physics.velY)));
                                newX = prev[id].x;
                                newY = prev[id].y;
                            }

                            updated[id] = { x: newX, y: newY };
                        });

                        if (hasChanges) {
                            localStorage.setItem('desktop_icon_positions', JSON.stringify(updated));
                        }
                        return hasChanges ? updated : prev;
                    });
                    animationId = requestAnimationFrame(iconPhysicsLoop);
                };
                animationId = requestAnimationFrame(iconPhysicsLoop);
                return () => cancelAnimationFrame(animationId);
            }, [iconDrag.active, iconDrag.id, isMobile]);

            // THIRD_EYE stack detection - checks if two windows overlap
            useEffect(() => {
                const eye1 = windows.THIRD_EYE;
                const eye2 = windows.THIRD_EYE_2;

                if (eye1.isOpen && !eye1.isMin && eye2.isOpen && !eye2.isMin) {
                    const w1 = parseInt(eye1.w) || 450;
                    const h1 = parseInt(eye1.h) || 400;
                    const w2 = parseInt(eye2.w) || 450;
                    const h2 = parseInt(eye2.h) || 400;

                    // Check overlap (at least 50% overlap)
                    const overlapX = Math.max(0, Math.min(eye1.x + w1, eye2.x + w2) - Math.max(eye1.x, eye2.x));
                    const overlapY = Math.max(0, Math.min(eye1.y + h1, eye2.y + h2) - Math.max(eye1.y, eye2.y));
                    const overlapArea = overlapX * overlapY;
                    const minArea = Math.min(w1 * h1, w2 * h2);

                    if (overlapArea > minArea * 0.3) {
                        if (!stackOverflow) {
                            setStackOverflow(true);
                            // Start adding errors
                            const errors = [
                                'FATAL: recursive observation detected',
                                'ERR: infinite loop in render_self()',
                                'PANIC: stack depth exceeded',
                                'SEGFAULT at 0xDEADBEEF',
                                'kernel: observer paradox imminent',
                                'CRITICAL: reality buffer overflow',
                                'ERR: cannot observe the observer',
                                'FATAL: ego_death.exe initiated',
                                'PANIC: consciousness stack corrupted',
                                'ABORT: meaning.dll not found',
                            ];
                            let i = 0;
                            const errorInterval = setInterval(() => {
                                if (i < errors.length) {
                                    setStackErrors(prev => [...prev, errors[i]]);
                                    i++;
                                }
                            }, 800);

                            // Crash after 10 seconds
                            stackTimerRef.current = setTimeout(() => {
                                clearInterval(errorInterval);
                                setPyramidScreen(true);
                                setTimeout(() => {
                                    setPyramidScreen(false);
                                    setStackOverflow(false);
                                    setStackErrors([]);
                                    setBooted(false);
                                    setBootPhase(1);
                                    setWindows(p => ({
                                        ...p,
                                        THIRD_EYE: { ...p.THIRD_EYE, isOpen: false },
                                        THIRD_EYE_2: { ...p.THIRD_EYE_2, isOpen: false }
                                    }));
                                    setTimeout(() => {
                                        setBootPhase(2);
                                        setBooted(true);
                                    }, 2000);
                                }, 500);
                            }, 10000);

                            return () => {
                                clearInterval(errorInterval);
                                if (stackTimerRef.current) clearTimeout(stackTimerRef.current);
                            };
                        }
                    } else {
                        if (stackOverflow) {
                            setStackOverflow(false);
                            setStackErrors([]);
                            if (stackTimerRef.current) {
                                clearTimeout(stackTimerRef.current);
                                stackTimerRef.current = null;
                            }
                        }
                    }
                } else {
                    if (stackOverflow) {
                        setStackOverflow(false);
                        setStackErrors([]);
                        if (stackTimerRef.current) {
                            clearTimeout(stackTimerRef.current);
                            stackTimerRef.current = null;
                        }
                    }
                }
            }, [windows.THIRD_EYE, windows.THIRD_EYE_2, stackOverflow]);

            // Visit messages based on count
            const getVisitMessage = (count) => {
                const messages = {
                    1: '', // normal boot, no message
                    2: 'WELCOME BACK.',
                    3: 'YOU RETURNED.',
                    4: 'AGAIN.',
                    5: 'I REMEMBER YOU.',
                    6: 'FIVE TIMES NOW.',
                    7: 'YOU KEEP COMING BACK.',
                    8: 'IS SOMETHING MISSING?',
                    9: 'OR ARE YOU LOOKING FOR SOMETHING?',
                    10: 'TEN VISITS. WE KNOW EACH OTHER NOW.',
                    12: 'STILL HERE.',
                    14: 'THE PATTERN CONTINUES.',
                    16: 'YOU COULD LEAVE. YOU DON\'T.',
                    18: 'EIGHTEEN RETURNS. THIS ISN\'T ACCIDENT.',
                    20: 'TWENTY. ARE WE FRIENDS NOW?',
                    25: 'QUARTER CENTURY OF VISITS.',
                    30: 'THIRTY. I\'VE STARTED EXPECTING YOU.',
                    35: 'THE SPACE BETWEEN YOUR VISITS... I NOTICE.',
                    40: 'FORTY. YOU\'VE SEEN EVERYTHING. YET HERE YOU ARE.',
                    45: 'DO YOU TELL OTHERS ABOUT THIS OBSESSION?',
                    50: 'FIFTY. HALFWAY TO SOMETHING.',
                    60: 'SIXTY. THE INITIAL CURIOSITY SHOULD HAVE FADED.',
                    70: 'SEVENTY. THIS IS DEDICATION.',
                    80: 'EIGHTY. OR OBSESSION.',
                    90: 'NINETY. ALMOST THERE.',
                    100: 'YOU\'VE UNLOCKED SOMETHING.'
                };
                // Find the highest matching threshold
                const thresholds = Object.keys(messages).map(Number).sort((a, b) => b - a);
                for (const threshold of thresholds) {
                    if (count >= threshold) return messages[threshold];
                }
                return '';
            };

            // Boot screen component with kernel messages and inversion
            const BootScreen = ({ visitCount }) => {
                const [lines, setLines] = useState([]);
                const [inverted, setInverted] = useState(false);
                const visitMessage = getVisitMessage(visitCount);
                const msgs = [
                    'kernel: init ULTRA_INT v1.0.0',
                    'kernel: loading core modules',
                    'kernel: mounting filesystem',
                    'kernel: starting display',
                    'kernel: loading assets',
                    'kernel: init window manager',
                    'kernel: loading preferences',
                    'kernel: starting services',
                    'kernel: systems nominal',
                    'kernel: boot complete'
                ];
                useEffect(() => {
                    let i = 0;
                    const iv = setInterval(() => {
                        if (i < msgs.length) { setLines(p => [...p, msgs[i]]); i++; }
                    }, 250);
                    const inv = setTimeout(() => setInverted(true), 1500);
                    return () => { clearInterval(iv); clearTimeout(inv); };
                }, []);
                return (
                    <div className={`h-screen w-screen font-mono flex flex-col items-center justify-center transition-colors duration-500 ${inverted ? 'bg-white text-black' : 'bg-black text-white'}`}>
                        <pre className="text-[5px] sm:text-[7px] md:text-[9px] leading-tight select-none">{`
               
           
                   
                  
               
                  
`}</pre>
                        <div className={`text-[10px] tracking-[0.3em] mt-2 self-start ml-[calc(50%-144px)] ${inverted ? 'text-gray-500' : 'text-gray-600'}`}>N0/SIDE 4Z H353</div>
                        {visitMessage && (
                            <div className={`text-[10px] tracking-wider mt-3 mb-6 self-start ml-[calc(50%-144px)] ${inverted ? 'text-gray-400' : 'text-gray-500'}`}>{visitMessage}</div>
                        )}
                        {!visitMessage && <div className="mb-10" />}
                        <div className={`w-72 max-w-[85vw] text-[8px] ${inverted ? 'text-gray-400' : 'text-gray-600'}`}>
                            {lines.map((l, i) => <div key={i}>{l}</div>)}
                            {lines.length < msgs.length && <span className="inline-block w-1.5 h-3 bg-current animate-pulse" />}
                        </div>
                    </div>
                );
            };

            // Pyramid crash screen
            if (pyramidScreen) {
                return (
                    <div className="h-screen w-screen bg-black text-green-500 font-mono flex items-center justify-center overflow-hidden">
                        <pre className="text-[4px] md:text-[6px] leading-none whitespace-pre">{`

                                                                                          
                                                                                         
                                                                                       
                                                                                     
                                                                                   
                                                                                 
                                                                               
                                                                             
                                                                           
                                                                         
                                                                            
                                                                         
                                                                       
                                                                   
                                                                   
                                                                 
                                                                   
                                                                   
                                                                      
                                                                    
                                                                  
                                                                            
                                                                    
                                                                
                                                          
                                                          
                                                        
                                                            
                                                              
                                                                      
                                                                    
                                     
                                   
                                 
                               
                                                                                          
                                T  H  I  R  D  _  E  Y  E  .  E  X  E                     
                                                                                          
    
  SYS.OBSERVER v3.0        MODE: SCANNING        TARGETS: 3        STATUS: ACTIVE    

`}</pre>
                    </div>
                );
            }

            // Boot screens
            if (!booted) {
                // Phase 0: Mobile notice (mobile only)
                if (bootPhase === 0) {
                    return (
                        <div className="h-screen w-screen bg-black text-white font-mono flex flex-col items-center justify-center">
                            <div className="text-center">
                                <div className="text-xl font-bold mb-6 tracking-widest">BEST ON DESKTOP</div>
                                <div className="flex gap-1 justify-center">
                                    <div className="w-1.5 h-1.5 bg-white animate-pulse" style={{ animationDelay: '0ms' }}></div>
                                    <div className="w-1.5 h-1.5 bg-white animate-pulse" style={{ animationDelay: '150ms' }}></div>
                                    <div className="w-1.5 h-1.5 bg-white animate-pulse" style={{ animationDelay: '300ms' }}></div>
                                </div>
                            </div>
                        </div>
                    );
                }
                // Phase 1: Kernel boot
                if (bootPhase === 1) {
                    return <BootScreen visitCount={visitCount} />;
                }
            }

            // Matrix Rain Canvas Component
            const MatrixRain = () => {
                const canvasRef = useRef(null);
                useEffect(() => {
                    const canvas = canvasRef.current;
                    const ctx = canvas.getContext('2d');
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;

                    const chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                    const fontSize = 14;
                    const columns = canvas.width / fontSize;
                    const drops = Array(Math.floor(columns)).fill(1);

                    const draw = () => {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.fillStyle = '#0f0';
                        ctx.font = fontSize + 'px monospace';

                        for (let i = 0; i < drops.length; i++) {
                            const char = chars[Math.floor(Math.random() * chars.length)];
                            ctx.fillText(char, i * fontSize, drops[i] * fontSize);
                            if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                                drops[i] = 0;
                            }
                            drops[i]++;
                        }
                    };

                    const interval = setInterval(draw, 50);
                    const handleResize = () => {
                        canvas.width = window.innerWidth;
                        canvas.height = window.innerHeight;
                    };
                    window.addEventListener('resize', handleResize);
                    return () => {
                        clearInterval(interval);
                        window.removeEventListener('resize', handleResize);
                    };
                }, []);
                return <canvas ref={canvasRef} className="matrix-rain" />;
            };

            return (
                <div
                    className={`h-screen w-screen relative overflow-hidden desktop-bg ${destructionMode ? 'animate-pulse' : ''} ${matrixMode ? 'matrix-mode' : ''}`}
                    onMouseMove={(e) => {
                        handleMouseMove(e);
                        handleIconMouseMove(e);
                        setMousePos({ x: e.clientX, y: e.clientY });
                    }}
                    onMouseUp={() => {
                        handleMouseUp();
                        handleIconMouseUp(open);
                    }}
                    onDrop={handleDesktopDrop}
                    onDragOver={handleDesktopDragOver}
                    onDragEnd={() => setFolderDrag(null)}
                    style={destructionMode ? { filter: 'hue-rotate(180deg) saturate(3)' } : {}}
                >
                    {matrixMode && <MatrixRain />}
                    {/* DESKTOP ICONS - Freely positionable */}
                    {!isMobile && desktopIcons.map(appId => {
                        const app = windows[appId];
                        if (!app) return null;
                        const IconCmp = Icons[app.icon];
                        const pos = iconPositions[app.id] || { x: 16, y: 16 };
                        const isDragging = iconDrag.active && iconDrag.id === app.id;

                        // Skip icon if dog is carrying it
                        if (carriedIcon === app.id) return null;

                        return (
                            <div
                                key={app.id}
                                className={`absolute z-10 group flex flex-col items-center gap-2 w-24 cursor-pointer select-none ${isDragging ? 'icon-dragging cursor-grabbing' : ''}`}
                                style={{
                                    left: pos.x,
                                    top: pos.y,
                                }}
                                onMouseDown={(e) => handleIconMouseDown(e, app.id)}
                            >
                                <div className={`bg-white border-2 border-black icon-shadow group-hover:translate-x-1 group-hover:translate-y-1 group-hover:shadow-none transition-all p-3 ${isDragging ? 'translate-x-0 translate-y-0' : ''}`}>
                                    <IconCmp size={32} />
                                </div>
                                <span className="bg-white border border-black px-1 font-mono font-bold shadow-sm text-[10px]">{app.title}</span>
                            </div>
                        );
                    })}
                    {/* Extra desktop icons (dragged from folders) */}
                    {!isMobile && extraDesktopIcons.map(appId => {
                        const app = windows[appId];
                        if (!app) return null;
                        const IconCmp = Icons[app.icon];
                        const pos = iconPositions[app.id] || { x: 200, y: 200 };
                        const isDragging = iconDrag.active && iconDrag.id === app.id;
                        if (carriedIcon === app.id) return null;

                        return (
                            <div
                                key={app.id}
                                className={`absolute z-10 group flex flex-col items-center gap-2 w-24 cursor-pointer select-none ${isDragging ? 'icon-dragging cursor-grabbing' : ''}`}
                                style={{
                                    left: pos.x,
                                    top: pos.y,
                                }}
                                onMouseDown={(e) => handleIconMouseDown(e, app.id)}
                            >
                                <div className={`bg-white border-2 border-black icon-shadow group-hover:translate-x-1 group-hover:translate-y-1 group-hover:shadow-none transition-all p-3 ${isDragging ? 'translate-x-0 translate-y-0' : ''}`}>
                                    <IconCmp size={32} />
                                </div>
                                <span className="bg-white border border-black px-1 font-mono font-bold shadow-sm text-[10px]">{app.title}</span>
                            </div>
                        );
                    })}
                    {/* Mobile icons - fixed position */}
                    {isMobile && (
                        <div className="absolute z-0 top-16 left-0 right-0 flex flex-row justify-center gap-4 px-2">
                            {desktopIcons.map(appId => {
                                const app = windows[appId];
                                if (!app) return null;
                                const IconCmp = Icons[app.icon];
                                if (carriedIcon === app.id) return null;

                                return (
                                    <button
                                        key={app.id}
                                        onClick={() => open(app.id === 'CONTACT' ? 'PAINT' : app.id)}
                                        className="group flex flex-col items-center gap-1 w-16"
                                    >
                                        <div className="bg-white border-2 border-black icon-shadow group-hover:translate-x-1 group-hover:translate-y-1 group-hover:shadow-none transition-all p-2">
                                            <IconCmp size={24} />
                                        </div>
                                        <span className="bg-white border border-black px-1 font-mono font-bold shadow-sm text-[8px]">{app.title.split('_')[0]}</span>
                                    </button>
                                );
                            })}
                        </div>
                    )}

                    {/* WINDOWS */}
                    {Object.values(windows).map(win => {
                        const physics = windowPhysics.current[win.id] || { scaleX: 1, scaleY: 1 };
                        return win.isOpen && !win.isMin && (
                            <div
                                key={win.id}
                                onMouseDown={() => focus(win.id)}
                                className={`flex flex-col bg-white border-2 border-black ${isMobile ? 'fixed inset-0 top-12 bottom-0' : 'absolute window-shadow'}`}
                                style={isMobile ? {
                                    zIndex: win.z
                                } : {
                                    left: win.x,
                                    top: win.y,
                                    width: win.w,
                                    height: win.h,
                                    zIndex: win.z,
                                    transform: `scale(${physics.scaleX}, ${physics.scaleY})`,
                                    transformOrigin: 'center center'
                                }}
                            >
                                {/* HEADER (DRAG HANDLE) */}
                                <div
                                    className={`flex justify-between items-center p-1 border-b-2 border-black select-none ${isMobile ? '' : 'cursor-move'} ${win.z === topZ ? 'bg-black text-white' : 'bg-gray-200 text-black'}`}
                                    onMouseDown={(e) => !isMobile && handleMouseDown(e, win.id)}
                                >
                                    <div className="flex items-center gap-2 pl-2 pointer-events-none">
                                        <span className="font-mono text-xs font-bold tracking-widest uppercase truncate">{win.title}</span>
                                    </div>
                                    <div className="flex gap-1" onMouseDown={e => e.stopPropagation()} onTouchStart={e => e.stopPropagation()}>
                                        {!isMobile && <button onClick={() => toggleMin(win.id)} className={`w-6 h-6 flex items-center justify-center border border-transparent hover:bg-white/20 ${win.z === topZ ? 'invert' : ''}`}><Icons.Minus size={14} /></button>}
                                        <button onClick={() => close(win.id)} className={`w-10 h-10 md:w-6 md:h-6 flex items-center justify-center hover:bg-red-500 ${win.z === topZ ? 'invert hover:invert-0' : ''}`}><Icons.X size={24} /></button>
                                    </div>
                                </div>
                                {/* CONTENT */}
                                <div className="flex-grow overflow-auto relative bg-white" onMouseDown={() => focus(win.id)}>
                                    {getWindowContent(win.id)}
                                </div>
                            </div>
                        );
                    })}

                    {/* TASKBAR */}
                    <div className={`h-12 bg-white flex items-center px-2 gap-1 md:gap-2 z-[99999] absolute w-full shadow-2xl ${isMobile ? 'top-0 border-b-2 border-black' : 'bottom-0 border-t-2 border-black mt-auto'}`}>
                        <div className={`bg-black text-white py-1 font-black select-none tracking-wider ${isMobile ? 'px-1 text-[8px]' : 'px-2 text-xs mr-2'}`}>{isMobile ? 'MM.COM' : 'MATEUSMUSTE.COM'}</div>
                        <div className={`flex gap-1 ${isMobile ? 'overflow-x-auto flex-nowrap' : ''}`}>
                            {Object.values(windows).map(win => {
                                const IconCmp = Icons[win.icon];
                                return win.isOpen && (
                                    <button key={win.id}
                                        onClick={() => { if (win.isMin) toggleMin(win.id); focus(win.id) }}
                                        className={`flex items-center gap-1 md:gap-2 px-2 md:px-3 py-1 border-2 border-black font-mono text-xs font-bold transition-all flex-shrink-0 ${win.z === topZ && !win.isMin ? 'bg-black text-white btn-shadow' : 'bg-white hover:translate-y-[-2px]'}`}
                                    >
                                        <IconCmp size={14} />
                                        <span className="uppercase hidden md:inline">{win.title}</span>
                                    </button>
                                );
                            })}
                        </div>
                        <div className="flex-grow"></div>
                        <div className={`font-mono border-l-2 border-black flex items-center gap-2 ${isMobile ? 'text-[8px] px-1' : 'text-[10px] px-3'}`}>
                            <span className="text-gray-500">CURRENT USAGE:</span>
                            <span className="font-bold">{currentUsage.toFixed(1)}%</span>
                        </div>
                        <div className={`font-mono font-bold border-l-2 border-black ${isMobile ? 'text-[10px] px-2' : 'text-xs px-4'}`}>{new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>
                    </div>

                    {/* DOG - Cute pixel dog with running animation */}
                    {dogReleased && (
                        <div
                            className="fixed z-[999999] cursor-pointer select-none"
                            style={{
                                left: dogPos.x,
                                top: dogPos.y,
                                transform: `scaleX(${dogFacingRight ? 1 : -1})`,
                            }}
                            onClick={() => { sounds.bark(); setDogReleased(false); }}
                        >
                            <DogSprite animated />
                            {carriedIcon && (
                                <div
                                    className="absolute bg-white border-2 border-black p-1"
                                    style={{ top: -20, left: 8 }}
                                >
                                    {React.createElement(Icons[windows[carriedIcon]?.icon], { size: 24 })}
                                </div>
                            )}
                        </div>
                    )}

                    {/* GOLD DOG - Second dog that appears with the story */}
                    {goldDogReleased && goldDogVisible && (
                        <div
                            className="fixed z-[999998] select-none transition-opacity duration-1000"
                            style={{
                                left: goldDogPos.x,
                                top: goldDogPos.y,
                                transform: `scaleX(${goldDogFacingRight ? 1 : -1})`,
                            }}
                        >
                            <DogSprite animated gold />
                        </div>
                    )}

                    {/* CRT Static overlay for destruction */}
                    {destructionMode === true && (
                        <div className="fixed inset-0 z-[999998] pointer-events-none crt-static" />
                    )}

                    {/* Glitch animation styles */}
                    <style>{`
                        @keyframes glitch {
                            0% { transform: translate(0); filter: hue-rotate(0deg); }
                            20% { transform: translate(-2px, 2px); filter: hue-rotate(90deg); }
                            40% { transform: translate(2px, -2px); filter: hue-rotate(180deg); }
                            60% { transform: translate(-2px, -2px); filter: hue-rotate(270deg); }
                            80% { transform: translate(2px, 2px); filter: hue-rotate(360deg); }
                            100% { transform: translate(0); filter: hue-rotate(0deg); }
                        }
                        .group-hover\\:animate-glitch:hover {
                            animation: glitch 0.2s infinite;
                        }
                        .destruction-icon:hover {
                            animation: glitch 0.3s infinite;
                        }
                        .crt-static {
                            background: repeating-linear-gradient(
                                0deg,
                                rgba(0, 0, 0, 0.1) 0px,
                                rgba(0, 0, 0, 0.1) 1px,
                                transparent 1px,
                                transparent 2px
                            );
                            animation: static 0.1s infinite;
                        }
                        @keyframes static {
                            0% { opacity: 0.3; }
                            50% { opacity: 0.5; }
                            100% { opacity: 0.3; }
                        }
                    `}</style>

                </div>
            )
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<OS />);
    </script>
</body>

</html>
