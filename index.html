<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MATEUSMUSTE // OS</title>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script src="https://cdn.tailwindcss.com"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Geist:wght@400;700;900&family=Geist+Mono:wght@400;700&display=swap"
        rel="stylesheet">

    <style>
        :root {
            --bg: #e5e5e5;
            --fg: #000000;
        }

        body {
            background-color: var(--bg);
            color: var(--fg);
            font-family: 'Geist', sans-serif;
            overflow: hidden;
            margin: 0;
            padding: 0;
            user-select: none;
            -webkit-font-smoothing: antialiased;
        }

        .font-mono {
            font-family: 'Geist Mono', monospace;
        }

        /* Brutalist Styles */
        .window-shadow {
            box-shadow: 10px 10px 0px 0px #000000;
        }

        .icon-shadow {
            box-shadow: 4px 4px 0px 0px #000000;
        }

        .btn-shadow {
            box-shadow: 2px 2px 0px 0px #000000;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }

        ::-webkit-scrollbar-track {
            background: #fff;
            border-left: 2px solid #000;
            border-top: 2px solid #000;
        }

        ::-webkit-scrollbar-thumb {
            background: #000;
            border: 2px solid #fff;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #333;
        }

        /* Background Pattern */
        .desktop-bg {
            background-color: #f0f0f0;
            background-image: radial-gradient(#aaa 1px, transparent 1px);
            background-size: 20px 20px;
        }

        canvas {
            touch-action: none;
        }
    </style>
</head>

<body>

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- PIXEL ART ICONS (32x32) ---
        const PixelIcon = ({ children, size = 32, ...props }) => (
            <svg {...props} width={size} height={size} viewBox="0 0 32 32" fill="none" style={{ imageRendering: 'pixelated' }}>
                {children}
            </svg>
        );

        const Icons = {
            // System Info - Monitor with info screen
            Terminal: (p) => (
                <PixelIcon {...p}>
                    <rect x="4" y="4" width="24" height="18" fill="#000" />
                    <rect x="6" y="6" width="20" height="14" fill="#fff" />
                    <rect x="8" y="8" width="16" height="2" fill="#000" />
                    <rect x="8" y="12" width="12" height="2" fill="#000" />
                    <rect x="8" y="16" width="8" height="2" fill="#000" />
                    <rect x="12" y="22" width="8" height="2" fill="#000" />
                    <rect x="10" y="24" width="12" height="4" fill="#000" />
                </PixelIcon>
            ),
            // Media Library - Stack of folders
            Folder: (p) => (
                <PixelIcon {...p}>
                    <rect x="4" y="10" width="24" height="18" fill="#000" />
                    <rect x="6" y="12" width="20" height="14" fill="#fff" />
                    <rect x="4" y="8" width="10" height="4" fill="#000" />
                    <rect x="6" y="6" width="6" height="4" fill="#000" />
                    <rect x="8" y="16" width="14" height="2" fill="#000" />
                    <rect x="8" y="20" width="10" height="2" fill="#000" />
                </PixelIcon>
            ),
            // Paint - Brush icon
            Palette: (p) => (
                <PixelIcon {...p}>
                    <rect x="22" y="2" width="6" height="6" fill="#000" />
                    <rect x="18" y="6" width="6" height="6" fill="#000" />
                    <rect x="14" y="10" width="6" height="6" fill="#000" />
                    <rect x="10" y="14" width="6" height="6" fill="#000" />
                    <rect x="6" y="18" width="6" height="6" fill="#000" />
                    <rect x="2" y="22" width="8" height="8" fill="#000" />
                    <rect x="4" y="24" width="4" height="4" fill="#fff" />
                </PixelIcon>
            ),
            // Snake Game - Pixel snake
            Snek: (p) => (
                <PixelIcon {...p}>
                    <rect x="4" y="12" width="4" height="4" fill="#000" />
                    <rect x="8" y="12" width="4" height="4" fill="#000" />
                    <rect x="12" y="12" width="4" height="4" fill="#000" />
                    <rect x="16" y="12" width="4" height="4" fill="#000" />
                    <rect x="16" y="16" width="4" height="4" fill="#000" />
                    <rect x="16" y="20" width="4" height="4" fill="#000" />
                    <rect x="20" y="20" width="4" height="4" fill="#000" />
                    <rect x="24" y="20" width="4" height="4" fill="#000" />
                    <rect x="2" y="10" width="2" height="2" fill="#000" />
                    <rect x="2" y="14" width="2" height="2" fill="#000" />
                    <rect x="26" y="24" width="4" height="4" fill="#fff" stroke="#000" strokeWidth="1" />
                </PixelIcon>
            ),
            // Trash Can - Desktop trash
            TrashCan: (p) => (
                <PixelIcon {...p}>
                    <rect x="6" y="4" width="20" height="4" fill="#000" />
                    <rect x="10" y="2" width="12" height="4" fill="#000" />
                    <rect x="8" y="8" width="16" height="20" fill="#000" />
                    <rect x="10" y="10" width="12" height="16" fill="#fff" />
                    <rect x="12" y="12" width="2" height="12" fill="#000" />
                    <rect x="15" y="12" width="2" height="12" fill="#000" />
                    <rect x="18" y="12" width="2" height="12" fill="#000" />
                </PixelIcon>
            ),
            // Undo arrow
            Undo: (p) => (
                <PixelIcon {...p}>
                    <rect x="4" y="12" width="4" height="4" fill="#000" />
                    <rect x="8" y="8" width="4" height="4" fill="#000" />
                    <rect x="12" y="4" width="4" height="4" fill="#000" />
                    <rect x="8" y="16" width="16" height="4" fill="#000" />
                    <rect x="20" y="20" width="4" height="8" fill="#000" />
                </PixelIcon>
            ),
            // Redo arrow
            Redo: (p) => (
                <PixelIcon {...p}>
                    <rect x="24" y="12" width="4" height="4" fill="#000" />
                    <rect x="20" y="8" width="4" height="4" fill="#000" />
                    <rect x="16" y="4" width="4" height="4" fill="#000" />
                    <rect x="8" y="16" width="16" height="4" fill="#000" />
                    <rect x="8" y="20" width="4" height="8" fill="#000" />
                </PixelIcon>
            ),
            // File icon for trash items
            FileDoc: (p) => (
                <PixelIcon {...p}>
                    <rect x="6" y="2" width="16" height="28" fill="#000" />
                    <rect x="8" y="4" width="12" height="24" fill="#fff" />
                    <rect x="10" y="8" width="8" height="2" fill="#000" />
                    <rect x="10" y="12" width="8" height="2" fill="#000" />
                    <rect x="10" y="16" width="6" height="2" fill="#000" />
                </PixelIcon>
            ),
            X: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>,
            Minus: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line></svg>,
            Square: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect></svg>,
            Trash: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>,
            Send: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>,
            // Media folder icons
            Movies: (p) => (
                <PixelIcon {...p}>
                    <rect x="4" y="6" width="24" height="20" fill="#000" />
                    <rect x="6" y="8" width="20" height="16" fill="#fff" />
                    <rect x="4" y="4" width="6" height="4" fill="#000" />
                    <polygon points="12,12 12,20 20,16" fill="#000" />
                </PixelIcon>
            ),
            Books: (p) => (
                <PixelIcon {...p}>
                    <rect x="4" y="6" width="24" height="20" fill="#000" />
                    <rect x="6" y="8" width="20" height="16" fill="#fff" />
                    <rect x="4" y="4" width="6" height="4" fill="#000" />
                    <rect x="10" y="11" width="12" height="2" fill="#000" />
                    <rect x="10" y="15" width="8" height="2" fill="#000" />
                    <rect x="10" y="19" width="10" height="2" fill="#000" />
                </PixelIcon>
            ),
            Games: (p) => (
                <PixelIcon {...p}>
                    <rect x="4" y="6" width="24" height="20" fill="#000" />
                    <rect x="6" y="8" width="20" height="16" fill="#fff" />
                    <rect x="4" y="4" width="6" height="4" fill="#000" />
                    <rect x="10" y="12" width="4" height="4" fill="#000" />
                    <rect x="18" y="12" width="4" height="4" fill="#000" />
                    <rect x="12" y="18" width="8" height="2" fill="#000" />
                </PixelIcon>
            ),
            Music: (p) => (
                <PixelIcon {...p}>
                    <rect x="4" y="6" width="24" height="20" fill="#000" />
                    <rect x="6" y="8" width="20" height="16" fill="#fff" />
                    <rect x="4" y="4" width="6" height="4" fill="#000" />
                    <rect x="18" y="10" width="2" height="10" fill="#000" />
                    <rect x="14" y="18" width="6" height="4" fill="#000" />
                    <rect x="18" y="10" width="6" height="4" fill="#000" />
                </PixelIcon>
            ),
            Back: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M19 12H5M12 19l-7-7 7-7" /></svg>,
            // New App Icons
            Void: (p) => (
                <PixelIcon {...p}>
                    <rect x="4" y="4" width="24" height="24" fill="#000" />
                    <rect x="6" y="6" width="20" height="20" fill="#fff" />
                    <rect x="8" y="8" width="16" height="2" fill="#000" />
                    <rect x="8" y="12" width="12" height="2" fill="#333" />
                    <rect x="8" y="16" width="14" height="2" fill="#666" />
                    <rect x="8" y="20" width="8" height="2" fill="#999" />
                </PixelIcon>
            ),
            Oracle: (p) => (
                <PixelIcon {...p}>
                    <rect x="10" y="2" width="12" height="4" fill="#000" />
                    <rect x="8" y="6" width="16" height="4" fill="#000" />
                    <rect x="6" y="10" width="20" height="12" fill="#000" />
                    <rect x="8" y="12" width="16" height="8" fill="#fff" />
                    <rect x="12" y="14" width="3" height="3" fill="#000" />
                    <rect x="17" y="14" width="3" height="3" fill="#000" />
                    <rect x="6" y="22" width="6" height="6" fill="#000" />
                    <rect x="20" y="22" width="6" height="6" fill="#000" />
                </PixelIcon>
            ),
            Radio: (p) => (
                <PixelIcon {...p}>
                    <rect x="4" y="8" width="24" height="18" fill="#000" />
                    <rect x="6" y="10" width="20" height="14" fill="#fff" />
                    <rect x="8" y="12" width="8" height="8" fill="#000" />
                    <rect x="10" y="14" width="4" height="4" fill="#fff" />
                    <rect x="18" y="12" width="6" height="2" fill="#000" />
                    <rect x="18" y="16" width="6" height="2" fill="#000" />
                    <rect x="14" y="2" width="2" height="8" fill="#000" />
                    <rect x="12" y="2" width="6" height="2" fill="#000" />
                </PixelIcon>
            ),
            Dice: (p) => (
                <PixelIcon {...p}>
                    <rect x="4" y="4" width="24" height="24" fill="#000" />
                    <rect x="6" y="6" width="20" height="20" fill="#fff" />
                    <rect x="10" y="10" width="4" height="4" fill="#000" />
                    <rect x="18" y="10" width="4" height="4" fill="#000" />
                    <rect x="14" y="14" width="4" height="4" fill="#000" />
                    <rect x="10" y="18" width="4" height="4" fill="#000" />
                    <rect x="18" y="18" width="4" height="4" fill="#000" />
                </PixelIcon>
            ),
            Labyrinth: (p) => (
                <PixelIcon {...p}>
                    <rect x="2" y="2" width="28" height="28" fill="#000" />
                    <rect x="4" y="4" width="24" height="24" fill="#fff" />
                    <rect x="4" y="8" width="16" height="2" fill="#000" />
                    <rect x="12" y="12" width="16" height="2" fill="#000" />
                    <rect x="4" y="16" width="12" height="2" fill="#000" />
                    <rect x="20" y="16" width="8" height="2" fill="#000" />
                    <rect x="8" y="20" width="16" height="2" fill="#000" />
                    <rect x="14" y="14" width="4" height="4" fill="#f00" />
                </PixelIcon>
            ),
            Synth: (p) => (
                <PixelIcon {...p}>
                    <rect x="2" y="8" width="28" height="18" fill="#000" />
                    <rect x="4" y="10" width="24" height="14" fill="#333" />
                    <rect x="6" y="12" width="4" height="8" fill="#fff" />
                    <rect x="11" y="12" width="4" height="8" fill="#fff" />
                    <rect x="16" y="12" width="4" height="8" fill="#fff" />
                    <rect x="21" y="12" width="4" height="8" fill="#fff" />
                    <rect x="8" y="12" width="2" height="5" fill="#000" />
                    <rect x="13" y="12" width="2" height="5" fill="#000" />
                    <rect x="23" y="12" width="2" height="5" fill="#000" />
                </PixelIcon>
            ),
            Destruction: (p) => (
                <PixelIcon {...p}>
                    <rect x="8" y="4" width="16" height="4" fill="#000" />
                    <rect x="6" y="8" width="20" height="4" fill="#000" />
                    <rect x="4" y="12" width="24" height="8" fill="#000" />
                    <rect x="6" y="20" width="20" height="4" fill="#000" />
                    <rect x="8" y="24" width="16" height="4" fill="#000" />
                    <rect x="10" y="10" width="4" height="4" fill="#f00" />
                    <rect x="18" y="10" width="4" height="4" fill="#f00" />
                    <rect x="12" y="16" width="8" height="2" fill="#f00" />
                </PixelIcon>
            ),
            Tarot: (p) => (
                <PixelIcon {...p}>
                    <rect x="8" y="2" width="16" height="28" fill="#000" />
                    <rect x="10" y="4" width="12" height="24" fill="#fff" />
                    <rect x="12" y="6" width="8" height="2" fill="#000" />
                    <rect x="14" y="10" width="4" height="4" fill="#000" />
                    <rect x="12" y="16" width="8" height="8" fill="#000" />
                    <rect x="14" y="18" width="4" height="4" fill="#fff" />
                </PixelIcon>
            ),
            Dog: (p) => (
                <PixelIcon {...p}>
                    <rect x="4" y="8" width="6" height="6" fill="#000" />
                    <rect x="6" y="6" width="4" height="4" fill="#000" />
                    <rect x="8" y="10" width="16" height="10" fill="#000" />
                    <rect x="10" y="12" width="12" height="6" fill="#8B4513" />
                    <rect x="6" y="10" width="2" height="2" fill="#fff" />
                    <rect x="22" y="8" width="4" height="4" fill="#000" />
                    <rect x="8" y="20" width="4" height="6" fill="#000" />
                    <rect x="18" y="20" width="4" height="6" fill="#000" />
                    <rect x="24" y="12" width="6" height="2" fill="#000" />
                </PixelIcon>
            )
        };

        // --- DATA ---
        const MEDIA_DB = {
            "CINEMA_TV": [
                { title: "Blade Runner 2049", rating: "MASTERPIECE" },
                { title: "Mr. Robot", rating: "SYS_ADMIN_FAV" },
                { title: "True Detective S1", rating: "10/10" },
                { title: "Succession", rating: "CORP_DRAMA" },
                { title: "The Bear", rating: "HIGH_STRESS" },
                { title: "Ex Machina", rating: "AI_ETHICS" },
                { title: "Fight Club", rating: "CULT_CLASSIC" },
                { title: "Arcane", rating: "VISUAL_PEAK" },
                { title: "Interstellar", rating: "SPACE_TIME" },
                { title: "Chernobyl", rating: "SYSTEM_FAILURE" },
                { title: "Better Call Saul", rating: "LEGAL_DRAMA" },
                { title: "Blue Eye Samurai", rating: "AESTHETIC" },
                { title: "Atlanta", rating: "SURREAL" },
                { title: "Whiplash", rating: "TEMPO" },
                { title: "There Will Be Blood", rating: "OIL" },
                { title: "Sicario", rating: "TENSION" },
                { title: "Black Mirror", rating: "DYSTOPIA" },
                { title: "Rick and Morty", rating: "SCI_FI" }
            ],
            "LITERATURE": [
                { title: "Brothers Karamazov", rating: "10/10" },
                { title: "Looking for Alaska", rating: "10/10" },
                { title: "Atlas Shrugged", rating: "10/10" },
                { title: "Pale Blue Dot", rating: "10/10" },
                { title: "Crime & Punishment", rating: "8/10" },
                { title: "The Fountainhead", rating: "9/10" },
                { title: "1984", rating: "8/10" },
                { title: "Master & Margarita", rating: "8/10" },
                { title: "American Psycho", rating: "8/10" },
                { title: "Elon Musk", rating: "9/10" }
            ],
            "GAMES": [
                { title: "Dark Souls III", rating: "10/10" },
                { title: "The Last of Us Pt II", rating: "10/10" },
                { title: "Outer Wilds", rating: "10/10" },
                { title: "God of War Ragnarok", rating: "10/10" },
                { title: "Blue Prince", rating: "10/10" },
                { title: "Cyberpunk 2077", rating: "9.5/10" },
                { title: "Night in the Woods", rating: "9.5/10" },
                { title: "Silent Hill 2", rating: "8/10" },
                { title: "Returnal", rating: "8/10" },
                { title: "Hollow Knight (Silksong)", rating: "8/10" },
                { title: "Deltarune", rating: "9/10" }
            ],
            "AUDIO": [
                { title: "The Life of Pablo", artist: "Kanye West" },
                { title: "Yeezus", artist: "Kanye West" },
                { title: "Mr. Morale...", artist: "Kendrick Lamar" },
                { title: "Miss Anthropocene", artist: "Grimes" },
                { title: "The Eminem Show", artist: "Eminem" }
            ]
        };

        // --- APP COMPONENTS ---

        const PaintApp = () => {
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const [tool, setTool] = useState('brush');
            const [color, setColor] = useState('#000000');
            const [size, setSize] = useState(4);
            const [isDrawing, setIsDrawing] = useState(false);
            const [status, setStatus] = useState("READY");
            const [startPos, setStartPos] = useState({ x: 0, y: 0 });
            const [textInput, setTextInput] = useState('');
            const [showTextInput, setShowTextInput] = useState(false);
            const [textPos, setTextPos] = useState({ x: 0, y: 0 });
            const snapshotRef = useRef(null);
            const historyRef = useRef([]);
            const historyIndexRef = useRef(-1);

            // Get accurate mouse position relative to canvas
            const getMousePos = (e) => {
                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            };

            const saveToHistory = () => {
                const canvas = canvasRef.current;
                const data = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
                historyRef.current = historyRef.current.slice(0, historyIndexRef.current + 1);
                historyRef.current.push(data);
                if (historyRef.current.length > 50) historyRef.current.shift();
                historyIndexRef.current = historyRef.current.length - 1;
            };

            const undo = () => {
                if (historyIndexRef.current > 0) {
                    historyIndexRef.current--;
                    canvasRef.current.getContext('2d').putImageData(historyRef.current[historyIndexRef.current], 0, 0);
                    setStatus("UNDO");
                }
            };

            const redo = () => {
                if (historyIndexRef.current < historyRef.current.length - 1) {
                    historyIndexRef.current++;
                    canvasRef.current.getContext('2d').putImageData(historyRef.current[historyIndexRef.current], 0, 0);
                    setStatus("REDO");
                }
            };

            useEffect(() => {
                const initCanvas = () => {
                    if (!containerRef.current) return;
                    const canvas = canvasRef.current;
                    const container = containerRef.current;
                    // Set fixed canvas size for proper pixel drawing
                    canvas.width = container.clientWidth - 4;
                    canvas.height = container.clientHeight - 4;
                    const ctx = canvas.getContext("2d");
                    ctx.fillStyle = "#ffffff";
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    saveToHistory();
                };
                initCanvas();
                window.addEventListener('resize', initCanvas);
                return () => window.removeEventListener('resize', initCanvas);
            }, []);

            const floodFill = (x, y, fillColor) => {
                const ctx = canvasRef.current.getContext('2d');
                const w = ctx.canvas.width;
                const h = ctx.canvas.height;
                const imgData = ctx.getImageData(0, 0, w, h);
                const data = imgData.data;
                const r = parseInt(fillColor.slice(1, 3), 16);
                const g = parseInt(fillColor.slice(3, 5), 16);
                const b = parseInt(fillColor.slice(5, 7), 16);
                const startIdx = (y * w + x) * 4;
                const sr = data[startIdx], sg = data[startIdx + 1], sb = data[startIdx + 2];
                if (sr === r && sg === g && sb === b) return;
                const stack = [[x, y]];
                while (stack.length) {
                    const [cx, cy] = stack.pop();
                    const idx = (cy * w + cx) * 4;
                    if (cx < 0 || cx >= w || cy < 0 || cy >= h) continue;
                    if (data[idx] === sr && data[idx + 1] === sg && data[idx + 2] === sb) {
                        data[idx] = r; data[idx + 1] = g; data[idx + 2] = b; data[idx + 3] = 255;
                        stack.push([cx + 1, cy], [cx - 1, cy], [cx, cy + 1], [cx, cy - 1]);
                    }
                }
                ctx.putImageData(imgData, 0, 0);
                saveToHistory();
            };

            const saveSnapshot = () => {
                const canvas = canvasRef.current;
                snapshotRef.current = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
            };

            const restoreSnapshot = () => {
                if (snapshotRef.current) {
                    canvasRef.current.getContext('2d').putImageData(snapshotRef.current, 0, 0);
                }
            };

            const startDraw = (e) => {
                const pos = getMousePos(e);
                if (tool === 'bucket') {
                    floodFill(Math.floor(pos.x), Math.floor(pos.y), color);
                    setStatus("FILLED");
                } else if (tool === 'text') {
                    setTextPos(pos);
                    setShowTextInput(true);
                    setStatus("TYPE TEXT");
                } else if (['rect', 'circle', 'line'].includes(tool)) {
                    setIsDrawing(true);
                    setStartPos(pos);
                    saveSnapshot();
                } else {
                    setIsDrawing(true);
                    setStartPos(pos);
                    const ctx = canvasRef.current.getContext('2d');
                    ctx.beginPath();
                    ctx.moveTo(pos.x, pos.y);
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.lineWidth = size;
                    ctx.strokeStyle = tool === 'eraser' ? '#ffffff' : color;
                }
            };

            const draw = (e) => {
                if (!isDrawing) return;
                const ctx = canvasRef.current.getContext('2d');
                const pos = getMousePos(e);

                if (tool === 'brush' || tool === 'eraser') {
                    ctx.lineTo(pos.x, pos.y);
                    ctx.stroke();
                } else if (['rect', 'circle', 'line'].includes(tool)) {
                    restoreSnapshot();
                    ctx.strokeStyle = color;
                    ctx.fillStyle = color;
                    ctx.lineWidth = size;

                    if (tool === 'rect') {
                        ctx.strokeRect(startPos.x, startPos.y, pos.x - startPos.x, pos.y - startPos.y);
                    } else if (tool === 'circle') {
                        const rx = Math.abs(pos.x - startPos.x) / 2;
                        const ry = Math.abs(pos.y - startPos.y) / 2;
                        const cx = startPos.x + (pos.x - startPos.x) / 2;
                        const cy = startPos.y + (pos.y - startPos.y) / 2;
                        ctx.beginPath();
                        ctx.ellipse(cx, cy, rx, ry, 0, 0, 2 * Math.PI);
                        ctx.stroke();
                    } else if (tool === 'line') {
                        ctx.beginPath();
                        ctx.moveTo(startPos.x, startPos.y);
                        ctx.lineTo(pos.x, pos.y);
                        ctx.stroke();
                    }
                }
            };

            const endDraw = () => {
                if (isDrawing) {
                    setIsDrawing(false);
                    if (tool === 'brush' || tool === 'eraser') {
                        canvasRef.current.getContext('2d').closePath();
                    }
                    saveToHistory();
                }
            };

            const placeText = () => {
                if (textInput.trim()) {
                    const ctx = canvasRef.current.getContext('2d');
                    ctx.fillStyle = color;
                    ctx.font = `${size * 4}px 'Geist Mono', monospace`;
                    ctx.fillText(textInput, textPos.x, textPos.y);
                    setStatus("TEXT PLACED");
                    saveToHistory();
                }
                setShowTextInput(false);
                setTextInput('');
            };

            const send = () => {
                setStatus("ENCRYPTING...");
                setTimeout(() => setStatus("UPLOADING..."), 500);
                setTimeout(() => setStatus("SENT TO MATEUS"), 1200);
            };

            const clear = () => {
                const ctx = canvasRef.current.getContext('2d');
                ctx.fillStyle = "#ffffff";
                ctx.fillRect(0, 0, canvasRef.current.width, canvasRef.current.height);
                setStatus("CLEARED");
                saveToHistory();
            };

            // Pixel knob component
            const PixelKnob = ({ value, onChange, min, max }) => {
                const knobSize = 24;
                const rotation = ((value - min) / (max - min)) * 270 - 135;
                return (
                    <div
                        className="relative cursor-pointer select-none"
                        style={{ width: knobSize, height: knobSize }}
                        onMouseDown={(e) => {
                            e.preventDefault();
                            const startY = e.clientY;
                            const startVal = value;
                            const onMove = (ev) => {
                                const diff = startY - ev.clientY;
                                const newVal = Math.min(max, Math.max(min, startVal + Math.floor(diff / 5)));
                                onChange(newVal);
                            };
                            const onUp = () => {
                                window.removeEventListener('mousemove', onMove);
                                window.removeEventListener('mouseup', onUp);
                            };
                            window.addEventListener('mousemove', onMove);
                            window.addEventListener('mouseup', onUp);
                        }}
                    >
                        <svg width={knobSize} height={knobSize} viewBox="0 0 24 24" style={{ imageRendering: 'pixelated' }}>
                            <rect x="4" y="4" width="16" height="16" fill="#000" />
                            <rect x="6" y="6" width="12" height="12" fill="#fff" />
                            <rect x="10" y="6" width="4" height="6" fill="#000" transform={`rotate(${rotation}, 12, 12)`} />
                        </svg>
                    </div>
                );
            };

            const tools = ['brush', 'eraser', 'bucket', 'line', 'rect', 'circle', 'text'];
            const colors = ['#000000', '#ffffff', '#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ff8800', '#8800ff'];

            return (
                <div className="h-full flex flex-col bg-gray-100 select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex flex-wrap gap-2 items-center">
                        <div className="flex gap-1">
                            <button onClick={undo} className="p-1 border border-black hover:bg-gray-100" title="Undo"><Icons.Undo size={16} /></button>
                            <button onClick={redo} className="p-1 border border-black hover:bg-gray-100" title="Redo"><Icons.Redo size={16} /></button>
                        </div>
                        <div className="w-px h-4 bg-black"></div>
                        <div className="flex gap-1 flex-wrap">
                            {tools.map(t => (
                                <button key={t} onClick={() => setTool(t)} className={`px-2 py-1 text-[10px] font-bold border border-black uppercase ${tool === t ? 'bg-black text-white' : 'bg-white hover:bg-gray-100'}`}>{t}</button>
                            ))}
                        </div>
                        <div className="w-px h-4 bg-black"></div>
                        <div className="flex gap-1 flex-wrap">
                            {colors.map(c => (
                                <button key={c} onClick={() => setColor(c)} className={`w-5 h-5 border border-black ${color === c ? 'ring-2 ring-offset-1 ring-black' : ''}`} style={{ backgroundColor: c }} />
                            ))}
                        </div>
                        <div className="w-px h-4 bg-black"></div>
                        <div className="flex items-center gap-1">
                            <PixelKnob value={size} onChange={setSize} min={1} max={20} />
                            <span className="text-[10px] font-mono w-4">{size}</span>
                        </div>
                        <div className="flex-grow"></div>
                        <button onClick={send} className="px-2 py-1 border border-black bg-black text-white text-xs font-bold hover:invert flex items-center gap-1"><Icons.Send size={12} /> SEND</button>
                    </div>
                    <div className="flex-grow relative cursor-crosshair bg-gray-300 p-[2px] overflow-hidden" ref={containerRef}>
                        <canvas
                            ref={canvasRef}
                            onMouseDown={startDraw}
                            onMouseMove={draw}
                            onMouseUp={endDraw}
                            onMouseLeave={endDraw}
                            className="block bg-white border border-gray-400"
                            style={{ width: '100%', height: '100%' }}
                        />
                        {showTextInput && (
                            <div className="absolute top-2 left-2 bg-white border-2 border-black p-2 flex gap-2">
                                <input
                                    type="text"
                                    value={textInput}
                                    onChange={(e) => setTextInput(e.target.value)}
                                    onKeyDown={(e) => e.key === 'Enter' && placeText()}
                                    placeholder="Type text..."
                                    className="border border-black px-2 py-1 text-xs font-mono"
                                    autoFocus
                                />
                                <button onClick={placeText} className="bg-black text-white px-2 text-xs font-bold">OK</button>
                            </div>
                        )}
                        <div className="absolute bottom-1 left-1 bg-black text-white text-[10px] px-2 font-mono">{status}</div>
                    </div>
                </div>
            )
        }

        const FileExplorer = () => {
            const [selectedFolder, setSelectedFolder] = useState(null);

            const folders = [
                { key: 'CINEMA_TV', name: 'MOVIES', icon: 'Movies' },
                { key: 'LITERATURE', name: 'BOOKS', icon: 'Books' },
                { key: 'GAMES', name: 'GAMES', icon: 'Games' },
                { key: 'AUDIO', name: 'MUSIC', icon: 'Music' }
            ];

            if (selectedFolder) {
                const FolderIcon = Icons[folders.find(f => f.key === selectedFolder)?.icon || 'Folder'];
                return (
                    <div className="h-full flex flex-col bg-white select-none">
                        <div className="p-3 border-b-2 border-black bg-gray-50 flex items-center gap-3">
                            <button onClick={() => setSelectedFolder(null)} className="p-1 border border-black hover:bg-black hover:text-white">
                                <Icons.Back size={16} />
                            </button>
                            <FolderIcon size={24} />
                            <span className="font-mono text-sm font-bold uppercase">{folders.find(f => f.key === selectedFolder)?.name}</span>
                            <span className="font-mono text-xs text-gray-400">({MEDIA_DB[selectedFolder].length} items)</span>
                        </div>
                        <div className="flex-grow overflow-auto">
                            <table className="w-full text-left border-collapse">
                                <thead className="bg-black text-white text-xs font-mono sticky top-0">
                                    <tr><th className="p-2">TITLE</th><th className="p-2 border-l border-gray-600">NOTE</th></tr>
                                </thead>
                                <tbody className="font-mono text-xs">
                                    {MEDIA_DB[selectedFolder].map((i, idx) => (
                                        <tr key={idx} className="border-b border-gray-200 hover:bg-yellow-100">
                                            <td className="p-2 font-bold">{i.title}</td>
                                            <td className="p-2 border-l border-gray-200">{i.rating || i.artist}</td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                    </div>
                );
            }

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-3 border-b-2 border-black bg-gray-50">
                        <span className="font-mono text-xs font-bold text-gray-400">/ROOT/MEDIA</span>
                    </div>
                    <div className="flex-grow p-6 flex items-start justify-center">
                        <div className="grid grid-cols-4 gap-8">
                            {folders.map(folder => {
                                const FolderIcon = Icons[folder.icon];
                                return (
                                    <button
                                        key={folder.key}
                                        onClick={() => setSelectedFolder(folder.key)}
                                        className="group flex flex-col items-center gap-2 p-4 hover:bg-gray-100 border-2 border-transparent hover:border-black transition-all"
                                    >
                                        <div className="bg-white border-2 border-black p-3 icon-shadow group-hover:translate-x-1 group-hover:translate-y-1 group-hover:shadow-none transition-all">
                                            <FolderIcon size={48} />
                                        </div>
                                        <span className="font-mono text-xs font-bold uppercase">{folder.name}</span>
                                        <span className="font-mono text-[10px] text-gray-400">{MEDIA_DB[folder.key].length} items</span>
                                    </button>
                                );
                            })}
                        </div>
                    </div>
                </div>
            );
        }

        const SystemInfo = () => (
            <div className="p-6 md:p-12 font-sans select-text">
                <header className="mb-12 border-b-4 border-black pb-8">
                    <h1 className="text-6xl md:text-8xl font-black uppercase tracking-tighter leading-none">Mateus<br />Muste</h1>
                    <div className="mt-4 flex flex-wrap gap-4 font-mono text-sm">
                        <span className="bg-black text-white px-2 py-1">FULL STACK ENGINEER</span>
                        <span className="border border-black px-2 py-1">ROMANIA</span>
                    </div>
                </header>
                <div className="grid md:grid-cols-2 gap-12">
                    <div className="space-y-8">
                        <section><h3 className="text-2xl font-black uppercase mb-4 border-b-2 border-black">Stack</h3>
                            <div className="flex flex-wrap gap-2">{['TS', 'React', 'Next', 'Rust', 'Go', 'AWS', 'Node', 'K8S', 'SQL', 'AI'].map(t => (<span key={t} className="px-2 py-1 border-2 border-black font-mono text-xs font-bold hover:bg-black hover:text-white cursor-crosshair">{t}</span>))}</div>
                        </section>
                        <section><h3 className="text-2xl font-black uppercase mb-4 border-b-2 border-black">Metrics</h3>
                            <div className="flex gap-4">
                                <div className="p-4 border-2 border-black text-center"><div className="text-3xl font-black">C2</div><div className="font-mono text-[10px]">CAMBRIDGE</div></div>
                                <div className="p-4 border-2 border-black text-center"><div className="text-3xl font-black">1570</div><div className="font-mono text-[10px]">SAT</div></div>
                            </div>
                        </section>
                    </div>
                    <div className="space-y-4">
                        <h3 className="text-2xl font-black uppercase mb-4 border-b-2 border-black">Projects</h3>
                        {[{ t: "AlgoTrade Bot", s: "Python/NLP", d: "Automated sentiment trading." }, { t: "NeuralSynth", s: "Rust/WASM", d: "Generative audio RNN." }, { t: "GraphVault", s: "WebGL", d: "3D knowledge graph." }].map((p, i) => (
                            <div key={i} className="group border-2 border-black p-4 hover:bg-black hover:text-white cursor-pointer">
                                <div className="flex justify-between mb-1"><h4 className="font-bold uppercase">{p.t}</h4><span className="font-mono text-xs">0{i + 1}</span></div>
                                <p className="font-mono text-xs opacity-70 mb-1">{p.s}</p><p className="text-sm italic">{p.d}</p>
                            </div>
                        ))}
                    </div>
                </div>
            </div>
        )

        const TrashApp = () => {
            const [shakingFile, setShakingFile] = useState(null);

            const trashFiles = [
                { name: 'MY_BITCOIN_WALLET.txt', icon: 'FileDoc' },
                { name: 'sleep_schedule.ics', icon: 'FileDoc' },
                { name: 'NYU_acceptance_letter.pdf', icon: 'FileDoc' }
            ];

            const handleFileClick = (fileName) => {
                setShakingFile(fileName);
                setTimeout(() => setShakingFile(null), 500);
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-3 border-b-2 border-black bg-gray-50 flex items-center gap-2">
                        <Icons.TrashCan size={24} />
                        <span className="font-mono text-sm font-bold uppercase">RECYCLE BIN</span>
                        <span className="font-mono text-xs text-gray-400">({trashFiles.length} items)</span>
                    </div>
                    <div className="flex-grow p-6">
                        <div className="grid grid-cols-3 gap-6">
                            {trashFiles.map(file => (
                                <button
                                    key={file.name}
                                    onClick={() => handleFileClick(file.name)}
                                    className="group flex flex-col items-center gap-2 p-4 cursor-not-allowed"
                                    style={{
                                        animation: shakingFile === file.name ? 'shake 0.5s ease-in-out' : 'none'
                                    }}
                                >
                                    <div className="bg-white border-2 border-black p-3 icon-shadow opacity-50">
                                        <Icons.FileDoc size={32} />
                                    </div>
                                    <span className="font-mono text-[10px] font-bold text-center break-all opacity-70">{file.name}</span>
                                </button>
                            ))}
                        </div>
                        <div className="mt-8 p-4 border-2 border-dashed border-gray-300 text-center">
                            <span className="font-mono text-xs text-gray-400">ITEMS CANNOT BE RECOVERED</span>
                        </div>
                    </div>
                    <style>{`
                        @keyframes shake {
                            0%, 100% { transform: translateX(0); }
                            10%, 30%, 50%, 70%, 90% { transform: translateX(-4px); }
                            20%, 40%, 60%, 80% { transform: translateX(4px); }
                        }
                    `}</style>
                </div>
            );
        }

        // --- VOID.TXT - Text disappears into the void ---
        const VoidApp = () => {
            const [lines, setLines] = useState([]);
            const [currentText, setCurrentText] = useState('');
            const inputRef = useRef(null);

            const handleKeyDown = (e) => {
                if (e.key === 'Enter' && currentText.trim()) {
                    const newLine = { id: Date.now(), text: currentText, opacity: 1 };
                    setLines(prev => [...prev, newLine]);
                    setCurrentText('');

                    // Start fading after 3 seconds
                    setTimeout(() => {
                        const fadeInterval = setInterval(() => {
                            setLines(prev => prev.map(line =>
                                line.id === newLine.id
                                    ? { ...line, opacity: Math.max(0, line.opacity - 0.1) }
                                    : line
                            ).filter(line => line.opacity > 0));
                        }, 100);
                        setTimeout(() => clearInterval(fadeInterval), 1100);
                    }, 3000);
                }
            };

            return (
                <div
                    className="h-full flex flex-col bg-black select-none cursor-text"
                    onClick={() => inputRef.current?.focus()}
                    onCopy={(e) => e.preventDefault()}
                    onCut={(e) => e.preventDefault()}
                >
                    <div className="p-2 border-b border-gray-800 flex justify-between items-center">
                        <span className="font-mono text-xs text-gray-500">VOID.TXT</span>
                        <span className="font-mono text-[10px] text-gray-700">NO SAVE // NO COPY // JUST VOID</span>
                    </div>
                    <div className="flex-grow p-4 overflow-auto font-mono text-sm">
                        {lines.map(line => (
                            <div
                                key={line.id}
                                className="mb-1 transition-all duration-100"
                                style={{
                                    color: `rgba(255,255,255,${line.opacity})`,
                                    textShadow: line.opacity > 0.5 ? '0 0 10px rgba(255,255,255,0.3)' : 'none'
                                }}
                            >
                                {line.text}
                            </div>
                        ))}
                        <div className="flex items-center text-white">
                            <span className="mr-2 text-gray-500">{'>'}</span>
                            <input
                                ref={inputRef}
                                type="text"
                                value={currentText}
                                onChange={(e) => setCurrentText(e.target.value)}
                                onKeyDown={handleKeyDown}
                                className="bg-transparent outline-none flex-grow text-white caret-white"
                                autoFocus
                                onPaste={(e) => e.preventDefault()}
                            />
                            <span className="animate-pulse text-white">_</span>
                        </div>
                    </div>
                    <div className="p-2 border-t border-gray-800 text-center">
                        <span className="font-mono text-[10px] text-gray-600">WRITE INTO THE VOID. WATCH IT DISAPPEAR.</span>
                    </div>
                </div>
            );
        };

        // --- ORACLE.EXE - Philosophical quotes ---
        const OracleApp = () => {
            const quotes = [
                "The soul is healed by being with children.",
                "Man is condemned to be free.",
                "He who has a why to live can bear almost any how.",
                "The question isn't who is going to let me; it's who is going to stop me.",
                "One must imagine Sisyphus happy.",
                "Pain and suffering are always inevitable for a large intelligence and a deep heart.",
                "God is dead. God remains dead. And we have killed him.",
                "I swear by my life and my love of it that I will never live for the sake of another man.",
                "In the depth of winter, I finally learned that within me there lay an invincible summer.",
                "The higher we soar the smaller we appear to those who cannot fly.",
                "The soul that sees beauty may sometimes walk alone.",
                "Should I kill myself, or have a cup of coffee?",
                "To live is to suffer, to survive is to find some meaning in the suffering.",
                "The only thing I know is that I know nothing.",
                "Beauty will save the world.",
                "There is always some madness in love. But there is also always some reason in madness.",
                "Man is the only creature who refuses to be what he is.",
                "A is A. A thing is itself.",
                "What does not kill me makes me stronger.",
                "The absurd is born of the confrontation between the human call and the unreasonable silence of the world.",
                "The best way to find yourself is to lose yourself in the service of others.",
                "Every deep thinker is more afraid of being understood than of being misunderstood.",
                "Money is only a tool. It will take you wherever you wish, but it will not replace you as the driver.",
                "We are all in the gutter, but some of us are looking at the stars.",
                "The only way to deal with an unfree world is to become so absolutely free that your very existence is an act of rebellion.",
                "Above all, don't lie to yourself.",
                "Whoever fights monsters should see to it that in the process he does not become a monster.",
                "I rebel; therefore I exist.",
                "The secret of happiness is freedom, the secret of freedom is courage.",
                "There is but one truly serious philosophical problem, and that is suicide."
            ];

            const [question, setQuestion] = useState('');
            const [answer, setAnswer] = useState(null);
            const [isThinking, setIsThinking] = useState(false);

            const askOracle = () => {
                if (!question.trim()) return;
                setIsThinking(true);
                setAnswer(null);

                setTimeout(() => {
                    const randomQuote = quotes[Math.floor(Math.random() * quotes.length)];
                    setAnswer(randomQuote);
                    setIsThinking(false);
                    setQuestion('');
                }, 1500 + Math.random() * 1000);
            };

            return (
                <div className="h-full flex flex-col bg-gray-900 text-white select-none">
                    <div className="p-3 border-b border-gray-700 bg-black">
                        <span className="font-mono text-xs text-gray-400">ORACLE.EXE // ASK THE DEAD</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-8">
                        {answer && (
                            <div className="mb-8 text-center max-w-lg">
                                <div className="text-2xl font-serif italic leading-relaxed mb-4">"{answer}"</div>
                                <div className="text-xs text-gray-500 font-mono"> THE ORACLE HAS SPOKEN</div>
                            </div>
                        )}
                        {isThinking && (
                            <div className="mb-8 text-center">
                                <div className="font-mono text-sm text-gray-400 animate-pulse">
                                    CONSULTING THE VOID...
                                </div>
                            </div>
                        )}
                        <div className="w-full max-w-md">
                            <input
                                type="text"
                                value={question}
                                onChange={(e) => setQuestion(e.target.value)}
                                onKeyDown={(e) => e.key === 'Enter' && askOracle()}
                                placeholder="ASK YOUR QUESTION..."
                                className="w-full bg-black border-2 border-gray-600 px-4 py-3 font-mono text-sm text-white placeholder-gray-600 focus:border-white outline-none"
                                disabled={isThinking}
                            />
                            <button
                                onClick={askOracle}
                                disabled={isThinking}
                                className="w-full mt-2 bg-white text-black py-2 font-mono font-bold text-sm hover:bg-gray-200 disabled:opacity-50"
                            >
                                SEEK TRUTH
                            </button>
                        </div>
                    </div>
                    <div className="p-2 border-t border-gray-800 text-center">
                        <span className="font-mono text-[10px] text-gray-600">DOSTOEVSKY  NIETZSCHE  RAND  CAMUS</span>
                    </div>
                </div>
            );
        };

        // --- RADIO.WAV - Playlist link ---
        const RadioApp = () => {
            const [isPlaying, setIsPlaying] = useState(false);
            const [visualizer, setVisualizer] = useState([]);

            useEffect(() => {
                const interval = setInterval(() => {
                    if (isPlaying) {
                        setVisualizer(Array(16).fill(0).map(() => Math.random() * 100));
                    }
                }, 100);
                return () => clearInterval(interval);
            }, [isPlaying]);

            const openPlaylist = () => {
                window.open('https://music.youtube.com/playlist?list=PLeIQRsOWZUhKaD53FTvwZCxsNWzjq0lfO&si=92O5A6kAPjk8Vzmg', '_blank');
                setIsPlaying(true);
            };

            return (
                <div className="h-full flex flex-col bg-black text-white select-none">
                    <div className="p-3 border-b border-gray-800">
                        <span className="font-mono text-xs text-gray-500">RADIO.WAV // MATEUS_PLAYLIST</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-8">
                        <div className="flex items-end justify-center gap-1 h-32 mb-8">
                            {(isPlaying ? visualizer : Array(16).fill(10)).map((h, i) => (
                                <div
                                    key={i}
                                    className="w-3 bg-white transition-all duration-100"
                                    style={{ height: `${h}%`, minHeight: '4px' }}
                                />
                            ))}
                        </div>
                        <button
                            onClick={openPlaylist}
                            className="bg-white text-black px-8 py-4 font-mono font-bold text-lg hover:bg-gray-200 border-4 border-white hover:border-gray-400 transition-all"
                        >
                            {isPlaying ? ' NOW PLAYING' : ' TUNE IN'}
                        </button>
                        <div className="mt-4 font-mono text-xs text-gray-500">
                            OPENS YOUTUBE MUSIC
                        </div>
                    </div>
                    <div className="p-4 border-t border-gray-800">
                        <div className="font-mono text-[10px] text-gray-600 text-center">
                            BROADCASTING FROM THE VOID
                        </div>
                    </div>
                </div>
            );
        };

        // --- DICE.EXE - D20 Roller with ASCII art ---
        const DiceApp = () => {
            const [result, setResult] = useState(null);
            const [isRolling, setIsRolling] = useState(false);
            const [rotation, setRotation] = useState(0);

            const d20Faces = [
                '        ',
                '      {n}      ',
                '           ',
                '           ',
                '',
                '           ',
                '           ',
                '           ',
                '      '
            ];

            const rollDice = () => {
                if (isRolling) return;
                setIsRolling(true);
                setResult(null);

                let rolls = 0;
                const maxRolls = 15;
                const rollInterval = setInterval(() => {
                    setResult(Math.floor(Math.random() * 20) + 1);
                    setRotation(r => r + 30);
                    rolls++;

                    if (rolls >= maxRolls) {
                        clearInterval(rollInterval);
                        setResult(Math.floor(Math.random() * 20) + 1);
                        setIsRolling(false);
                    }
                }, 80);
            };

            const getResultColor = () => {
                if (!result) return 'text-white';
                if (result === 20) return 'text-green-400';
                if (result === 1) return 'text-red-400';
                return 'text-white';
            };

            return (
                <div className="h-full flex flex-col bg-gray-900 text-white select-none">
                    <div className="p-3 border-b border-gray-700 bg-black">
                        <span className="font-mono text-xs text-gray-400">DICE.EXE // D20 ROLLER</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-4">
                        <pre
                            className={`font-mono text-xs md:text-sm leading-tight mb-6 transition-transform duration-100 ${getResultColor()}`}
                            style={{ transform: `rotate(${isRolling ? rotation % 360 : 0}deg)` }}
                        >
{`        
        
         
       ${result ? String(result).padStart(2, ' ') : '??'}  
         
          
  
            
           
          
     
          
         
        `}
                        </pre>
                        {result && !isRolling && (
                            <div className={`text-4xl font-black mb-4 ${getResultColor()}`}>
                                {result === 20 ? 'CRITICAL HIT!' : result === 1 ? 'CRITICAL FAIL!' : result}
                            </div>
                        )}
                        <button
                            onClick={rollDice}
                            disabled={isRolling}
                            className="bg-white text-black px-8 py-3 font-mono font-bold text-sm hover:bg-gray-200 disabled:opacity-50 border-2 border-white"
                        >
                            {isRolling ? 'ROLLING...' : 'ROLL D20'}
                        </button>
                    </div>
                </div>
            );
        };

        // --- Updated SNEK.EXE with Ghost ---
        const SnakeAppNew = () => {
            const canvasRef = useRef(null);
            const [score, setScore] = useState(0);
            const [highScore, setHighScore] = useState(0);
            const [gameOver, setGameOver] = useState(false);
            const [gameStarted, setGameStarted] = useState(false);
            const snake = useRef([{ x: 15, y: 10 }]);
            const food = useRef({ x: 20, y: 10 });
            const ghost = useRef({ x: 5, y: 10 });
            const dir = useRef({ x: 1, y: 0 });
            const nextDir = useRef({ x: 1, y: 0 });
            const loopRef = useRef(null);

            const GRID_W = 30;
            const GRID_H = 20;
            const CELL = 20;

            const start = () => {
                snake.current = [{ x: 15, y: 10 }, { x: 14, y: 10 }, { x: 13, y: 10 }];
                dir.current = { x: 1, y: 0 };
                nextDir.current = { x: 1, y: 0 };
                food.current = { x: Math.floor(Math.random() * GRID_W), y: Math.floor(Math.random() * GRID_H) };
                ghost.current = { x: 2, y: 2 };
                setScore(0);
                setGameOver(false);
                setGameStarted(true);
                if (loopRef.current) clearInterval(loopRef.current);
                loopRef.current = setInterval(update, 100);
            };

            const update = () => {
                const ctx = canvasRef.current?.getContext('2d');
                if (!ctx) return;

                dir.current = nextDir.current;
                const head = {
                    x: snake.current[0].x + dir.current.x,
                    y: snake.current[0].y + dir.current.y
                };

                // Wall collision
                if (head.x < 0 || head.x >= GRID_W || head.y < 0 || head.y >= GRID_H) {
                    endGame();
                    return;
                }

                // Self collision
                if (snake.current.some(s => s.x === head.x && s.y === head.y)) {
                    endGame();
                    return;
                }

                // Ghost collision
                if (ghost.current.x === head.x && ghost.current.y === head.y) {
                    endGame();
                    return;
                }

                snake.current.unshift(head);

                // Eat food
                if (head.x === food.current.x && head.y === food.current.y) {
                    setScore(s => {
                        const newScore = s + 10;
                        setHighScore(h => Math.max(h, newScore));
                        return newScore;
                    });
                    food.current = {
                        x: Math.floor(Math.random() * GRID_W),
                        y: Math.floor(Math.random() * GRID_H)
                    };
                } else {
                    snake.current.pop();
                }

                // Move ghost towards snake head
                const dx = head.x - ghost.current.x;
                const dy = head.y - ghost.current.y;
                if (Math.abs(dx) > Math.abs(dy)) {
                    ghost.current.x += dx > 0 ? 1 : -1;
                } else if (dy !== 0) {
                    ghost.current.y += dy > 0 ? 1 : -1;
                }

                // Draw
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, GRID_W * CELL, GRID_H * CELL);

                // Grid lines (subtle)
                ctx.strokeStyle = '#222';
                for (let i = 0; i <= GRID_W; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * CELL, 0);
                    ctx.lineTo(i * CELL, GRID_H * CELL);
                    ctx.stroke();
                }
                for (let i = 0; i <= GRID_H; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, i * CELL);
                    ctx.lineTo(GRID_W * CELL, i * CELL);
                    ctx.stroke();
                }

                // Snake
                snake.current.forEach((s, i) => {
                    ctx.fillStyle = i === 0 ? '#fff' : '#888';
                    ctx.fillRect(s.x * CELL + 1, s.y * CELL + 1, CELL - 2, CELL - 2);
                });

                // Food
                ctx.fillStyle = '#fff';
                ctx.fillRect(food.current.x * CELL + 4, food.current.y * CELL + 4, CELL - 8, CELL - 8);

                // Ghost (semi-transparent)
                ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
                ctx.beginPath();
                ctx.arc(ghost.current.x * CELL + CELL/2, ghost.current.y * CELL + CELL/2, CELL/2 - 2, 0, Math.PI * 2);
                ctx.fill();
                // Ghost eyes
                ctx.fillStyle = '#fff';
                ctx.fillRect(ghost.current.x * CELL + 5, ghost.current.y * CELL + 6, 4, 4);
                ctx.fillRect(ghost.current.x * CELL + 11, ghost.current.y * CELL + 6, 4, 4);
            };

            const endGame = () => {
                setGameOver(true);
                setGameStarted(false);
                clearInterval(loopRef.current);
            };

            useEffect(() => {
                const handle = (e) => {
                    if (!gameStarted) return;
                    if (e.key === 'ArrowUp' && dir.current.y === 0) nextDir.current = { x: 0, y: -1 };
                    if (e.key === 'ArrowDown' && dir.current.y === 0) nextDir.current = { x: 0, y: 1 };
                    if (e.key === 'ArrowLeft' && dir.current.x === 0) nextDir.current = { x: -1, y: 0 };
                    if (e.key === 'ArrowRight' && dir.current.x === 0) nextDir.current = { x: 1, y: 0 };
                };
                window.addEventListener('keydown', handle);
                return () => {
                    window.removeEventListener('keydown', handle);
                    clearInterval(loopRef.current);
                };
            }, [gameStarted]);

            // Initial canvas draw
            useEffect(() => {
                const ctx = canvasRef.current?.getContext('2d');
                if (ctx) {
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(0, 0, GRID_W * CELL, GRID_H * CELL);
                }
            }, []);

            return (
                <div className="h-full flex flex-col items-center justify-center bg-black p-4 select-none">
                    <div className="flex justify-between w-[600px] font-mono text-xs mb-2 text-gray-400">
                        <span>SCORE: <span className="text-white">{score}</span></span>
                        <span>HIGH: <span className="text-white">{highScore}</span></span>
                        <span className={gameOver ? 'text-red-500' : gameStarted ? 'text-green-500' : 'text-gray-500'}>
                            {gameOver ? 'DEAD' : gameStarted ? 'ALIVE' : 'READY'}
                        </span>
                    </div>
                    <div className="relative border-2 border-gray-800">
                        <canvas ref={canvasRef} width={600} height={400} className="block" />
                        {!gameStarted && (
                            <div className="absolute inset-0 bg-black/90 flex flex-col items-center justify-center text-white">
                                <pre className="font-mono text-xs mb-4 text-gray-500">
{`  
         
         
  `}
                                </pre>
                                <h1 className="text-3xl font-black mb-2 tracking-widest">SNEK</h1>
                                {gameOver && <p className="text-red-500 mb-4 font-mono text-sm">THE GHOST GOT YOU</p>}
                                <button
                                    onClick={start}
                                    className="border-2 border-white px-6 py-2 hover:bg-white hover:text-black font-mono font-bold text-sm"
                                >
                                    {gameOver ? 'RETRY' : 'START'}
                                </button>
                                <p className="mt-4 text-gray-600 font-mono text-xs">ARROW KEYS TO MOVE</p>
                                <p className="text-gray-700 font-mono text-xs">AVOID THE GHOST</p>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // --- LABYRINTH.EXE - Procedural Maze ---
        const LabyrinthApp = () => {
            const canvasRef = useRef(null);
            const [level, setLevel] = useState(1);
            const [score, setScore] = useState(0);
            const [highScore, setHighScore] = useState(0);
            const [won, setWon] = useState(false);
            const [showingMaze, setShowingMaze] = useState(false);
            const mazeRef = useRef(null);
            const playerRef = useRef({ x: 1, y: 1 });
            const exitRef = useRef({ x: 0, y: 0 });

            const CELL_SIZE = 15;

            const generateMaze = (width, height) => {
                const maze = Array(height).fill(null).map(() => Array(width).fill(1));

                const carve = (x, y) => {
                    maze[y][x] = 0;
                    const directions = [[0, -2], [0, 2], [-2, 0], [2, 0]].sort(() => Math.random() - 0.5);

                    for (const [dx, dy] of directions) {
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx > 0 && nx < width - 1 && ny > 0 && ny < height - 1 && maze[ny][nx] === 1) {
                            maze[y + dy/2][x + dx/2] = 0;
                            carve(nx, ny);
                        }
                    }
                };

                carve(1, 1);
                return maze;
            };

            const startLevel = (lvl) => {
                const size = 15 + lvl * 4;
                const maze = generateMaze(size | 1, size | 1);
                mazeRef.current = maze;
                playerRef.current = { x: 1, y: 1 };

                // Find exit (bottom-right area)
                for (let y = maze.length - 2; y > maze.length / 2; y--) {
                    for (let x = maze[0].length - 2; x > maze[0].length / 2; x--) {
                        if (maze[y][x] === 0) {
                            exitRef.current = { x, y };
                            break;
                        }
                    }
                    if (exitRef.current.x !== 0) break;
                }

                setWon(false);
                setShowingMaze(false);
                draw();
            };

            const draw = () => {
                const canvas = canvasRef.current;
                if (!canvas || !mazeRef.current) return;
                const ctx = canvas.getContext('2d');
                const maze = mazeRef.current;

                canvas.width = maze[0].length * CELL_SIZE;
                canvas.height = maze.length * CELL_SIZE;

                // Draw maze
                for (let y = 0; y < maze.length; y++) {
                    for (let x = 0; x < maze[0].length; x++) {
                        ctx.fillStyle = maze[y][x] === 1 ? '#000' : '#fff';
                        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }

                // Draw exit
                ctx.fillStyle = '#0f0';
                ctx.fillRect(exitRef.current.x * CELL_SIZE + 2, exitRef.current.y * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);

                // Draw player
                ctx.fillStyle = '#f00';
                ctx.fillRect(playerRef.current.x * CELL_SIZE + 2, playerRef.current.y * CELL_SIZE + 2, CELL_SIZE - 4, CELL_SIZE - 4);
            };

            const move = (dx, dy) => {
                if (won || showingMaze) return;
                const maze = mazeRef.current;
                if (!maze) return;

                const nx = playerRef.current.x + dx;
                const ny = playerRef.current.y + dy;

                if (nx >= 0 && nx < maze[0].length && ny >= 0 && ny < maze.length && maze[ny][nx] === 0) {
                    playerRef.current = { x: nx, y: ny };
                    draw();

                    if (nx === exitRef.current.x && ny === exitRef.current.y) {
                        const points = level * 100;
                        setScore(s => {
                            const newScore = s + points;
                            setHighScore(h => Math.max(h, newScore));
                            return newScore;
                        });
                        setWon(true);

                        // Show full maze then start next level
                        setTimeout(() => {
                            setShowingMaze(true);
                            setTimeout(() => {
                                setLevel(l => l + 1);
                                startLevel(level + 1);
                            }, 2000);
                        }, 1000);
                    }
                }
            };

            const giveUp = () => {
                setLevel(1);
                setScore(0);
                startLevel(1);
            };

            useEffect(() => {
                const handle = (e) => {
                    if (e.key === 'ArrowUp') move(0, -1);
                    if (e.key === 'ArrowDown') move(0, 1);
                    if (e.key === 'ArrowLeft') move(-1, 0);
                    if (e.key === 'ArrowRight') move(1, 0);
                };
                window.addEventListener('keydown', handle);
                startLevel(1);
                return () => window.removeEventListener('keydown', handle);
            }, []);

            return (
                <div className="h-full flex flex-col bg-gray-100 select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex justify-between items-center">
                        <span className="font-mono text-xs font-bold">LABYRINTH.EXE</span>
                        <div className="flex gap-4 font-mono text-xs">
                            <span>LVL: {level}</span>
                            <span>SCORE: {score}</span>
                            <span>HIGH: {highScore}</span>
                        </div>
                    </div>
                    <div className="flex-grow flex items-center justify-center p-4 overflow-auto relative">
                        {won && !showingMaze && (
                            <div className="absolute inset-0 bg-black/80 flex items-center justify-center z-10">
                                <div className="text-white text-center">
                                    <div className="text-2xl font-black mb-2">YOU FOUND THE WAY OUT</div>
                                    <div className="font-mono text-sm text-gray-400">+{level * 100} POINTS</div>
                                </div>
                            </div>
                        )}
                        {showingMaze && (
                            <div className="absolute inset-0 bg-black/80 flex items-center justify-center z-10">
                                <div className="text-white text-center">
                                    <div className="text-xl font-mono mb-2">MAZE {level} COMPLETE</div>
                                    <div className="font-mono text-xs text-gray-400">GENERATING HARDER MAZE...</div>
                                </div>
                            </div>
                        )}
                        <div className="border-4 border-black bg-white p-1">
                            <canvas ref={canvasRef} className="block" style={{ imageRendering: 'pixelated' }} />
                        </div>
                    </div>
                    <div className="p-2 border-t-2 border-black bg-white flex justify-between items-center">
                        <span className="font-mono text-[10px] text-gray-500">ARROW KEYS TO MOVE</span>
                        <button
                            onClick={giveUp}
                            className="font-mono text-[10px] text-gray-500 hover:text-black"
                        >
                            GIVE UP? "How will we ever get out of this labyrinth?"
                        </button>
                    </div>
                </div>
            );
        };

        // --- SYNTH_001.WAV - Brutalist Synthesizer ---
        const SynthApp = () => {
            const [tempo, setTempo] = useState(120);
            const [filter, setFilter] = useState(1000);
            const [isPlaying, setIsPlaying] = useState(false);
            const [currentStep, setCurrentStep] = useState(0);
            const [grid, setGrid] = useState(() => {
                return {
                    sine: Array(16).fill(false),
                    square: Array(16).fill(false),
                    saw: Array(16).fill(false),
                    noise: Array(16).fill(false)
                };
            });
            const audioCtxRef = useRef(null);
            const intervalRef = useRef(null);

            const oscillators = ['sine', 'square', 'saw', 'noise'];

            const toggleNote = (osc, step) => {
                setGrid(prev => ({
                    ...prev,
                    [osc]: prev[osc].map((v, i) => i === step ? !v : v)
                }));
            };

            const playSound = (type, filterFreq) => {
                if (!audioCtxRef.current) {
                    audioCtxRef.current = new (window.AudioContext || window.webkitAudioContext)();
                }
                const ctx = audioCtxRef.current;

                let osc;
                const gain = ctx.createGain();
                const filt = ctx.createBiquadFilter();
                filt.type = 'lowpass';
                filt.frequency.value = filterFreq;

                if (type === 'noise') {
                    const bufferSize = ctx.sampleRate * 0.1;
                    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        data[i] = Math.random() * 2 - 1;
                    }
                    osc = ctx.createBufferSource();
                    osc.buffer = buffer;
                } else {
                    osc = ctx.createOscillator();
                    osc.type = type === 'saw' ? 'sawtooth' : type;
                    osc.frequency.value = 220 + Math.random() * 110;
                }

                gain.gain.setValueAtTime(0.3, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);

                osc.connect(filt);
                filt.connect(gain);
                gain.connect(ctx.destination);
                osc.start(ctx.currentTime);
                osc.stop(ctx.currentTime + 0.1);
            };

            const togglePlay = () => {
                if (isPlaying) {
                    clearInterval(intervalRef.current);
                    setIsPlaying(false);
                    setCurrentStep(0);
                } else {
                    setIsPlaying(true);
                    let step = 0;
                    intervalRef.current = setInterval(() => {
                        setCurrentStep(step);
                        oscillators.forEach(osc => {
                            if (grid[osc][step]) {
                                playSound(osc, filter);
                            }
                        });
                        step = (step + 1) % 16;
                    }, (60 / tempo) * 250);
                }
            };

            useEffect(() => {
                return () => clearInterval(intervalRef.current);
            }, []);

            useEffect(() => {
                if (isPlaying) {
                    clearInterval(intervalRef.current);
                    let step = currentStep;
                    intervalRef.current = setInterval(() => {
                        setCurrentStep(step);
                        oscillators.forEach(osc => {
                            if (grid[osc][step]) {
                                playSound(osc, filter);
                            }
                        });
                        step = (step + 1) % 16;
                    }, (60 / tempo) * 250);
                }
            }, [tempo, filter, grid]);

            return (
                <div className="h-full flex flex-col bg-black text-white select-none">
                    <div className="p-2 border-b border-gray-800 flex justify-between items-center">
                        <span className="font-mono text-xs text-gray-500">SYNTH_001.WAV</span>
                        <button
                            onClick={togglePlay}
                            className={`px-4 py-1 font-mono text-xs font-bold border ${isPlaying ? 'bg-white text-black' : 'border-white'}`}
                        >
                            {isPlaying ? ' STOP' : ' PLAY'}
                        </button>
                    </div>
                    <div className="flex-grow p-4 overflow-auto">
                        <div className="space-y-2">
                            {oscillators.map(osc => (
                                <div key={osc} className="flex items-center gap-2">
                                    <span className="font-mono text-[10px] w-12 text-gray-500 uppercase">{osc}</span>
                                    <div className="flex gap-1">
                                        {grid[osc].map((active, i) => (
                                            <button
                                                key={i}
                                                onClick={() => toggleNote(osc, i)}
                                                className={`w-6 h-8 border transition-all ${
                                                    active
                                                        ? 'bg-white border-white'
                                                        : 'bg-gray-900 border-gray-700 hover:border-gray-500'
                                                } ${currentStep === i && isPlaying ? 'ring-2 ring-red-500' : ''}`}
                                            />
                                        ))}
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                    <div className="p-4 border-t border-gray-800 flex gap-8">
                        <div className="flex items-center gap-2">
                            <span className="font-mono text-[10px] text-gray-500">TEMPO</span>
                            <input
                                type="range"
                                min="60"
                                max="200"
                                value={tempo}
                                onChange={(e) => setTempo(Number(e.target.value))}
                                className="w-24 accent-white"
                            />
                            <span className="font-mono text-xs w-8">{tempo}</span>
                        </div>
                        <div className="flex items-center gap-2">
                            <span className="font-mono text-[10px] text-gray-500">FILTER</span>
                            <input
                                type="range"
                                min="100"
                                max="5000"
                                value={filter}
                                onChange={(e) => setFilter(Number(e.target.value))}
                                className="w-24 accent-white"
                            />
                            <span className="font-mono text-xs w-12">{filter}Hz</span>
                        </div>
                    </div>
                </div>
            );
        };

        // --- DESTRUCTION.EXE - Screen destroyer ---
        const DestructionApp = ({ triggerDestruction }) => {
            return (
                <div className="h-full flex flex-col items-center justify-center bg-black text-white select-none">
                    <div className="text-center">
                        <div className="text-6xl mb-4"></div>
                        <div className="font-mono text-xl mb-2">DESTRUCTION.EXE</div>
                        <div className="font-mono text-xs text-gray-500 mb-8">WARNING: WILL DESTROY EVERYTHING</div>
                        <button
                            onClick={triggerDestruction}
                            className="px-8 py-4 bg-red-600 text-white font-mono font-bold text-lg hover:bg-red-700 border-4 border-red-400 animate-pulse"
                        >
                            EXECUTE
                        </button>
                    </div>
                </div>
            );
        };

        // --- TAROT.DAT - Tarot card pull ---
        const TarotApp = () => {
            const [card, setCard] = useState(null);
            const [revealed, setRevealed] = useState(false);
            const [alreadyPulled, setAlreadyPulled] = useState(false);

            const tarotCards = [
                { name: 'THE FOOL', meaning: 'New beginnings, innocence, spontaneity', ascii: `
   
           
         
           
          
          
    ~~~~~~~~
       0    
   ` },
                { name: 'THE MAGICIAN', meaning: 'Manifestation, resourcefulness, power', ascii: `
   
           
         
         
       
          
       I    
   ` },
                { name: 'THE HIGH PRIESTESS', meaning: 'Intuition, mystery, inner knowledge', ascii: `
   
          
          
         
     B  J  
     
      II    
   ` },
                { name: 'THE EMPRESS', meaning: 'Abundance, nurturing, fertility', ascii: `
   
           
          
         
       
    ~~~~~~~~
      III   
   ` },
                { name: 'THE EMPEROR', meaning: 'Authority, structure, control', ascii: `
   
           
          
       
         
       
      IV    
   ` },
                { name: 'THE HIEROPHANT', meaning: 'Tradition, conformity, spirituality', ascii: `
   
         
          
         
         
      
       V    
   ` },
                { name: 'THE LOVERS', meaning: 'Love, harmony, relationships', ascii: `
   
           
         
          
         
        
      VI    
   ` },
                { name: 'THE CHARIOT', meaning: 'Willpower, determination, success', ascii: `
   
         
          
       
       
      
      VII   
   ` },
                { name: 'STRENGTH', meaning: 'Courage, persuasion, inner strength', ascii: `
   
           
         
         
          
    ~~~~~~~~
     VIII   
   ` },
                { name: 'THE HERMIT', meaning: 'Soul-searching, introspection, solitude', ascii: `
   
           
          
         
         
       
      IX    
   ` },
                { name: 'WHEEL OF FORTUNE', meaning: 'Change, cycles, destiny', ascii: `
   
     T     
     
         
     
        A  
       X    
   ` },
                { name: 'JUSTICE', meaning: 'Fairness, truth, law', ascii: `
   
          
         
         
          
     
      XI    
   ` },
                { name: 'THE HANGED MAN', meaning: 'Surrender, letting go, new perspective', ascii: `
   
     
           
         
           
          
      XII   
   ` },
                { name: 'DEATH', meaning: 'Endings, change, transformation', ascii: `
   
         
           
         
       
    ~~~~~~~~
     XIII   
   ` },
                { name: 'TEMPERANCE', meaning: 'Balance, moderation, patience', ascii: `
   
           
         
       
          
    ~~~~~~~~
     XIV    
   ` },
                { name: 'THE DEVIL', meaning: 'Shadow self, attachment, addiction', ascii: `
   
         
          
         
          
      
      XV    
   ` },
                { name: 'THE TOWER', meaning: 'Sudden change, upheaval, revelation', ascii: `
   
       
         
         
       
     
     XVI    
   ` },
                { name: 'THE STAR', meaning: 'Hope, faith, renewal', ascii: `
   
         
         
         
        
    ~~~~~~~~
     XVII   
   ` },
                { name: 'THE MOON', meaning: 'Illusion, fear, subconscious', ascii: `
   
          
     
        
          
    ~~~~~~~~
    XVIII   
   ` },
                { name: 'THE SUN', meaning: 'Joy, success, celebration', ascii: `
   
        
      
        
         
      
     XIX    
   ` },
                { name: 'JUDGEMENT', meaning: 'Reflection, reckoning, awakening', ascii: `
   
      
         
       
       
       
      XX    
   ` },
                { name: 'THE WORLD', meaning: 'Completion, accomplishment, travel', ascii: `
   
          
     
         
     
          
     XXI    
   ` }
            ];

            useEffect(() => {
                // Check localStorage for existing pull (simulating IP-based storage)
                const savedCard = localStorage.getItem('tarot_card');
                if (savedCard) {
                    setCard(JSON.parse(savedCard));
                    setRevealed(true);
                    setAlreadyPulled(true);
                }
            }, []);

            const pullCard = () => {
                if (alreadyPulled) return;

                const randomCard = tarotCards[Math.floor(Math.random() * tarotCards.length)];
                setCard(randomCard);
                localStorage.setItem('tarot_card', JSON.stringify(randomCard));

                setTimeout(() => setRevealed(true), 500);
                setAlreadyPulled(true);
            };

            return (
                <div className="h-full flex flex-col bg-purple-950 text-white select-none">
                    <div className="p-3 border-b border-purple-800">
                        <span className="font-mono text-xs text-purple-400">TAROT.DAT // YOUR FATE AWAITS</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-4">
                        {!card ? (
                            <div className="text-center">
                                <pre className="font-mono text-xs text-purple-300 mb-4">
{`   
          
      ?   
          
          
          
          
   `}
                                </pre>
                                <button
                                    onClick={pullCard}
                                    className="px-6 py-3 bg-purple-800 text-white font-mono font-bold hover:bg-purple-700 border-2 border-purple-500"
                                >
                                    PULL YOUR CARD
                                </button>
                                <p className="mt-4 font-mono text-xs text-purple-500">ONE PULL PER VISITOR</p>
                            </div>
                        ) : (
                            <div className={`text-center transition-all duration-500 ${revealed ? 'opacity-100' : 'opacity-0'}`}>
                                <pre className="font-mono text-xs text-yellow-200 mb-4">{card.ascii}</pre>
                                <div className="text-xl font-black mb-2">{card.name}</div>
                                <div className="font-mono text-sm text-purple-300 max-w-xs">{card.meaning}</div>
                                {alreadyPulled && (
                                    <p className="mt-4 font-mono text-xs text-purple-600">YOUR FATE HAS BEEN SEALED</p>
                                )}
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // --- DOG.EXE - Pixel dog pet ---
        const DogApp = ({ onClose }) => {
            return (
                <div className="h-full flex flex-col items-center justify-center bg-yellow-50 select-none">
                    <div className="text-center p-4">
                        <pre className="font-mono text-xs mb-4">
{`    
        
       
        
   _____
       
      `}
                        </pre>
                        <div className="font-mono text-lg font-bold mb-2">DOG.EXE</div>
                        <div className="font-mono text-xs text-gray-500 mb-4">CLICK TO RELEASE THE DOG</div>
                        <button
                            onClick={onClose}
                            className="px-6 py-2 bg-yellow-500 text-black font-mono font-bold hover:bg-yellow-400 border-2 border-black"
                        >
                            RELEASE
                        </button>
                    </div>
                </div>
            );
        };

        // --- OS SHELL ---

        const OS = () => {
            const [booted, setBooted] = useState(false);
            const [topZ, setTopZ] = useState(100);
            const [destructionMode, setDestructionMode] = useState(false);
            const [dogReleased, setDogReleased] = useState(false);
            const [dogPos, setDogPos] = useState({ x: 100, y: 100 });
            const [dogVel, setDogVel] = useState({ x: 2, y: 2 });
            const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
            const [carriedIcon, setCarriedIcon] = useState(null);
            const [iconPositions, setIconPositions] = useState({});
            const destructionRef = useRef(null);

            // Destruction effect
            const triggerDestruction = () => {
                setDestructionMode(true);

                // Make windows fall with physics
                setTimeout(() => {
                    const interval = setInterval(() => {
                        setWindows(prev => {
                            const updated = { ...prev };
                            Object.keys(updated).forEach(key => {
                                if (updated[key].isOpen) {
                                    updated[key] = {
                                        ...updated[key],
                                        y: updated[key].y + Math.random() * 20 + 10,
                                        x: updated[key].x + (Math.random() - 0.5) * 20
                                    };
                                }
                            });
                            return updated;
                        });
                    }, 50);

                    setTimeout(() => {
                        clearInterval(interval);
                        // Black screen and reboot
                        setTimeout(() => {
                            setDestructionMode('black');
                            setTimeout(() => {
                                setDestructionMode('reboot');
                                setTimeout(() => {
                                    setDestructionMode(false);
                                    // Reset windows
                                    window.location.reload();
                                }, 3000);
                            }, 2000);
                        }, 1500);
                    }, 2000);
                }, 100);
            };

            // Dog AI
            useEffect(() => {
                if (!dogReleased) return;

                const dogInterval = setInterval(() => {
                    setDogPos(prev => {
                        // Run away from mouse
                        const dx = prev.x - mousePos.x;
                        const dy = prev.y - mousePos.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        let newX = prev.x;
                        let newY = prev.y;

                        if (dist < 200) {
                            // Flee from mouse
                            newX += (dx / dist) * 8;
                            newY += (dy / dist) * 8;
                        } else {
                            // Random movement
                            newX += (Math.random() - 0.5) * 10;
                            newY += (Math.random() - 0.5) * 10;
                        }

                        // Bounds
                        newX = Math.max(0, Math.min(window.innerWidth - 60, newX));
                        newY = Math.max(0, Math.min(window.innerHeight - 100, newY));

                        return { x: newX, y: newY };
                    });

                    // Randomly grab icons
                    if (!carriedIcon && Math.random() < 0.01) {
                        const iconKeys = Object.keys(windows);
                        const randomIcon = iconKeys[Math.floor(Math.random() * iconKeys.length)];
                        setCarriedIcon(randomIcon);
                    }
                }, 50);

                return () => clearInterval(dogInterval);
            }, [dogReleased, mousePos, carriedIcon]);

            // Window State (Position x/y added for dragging)
            const [windows, setWindows] = useState({
                "SYSTEM": { id: "SYSTEM", title: "SYSTEM_INFO", icon: "Terminal", x: 50, y: 50, w: '1000px', h: '800px', isOpen: true, isMin: false, z: 10, content: <SystemInfo /> },
                "FILES": { id: "FILES", title: "MEDIA_LIB", icon: "Folder", x: 100, y: 80, w: '800px', h: '500px', isOpen: false, isMin: false, z: 11, content: <FileExplorer /> },
                "PAINT": { id: "PAINT", title: "PAINT.EXE", icon: "Palette", x: 150, y: 110, w: '700px', h: '600px', isOpen: false, isMin: false, z: 12, content: <PaintApp /> },
                "SNAKE": { id: "SNAKE", title: "SNEK.EXE", icon: "Snek", x: 200, y: 140, w: '640px', h: '520px', isOpen: false, isMin: false, z: 13, content: <SnakeAppNew /> },
                "TRASH": { id: "TRASH", title: "TRASH.BIN", icon: "TrashCan", x: 250, y: 170, w: '500px', h: '400px', isOpen: false, isMin: false, z: 14, content: <TrashApp /> },
                "VOID": { id: "VOID", title: "VOID.TXT", icon: "Void", x: 300, y: 50, w: '500px', h: '400px', isOpen: false, isMin: false, z: 15, content: <VoidApp /> },
                "ORACLE": { id: "ORACLE", title: "ORACLE.EXE", icon: "Oracle", x: 350, y: 80, w: '500px', h: '450px', isOpen: false, isMin: false, z: 16, content: <OracleApp /> },
                "RADIO": { id: "RADIO", title: "RADIO.WAV", icon: "Radio", x: 400, y: 110, w: '400px', h: '400px', isOpen: false, isMin: false, z: 17, content: <RadioApp /> },
                "DICE": { id: "DICE", title: "DICE.EXE", icon: "Dice", x: 450, y: 140, w: '350px', h: '450px', isOpen: false, isMin: false, z: 18, content: <DiceApp /> },
                "LABYRINTH": { id: "LABYRINTH", title: "LABYRINTH.EXE", icon: "Labyrinth", x: 100, y: 50, w: '600px', h: '500px', isOpen: false, isMin: false, z: 19, content: <LabyrinthApp /> },
                "SYNTH": { id: "SYNTH", title: "SYNTH_001.WAV", icon: "Synth", x: 150, y: 80, w: '500px', h: '350px', isOpen: false, isMin: false, z: 20, content: <SynthApp /> },
                "DESTRUCTION": { id: "DESTRUCTION", title: "DESTRUCTION.EXE", icon: "Destruction", x: 200, y: 110, w: '400px', h: '350px', isOpen: false, isMin: false, z: 21, content: <DestructionApp triggerDestruction={triggerDestruction} /> },
                "TAROT": { id: "TAROT", title: "TAROT.DAT", icon: "Tarot", x: 250, y: 140, w: '350px', h: '450px', isOpen: false, isMin: false, z: 22, content: <TarotApp /> },
                "DOG": { id: "DOG", title: "DOG.EXE", icon: "Dog", x: 300, y: 170, w: '300px', h: '350px', isOpen: false, isMin: false, z: 23, content: <DogApp onClose={() => { setDogReleased(true); close("DOG"); }} /> }
            });

            // Dragging State
            const [drag, setDrag] = useState({ id: null, offsetX: 0, offsetY: 0 });

            useEffect(() => { setTimeout(() => setBooted(true), 600); }, []);

            // Window Ops
            const focus = (id) => {
                setWindows(p => ({ ...p, [id]: { ...p[id], z: topZ + 1 } }));
                setTopZ(z => z + 1);
            }
            const open = (id) => {
                setWindows(p => ({ ...p, [id]: { ...p[id], isOpen: true, isMin: false, z: topZ + 1 } }));
                setTopZ(z => z + 1);
            }
            const close = (id) => setWindows(p => ({ ...p, [id]: { ...p[id], isOpen: false } }));
            const toggleMin = (id) => setWindows(p => ({ ...p, [id]: { ...p[id], isMin: !p[id].isMin } }));

            // Drag Handlers
            const handleMouseDown = (e, id) => {
                e.preventDefault();
                focus(id); // bring to front
                const win = windows[id];
                const rect = e.currentTarget.getBoundingClientRect(); // click target is header
                // Calculate offset from the window's top-left corner
                // However, we track window X/Y which is top/left style. 
                // Simple math: MouseX - WindowX
                setDrag({
                    id: id,
                    offsetX: e.clientX - win.x,
                    offsetY: e.clientY - win.y
                });
            };

            const handleMouseMove = (e) => {
                if (drag.id) {
                    setWindows(prev => ({
                        ...prev,
                        [drag.id]: {
                            ...prev[drag.id],
                            x: e.clientX - drag.offsetX,
                            y: e.clientY - drag.offsetY
                        }
                    }));
                }
            };

            const handleMouseUp = () => setDrag({ id: null, offsetX: 0, offsetY: 0 });

            if (!booted) return <div className="h-screen w-screen bg-black text-white font-mono flex items-center justify-center">BOOTING_KERNEL...</div>;

            // Destruction overlay
            if (destructionMode === 'black') {
                return <div className="h-screen w-screen bg-black" />;
            }
            if (destructionMode === 'reboot') {
                return (
                    <div className="h-screen w-screen bg-black text-green-500 font-mono flex flex-col items-center justify-center">
                        <pre className="text-xs mb-4">
{`
      
  
          
            
              
                 
`}
                        </pre>
                        <div className="animate-pulse">REBOOTING...</div>
                        <div className="mt-4 text-xs text-green-700">DESTRUCTION COMPLETE</div>
                    </div>
                );
            }

            return (
                <div
                    className={`h-screen w-screen relative overflow-hidden desktop-bg ${destructionMode ? 'animate-pulse' : ''}`}
                    onMouseMove={(e) => {
                        handleMouseMove(e);
                        setMousePos({ x: e.clientX, y: e.clientY });
                    }}
                    onMouseUp={handleMouseUp}
                    style={destructionMode ? { filter: 'hue-rotate(180deg) saturate(3)' } : {}}
                >
                    {/* DESKTOP ICONS */}
                    <div className="absolute top-4 left-4 flex flex-col gap-4 z-0 max-h-[calc(100vh-80px)] overflow-y-auto">
                        {Object.values(windows).map(app => {
                            const IconCmp = Icons[app.icon];
                            const isDestruction = app.id === 'DESTRUCTION';
                            const iconOffset = iconPositions[app.id] || { x: 0, y: 0 };

                            // Skip icon if dog is carrying it
                            if (carriedIcon === app.id) return null;

                            return (
                                <button
                                    key={app.id}
                                    onClick={() => open(app.id)}
                                    className={`group flex flex-col items-center gap-2 w-20 ${isDestruction ? 'destruction-icon' : ''}`}
                                    style={{
                                        transform: `translate(${iconOffset.x}px, ${iconOffset.y}px)`,
                                        transition: 'transform 0.3s ease'
                                    }}
                                >
                                    <div className={`bg-white border-2 border-black p-3 icon-shadow group-hover:translate-x-1 group-hover:translate-y-1 group-hover:shadow-none transition-all ${isDestruction ? 'group-hover:animate-glitch' : ''}`}>
                                        <IconCmp size={32} />
                                    </div>
                                    <span className="bg-white border border-black px-1 text-[10px] font-mono font-bold shadow-sm">{app.title}</span>
                                </button>
                            );
                        })}
                    </div>

                    {/* WINDOWS */}
                    {Object.values(windows).map(win => (
                        win.isOpen && !win.isMin && (
                            <div
                                key={win.id}
                                onMouseDown={() => focus(win.id)}
                                className="absolute flex flex-col bg-white border-2 border-black window-shadow"
                                style={{
                                    left: win.x,
                                    top: win.y,
                                    width: win.w,
                                    height: win.h,
                                    zIndex: win.z
                                }}
                            >
                                {/* HEADER (DRAG HANDLE) */}
                                <div
                                    className={`flex justify-between items-center p-1 border-b-2 border-black select-none cursor-move ${win.z === topZ ? 'bg-black text-white' : 'bg-gray-200 text-black'}`}
                                    onMouseDown={(e) => handleMouseDown(e, win.id)}
                                >
                                    <div className="flex items-center gap-2 pl-2 pointer-events-none">
                                        <Icons.Square size={10} className="fill-current" />
                                        <span className="font-mono text-xs font-bold tracking-widest uppercase">{win.title}</span>
                                    </div>
                                    <div className="flex gap-1" onMouseDown={e => e.stopPropagation()}>
                                        <button onClick={() => toggleMin(win.id)} className="w-6 h-6 flex items-center justify-center border border-transparent hover:bg-white/20"><Icons.Minus size={14} /></button>
                                        <button onClick={() => close(win.id)} className="w-6 h-6 flex items-center justify-center border border-transparent hover:bg-red-500 hover:text-white"><Icons.X size={14} /></button>
                                    </div>
                                </div>
                                {/* CONTENT */}
                                <div className="flex-grow overflow-auto relative bg-white" onMouseDown={e => e.stopPropagation()}>
                                    {win.content}
                                </div>
                            </div>
                        )
                    ))}

                    {/* TASKBAR */}
                    <div className="mt-auto h-12 bg-white border-t-2 border-black flex items-center px-2 gap-2 z-[99999] absolute bottom-0 w-full shadow-2xl">
                        <div className="bg-black text-white px-2 py-1 font-black mr-2 select-none">MM</div>
                        {Object.values(windows).map(win => {
                            const IconCmp = Icons[win.icon];
                            return win.isOpen && (
                                <button key={win.id}
                                    onClick={() => { if (win.isMin) toggleMin(win.id); focus(win.id) }}
                                    className={`flex items-center gap-2 px-3 py-1 border-2 border-black font-mono text-xs font-bold transition-all ${win.z === topZ && !win.isMin ? 'bg-black text-white btn-shadow' : 'bg-white hover:translate-y-[-2px]'}`}
                                >
                                    <IconCmp size={14} />
                                    <span className="uppercase hidden md:inline">{win.title}</span>
                                </button>
                            );
                        })}
                        <div className="flex-grow"></div>
                        <div className="font-mono text-xs font-bold px-4 border-l-2 border-black">{new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>
                    </div>

                    {/* DOG */}
                    {dogReleased && (
                        <div
                            className="fixed z-[999999] cursor-pointer select-none transition-all duration-75"
                            style={{ left: dogPos.x, top: dogPos.y }}
                            onClick={() => setDogReleased(false)}
                        >
                            <pre className="font-mono text-[8px] leading-none">
{`  
  
   
 ___
  `}
                            </pre>
                            {carriedIcon && (
                                <div className="absolute -top-8 left-4 bg-white border border-black p-1">
                                    {React.createElement(Icons[windows[carriedIcon]?.icon], { size: 16 })}
                                </div>
                            )}
                        </div>
                    )}

                    {/* CRT Static overlay for destruction */}
                    {destructionMode === true && (
                        <div className="fixed inset-0 z-[999998] pointer-events-none crt-static" />
                    )}

                    {/* Glitch animation styles */}
                    <style>{`
                        @keyframes glitch {
                            0% { transform: translate(0); filter: hue-rotate(0deg); }
                            20% { transform: translate(-2px, 2px); filter: hue-rotate(90deg); }
                            40% { transform: translate(2px, -2px); filter: hue-rotate(180deg); }
                            60% { transform: translate(-2px, -2px); filter: hue-rotate(270deg); }
                            80% { transform: translate(2px, 2px); filter: hue-rotate(360deg); }
                            100% { transform: translate(0); filter: hue-rotate(0deg); }
                        }
                        .group-hover\\:animate-glitch:hover {
                            animation: glitch 0.2s infinite;
                        }
                        .destruction-icon:hover {
                            animation: glitch 0.3s infinite;
                        }
                        .crt-static {
                            background: repeating-linear-gradient(
                                0deg,
                                rgba(0, 0, 0, 0.1) 0px,
                                rgba(0, 0, 0, 0.1) 1px,
                                transparent 1px,
                                transparent 2px
                            );
                            animation: static 0.1s infinite;
                        }
                        @keyframes static {
                            0% { opacity: 0.3; }
                            50% { opacity: 0.5; }
                            100% { opacity: 0.3; }
                        }
                    `}</style>

                </div>
            )
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<OS />);
    </script>
</body>

</html>