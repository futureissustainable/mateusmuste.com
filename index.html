<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MATEUSMUSTE // OS</title>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script src="https://cdn.tailwindcss.com"></script>

    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script type="module">
        // Try multiple CDNs for COBE with fallback
        const cdns = [
            'https://cdn.skypack.dev/cobe',
            'https://esm.sh/cobe',
            'https://unpkg.com/cobe?module'
        ];
        async function loadCobe() {
            for (const cdn of cdns) {
                try {
                    const module = await import(cdn);
                    window.createGlobe = module.default;
                    return;
                } catch (e) { console.warn('COBE CDN failed:', cdn); }
            }
            console.error('All COBE CDNs failed');
        }
        loadCobe();
    </script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.cdnfonts.com/css/mondwest" rel="stylesheet">

    <style>
        :root {
            --bg: #E8E8E8;
            --fg: #000000;
            /* Warm neutral grays */
            --gray-50: #FAFAFA;
            --gray-100: #F0F0F0;
            --gray-200: #E0E0E0;
            --gray-300: #C0C0C0;
            --gray-400: #909090;
            --gray-500: #606060;
            /* Accent colors */
            --crimson: #DC143C;
            --code-green: #00FF41;
        }

        body {
            background-color: var(--bg);
            color: var(--fg);
            font-family: 'Mondwest', sans-serif;
            overflow: hidden;
            margin: 0;
            padding: 0;
            user-select: none;
            -webkit-font-smoothing: antialiased;
        }

        /* Global hover transitions */
        button, a, [role="button"], .cursor-pointer {
            transition: all 50ms ease-out;
        }

        .font-mono {
            font-family: 'Mondwest', sans-serif;
        }

        /* Brutalist Styles */
        .window-shadow {
            box-shadow: 10px 10px 0px 0px #000000;
        }

        .icon-shadow {
            box-shadow: 4px 4px 0px 0px #000000;
        }

        .btn-shadow {
            box-shadow: 2px 2px 0px 0px #000000;
        }

        /* Design System - Standardized Components */

        /* Primary Button: solid black */
        .btn-primary {
            padding: 0.75rem 1.5rem;
            background: #000;
            color: #fff;
            font-family: 'Mondwest', sans-serif;
            font-size: 0.875rem;
            font-weight: 700;
            border: 2px solid #000;
            cursor: pointer;
            transition: filter 0.15s;
        }
        .btn-primary:hover { filter: invert(1); }
        .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Secondary Button: outlined */
        .btn-secondary {
            padding: 0.75rem 1.5rem;
            background: #fff;
            color: #000;
            font-family: 'Mondwest', sans-serif;
            font-size: 0.875rem;
            font-weight: 700;
            border: 2px solid #000;
            cursor: pointer;
            transition: all 0.15s;
        }
        .btn-secondary:hover { background: #000; color: #fff; }

        /* Button Sizes */
        .btn-xs { padding: 0.25rem 0.5rem; font-size: 0.625rem; }
        .btn-sm { padding: 0.5rem 1rem; font-size: 0.75rem; }
        .btn-lg { padding: 1rem 2rem; font-size: 1.125rem; }
        .btn-full { width: 100%; }

        /* Icon Button (square, compact) */
        .btn-icon {
            padding: 0.25rem;
            background: #fff;
            border: 1px solid #000;
            cursor: pointer;
        }
        .btn-icon:hover { background: #f3f3f3; }

        /* Toolbar Button (selectable toggle) */
        .btn-toolbar {
            padding: 0.25rem 0.5rem;
            font-family: 'Mondwest', sans-serif;
            font-size: 0.625rem;
            font-weight: 700;
            text-transform: uppercase;
            border: 1px solid #000;
            cursor: pointer;
            background: #fff;
        }
        .btn-toolbar:hover { background: #f3f3f3; }
        .btn-toolbar.active { background: #000; color: #fff; }

        /* App Header */
        .app-header {
            padding: 0.5rem;
            border-bottom: 2px solid #000;
            background: #fff;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .app-header-title {
            font-family: 'Mondwest', sans-serif;
            font-size: 0.75rem;
            font-weight: 700;
        }
        .app-header-subtitle {
            font-family: 'Mondwest', sans-serif;
            font-size: 10px;
            color: #6b7280;
        }

        /* App Footer/Status Bar */
        .app-footer {
            padding: 0.5rem;
            border-top: 2px solid #000;
            background: #fff;
            text-align: center;
        }
        .app-footer-text {
            font-family: 'Mondwest', sans-serif;
            font-size: 10px;
            color: #6b7280;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }

        ::-webkit-scrollbar-track {
            background: #fff;
            border-left: 2px solid #000;
            border-top: 2px solid #000;
        }

        ::-webkit-scrollbar-thumb {
            background: #000;
            border: 2px solid #fff;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #333;
        }

        /* Background Patterns */
        .desktop-bg-grid {
            background-color: #f0f0f0;
            background-image: radial-gradient(#aaa 1px, transparent 1px);
            background-size: 20px 20px;
        }
        .desktop-bg-solid {
            background-color: #e5e5e5;
        }
        .desktop-bg-ascii {
            background-color: #f0f0f0;
        }

        canvas {
            touch-action: none;
        }

        /* Window fold animations */
        @keyframes window-fold-in {
            0% {
                opacity: 0;
                transform: perspective(800px) rotateX(-90deg) scaleY(0);
                transform-origin: top center;
            }
            100% {
                opacity: 1;
                transform: perspective(800px) rotateX(0deg) scaleY(1);
                transform-origin: top center;
            }
        }

        @keyframes window-fold-out {
            0% {
                opacity: 1;
                transform: perspective(800px) rotateX(0deg) scaleY(1);
                transform-origin: top center;
            }
            100% {
                opacity: 0;
                transform: perspective(800px) rotateX(-90deg) scaleY(0);
                transform-origin: top center;
            }
        }

        .window-opening {
            animation: window-fold-in 0.2s cubic-bezier(0.22, 1, 0.36, 1) forwards;
        }

        .window-closing {
            animation: window-fold-out 0.15s cubic-bezier(0.55, 0, 1, 0.45) forwards;
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            10%,
            30%,
            50%,
            70%,
            90% {
                transform: translateX(-5px);
            }

            20%,
            40%,
            60%,
            80% {
                transform: translateX(5px);
            }
        }

        .animate-shake {
            animation: shake 0.5s ease-in-out;
        }

        /* ThirdEye stack overflow animations */
        @keyframes flash {
            0% { opacity: 0; background: rgba(255,0,0,0.1); }
            100% { opacity: 1; background: rgba(255,0,0,0.4); }
        }

        @keyframes glitch {
            0% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            50% { transform: translateX(2px); }
            75% { transform: translateX(-1px); }
            100% { transform: translateX(0); }
        }

        /* Matrix Mode */
        .matrix-mode {
            background: #000 !important;
            background-image: none !important;
        }
        .matrix-mode * {
            color: #0f0 !important;
            border-color: #0f0 !important;
        }
        .matrix-mode .bg-white,
        .matrix-mode .bg-gray-50,
        .matrix-mode .bg-gray-100 {
            background-color: #000 !important;
        }
        .matrix-mode button,
        .matrix-mode .border,
        .matrix-mode .border-2,
        .matrix-mode .border-4 {
            border-color: #0f0 !important;
        }
        .matrix-mode svg {
            filter: brightness(0) invert(1) sepia(1) saturate(50) hue-rotate(70deg);
        }
        .matrix-mode canvas {
            filter: hue-rotate(70deg) saturate(3) brightness(0.8);
        }
        .matrix-rain {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
            opacity: 0.15;
        }

        /* Icon drag shake animation */
        @keyframes iconShake {
            0%, 100% { transform: rotate(-1deg); }
            50% { transform: rotate(1deg); }
        }
        .icon-dragging {
            animation: iconShake 0.15s ease-in-out infinite;
            transform: scale(1.1) translateY(-8px);
            z-index: 99999 !important;
        }

        /* Stack overflow flash animation */
        @keyframes stackFlash {
            0%, 100% { opacity: 1; background: #000; }
            50% { opacity: 0.7; background: #300; }
        }

        /* Fade in animation for revealing apps */
        @keyframes fadeIn {
            0% { opacity: 0; transform: scale(0.8) translateY(10px); }
            100% { opacity: 1; transform: scale(1) translateY(0); }
        }
        .animate-fade-in {
            animation: fadeIn 0.3s ease-out forwards;
        }
    </style>
</head>

<body>

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- SOUND SYSTEM ---
        let audioCtx = null;
        let activeDragNodes = null;
        let soundMuted = localStorage.getItem('sound_muted') === 'true';

        const getAudioCtx = () => {
            if (soundMuted) return null;
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            return audioCtx;
        };

        const toggleMute = () => {
            soundMuted = !soundMuted;
            localStorage.setItem('sound_muted', soundMuted.toString());
            return soundMuted;
        };

        const makeDistortion = (ctx, amount) => {
            const dist = ctx.createWaveShaper();
            const curve = new Float32Array(256);
            for (let i = 0; i < 256; i++) {
                const x = (i - 128) / 128;
                curve[i] = Math.tanh(x * amount);
            }
            dist.curve = curve;
            return dist;
        };

        const sounds = {
            dragStart: () => {
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                if (activeDragNodes) return;

                const bufferSize = ctx.sampleRate * 2.0;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    b0 = 0.99886 * b0 + white * 0.0555179;
                    b1 = 0.99332 * b1 + white * 0.0750759;
                    b2 = 0.96900 * b2 + white * 0.1538520;
                    b3 = 0.86650 * b3 + white * 0.3104856;
                    b4 = 0.55000 * b4 + white * 0.5329522;
                    b5 = -0.7616 * b5 - white * 0.0168980;
                    data[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.11;
                    b6 = white * 0.115926;
                }

                const noise = ctx.createBufferSource();
                noise.buffer = buffer;
                noise.loop = true;
                const filter = ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 800;
                filter.Q.value = 0.5;
                const hapticOsc = ctx.createOscillator();
                hapticOsc.type = 'sine';
                hapticOsc.frequency.value = 140;
                const lfo = ctx.createOscillator();
                lfo.type = 'sine';
                lfo.frequency.value = 13;
                const mainGain = ctx.createGain();
                const noiseGain = ctx.createGain();
                const hapticGain = ctx.createGain();
                const lfoGain = ctx.createGain();

                noise.connect(filter);
                filter.connect(noiseGain);
                noiseGain.connect(mainGain);
                hapticOsc.connect(hapticGain);
                hapticGain.connect(mainGain);
                mainGain.connect(ctx.destination);
                lfo.connect(lfoGain);
                lfoGain.connect(mainGain.gain);

                noiseGain.gain.value = 1.0;
                hapticGain.gain.value = 0.4;
                const baseVol = 0.012;
                mainGain.gain.setValueAtTime(0, now);
                mainGain.gain.linearRampToValueAtTime(baseVol, now + 0.15);
                lfoGain.gain.value = 0.008;

                noise.start(now);
                hapticOsc.start(now);
                lfo.start(now);
                activeDragNodes = { noise, hapticOsc, lfo, mainGain };
            },

            dragStop: () => {
                if (!activeDragNodes) return;
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                const { noise, hapticOsc, lfo, mainGain } = activeDragNodes;
                mainGain.gain.cancelScheduledValues(now);
                mainGain.gain.setValueAtTime(mainGain.gain.value, now);
                mainGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.1);
                noise.stop(now + 0.1);
                hapticOsc.stop(now + 0.1);
                lfo.stop(now + 0.1);
                activeDragNodes = null;
            },

            windowOpen: () => {
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(1200, now + 0.05);
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.3, now + 0.005);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.1);
            },

            windowClose: () => {
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(250, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                gain.gain.setValueAtTime(0.35, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.15);
            },

            success: () => {
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                [523.25, 659.25, 783.99, 987.77].forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    const start = now + i * 0.04;
                    gain.gain.setValueAtTime(0, start);
                    gain.gain.linearRampToValueAtTime(0.08, start + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.001, start + 0.4);
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(start);
                    osc.stop(start + 0.4);
                });
            },

            error: () => {
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                [150, 154].forEach(freq => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    const filter = ctx.createBiquadFilter();
                    osc.type = 'sawtooth';
                    osc.frequency.value = freq;
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(400, now);
                    filter.frequency.linearRampToValueAtTime(100, now + 0.3);
                    gain.gain.setValueAtTime(0.15, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(now);
                    osc.stop(now + 0.3);
                });
            },

            bounce: (vel = 1) => {
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                const dist = makeDistortion(ctx, 12);
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(dist);
                dist.connect(gain);
                gain.connect(ctx.destination);
                osc.type = 'sine';
                osc.frequency.setValueAtTime(220 + (vel * 100), now);
                osc.frequency.exponentialRampToValueAtTime(40, now + 0.15);
                gain.gain.setValueAtTime(0.4 * Math.min(vel, 1.2), now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                osc.start(now);
                osc.stop(now + 0.2);
            },

            bounceIcon: (vel = 1) => {
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600 + (vel * 150), now);
                osc.frequency.exponentialRampToValueAtTime(200, now + 0.06);
                gain.gain.setValueAtTime(0.12 * Math.min(vel, 1), now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
                osc.start(now);
                osc.stop(now + 0.08);
            },

            bootSequence: () => {
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                const notes = [174.61, 220.00, 261.63, 329.63, 392.00];
                notes.forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    const start = now + i * 0.4;
                    gain.gain.setValueAtTime(0, start);
                    gain.gain.linearRampToValueAtTime(0.15, start + 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.001, start + 0.6);
                    osc.start(start);
                    osc.stop(start + 0.6);
                });
            },

            laser: () => {
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(2000, now);
                osc.frequency.exponentialRampToValueAtTime(200, now + 0.15);
                gain.gain.setValueAtTime(0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.15);
            },

            explosion: () => {
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                const dist = makeDistortion(ctx, 20);
                osc.connect(dist);
                dist.connect(gain);
                gain.connect(ctx.destination);
                osc.type = 'sine';
                osc.frequency.setValueAtTime(120, now);
                osc.frequency.exponentialRampToValueAtTime(10, now + 0.5);
                gain.gain.setValueAtTime(0.6, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
                osc.start(now);
                osc.stop(now + 0.6);
            },

            coin: () => {
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                [987.77, 1318.51].forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    const t = now + i * 0.08;
                    gain.gain.setValueAtTime(0.05, t);
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(t);
                    osc.stop(t + 0.5);
                });
            },

            gameOver: () => {
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                [440, 311, 220, 155].forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'triangle';
                    osc.frequency.value = freq;
                    const start = now + i * 0.3;
                    gain.gain.setValueAtTime(0.1, start);
                    gain.gain.exponentialRampToValueAtTime(0.001, start + 0.4);
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(start);
                    osc.stop(start + 0.4);
                });
            },

            bark: () => {
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.linearRampToValueAtTime(150, now + 0.15);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.15);
            },

            // Metallic ping for START.EXE reveals
            ping: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(1200, now);
                osc.frequency.exponentialRampToValueAtTime(800, now + 0.3);
                gain.gain.setValueAtTime(0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.5);
            },

            diceRoll: () => {
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                // Rapid clicks that slow down like a dice settling
                for (let i = 0; i < 12; i++) {
                    const delay = i * 0.05 + (i * i * 0.008);
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'square';
                    osc.frequency.value = 800 + Math.random() * 400;
                    gain.gain.setValueAtTime(0.08 * (1 - i * 0.07), now + delay);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.03);
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(now + delay);
                    osc.stop(now + delay + 0.03);
                }
            },

            mineDing: () => {
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.value = 1200;
                gain.gain.setValueAtTime(0.06, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.1);
            },

            // UI click sound - subtle, satisfying
            click: () => {
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(600, now + 0.05);
                gain.gain.setValueAtTime(0.08, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.05);
            },

            // Copy to clipboard sound
            copy: () => {
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                [1000, 1200].forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    const start = now + i * 0.05;
                    gain.gain.setValueAtTime(0.06, start);
                    gain.gain.exponentialRampToValueAtTime(0.001, start + 0.08);
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(start);
                    osc.stop(start + 0.08);
                });
            },

            // Key press sound for typing games
            keyPress: () => {
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'square';
                osc.frequency.value = 400 + Math.random() * 100;
                gain.gain.setValueAtTime(0.03, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.03);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.03);
            },

            // Note toggle for synth
            noteToggle: () => {
                const ctx = getAudioCtx();
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.value = 880;
                gain.gain.setValueAtTime(0.04, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.04);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.04);
            }
        };

        // --- HIGH SCORE SYSTEM (local storage based) ---
        const HighScoreManager = {
            userIP: null,
            ipReady: false,

            init() {
                // Try cached IP first for immediate use
                const cachedIP = localStorage.getItem('user_ip_cache');
                if (cachedIP) this.userIP = cachedIP;
                // Fetch fresh IP in background
                this.fetchIP();
            },

            async fetchIP() {
                if (this.ipReady) return this.userIP;
                try {
                    const res = await fetch('https://api.ipify.org?format=json');
                    const data = await res.json();
                    this.userIP = data.ip;
                    localStorage.setItem('user_ip_cache', data.ip);
                } catch (e) {
                    this.userIP = this.userIP || 'local';
                }
                this.ipReady = true;
                return this.userIP;
            },

            getStorageKey(game) {
                // Use cached IP or 'local' - consistent within session
                return `highscore_${game}_${this.userIP || 'local'}`;
            },

            saveHighScore(game, score) {
                const key = this.getStorageKey(game);
                const current = localStorage.getItem(key);
                if (!current || score > parseInt(current, 10)) {
                    localStorage.setItem(key, score.toString());
                    return true;
                }
                return false;
            },

            getHighScore(game) {
                const key = this.getStorageKey(game);
                return parseInt(localStorage.getItem(key) || '0', 10);
            }
        };

        // Initialize on load (uses cached IP, fetches fresh in background)
        HighScoreManager.init();

        // --- PIXELARTICONS (from unpkg CDN) ---
        const PixelartIcon = ({ name, size = 64, style = {}, className = '', ...props }) => (
            <img
                src={`https://unpkg.com/pixelarticons@1.8.1/svg/${name}.svg`}
                width={size}
                height={size}
                alt={name}
                style={{ imageRendering: 'pixelated', ...style }}
                className={className}
                {...props}
            />
        );

        const Icons = {
            // System Info - Monitor
            Terminal: (p) => <PixelartIcon name="monitor" {...p} />,
            // Media Library - Folder
            Folder: (p) => <PixelartIcon name="folder" {...p} />,
            // Paint - Fill bucket
            Palette: (p) => <PixelartIcon name="fill" {...p} />,
            // Snake Game - Gamepad
            Snek: (p) => <PixelartIcon name="gamepad" {...p} />,
            // Trash Can
            TrashCan: (p) => <PixelartIcon name="trash" {...p} />,
            // Undo arrow
            Undo: (p) => <PixelartIcon name="undo" {...p} />,
            // Redo arrow
            Redo: (p) => <PixelartIcon name="redo" {...p} />,
            // File document
            FileDoc: (p) => <PixelartIcon name="file" {...p} />,
            // Window controls
            X: ({ size = 24, ...p }) => <PixelartIcon name="close" size={size} {...p} />,
            Minus: ({ size = 24, ...p }) => <PixelartIcon name="minus" size={size} {...p} />,
            Square: ({ size = 24, ...p }) => <PixelartIcon name="checkbox" size={size} {...p} />,
            Trash: (p) => <PixelartIcon name="trash" {...p} />,
            Send: (p) => <PixelartIcon name="send" {...p} />,
            // Media folder icons
            Movies: (p) => <PixelartIcon name="movie" {...p} />,
            Books: (p) => <PixelartIcon name="book" {...p} />,
            Games: (p) => <PixelartIcon name="gamepad" {...p} />,
            Music: (p) => <PixelartIcon name="music" {...p} />,
            Back: (p) => <PixelartIcon name="arrow-left" {...p} />,
            // App Icons
            Void: (p) => <PixelartIcon name="code" {...p} />,
            Radio: (p) => <PixelartIcon name="radio-on" {...p} />,
            Dice: (p) => <PixelartIcon name="dice" {...p} />,
            Labyrinth: (p) => <PixelartIcon name="layout-rows" {...p} />,
            Minesweeper: (p) => <PixelartIcon name="table" {...p} />,
            Starship: (p) => <PixelartIcon name="arrow-up" {...p} />,
            Synth: (p) => <PixelartIcon name="keyboard" {...p} />,
            Destruction: (p) => <PixelartIcon name="power" {...p} />,
            Tarot: (p) => <PixelartIcon name="card" {...p} />,
            Dog: (p) => <PixelartIcon name="paw" {...p} />,
            // Email icon
            Email: (p) => <PixelartIcon name="mail" {...p} />,
            // Apps folder icon
            Apps: (p) => <PixelartIcon name="add-grid" {...p} />,
            // Gallery
            Gallery: (p) => <PixelartIcon name="image" {...p} />,
            // Globe
            Globe: (p) => <PixelartIcon name="map" {...p} />,
            // Pomodoro timer
            Pomodoro: (p) => <PixelartIcon name="clock" {...p} />,
            // Charging/power
            Charging: (p) => <PixelartIcon name="power" {...p} />,
            // Sound
            Speaker: (p) => <PixelartIcon name="volume-3" {...p} />,
            SpeakerOff: (p) => <PixelartIcon name="volume-x" {...p} />,
            // Health scanner
            HealthScanner: (p) => <PixelartIcon name="heart" {...p} />,
            // Lock icon
            Lock: (p) => <PixelartIcon name="lock" {...p} />,
            // Folder icons for app categories
            FolderClosed: (p) => <PixelartIcon name="folder" {...p} />,
            GamesFolder: (p) => <PixelartIcon name="gamepad" {...p} />,
            ProductivityFolder: (p) => <PixelartIcon name="sliders" {...p} />,
            AboutFolder: (p) => <PixelartIcon name="user" {...p} />,
            // Third Eye - code viewer
            ThirdEye: (p) => <PixelartIcon name="bullseye" {...p} />,
            // Browser
            Browser: (p) => <PixelartIcon name="layout-sidebar-left" {...p} />,
            // Words game
            Words: (p) => <PixelartIcon name="article" {...p} />,
            // Trophy for achievements
            Trophy: (p) => <PixelartIcon name="trophy" {...p} />,
            // Achievement icons
            Message: (p) => <PixelartIcon name="message" {...p} />,
            RainAlt: (p) => <PixelartIcon name="drop-half" {...p} />,
            Alert: (p) => <PixelartIcon name="alert" {...p} />,
            Repeat: (p) => <PixelartIcon name="reload" {...p} />,
            Sword: (p) => <PixelartIcon name="sliders" {...p} />,
            Expand: (p) => <PixelartIcon name="open" {...p} />,
            Controller: (p) => <PixelartIcon name="gamepad" {...p} />,
            Clock: (p) => <PixelartIcon name="clock" {...p} />,
            Cursor: (p) => <PixelartIcon name="cursor" {...p} />,
            Skull: (p) => <PixelartIcon name="mood-sad" {...p} />,
            Fire: (p) => <PixelartIcon name="zap" {...p} />,
            Bomb: (p) => <PixelartIcon name="close-box" {...p} />,
            Badge: (p) => <PixelartIcon name="calendar" {...p} />,
        };

        // --- SHARED DOG SPRITE ---
        const DogSprite = ({ animated = false, style = {}, gold = false }) => {
            const color = gold ? '#DAA520' : '#000';
            const eyeColor = gold ? '#000' : '#fff';
            const pupilColor = gold ? '#fff' : '#000';
            return (
                <svg width="64" height="48" viewBox="0 0 64 48" style={{ imageRendering: 'pixelated', ...style }}>
                    <rect x="16" y="16" width="32" height="16" fill={color} />
                    <rect x="4" y="12" width="16" height="16" fill={color} />
                    <rect x="2" y="4" width="6" height="14" fill={color} />
                    <rect x="14" y="4" width="6" height="14" fill={color} />
                    <rect x="8" y="16" width="6" height="6" fill={eyeColor} />
                    <rect x="10" y="18" width="3" height="3" fill={pupilColor} />
                    <rect x="4" y="22" width="4" height="4" fill={color} />
                    {animated && <rect x="2" y="26" width="4" height="2" fill={color} />}
                    <rect x="16" y="32" width="6" height={animated ? (Math.sin(Date.now() / 100) > 0 ? 10 : 14) : 12} fill={color} />
                    <rect x="26" y="32" width="6" height={animated ? (Math.sin(Date.now() / 100) > 0 ? 14 : 10) : 10} fill={color} />
                    <rect x="34" y="32" width="6" height={animated ? (Math.sin(Date.now() / 100) > 0 ? 10 : 14) : 12} fill={color} />
                    <rect x="42" y="32" width="6" height={animated ? (Math.sin(Date.now() / 100) > 0 ? 14 : 10) : 10} fill={color} />
                    <rect x="48" y={animated ? 12 + Math.sin(Date.now() / 150) * 4 : 12} width="12" height="4" fill={color} />
                    <rect x="58" y={animated ? 8 + Math.sin(Date.now() / 150) * 4 : 8} width="4" height="6" fill={color} />
                </svg>
            );
        };

        // --- DATA ---
        const MEDIA_DB = {
            "CINEMA_TV": [
                { title: "Blade Runner 2049" },
                { title: "Mr. Robot" },
                { title: "True Detective" },
                { title: "Succession" },
                { title: "The Bear" },
                { title: "Ex Machina" },
                { title: "Fight Club" },
                { title: "Interstellar" },
                { title: "Chernobyl" },
                { title: "Better Call Saul" },
                { title: "Whiplash" },
                { title: "There Will Be Blood" },
                { title: "Black Mirror" }
            ],
            "LITERATURE": [
                { title: "Brothers Karamazov", rating: "10/10" },
                { title: "Looking for Alaska", rating: "10/10" },
                { title: "Atlas Shrugged", rating: "10/10" },
                { title: "Pale Blue Dot", rating: "10/10" },
                { title: "Lean Startup", rating: "9/10" },
                { title: "Fight Club", rating: "9/10" },
                { title: "Principles by Ray Dalio", rating: "9/10" },
                { title: "The Fountainhead", rating: "9/10" },
                { title: "Crime & Punishment", rating: "8/10" },
                { title: "1984", rating: "8/10" },
                { title: "Master & Margarita", rating: "8/10" },
                { title: "American Psycho", rating: "8/10" },
                { title: "Elon Musk Biography", rating: "8/10" },
                { title: "How to Get Filthy Rich in Rising Asia", rating: "8/10" },
                { title: "Fathers and Sons", rating: "8/10" },
                { title: "The Long Walk", rating: "8/10" },
                { title: "What's Our Problem?", rating: "7/10" },
                { title: "The Alchemist", rating: "7/10" },
                { title: "Kafka on the Shore", rating: "6/10" },
                { title: "Geometry for Ocelots", rating: "READING" }
            ],
            "GAMES": [
                { title: "Dark Souls III", rating: "10/10" },
                { title: "The Last of Us Pt II", rating: "10/10" },
                { title: "Outer Wilds", rating: "10/10" },
                { title: "God of War Ragnarok", rating: "10/10" },
                { title: "Blue Prince", rating: "10/10" },
                { title: "Cyberpunk 2077", rating: "9.5/10" },
                { title: "Night in the Woods", rating: "9.5/10" }
            ],
            "AUDIO": [
                { title: "Ison", artist: "Sevdaliza" },
                { title: "Mr. Morale...", artist: "Kendrick Lamar" },
                { title: "LP!", artist: "JPEGMAFIA" },
                { title: "If You're Reading This It's Too Late", artist: "Drake" },
                { title: "The Life of Pablo", artist: "Kanye West" },
                { title: "Miss Anthropocene", artist: "Grimes" },
                { title: "The Eminem Show", artist: "Eminem" },
                { title: "4 Your Eyez Only", artist: "J. Cole" },
                { title: "Yeezus", artist: "Kanye West" },
                { title: "This story is dedicated...", artist: "Grimes" }
            ]
        };

        // --- APP COMPONENTS ---

        const PaintApp = ({ showHint }) => {
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const [tool, setTool] = useState('brush');
            const [color, setColor] = useState('#000000');
            const [size, setSize] = useState(4);
            const [isDrawing, setIsDrawing] = useState(false);
            const [status, setStatus] = useState("READY");
            const [startPos, setStartPos] = useState({ x: 0, y: 0 });
            const [textInput, setTextInput] = useState('');
            const [showTextInput, setShowTextInput] = useState(false);
            const [textPos, setTextPos] = useState({ x: 0, y: 0 });
            const snapshotRef = useRef(null);
            const historyRef = useRef([]);
            const historyIndexRef = useRef(-1);

            // Get accurate mouse/touch position relative to canvas
            const getMousePos = (e) => {
                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                // Handle both mouse and touch events
                let clientX, clientY;
                if (e.touches && e.touches.length > 0) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else if (e.changedTouches && e.changedTouches.length > 0) {
                    clientX = e.changedTouches[0].clientX;
                    clientY = e.changedTouches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                return {
                    x: (clientX - rect.left) * scaleX,
                    y: (clientY - rect.top) * scaleY
                };
            };

            // Touch event handlers
            const handleTouchStart = (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    startDraw(e);
                }
            };
            const handleTouchMove = (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    draw(e);
                }
            };
            const handleTouchEnd = (e) => {
                e.preventDefault();
                endDraw();
            };

            const saveToHistory = () => {
                const canvas = canvasRef.current;
                const data = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
                historyRef.current = historyRef.current.slice(0, historyIndexRef.current + 1);
                historyRef.current.push(data);
                if (historyRef.current.length > 50) historyRef.current.shift();
                historyIndexRef.current = historyRef.current.length - 1;
            };

            const undo = () => {
                if (historyIndexRef.current > 0) {
                    historyIndexRef.current--;
                    canvasRef.current.getContext('2d').putImageData(historyRef.current[historyIndexRef.current], 0, 0);
                    setStatus("UNDO");
                }
            };

            const redo = () => {
                if (historyIndexRef.current < historyRef.current.length - 1) {
                    historyIndexRef.current++;
                    canvasRef.current.getContext('2d').putImageData(historyRef.current[historyIndexRef.current], 0, 0);
                    setStatus("REDO");
                }
            };

            useEffect(() => {
                const initCanvas = () => {
                    if (!containerRef.current) return;
                    const canvas = canvasRef.current;
                    const container = containerRef.current;
                    // Set fixed canvas size for proper pixel drawing
                    canvas.width = container.clientWidth - 4;
                    canvas.height = container.clientHeight - 4;
                    const ctx = canvas.getContext("2d");
                    ctx.fillStyle = "#ffffff";
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    // Draw hint text if showHint is true
                    if (showHint) {
                        ctx.save();
                        ctx.globalAlpha = 0.15;
                        ctx.fillStyle = "#000000";
                        ctx.font = "24px 'Mondwest', sans-serif";
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        ctx.fillText("draw your message :)", canvas.width / 2, canvas.height / 2);
                        ctx.restore();
                    }
                    saveToHistory();
                };
                initCanvas();
                window.addEventListener('resize', initCanvas);
                return () => window.removeEventListener('resize', initCanvas);
            }, []);

            const floodFill = (x, y, fillColor) => {
                const ctx = canvasRef.current.getContext('2d');
                const w = ctx.canvas.width;
                const h = ctx.canvas.height;
                const imgData = ctx.getImageData(0, 0, w, h);
                const data = imgData.data;
                const r = parseInt(fillColor.slice(1, 3), 16);
                const g = parseInt(fillColor.slice(3, 5), 16);
                const b = parseInt(fillColor.slice(5, 7), 16);
                const startIdx = (y * w + x) * 4;
                const sr = data[startIdx], sg = data[startIdx + 1], sb = data[startIdx + 2];
                if (sr === r && sg === g && sb === b) return;
                const stack = [[x, y]];
                while (stack.length) {
                    const [cx, cy] = stack.pop();
                    const idx = (cy * w + cx) * 4;
                    if (cx < 0 || cx >= w || cy < 0 || cy >= h) continue;
                    if (data[idx] === sr && data[idx + 1] === sg && data[idx + 2] === sb) {
                        data[idx] = r; data[idx + 1] = g; data[idx + 2] = b; data[idx + 3] = 255;
                        stack.push([cx + 1, cy], [cx - 1, cy], [cx, cy + 1], [cx, cy - 1]);
                    }
                }
                ctx.putImageData(imgData, 0, 0);
                saveToHistory();
            };

            const saveSnapshot = () => {
                const canvas = canvasRef.current;
                snapshotRef.current = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
            };

            const restoreSnapshot = () => {
                if (snapshotRef.current) {
                    canvasRef.current.getContext('2d').putImageData(snapshotRef.current, 0, 0);
                }
            };

            const startDraw = (e) => {
                const pos = getMousePos(e);
                if (tool === 'bucket') {
                    floodFill(Math.floor(pos.x), Math.floor(pos.y), color);
                    setStatus("FILLED");
                } else if (tool === 'text') {
                    setTextPos(pos);
                    setShowTextInput(true);
                    setStatus("TYPE TEXT");
                } else if (['rect', 'circle', 'line'].includes(tool)) {
                    setIsDrawing(true);
                    setStartPos(pos);
                    saveSnapshot();
                } else {
                    setIsDrawing(true);
                    setStartPos(pos);
                    const ctx = canvasRef.current.getContext('2d');
                    ctx.beginPath();
                    ctx.moveTo(pos.x, pos.y);
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.lineWidth = size;
                    ctx.strokeStyle = tool === 'eraser' ? '#ffffff' : color;
                }
            };

            const draw = (e) => {
                if (!isDrawing) return;
                const ctx = canvasRef.current.getContext('2d');
                const pos = getMousePos(e);

                if (tool === 'brush' || tool === 'eraser') {
                    ctx.lineTo(pos.x, pos.y);
                    ctx.stroke();
                } else if (['rect', 'circle', 'line'].includes(tool)) {
                    restoreSnapshot();
                    ctx.strokeStyle = color;
                    ctx.fillStyle = color;
                    ctx.lineWidth = size;

                    if (tool === 'rect') {
                        ctx.strokeRect(startPos.x, startPos.y, pos.x - startPos.x, pos.y - startPos.y);
                    } else if (tool === 'circle') {
                        const rx = Math.abs(pos.x - startPos.x) / 2;
                        const ry = Math.abs(pos.y - startPos.y) / 2;
                        const cx = startPos.x + (pos.x - startPos.x) / 2;
                        const cy = startPos.y + (pos.y - startPos.y) / 2;
                        ctx.beginPath();
                        ctx.ellipse(cx, cy, rx, ry, 0, 0, 2 * Math.PI);
                        ctx.stroke();
                    } else if (tool === 'line') {
                        ctx.beginPath();
                        ctx.moveTo(startPos.x, startPos.y);
                        ctx.lineTo(pos.x, pos.y);
                        ctx.stroke();
                    }
                }
            };

            const endDraw = () => {
                if (isDrawing) {
                    setIsDrawing(false);
                    if (tool === 'brush' || tool === 'eraser') {
                        canvasRef.current.getContext('2d').closePath();
                    }
                    saveToHistory();
                }
            };

            const placeText = () => {
                if (textInput.trim()) {
                    const ctx = canvasRef.current.getContext('2d');
                    ctx.fillStyle = color;
                    ctx.font = `${size * 4}px 'Mondwest', sans-serif`;
                    ctx.fillText(textInput, textPos.x, textPos.y);
                    setStatus("TEXT PLACED");
                    saveToHistory();
                }
                setShowTextInput(false);
                setTextInput('');
            };

            const send = async () => {
                const canvas = canvasRef.current;
                try {
                    // Copy canvas to clipboard
                    canvas.toBlob(async (blob) => {
                        if (blob) {
                            try {
                                await navigator.clipboard.write([
                                    new ClipboardItem({ 'image/png': blob })
                                ]);
                                setStatus("COPIED TO CLIPBOARD");
                            } catch (e) {
                                setStatus("COPY FAILED");
                            }
                        }
                    }, 'image/png');
                    // Open mailto
                    setTimeout(() => {
                        window.location.href = 'mailto:mateusmuste9@gmail.com';
                    }, 500);
                } catch (e) {
                    setStatus("ERROR");
                }
            };

            const clear = () => {
                const ctx = canvasRef.current.getContext('2d');
                ctx.fillStyle = "#ffffff";
                ctx.fillRect(0, 0, canvasRef.current.width, canvasRef.current.height);
                setStatus("CLEARED");
                saveToHistory();
            };

            // Pixel knob component
            const PixelKnob = ({ value, onChange, min, max }) => {
                const knobSize = 24;
                const rotation = ((value - min) / (max - min)) * 270 - 135;
                return (
                    <div
                        className="relative cursor-pointer select-none"
                        style={{ width: knobSize, height: knobSize }}
                        onMouseDown={(e) => {
                            e.preventDefault();
                            const startY = e.clientY;
                            const startVal = value;
                            const onMove = (ev) => {
                                const diff = startY - ev.clientY;
                                const newVal = Math.min(max, Math.max(min, startVal + Math.floor(diff / 5)));
                                onChange(newVal);
                            };
                            const onUp = () => {
                                window.removeEventListener('mousemove', onMove);
                                window.removeEventListener('mouseup', onUp);
                            };
                            window.addEventListener('mousemove', onMove);
                            window.addEventListener('mouseup', onUp);
                        }}
                    >
                        <svg width={knobSize} height={knobSize} viewBox="0 0 24 24" style={{ imageRendering: 'pixelated' }}>
                            <rect x="4" y="4" width="16" height="16" fill="#000" />
                            <rect x="6" y="6" width="12" height="12" fill="#fff" />
                            <rect x="10" y="6" width="4" height="6" fill="#000" transform={`rotate(${rotation}, 12, 12)`} />
                        </svg>
                    </div>
                );
            };

            const tools = ['brush', 'eraser', 'bucket', 'line', 'rect', 'circle', 'text'];
            const colors = ['#000000', '#ffffff', '#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ff8800', '#8800ff'];

            return (
                <div className="h-full flex flex-col bg-gray-100 select-none">
                    <div className="app-header flex-shrink-0">
                        <div className="flex items-center gap-2 min-w-0">
                            <Icons.Palette size={16} className="flex-shrink-0" />
                            <span className="app-header-title truncate">PAINT.EXE</span>
                        </div>
                        <button onClick={() => { sounds.click(); send(); }} className="btn-primary btn-xs flex items-center gap-1 flex-shrink-0">
                            <Icons.Send size={12} /> SEND
                        </button>
                    </div>
                    <div className="p-2 border-b-2 border-black bg-white flex flex-wrap gap-2 items-center">
                        <div className="flex gap-1">
                            <button onClick={() => { sounds.click(); undo(); }} className="btn-icon" title="Undo"><Icons.Undo size={16} /></button>
                            <button onClick={() => { sounds.click(); redo(); }} className="btn-icon" title="Redo"><Icons.Redo size={16} /></button>
                        </div>
                        <div className="w-px h-4 bg-black"></div>
                        <div className="flex gap-1 flex-wrap">
                            {tools.map(t => (
                                <button key={t} onClick={() => { sounds.click(); setTool(t); }} className={`btn-toolbar ${tool === t ? 'active' : ''}`}>{t}</button>
                            ))}
                        </div>
                        <div className="w-px h-4 bg-black"></div>
                        <div className="flex gap-1 flex-wrap">
                            {colors.map(c => (
                                <button key={c} onClick={() => { sounds.click(); setColor(c); }} className={`w-5 h-5 border border-black ${color === c ? 'ring-2 ring-offset-1 ring-black' : ''}`} style={{ backgroundColor: c }} />
                            ))}
                        </div>
                        <div className="w-px h-4 bg-black"></div>
                        <div className="flex items-center gap-1">
                            <PixelKnob value={size} onChange={setSize} min={1} max={20} />
                            <span className="text-[10px] font-mono w-4">{size}</span>
                        </div>
                    </div>
                    <div className="flex-grow relative cursor-crosshair bg-gray-300 p-[2px] overflow-hidden" ref={containerRef}>
                        <canvas
                            ref={canvasRef}
                            onMouseDown={startDraw}
                            onMouseMove={draw}
                            onMouseUp={endDraw}
                            onMouseLeave={endDraw}
                            onTouchStart={handleTouchStart}
                            onTouchMove={handleTouchMove}
                            onTouchEnd={handleTouchEnd}
                            className="block bg-white border border-gray-400 touch-none"
                            style={{ width: '100%', height: '100%' }}
                        />
                        {showTextInput && (
                            <div className="absolute top-2 left-2 bg-white border-2 border-black p-2 flex gap-2">
                                <input
                                    type="text"
                                    value={textInput}
                                    onChange={(e) => setTextInput(e.target.value)}
                                    onKeyDown={(e) => e.key === 'Enter' && placeText()}
                                    placeholder="Type text..."
                                    className="border border-black px-2 py-1 text-xs font-mono"
                                    autoFocus
                                />
                                <button onClick={placeText} className="btn-primary btn-xs">OK</button>
                            </div>
                        )}
                        <div className="absolute bottom-1 left-1 bg-black text-white text-[10px] px-2 font-mono">{status}</div>
                    </div>
                </div>
            )
        }

        const FileExplorer = ({ onAchievement }) => {
            const [selectedFolder, setSelectedFolder] = useState(null);
            const [visitedFolders, setVisitedFolders] = useState(() => {
                const stored = localStorage.getItem('media_lib_visited');
                return stored ? JSON.parse(stored) : [];
            });

            const folders = [
                { key: 'CINEMA_TV', name: 'TV', icon: 'Movies' },
                { key: 'LITERATURE', name: 'BOOKS', icon: 'Books' },
                { key: 'GAMES', name: 'GAMES', icon: 'Games' },
                { key: 'AUDIO', name: 'MUSIC', icon: 'Music' }
            ];

            const handleFolderSelect = (key) => {
                setSelectedFolder(key);
                if (!visitedFolders.includes(key)) {
                    const newVisited = [...visitedFolders, key];
                    setVisitedFolders(newVisited);
                    localStorage.setItem('media_lib_visited', JSON.stringify(newVisited));
                    // Check if all folders visited
                    if (newVisited.length >= folders.length) {
                        onAchievement?.('DEEP_LISTENER');
                    }
                }
            };

            if (selectedFolder) {
                const FolderIcon = Icons[folders.find(f => f.key === selectedFolder)?.icon || 'Folder'];
                return (
                    <div className="h-full flex flex-col bg-white select-none">
                        <div className="p-2 border-b-2 border-black bg-white flex items-center gap-3">
                            <button onClick={() => setSelectedFolder(null)} className="p-1 border-2 border-black hover:bg-black hover:text-white">
                                <Icons.Back size={16} />
                            </button>
                            <FolderIcon size={24} />
                            <span className="font-mono text-xs font-bold uppercase">{folders.find(f => f.key === selectedFolder)?.name}</span>
                            <span className="app-footer-text">({MEDIA_DB[selectedFolder].length} ITEMS)</span>
                        </div>
                        <div className="flex-grow overflow-auto">
                            <table className="w-full text-left border-collapse">
                                <thead className="bg-black text-white text-xs font-mono sticky top-0">
                                    <tr><th className="p-2">TITLE</th><th className="p-2 border-l border-gray-600">NOTE</th></tr>
                                </thead>
                                <tbody className="font-mono text-xs">
                                    {MEDIA_DB[selectedFolder].map((i, idx) => (
                                        <tr key={idx} className="border-b border-gray-200 hover:bg-yellow-100">
                                            <td className="p-2 font-bold">{i.title}</td>
                                            <td className="p-2 border-l border-gray-200">{i.rating || i.artist}</td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                        <div className="app-footer">
                            <span className="app-footer-text">CLICK TO VIEW  HOVER TO PREVIEW</span>
                        </div>
                    </div>
                );
            }

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex items-center gap-2">
                        <Icons.Folder size={24} />
                        <span className="app-header-title">MEDIA_LIB</span>
                        <span className="app-footer-text">/ROOT/MEDIA</span>
                    </div>
                    <div className="flex-grow p-6 flex items-start justify-center bg-gray-50">
                        <div className="grid grid-cols-4 gap-8">
                            {folders.map(folder => {
                                const FolderIcon = Icons[folder.icon];
                                const isVisited = visitedFolders.includes(folder.key);
                                return (
                                    <button
                                        key={folder.key}
                                        onClick={() => handleFolderSelect(folder.key)}
                                        className="group flex flex-col items-center gap-2 p-4 hover:bg-white border-2 border-transparent hover:border-black transition-all"
                                    >
                                        <div className={`bg-white border-2 border-black p-3 icon-shadow group-hover:translate-x-1 group-hover:translate-y-1 group-hover:shadow-none transition-all ${isVisited ? 'opacity-100' : 'opacity-70'}`}>
                                            <FolderIcon size={48} />
                                        </div>
                                        <span className="font-mono text-xs font-bold uppercase">{folder.name}</span>
                                        <span className="app-footer-text">{MEDIA_DB[folder.key].length} ITEMS</span>
                                    </button>
                                );
                            })}
                        </div>
                    </div>
                    <div className="app-footer">
                        <span className="app-footer-text">MOVIES  BOOKS  GAMES  MUSIC</span>
                    </div>
                </div>
            );
        }

        const SystemInfo = ({ onThirdEyeWorld, totalVisitors }) => {
            const [konamiProgress, setKonamiProgress] = useState(0);
            const konamiCode = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'KeyB', 'KeyA'];
            // Mobile: swipe up, up, down, down, left, right, left, right, tap, tap
            const mobileKonamiCode = ['up', 'up', 'down', 'down', 'left', 'right', 'left', 'right', 'tap', 'tap'];
            const touchStartRef = useRef({ x: 0, y: 0, time: 0 });
            const konamiTimeoutRef = useRef(null);

            const handleKonamiGesture = (gesture) => {
                const expectedGesture = mobileKonamiCode[konamiProgress];
                if (gesture === expectedGesture) {
                    const newProgress = konamiProgress + 1;
                    setKonamiProgress(newProgress);
                    // Reset after 3 seconds of inactivity
                    clearTimeout(konamiTimeoutRef.current);
                    konamiTimeoutRef.current = setTimeout(() => setKonamiProgress(0), 3000);
                    if (newProgress === mobileKonamiCode.length) {
                        onThirdEyeWorld?.();
                        setKonamiProgress(0);
                        clearTimeout(konamiTimeoutRef.current);
                    }
                } else {
                    setKonamiProgress(0);
                }
            };

            const handleTouchStart = (e) => {
                touchStartRef.current = {
                    x: e.touches[0].clientX,
                    y: e.touches[0].clientY,
                    time: Date.now()
                };
            };

            const handleTouchEnd = (e) => {
                const dx = e.changedTouches[0].clientX - touchStartRef.current.x;
                const dy = e.changedTouches[0].clientY - touchStartRef.current.y;
                const elapsed = Date.now() - touchStartRef.current.time;
                const threshold = 50;

                // Detect gesture
                if (Math.abs(dx) < 20 && Math.abs(dy) < 20 && elapsed < 300) {
                    // Tap
                    handleKonamiGesture('tap');
                } else if (Math.abs(dx) > Math.abs(dy)) {
                    // Horizontal swipe
                    if (dx > threshold) handleKonamiGesture('right');
                    else if (dx < -threshold) handleKonamiGesture('left');
                } else {
                    // Vertical swipe
                    if (dy > threshold) handleKonamiGesture('down');
                    else if (dy < -threshold) handleKonamiGesture('up');
                }
            };

            useEffect(() => {
                const handleKeyDown = (e) => {
                    const expectedKey = konamiCode[konamiProgress];
                    if (e.code === expectedKey) {
                        const newProgress = konamiProgress + 1;
                        setKonamiProgress(newProgress);
                        if (newProgress === konamiCode.length) {
                            onThirdEyeWorld?.();
                            setKonamiProgress(0);
                        }
                    } else {
                        setKonamiProgress(0);
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [konamiProgress, onThirdEyeWorld]);

            return (
            <div className="p-6 md:p-12 font-sans select-text" onTouchStart={handleTouchStart} onTouchEnd={handleTouchEnd}>
                <header className="mb-12 border-b-4 border-black pb-8">
                    <h1 className="text-6xl md:text-8xl font-black uppercase tracking-tighter leading-none">Mateus<br />Muste</h1>
                    <div className="mt-4 flex flex-wrap gap-4 font-mono text-sm">
                        <span className="bg-black text-white px-2 py-1">DIGITAL DESIGNER</span>
                        <span className="bg-black text-white px-2 py-1">RADICAL OPTIMIST</span>
                        <span className="border border-black px-2 py-1">ROMANIA</span>
                        {totalVisitors && (
                            <span className="border border-black px-2 py-1 ml-auto">VISITORS: {totalVisitors.toLocaleString()}</span>
                        )}
                    </div>
                </header>
                <div className="grid md:grid-cols-2 gap-12">
                    <div className="space-y-8">
                        <section>
                            <h3 className="text-2xl font-black uppercase mb-4 border-b-2 border-black">App Stack</h3>
                            <div className="grid grid-cols-4 gap-1">
                                {[
                                    { name: 'PHOTOSHOP', yrs: 9 },
                                    { name: 'PREMIERE', yrs: 8 },
                                    { name: 'AFTER EFFECTS', yrs: 6 },
                                    { name: 'EXCEL', yrs: 5 },
                                    { name: 'META ADS', yrs: 5 },
                                    { name: 'DAVINCI', yrs: 4 },
                                    { name: 'ARCHICAD', yrs: 3 },
                                    { name: 'SQUARESPACE', yrs: 3 },
                                    { name: 'UNREAL', yrs: 3 },
                                    { name: 'WEBFLOW', yrs: 3 },
                                    { name: 'MIDJOURNEY', yrs: 2 },
                                    { name: 'GOOGLE ADS', yrs: 2 },
                                    { name: 'BLENDER', yrs: 1 },
                                    { name: 'CURSOR', yrs: 1 },
                                    { name: 'COMFYUI', yrs: 1 },
                                    { name: 'N8N', yrs: 1 }
                                ].map((app, i, arr) => (
                                    <div
                                        key={i}
                                        className="border-2 border-black aspect-square flex flex-col items-center justify-center p-1 cursor-default"
                                        style={{ opacity: 1 - (i / (arr.length - 1)) * 0.66 }}
                                    >
                                        <span className="font-black text-[8px] text-center leading-tight">{app.name}</span>
                                        <span className="font-mono text-[8px] mt-1">{app.yrs} YRS</span>
                                    </div>
                                ))}
                            </div>
                        </section>
                        <section><h3 className="text-2xl font-black uppercase mb-4 border-b-2 border-black">Metrics</h3>
                            <div className="flex gap-4">
                                <div className="p-4 border-2 border-black text-center"><div className="text-3xl font-black">C2</div><div className="font-mono text-[10px]">CAMBRIDGE</div></div>
                                <div className="p-4 border-2 border-black text-center"><div className="text-3xl font-black">1570</div><div className="font-mono text-[10px]">SAT</div></div>
                            </div>
                        </section>
                    </div>
                    <div className="space-y-4">
                        <h3 className="text-2xl font-black uppercase mb-4 border-b-2 border-black">Projects</h3>
                        {[
                            { t: "BIOBUILDS", num: "01", s: "Web / Video / Marketing", d: "Sustainable construction across Europe. Entered 3 markets." },
                            { t: "ROMANIA OLYMPICS 2024", num: "02", s: "Premiere / After Effects", d: "National contest winner. Cluj-Napoca." },
                            { t: "ULT", num: "03", s: "Documentary / Editing", d: "Self-directed channel. Skill laboratory." }
                        ].map((p, i) => (
                            <div key={i} className="group border-2 border-black p-4 hover:bg-black hover:text-white cursor-pointer">
                                <div className="flex justify-between mb-1"><h4 className="font-bold uppercase">{p.t}</h4><span className="font-mono text-xs">{p.num}</span></div>
                                <p className="font-mono text-xs opacity-70 mb-1">{p.s}</p><p className="text-sm italic">{p.d}</p>
                            </div>
                        ))}
                    </div>
                </div>
            </div>
            );
        };

        // ABOUT.EXE - Static portfolio page (no animations)
        const AboutApp = () => {
            const skills = [
                { name: 'PHOTOSHOP', yrs: 9 },
                { name: 'PREMIERE', yrs: 8 },
                { name: 'AFTER EFFECTS', yrs: 6 },
                { name: 'EXCEL', yrs: 5 },
                { name: 'META ADS', yrs: 5 },
                { name: 'DAVINCI', yrs: 4 },
                { name: 'ARCHICAD', yrs: 3 },
                { name: 'WEBFLOW', yrs: 3 },
                { name: 'UNREAL', yrs: 3 },
                { name: 'MIDJOURNEY', yrs: 2 },
                { name: 'CURSOR', yrs: 1 },
                { name: 'COMFYUI', yrs: 1 }
            ];

            const projects = [
                { t: "BIOBUILDS", s: "Web / Video / Marketing", d: "Sustainable construction across Europe." },
                { t: "ROMANIA OLYMPICS 2024", s: "Premiere / After Effects", d: "National contest winner." },
                { t: "ULT", s: "Documentary / Editing", d: "Self-directed channel." }
            ];

            return (
                <div className="h-full flex flex-col bg-white select-none overflow-auto">
                    <div className="p-6 md:p-8 space-y-8">
                        {/* Name */}
                        <h1 className="font-black tracking-tighter leading-[0.85]" style={{ fontSize: 'clamp(4rem, 15vw, 10rem)' }}>
                            MATEUS<br />MUSTE
                        </h1>

                        {/* Badges */}
                        <div className="flex flex-wrap gap-2">
                            <span className="bg-black text-white px-2 py-1 font-mono text-[10px] md:text-xs">DIGITAL DESIGNER</span>
                            <span className="bg-black text-white px-2 py-1 font-mono text-[10px] md:text-xs">RADICAL OPTIMIST</span>
                            <span className="border-2 border-black px-2 py-1 font-mono text-[10px] md:text-xs">ROMANIA</span>
                        </div>

                        {/* Skills */}
                        <div>
                            <h3 className="font-black text-lg uppercase mb-4 border-b-2 border-black pb-2">Skills</h3>
                            <div className="grid grid-cols-3 md:grid-cols-4 gap-2">
                                {skills.map((skill, i) => (
                                    <div key={i} className="border-2 border-black p-2 text-center" style={{ opacity: 1 - (i / skills.length) * 0.5 }}>
                                        <div className="font-bold text-[10px]">{skill.name}</div>
                                        <div className="font-mono text-[10px] text-gray-500">{skill.yrs} YRS</div>
                                    </div>
                                ))}
                            </div>
                        </div>

                        {/* Projects */}
                        <div>
                            <h3 className="font-black text-lg uppercase mb-4 border-b-2 border-black pb-2">Projects</h3>
                            <div className="space-y-2">
                                {projects.map((p, i) => (
                                    <div key={i} className="border-2 border-black p-3 hover:bg-black hover:text-white transition-colors cursor-pointer">
                                        <div className="font-bold text-sm uppercase">{p.t}</div>
                                        <div className="font-mono text-[10px] text-gray-500">{p.s}</div>
                                        <div className="text-[13px] mt-1">{p.d}</div>
                                    </div>
                                ))}
                            </div>
                        </div>

                    </div>
                </div>
            );
        };

        // MESSAGES.EXE - Messenger app for intro sequence
        const MessagesApp = ({ onIntroComplete }) => {
            const [messages, setMessages] = useState([]);
            const [isTyping, setIsTyping] = useState(false);
            const introStartedRef = useRef(false);
            const onIntroCompleteRef = useRef(onIntroComplete);
            const messagesEndRef = useRef(null);

            // Keep the callback ref updated
            onIntroCompleteRef.current = onIntroComplete;

            const introMessages = [
                "Hi!",
                "This isn't a portfolio. It's a mind system.",
                "Most of what I've built, loved, and learned is here.",
                "Some on display, some buried deeper.",
                "You start with four apps.",
                "Explore.",
                "Break things.",
                "Have fun."
            ];

            // Typing sound effect
            const playTypingSound = () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800 + Math.random() * 200, now);
                osc.frequency.exponentialRampToValueAtTime(400, now + 0.05);
                gain.gain.setValueAtTime(0.08, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.05);
            };

            // Message sent sound
            const playMessageSound = () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.exponentialRampToValueAtTime(900, now + 0.08);
                gain.gain.setValueAtTime(0.12, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.1);
            };

            // Start intro sequence when component mounts - use ref to prevent double-run
            useEffect(() => {
                if (introStartedRef.current) return;
                introStartedRef.current = true;

                let messageIndex = 0;
                let cancelled = false;

                const sendNextMessage = () => {
                    if (cancelled) return;
                    if (messageIndex >= introMessages.length) {
                        // All messages sent, wait 2 seconds then reveal apps
                        setTimeout(() => {
                            if (!cancelled) onIntroCompleteRef.current?.();
                        }, 2000);
                        return;
                    }

                    // Show typing indicator
                    setIsTyping(true);

                    // Play typing sounds for 1.5 seconds
                    const typingDuration = 1500;
                    const typingSoundInterval = setInterval(() => {
                        if (!cancelled) playTypingSound();
                    }, 100);

                    setTimeout(() => {
                        if (cancelled) {
                            clearInterval(typingSoundInterval);
                            return;
                        }
                        clearInterval(typingSoundInterval);
                        setIsTyping(false);
                        playMessageSound();
                        setMessages(prev => [...prev, introMessages[messageIndex]]);
                        messageIndex++;

                        // Next message after 3 seconds
                        setTimeout(sendNextMessage, 3000);
                    }, typingDuration);
                };

                // Start after a brief delay
                setTimeout(sendNextMessage, 1000);

                return () => { cancelled = true; };
            }, []); // Empty dependency array - run once only

            // Auto-scroll to bottom
            useEffect(() => {
                messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
            }, [messages, isTyping]);

            return (
                <div className="h-full flex flex-col bg-gray-100 select-none">
                    {/* Header */}
                    <div className="bg-white border-b-2 border-black p-3 flex items-center gap-3">
                        <div className="w-10 h-10 bg-black text-white flex items-center justify-center font-mono font-bold text-lg">
                            MM
                        </div>
                        <div>
                            <div className="font-mono font-bold text-sm">MATEUS MUSTE</div>
                            <div className="font-mono text-[10px] text-gray-500">
                                {isTyping ? 'typing...' : 'online'}
                            </div>
                        </div>
                    </div>

                    {/* Messages area */}
                    <div className="flex-grow overflow-auto p-4 space-y-3">
                        {messages.map((msg, i) => (
                            <div key={i} className="flex justify-start">
                                <div className="bg-white border-2 border-black px-4 py-2 max-w-[80%] shadow-sm">
                                    <p className="font-mono text-sm">{msg}</p>
                                </div>
                            </div>
                        ))}

                        {/* Typing indicator */}
                        {isTyping && (
                            <div className="flex justify-start">
                                <div className="bg-white border-2 border-black px-4 py-2 shadow-sm">
                                    <div className="flex gap-1">
                                        <span className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '0ms' }}></span>
                                        <span className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '150ms' }}></span>
                                        <span className="w-2 h-2 bg-gray-400 rounded-full animate-bounce" style={{ animationDelay: '300ms' }}></span>
                                    </div>
                                </div>
                            </div>
                        )}
                        <div ref={messagesEndRef} />
                    </div>

                    {/* Input area (disabled, just for show) */}
                    <div className="bg-white border-t-2 border-black p-3">
                        <div className="flex gap-2">
                            <input
                                type="text"
                                disabled
                                placeholder="..."
                                className="flex-grow border-2 border-black px-3 py-2 font-mono text-sm bg-gray-50 cursor-not-allowed"
                            />
                            <button disabled className="bg-gray-300 border-2 border-black px-4 py-2 font-mono text-xs font-bold cursor-not-allowed">
                                SEND
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        const TrashApp = () => {
            const [shakingFile, setShakingFile] = useState(null);

            const trashFiles = [
                { name: 'BITCOIN_WALLET.txt', icon: 'FileDoc' },
                { name: 'ACCEPTANCE_LETTER.pdf', icon: 'FileDoc' },
                { name: 'SCHEDULE.ics', icon: 'FileDoc' }
            ];

            const handleFileClick = (fileName) => {
                setShakingFile(fileName);
                setTimeout(() => setShakingFile(null), 500);
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="app-header">
                        <span className="app-header-title">RECYCLE_BIN</span>
                        <span className="app-header-subtitle">{trashFiles.length} ITEMS</span>
                    </div>
                    <div className="flex-grow p-4">
                        <div className="grid grid-cols-3 gap-4">
                            {trashFiles.map(file => (
                                <button
                                    key={file.name}
                                    onClick={() => handleFileClick(file.name)}
                                    className="group flex flex-col items-center gap-2 p-3 cursor-not-allowed hover:bg-gray-100"
                                    style={{
                                        animation: shakingFile === file.name ? 'shake 0.5s ease-in-out' : 'none'
                                    }}
                                >
                                    <div className="bg-white border-2 border-black p-2 icon-shadow opacity-50 group-hover:opacity-70">
                                        <Icons.FileDoc size={24} />
                                    </div>
                                    <span className="font-mono text-[8px] font-bold text-center break-all opacity-50 group-hover:opacity-70">{file.name}</span>
                                </button>
                            ))}
                        </div>
                    </div>
                    <div className="p-2 border-t-2 border-black text-center">
                        <span className="font-mono text-[10px] text-gray-500">PERMANENTLY DELETED</span>
                    </div>
                </div>
            );
        }

        // --- VOID.TXT - Text encrypts then fades into the void ---
        const VoidApp = ({ onAchievement }) => {
            // Each char: { id, char, timestamp, phase: 'visible'|'encrypting'|'fading', opacity }
            const [chars, setChars] = useState([]);
            const inputRef = useRef(null);
            const charIdRef = useRef(0);
            const [totalChars, setTotalChars] = useState(() => {
                const stored = localStorage.getItem('void_total_chars');
                return stored ? parseInt(stored, 10) : 0;
            });

            const encryptChar = () => {
                const symbols = '@#$%&*';
                return symbols[Math.floor(Math.random() * symbols.length)];
            };

            // Process loop - runs every 50ms to update char states
            useEffect(() => {
                const interval = setInterval(() => {
                    const now = Date.now();
                    setChars(prev => {
                        let updated = false;
                        const newChars = prev.map(c => {
                            // After 1.5s, start encrypting
                            if (c.phase === 'visible' && now - c.timestamp >= 1500) {
                                updated = true;
                                return { ...c, phase: 'encrypting', displayChar: encryptChar() };
                            }
                            // After encrypting for 300ms, start fading
                            if (c.phase === 'encrypting' && now - c.timestamp >= 1800) {
                                updated = true;
                                return { ...c, phase: 'fading', opacity: 0.8 };
                            }
                            // Fade out
                            if (c.phase === 'fading') {
                                const newOpacity = c.opacity - 0.15;
                                if (newOpacity <= 0) {
                                    updated = true;
                                    return null; // Mark for removal
                                }
                                updated = true;
                                return { ...c, opacity: newOpacity, displayChar: encryptChar() };
                            }
                            return c;
                        }).filter(Boolean);
                        return updated ? newChars : prev;
                    });
                }, 50);
                return () => clearInterval(interval);
            }, []);

            const handleKeyDown = (e) => {
                if (e.key === 'Backspace') {
                    // Remove most recent visible char
                    setChars(prev => {
                        const visibleChars = prev.filter(c => c.phase === 'visible');
                        if (visibleChars.length === 0) return prev;
                        const lastVisible = visibleChars[visibleChars.length - 1];
                        return prev.filter(c => c.id !== lastVisible.id);
                    });
                    e.preventDefault();
                } else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
                    // Add new character
                    const newChar = {
                        id: charIdRef.current++,
                        char: e.key,
                        displayChar: e.key,
                        timestamp: Date.now(),
                        phase: 'visible',
                        opacity: 1
                    };
                    setChars(prev => [...prev, newChar]);
                    // Track total characters for VOIDBORN achievement
                    const newTotal = totalChars + 1;
                    setTotalChars(newTotal);
                    localStorage.setItem('void_total_chars', newTotal.toString());
                    if (newTotal >= 1000) onAchievement?.('VOIDBORN');
                    e.preventDefault();
                }
            };

            // Render chars grouped - visible chars are white, encrypting are green
            const renderChars = () => {
                return chars.map(c => (
                    <span
                        key={c.id}
                        style={{
                            color: c.phase === 'encrypting' ? '#0f0' :
                                c.phase === 'fading' ? `rgba(0,255,0,${c.opacity})` : 'white',
                            textShadow: c.phase !== 'visible' ? '0 0 5px #0f0' : 'none'
                        }}
                    >
                        {c.displayChar}
                    </span>
                ));
            };

            return (
                <div
                    className="h-full flex flex-col bg-black select-none cursor-text"
                    onClick={() => inputRef.current?.focus()}
                    onCopy={(e) => e.preventDefault()}
                    onCut={(e) => e.preventDefault()}
                >
                    <div className="p-2 border-b border-gray-800 bg-black">
                        <span className="font-mono text-xs font-bold text-white">VOID.TXT</span>
                    </div>
                    <div className="flex-grow p-4 overflow-auto font-mono text-sm">
                        <div className="flex flex-wrap items-start">
                            <span className="mr-2 text-gray-600">{'>'}</span>
                            <div className="flex-grow">
                                {renderChars()}
                                <span className="animate-pulse text-white">_</span>
                            </div>
                        </div>
                        <input
                            ref={inputRef}
                            type="text"
                            className="absolute opacity-0 pointer-events-none"
                            onKeyDown={handleKeyDown}
                            onPaste={(e) => e.preventDefault()}
                            autoFocus
                        />
                    </div>
                </div>
            );
        };

        // --- RADIO.WAV - Playlist link ---
        const RadioApp = () => {
            const [isPlaying, setIsPlaying] = useState(false);
            const [visualizer, setVisualizer] = useState([]);

            useEffect(() => {
                const interval = setInterval(() => {
                    if (isPlaying) {
                        setVisualizer(Array(16).fill(0).map(() => Math.random() * 100));
                    }
                }, 100);
                return () => clearInterval(interval);
            }, [isPlaying]);

            const openPlaylist = () => {
                window.open('https://music.youtube.com/playlist?list=PLeIQRsOWZUhKaD53FTvwZCxsNWzjq0lfO&si=92O5A6kAPjk8Vzmg', '_blank');
                setIsPlaying(true);
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="app-header">
                        <span className="app-header-title">RADIO.WAV</span>
                        <span className="app-footer-text">MATEUS_PLAYLIST</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-8 bg-gray-50">
                        <div className="flex items-end justify-center gap-1 h-32 mb-8 p-4 border-2 border-black bg-white">
                            {(isPlaying ? visualizer : Array(16).fill(10)).map((h, i) => (
                                <div
                                    key={i}
                                    className="w-3 bg-black transition-all duration-100"
                                    style={{ height: `${h}%`, minHeight: '4px' }}
                                />
                            ))}
                        </div>
                        <button
                            onClick={openPlaylist}
                            className="btn-primary btn-lg"
                        >
                            {isPlaying ? ' NOW PLAYING' : ' TUNE IN'}
                        </button>
                        <div className="mt-4 font-mono text-xs text-gray-500">
                            OPENS YOUTUBE MUSIC
                        </div>
                    </div>
                    <div className="p-2 border-t-2 border-black bg-white">
                        <div className="font-mono text-[10px] text-gray-500 text-center">
                            BROADCASTING FROM THE VOID
                        </div>
                    </div>
                </div>
            );
        };

        // --- DICE.EXE - D20 Roller with Three.js ---
        const DiceApp = ({ onAchievement }) => {
            const [result, setResult] = useState(null);
            const [isRolling, setIsRolling] = useState(false);
            const isRollingRef = useRef(false); // Ref to avoid stale closure
            const containerRef = useRef(null);
            const sceneRef = useRef(null);
            const diceRef = useRef(null);
            const animationRef = useRef(null);
            const consecutiveTwenties = useRef(0);

            const getResultStyle = () => {
                if (!result) return '';
                if (result === 20) return 'bg-black text-white';
                if (result === 1) return 'border-2 border-black';
                return '';
            };

            // Initialize Three.js scene
            useEffect(() => {
                if (!containerRef.current || sceneRef.current) return;

                const width = 200;
                const height = 200;

                // Scene
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xffffff);

                // Camera
                const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
                camera.position.z = 4;

                // Renderer
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                renderer.setPixelRatio(window.devicePixelRatio);
                containerRef.current.appendChild(renderer.domElement);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(2, 2, 2);
                scene.add(directionalLight);

                const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
                backLight.position.set(-2, -2, -2);
                scene.add(backLight);

                // D20 (Icosahedron)
                const geometry = new THREE.IcosahedronGeometry(1.2, 0);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x111111,
                    metalness: 0.1,
                    roughness: 0.4,
                    flatShading: true
                });
                const dice = new THREE.Mesh(geometry, material);
                scene.add(dice);

                // Edge lines
                const edges = new THREE.EdgesGeometry(geometry);
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0x444444 });
                const wireframe = new THREE.LineSegments(edges, lineMaterial);
                dice.add(wireframe);

                diceRef.current = dice;
                sceneRef.current = { scene, camera, renderer };

                // Initial render
                renderer.render(scene, camera);

                // Idle animation - uses ref to avoid stale closure
                const idleAnimate = () => {
                    if (!isRollingRef.current) {
                        dice.rotation.x += 0.003;
                        dice.rotation.y += 0.005;
                    }
                    renderer.render(scene, camera);
                    animationRef.current = requestAnimationFrame(idleAnimate);
                };
                idleAnimate();

                return () => {
                    cancelAnimationFrame(animationRef.current);
                    renderer.dispose();
                    if (containerRef.current && renderer.domElement) {
                        containerRef.current.removeChild(renderer.domElement);
                    }
                };
            }, []);

            const rollDice = () => {
                if (isRolling || !diceRef.current || !sceneRef.current) return;
                setIsRolling(true);
                isRollingRef.current = true;
                setResult(null);
                sounds.diceRoll();

                const dice = diceRef.current;
                const { renderer, scene, camera } = sceneRef.current;

                // Random target rotation
                const targetRotX = dice.rotation.x + Math.PI * (4 + Math.random() * 4);
                const targetRotY = dice.rotation.y + Math.PI * (4 + Math.random() * 4);
                const targetRotZ = dice.rotation.z + Math.PI * (2 + Math.random() * 2);

                const startRotX = dice.rotation.x;
                const startRotY = dice.rotation.y;
                const startRotZ = dice.rotation.z;

                const duration = 1500;
                const startTime = Date.now();

                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // Easing - decelerate
                    const eased = 1 - Math.pow(1 - progress, 3);

                    dice.rotation.x = startRotX + (targetRotX - startRotX) * eased;
                    dice.rotation.y = startRotY + (targetRotY - startRotY) * eased;
                    dice.rotation.z = startRotZ + (targetRotZ - startRotZ) * eased;

                    renderer.render(scene, camera);

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        const roll = Math.floor(Math.random() * 20) + 1;
                        setResult(roll);
                        setIsRolling(false);
                        isRollingRef.current = false;
                        // Track consecutive 20s for IMPOSSIBLE achievement
                        if (roll === 20) {
                            consecutiveTwenties.current++;
                            if (consecutiveTwenties.current >= 3) {
                                onAchievement?.('IMPOSSIBLE');
                            }
                        } else {
                            consecutiveTwenties.current = 0;
                        }
                    }
                };

                animate();
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-2 border-b border-gray-200 bg-white flex justify-between items-center">
                        <span className="font-mono text-[10px] font-bold tracking-wider">DICE.EXE</span>
                        <span className="font-mono text-[10px] text-gray-400">D20</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-8 bg-white">
                        <div className="mb-8" ref={containerRef} style={{ width: 200, height: 200 }} />
                        {result && !isRolling && (
                            <div className={`font-mono text-[10px] tracking-widest mb-6 px-4 py-2 ${getResultStyle()}`}>
                                {result === 20 ? '20 CRITICAL' : result === 1 ? '1 USELESS' : `RESULT: ${result}`}
                            </div>
                        )}
                        <button
                            onClick={rollDice}
                            disabled={isRolling}
                            className="bg-black text-white px-6 py-2 font-mono text-[10px] tracking-widest hover:bg-gray-800 disabled:bg-gray-300 transition-colors"
                        >
                            {isRolling ? 'ROLLING' : 'ROLL'}
                        </button>
                    </div>
                </div>
            );
        };

        // --- SNEK.EXE ---
        const SnakeAppNew = ({ onAchievement }) => {
            const canvasRef = useRef(null);
            const [score, setScore] = useState(0);
            const achievementTriggered = useRef(false);
            const [highScore, setHighScore] = useState(() => HighScoreManager.getHighScore('snake'));
            const [gameOver, setGameOver] = useState(false);
            const [gameStarted, setGameStarted] = useState(false);
            const snake = useRef([{ x: 15, y: 10 }]);
            const food = useRef({ x: 20, y: 10 });
            const dir = useRef({ x: 1, y: 0 });
            const nextDir = useRef({ x: 1, y: 0 });
            const runningRef = useRef(false);
            const lastTimeRef = useRef(0);
            const frameRef = useRef(null);

            const GRID_W = 30;
            const GRID_H = 20;
            const CELL = 20;

            // Load high score from storage when IP is ready
            useEffect(() => {
                const loadHighScore = async () => {
                    await HighScoreManager.fetchIP();
                    setHighScore(HighScoreManager.getHighScore('snake'));
                };
                loadHighScore();
            }, []);

            const start = () => {
                snake.current = [{ x: 15, y: 10 }, { x: 14, y: 10 }, { x: 13, y: 10 }];
                dir.current = { x: 1, y: 0 };
                nextDir.current = { x: 1, y: 0 };
                food.current = { x: Math.floor(Math.random() * GRID_W), y: Math.floor(Math.random() * GRID_H) };
                setScore(0);
                setGameOver(false);
                setGameStarted(true);
                runningRef.current = true;
                lastTimeRef.current = 0;
            };

            const update = () => {
                const ctx = canvasRef.current?.getContext('2d');
                if (!ctx) return;

                dir.current = nextDir.current;
                const head = {
                    x: snake.current[0].x + dir.current.x,
                    y: snake.current[0].y + dir.current.y
                };

                // Wall collision
                if (head.x < 0 || head.x >= GRID_W || head.y < 0 || head.y >= GRID_H) {
                    endGame();
                    return;
                }

                // Self collision
                if (snake.current.some(s => s.x === head.x && s.y === head.y)) {
                    endGame();
                    return;
                }

                snake.current.unshift(head);

                // Eat food
                if (head.x === food.current.x && head.y === food.current.y) {
                    sounds.coin();
                    setScore(s => {
                        const newScore = s + 10;
                        setHighScore(h => {
                            const newHigh = Math.max(h, newScore);
                            HighScoreManager.saveHighScore('snake', newHigh);
                            return newHigh;
                        });
                        if (newScore >= 50 && !achievementTriggered.current) {
                            achievementTriggered.current = true;
                            onAchievement?.('OUROBOROS');
                        }
                        return newScore;
                    });
                    food.current = {
                        x: Math.floor(Math.random() * GRID_W),
                        y: Math.floor(Math.random() * GRID_H)
                    };
                } else {
                    snake.current.pop();
                }

                // Draw - light theme
                ctx.fillStyle = '#f5f5f5';
                ctx.fillRect(0, 0, GRID_W * CELL, GRID_H * CELL);

                // Grid lines (subtle)
                ctx.strokeStyle = '#e0e0e0';
                for (let i = 0; i <= GRID_W; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * CELL, 0);
                    ctx.lineTo(i * CELL, GRID_H * CELL);
                    ctx.stroke();
                }
                for (let i = 0; i <= GRID_H; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, i * CELL);
                    ctx.lineTo(GRID_W * CELL, i * CELL);
                    ctx.stroke();
                }

                // Snake - black
                snake.current.forEach((s, i) => {
                    ctx.fillStyle = i === 0 ? '#000' : '#333';
                    ctx.fillRect(s.x * CELL + 1, s.y * CELL + 1, CELL - 2, CELL - 2);
                });

                // Food - black dot
                ctx.fillStyle = '#000';
                ctx.fillRect(food.current.x * CELL + 6, food.current.y * CELL + 6, CELL - 12, CELL - 12);
            };

            const endGame = () => {
                runningRef.current = false;
                setGameOver(true);
                setGameStarted(false);
                sounds.gameOver();
            };

            // Game loop using requestAnimationFrame
            useEffect(() => {
                const gameLoop = (timestamp) => {
                    if (!runningRef.current) {
                        frameRef.current = requestAnimationFrame(gameLoop);
                        return;
                    }

                    if (timestamp - lastTimeRef.current >= 100) {
                        lastTimeRef.current = timestamp;
                        update();
                    }

                    frameRef.current = requestAnimationFrame(gameLoop);
                };

                frameRef.current = requestAnimationFrame(gameLoop);

                return () => {
                    if (frameRef.current) cancelAnimationFrame(frameRef.current);
                };
            }, []);

            useEffect(() => {
                const handle = (e) => {
                    if (!runningRef.current) return;
                    if (e.key === 'ArrowUp' && dir.current.y === 0) nextDir.current = { x: 0, y: -1 };
                    if (e.key === 'ArrowDown' && dir.current.y === 0) nextDir.current = { x: 0, y: 1 };
                    if (e.key === 'ArrowLeft' && dir.current.x === 0) nextDir.current = { x: -1, y: 0 };
                    if (e.key === 'ArrowRight' && dir.current.x === 0) nextDir.current = { x: 1, y: 0 };
                };
                window.addEventListener('keydown', handle);
                return () => window.removeEventListener('keydown', handle);
            }, []);

            // Initial canvas draw - light theme
            useEffect(() => {
                const ctx = canvasRef.current?.getContext('2d');
                if (ctx) {
                    ctx.fillStyle = '#f5f5f5';
                    ctx.fillRect(0, 0, GRID_W * CELL, GRID_H * CELL);

                    // Draw grid lines
                    ctx.strokeStyle = '#e0e0e0';
                    for (let i = 0; i <= GRID_W; i++) {
                        ctx.beginPath();
                        ctx.moveTo(i * CELL, 0);
                        ctx.lineTo(i * CELL, GRID_H * CELL);
                        ctx.stroke();
                    }
                    for (let i = 0; i <= GRID_H; i++) {
                        ctx.beginPath();
                        ctx.moveTo(0, i * CELL);
                        ctx.lineTo(GRID_W * CELL, i * CELL);
                        ctx.stroke();
                    }
                }
            }, []);

            // Touch controls for mobile
            const handleDirection = (newDir) => {
                if (!runningRef.current) return;
                if (newDir === 'up' && dir.current.y === 0) nextDir.current = { x: 0, y: -1 };
                if (newDir === 'down' && dir.current.y === 0) nextDir.current = { x: 0, y: 1 };
                if (newDir === 'left' && dir.current.x === 0) nextDir.current = { x: -1, y: 0 };
                if (newDir === 'right' && dir.current.x === 0) nextDir.current = { x: 1, y: 0 };
            };

            // Swipe detection
            const touchStartRef = useRef({ x: 0, y: 0 });
            const handleTouchStart = (e) => {
                touchStartRef.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            };
            const handleTouchEnd = (e) => {
                if (!runningRef.current) return;
                const dx = e.changedTouches[0].clientX - touchStartRef.current.x;
                const dy = e.changedTouches[0].clientY - touchStartRef.current.y;
                if (Math.abs(dx) > Math.abs(dy)) {
                    if (dx > 30) handleDirection('right');
                    else if (dx < -30) handleDirection('left');
                } else {
                    if (dy > 30) handleDirection('down');
                    else if (dy < -30) handleDirection('up');
                }
            };

            return (
                <div className="h-full flex flex-col bg-white select-none" onTouchStart={handleTouchStart} onTouchEnd={handleTouchEnd}>
                    <div className="app-header">
                        <span className="app-header-title">SNEK.EXE</span>
                        <div className="flex gap-4 font-mono text-xs">
                            <span>SCORE: <span className="font-bold">{score}</span></span>
                            <span>HIGH: <span className="font-bold">{highScore}</span></span>
                            <span className={gameOver ? 'text-red-600' : gameStarted ? 'text-green-600' : 'text-gray-500'}>
                                {gameOver ? 'DEAD' : gameStarted ? 'ALIVE' : 'READY'}
                            </span>
                        </div>
                    </div>
                    <div className="flex-grow flex items-center justify-center p-2 md:p-4 bg-gray-50 overflow-hidden">
                        <div className="relative border-2 border-black" style={{ width: 'min(100%, 600px)', aspectRatio: '3/2' }}>
                            <canvas ref={canvasRef} width={600} height={400} className="block w-full h-full" style={{ imageRendering: 'pixelated' }} />
                            {!gameStarted && (
                                <div className="absolute inset-0 bg-white/95 flex flex-col items-center justify-center">
                                    <div className="text-4xl font-black mb-2 tracking-widest">SNEK</div>
                                    {gameOver && <p className="text-red-600 mb-4 font-mono text-sm">GAME OVER</p>}
                                    <button
                                        onClick={start}
                                        className="btn-primary"
                                    >
                                        {gameOver ? 'RETRY' : 'START'}
                                    </button>
                                    <p className="mt-4 text-gray-500 font-mono text-xs text-center px-4 hidden md:block">ARROW KEYS TO MOVE</p>
                                    <p className="mt-4 text-gray-500 font-mono text-xs text-center px-4 md:hidden">SWIPE TO MOVE</p>
                                </div>
                            )}
                        </div>
                    </div>
                    <div className="app-footer">
                        <span className="app-footer-text">EAT FOOD  GROW LONGER  DON'T DIE</span>
                    </div>
                </div>
            );
        };

        // --- LABYRINTH.EXE - Procedural Maze ---
        const LabyrinthApp = ({ onAchievement }) => {
            const canvasRef = useRef(null);
            const [level, setLevel] = useState(1);
            const [score, setScore] = useState(0);
            const [highScore, setHighScore] = useState(() => HighScoreManager.getHighScore('labyrinth'));
            const [won, setWon] = useState(false);
            const [showingMaze, setShowingMaze] = useState(false);
            const mazeRef = useRef(null);
            const playerRef = useRef({ x: 1, y: 1 });
            const exitRef = useRef({ x: 0, y: 0 });

            const CELL_SIZE = 8; // Thinner walls

            // Load high score from storage when IP is ready
            useEffect(() => {
                const loadHighScore = async () => {
                    await HighScoreManager.fetchIP();
                    setHighScore(HighScoreManager.getHighScore('labyrinth'));
                };
                loadHighScore();
            }, []);

            const generateMaze = (width, height) => {
                const maze = Array(height).fill(null).map(() => Array(width).fill(1));

                // Iterative maze generation to avoid stack overflow on large mazes
                const stack = [[1, 1]];
                maze[1][1] = 0;

                while (stack.length > 0) {
                    const [x, y] = stack[stack.length - 1];
                    const directions = [[0, -2], [0, 2], [-2, 0], [2, 0]].sort(() => Math.random() - 0.5);
                    let found = false;

                    for (const [dx, dy] of directions) {
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx > 0 && nx < width - 1 && ny > 0 && ny < height - 1 && maze[ny][nx] === 1) {
                            maze[y + dy / 2][x + dx / 2] = 0;
                            maze[ny][nx] = 0;
                            stack.push([nx, ny]);
                            found = true;
                            break;
                        }
                    }

                    if (!found) stack.pop();
                }
                return maze;
            };

            const startLevel = (lvl) => {
                // Start tiny and get exponentially harder with each level
                // Level 1: 9x9, Level 2: 11x11, Level 3: 15x15, Level 5: 27x27, Level 10: 99x99
                const size = 7 + Math.floor(Math.pow(1.5, lvl) * 2);
                const cappedSize = Math.min(size | 1, 151); // Ensure odd, cap at 151
                const maze = generateMaze(cappedSize | 1, cappedSize | 1);
                mazeRef.current = maze;
                playerRef.current = { x: 1, y: 1 };

                // Find exit (bottom-right area)
                for (let y = maze.length - 2; y > maze.length / 2; y--) {
                    for (let x = maze[0].length - 2; x > maze[0].length / 2; x--) {
                        if (maze[y][x] === 0) {
                            exitRef.current = { x, y };
                            break;
                        }
                    }
                    if (exitRef.current.x !== 0) break;
                }

                setWon(false);
                setShowingMaze(false);
                draw();
            };

            const draw = () => {
                const canvas = canvasRef.current;
                if (!canvas || !mazeRef.current) return;
                const ctx = canvas.getContext('2d');
                const maze = mazeRef.current;

                canvas.width = maze[0].length * CELL_SIZE;
                canvas.height = maze.length * CELL_SIZE;

                // Draw maze - clean minimal style
                for (let y = 0; y < maze.length; y++) {
                    for (let x = 0; x < maze[0].length; x++) {
                        ctx.fillStyle = maze[y][x] === 1 ? '#111' : '#fafafa';
                        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }

                // Draw exit - simple square
                const ex = exitRef.current.x * CELL_SIZE;
                const ey = exitRef.current.y * CELL_SIZE;
                ctx.fillStyle = '#fafafa';
                ctx.fillRect(ex, ey, CELL_SIZE, CELL_SIZE);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(ex + 2, ey + 2, CELL_SIZE - 4, CELL_SIZE - 4);

                // Draw player - simple filled square
                const px = playerRef.current.x * CELL_SIZE;
                const py = playerRef.current.y * CELL_SIZE;
                ctx.fillStyle = '#000';
                ctx.fillRect(px + 2, py + 2, CELL_SIZE - 4, CELL_SIZE - 4);
            };

            const move = (dx, dy) => {
                if (won || showingMaze) return;
                const maze = mazeRef.current;
                if (!maze) return;

                const nx = playerRef.current.x + dx;
                const ny = playerRef.current.y + dy;

                if (nx >= 0 && nx < maze[0].length && ny >= 0 && ny < maze.length && maze[ny][nx] === 0) {
                    playerRef.current = { x: nx, y: ny };
                    draw();

                    if (nx === exitRef.current.x && ny === exitRef.current.y) {
                        const points = level * 100;
                        setScore(s => {
                            const newScore = s + points;
                            setHighScore(h => {
                                const newHigh = Math.max(h, newScore);
                                HighScoreManager.saveHighScore('labyrinth', newHigh);
                                return newHigh;
                            });
                            return newScore;
                        });
                        setWon(true);
                        sounds.success();

                        // FIRST_BLOOD - win any game
                        onAchievement?.('FIRST_BLOOD');
                        // Check for DAEDALUS achievement
                        if (level >= 10) onAchievement?.('DAEDALUS');

                        // Show full maze then start next level
                        setTimeout(() => {
                            setShowingMaze(true);
                            setTimeout(() => {
                                setLevel(l => l + 1);
                                startLevel(level + 1);
                            }, 2000);
                        }, 1000);
                    }
                }
            };

            const giveUp = () => {
                setLevel(1);
                setScore(0);
                startLevel(1);
            };

            useEffect(() => {
                const handle = (e) => {
                    if (e.key === 'ArrowUp') move(0, -1);
                    if (e.key === 'ArrowDown') move(0, 1);
                    if (e.key === 'ArrowLeft') move(-1, 0);
                    if (e.key === 'ArrowRight') move(1, 0);
                };
                window.addEventListener('keydown', handle);
                startLevel(1);
                return () => window.removeEventListener('keydown', handle);
            }, []);

            // Touch/swipe controls for mobile
            const touchStartRef = useRef({ x: 0, y: 0 });
            const handleTouchStart = (e) => {
                touchStartRef.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            };
            const handleTouchEnd = (e) => {
                const dx = e.changedTouches[0].clientX - touchStartRef.current.x;
                const dy = e.changedTouches[0].clientY - touchStartRef.current.y;
                const threshold = 20;
                if (Math.abs(dx) > Math.abs(dy)) {
                    if (dx > threshold) move(1, 0);
                    else if (dx < -threshold) move(-1, 0);
                } else {
                    if (dy > threshold) move(0, 1);
                    else if (dy < -threshold) move(0, -1);
                }
            };

            return (
                <div className="h-full flex flex-col bg-white select-none" onTouchStart={handleTouchStart} onTouchEnd={handleTouchEnd}>
                    <div className="h-8 px-3 flex justify-between items-center">
                        <span className="font-mono text-[10px] font-bold tracking-widest text-black">LABYRINTH</span>
                        <div className="flex gap-6 font-mono text-[10px]">
                            <span className="text-gray-400">LVL <span className="text-black font-bold">{level}</span></span>
                            <span className="text-gray-400">PTS <span className="text-black font-bold">{score}</span></span>
                        </div>
                    </div>
                    <div className="flex-grow flex items-center justify-center relative bg-white">
                        {won && !showingMaze && (
                            <div className="absolute inset-0 bg-white/95 flex items-center justify-center z-10">
                                <div className="text-center">
                                    <div className="text-2xl font-black tracking-widest">CLEAR</div>
                                    <div className="font-mono text-[10px] text-gray-400 mt-1">+{level * 100}</div>
                                </div>
                            </div>
                        )}
                        {showingMaze && (
                            <div className="absolute inset-0 bg-white flex items-center justify-center z-10">
                                <div className="font-mono text-[10px] text-gray-400 tracking-widest animate-pulse">
                                    GENERATING LEVEL {level}
                                </div>
                            </div>
                        )}
                        <canvas ref={canvasRef} className="block" style={{ imageRendering: 'pixelated' }} />
                    </div>
                    <div className="h-8 px-3 flex justify-between items-center">
                        <span className="font-mono text-[10px] text-gray-300 hidden md:inline"></span>
                        <span className="font-mono text-[10px] text-gray-300 md:hidden">SWIPE TO MOVE</span>
                        <button
                            onClick={giveUp}
                            className="font-mono text-[10px] text-gray-300 hover:text-black transition-colors"
                        >
                            RESTART
                        </button>
                    </div>
                </div>
            );
        };

        // --- MINESWEEPER.EXE - Ultra Clean Minesweeper ---
        const MinesweeperApp = ({ onAchievement }) => {
            const [grid, setGrid] = useState([]);
            const [revealed, setRevealed] = useState([]);
            const [flagged, setFlagged] = useState([]);
            const [gameOver, setGameOver] = useState(false);
            const [won, setWon] = useState(false);
            const [mineCount, setMineCount] = useState(0);
            const [time, setTime] = useState(0);
            const [started, setStarted] = useState(false);
            const timerRef = useRef(null);
            const usedFlags = useRef(false);

            const ROWS = 12;
            const COLS = 16;
            const MINES = 30;

            const initGame = () => {
                // Create empty grid
                const newGrid = Array(ROWS).fill(null).map(() => Array(COLS).fill(0));
                const newRevealed = Array(ROWS).fill(null).map(() => Array(COLS).fill(false));
                const newFlagged = Array(ROWS).fill(null).map(() => Array(COLS).fill(false));

                // Place mines
                let placed = 0;
                while (placed < MINES) {
                    const r = Math.floor(Math.random() * ROWS);
                    const c = Math.floor(Math.random() * COLS);
                    if (newGrid[r][c] !== -1) {
                        newGrid[r][c] = -1;
                        placed++;
                    }
                }

                // Calculate numbers
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (newGrid[r][c] === -1) continue;
                        let count = 0;
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                const nr = r + dr, nc = c + dc;
                                if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && newGrid[nr][nc] === -1) {
                                    count++;
                                }
                            }
                        }
                        newGrid[r][c] = count;
                    }
                }

                setGrid(newGrid);
                setRevealed(newRevealed);
                setFlagged(newFlagged);
                setGameOver(false);
                setWon(false);
                setMineCount(MINES);
                setTime(0);
                setStarted(false);
                usedFlags.current = false;
                if (timerRef.current) clearInterval(timerRef.current);
            };

            useEffect(() => {
                initGame();
                return () => { if (timerRef.current) clearInterval(timerRef.current); };
            }, []);

            useEffect(() => {
                if (started && !gameOver && !won) {
                    timerRef.current = setInterval(() => setTime(t => t + 1), 1000);
                }
                return () => { if (timerRef.current) clearInterval(timerRef.current); };
            }, [started, gameOver, won]);

            const reveal = (r, c) => {
                if (gameOver || won || revealed[r][c] || flagged[r][c]) return;

                if (!started) setStarted(true);

                const newRevealed = revealed.map(row => [...row]);

                if (grid[r][c] === -1) {
                    // Hit mine - reveal all mines
                    sounds.explosion();
                    for (let i = 0; i < ROWS; i++) {
                        for (let j = 0; j < COLS; j++) {
                            if (grid[i][j] === -1) newRevealed[i][j] = true;
                        }
                    }
                    setRevealed(newRevealed);
                    setGameOver(true);
                    return;
                }

                // Safe cell - play ding
                sounds.mineDing();

                // Flood fill for empty cells
                const flood = (row, col) => {
                    if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return;
                    if (newRevealed[row][col] || flagged[row][col]) return;
                    newRevealed[row][col] = true;
                    if (grid[row][col] === 0) {
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                flood(row + dr, col + dc);
                            }
                        }
                    }
                };

                flood(r, c);
                setRevealed(newRevealed);

                // Check win
                let unrevealed = 0;
                for (let i = 0; i < ROWS; i++) {
                    for (let j = 0; j < COLS; j++) {
                        if (!newRevealed[i][j]) unrevealed++;
                    }
                }
                if (unrevealed === MINES) {
                    setWon(true);
                    onAchievement?.('FIRST_BLOOD');
                    if (!usedFlags.current) onAchievement?.('UNTOUCHABLE');
                }
            };

            const flag = (e, r, c) => {
                e.preventDefault();
                if (gameOver || won || revealed[r][c]) return;
                if (!started) setStarted(true);
                usedFlags.current = true;

                const newFlagged = flagged.map(row => [...row]);
                newFlagged[r][c] = !newFlagged[r][c];
                setFlagged(newFlagged);
                setMineCount(m => newFlagged[r][c] ? m - 1 : m + 1);
            };

            const getCellContent = (r, c) => {
                if (flagged[r][c]) return '';
                if (!revealed[r][c]) return '';
                if (grid[r][c] === -1) return '';
                if (grid[r][c] === 0) return '';
                return grid[r][c];
            };

            const getCellStyle = (r, c) => {
                if (flagged[r][c]) return 'bg-gray-100 text-black';
                if (!revealed[r][c]) return 'bg-gray-200 hover:bg-gray-300';
                if (grid[r][c] === -1) return 'bg-black text-white';
                return 'bg-white text-black';
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="h-10 px-4 flex justify-between items-center border-b border-gray-100">
                        <span className="font-mono text-[10px] font-bold tracking-widest text-black">MINESWEEPER</span>
                        <div className="flex gap-8 font-mono text-[10px]">
                            <span className="text-gray-400">MINES <span className="text-black font-bold">{mineCount.toString().padStart(3, '0')}</span></span>
                            <span className="text-gray-400">TIME <span className="text-black font-bold">{time.toString().padStart(3, '0')}</span></span>
                        </div>
                    </div>

                    <div className="flex-grow flex items-center justify-center relative bg-gray-50 p-4">
                        {(gameOver || won) && (
                            <div className="absolute inset-0 bg-white/95 flex items-center justify-center z-10">
                                <div className="text-center">
                                    <div className="text-2xl font-black tracking-widest">{won ? 'CLEARED' : 'DETONATED'}</div>
                                    <div className="font-mono text-[10px] text-gray-400 mt-2">{time}s</div>
                                    <button
                                        onClick={initGame}
                                        className="mt-4 px-4 py-2 bg-black text-white font-mono text-[10px] tracking-widest hover:bg-gray-800"
                                    >
                                        RETRY
                                    </button>
                                </div>
                            </div>
                        )}

                        <div className="border border-gray-200">
                            {grid.map((row, r) => (
                                <div key={r} className="flex">
                                    {row.map((cell, c) => (
                                        <button
                                            key={c}
                                            onClick={() => reveal(r, c)}
                                            onContextMenu={(e) => flag(e, r, c)}
                                            className={`w-6 h-6 border border-gray-100 font-mono text-[10px] font-bold flex items-center justify-center transition-colors ${getCellStyle(r, c)}`}
                                        >
                                            {getCellContent(r, c)}
                                        </button>
                                    ))}
                                </div>
                            ))}
                        </div>
                    </div>

                    <div className="h-8 px-4 flex justify-between items-center border-t border-gray-100">
                        <span className="font-mono text-[10px] text-gray-300">LEFT CLICK REVEAL  RIGHT CLICK FLAG</span>
                        <button
                            onClick={initGame}
                            className="font-mono text-[10px] text-gray-300 hover:text-black transition-colors"
                        >
                            NEW GAME
                        </button>
                    </div>
                </div>
            );
        };

        // --- STARSHIP.EXE - Low Poly Star Fox Style Game ---
        const StarshipApp = ({ onAchievement }) => {
            const containerRef = useRef(null);
            const gameRef = useRef(null);
            const keysRef = useRef({ left: false, right: false, up: false, down: false, shoot: false });
            const touchRef = useRef({ startX: 0, startY: 0, startTime: 0, isDragging: false });
            const [score, setScore] = useState(0);
            const [highScore, setHighScore] = useState(() => HighScoreManager.getHighScore('starship'));
            const [gameOver, setGameOver] = useState(false);
            const [started, setStarted] = useState(false);
            const achievementTriggered = useRef(false);
            const onAchievementRef = useRef(onAchievement);
            onAchievementRef.current = onAchievement;

            // Load high score from storage when IP is ready
            useEffect(() => {
                const loadHighScore = async () => {
                    await HighScoreManager.fetchIP();
                    setHighScore(HighScoreManager.getHighScore('starship'));
                };
                loadHighScore();
            }, []);

            // Mobile control handlers
            const handleStart = () => {
                if (gameRef.current) {
                    if (gameOver) gameRef.current.restart();
                    else gameRef.current.start();
                }
            };

            // Touch-based drag controls
            const handleTouchStart = (e) => {
                const touch = e.touches[0];
                touchRef.current = {
                    startX: touch.clientX,
                    startY: touch.clientY,
                    startTime: Date.now(),
                    isDragging: false
                };
            };

            const handleTouchMove = (e) => {
                if (!started || gameOver) return;
                e.preventDefault();
                const touch = e.touches[0];
                const dx = touch.clientX - touchRef.current.startX;
                const dy = touch.clientY - touchRef.current.startY;
                touchRef.current.isDragging = true;

                // Set movement based on drag position (relative to start)
                const threshold = 20;
                keysRef.current.left = dx < -threshold;
                keysRef.current.right = dx > threshold;
                keysRef.current.up = dy < -threshold;
                keysRef.current.down = dy > threshold;
            };

            const handleTouchEnd = (e) => {
                // Reset all movement
                keysRef.current.left = false;
                keysRef.current.right = false;
                keysRef.current.up = false;
                keysRef.current.down = false;

                // Tap to shoot (short touch without much movement)
                const elapsed = Date.now() - touchRef.current.startTime;
                if (elapsed < 200 && !touchRef.current.isDragging) {
                    if (!started && !gameOver) {
                        handleStart();
                    } else if (gameRef.current && started && !gameOver) {
                        gameRef.current.shoot();
                    }
                }
            };

            useEffect(() => {
                if (!containerRef.current || gameRef.current) return;

                const width = 500;
                const height = 350;

                // Scene
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xffffff);
                scene.fog = new THREE.Fog(0xffffff, 20, 80);

                // Camera
                const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
                camera.position.set(0, 2, 0);
                camera.lookAt(0, 0, -20);

                // Renderer
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                containerRef.current.appendChild(renderer.domElement);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
                scene.add(ambientLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(5, 10, 5);
                scene.add(dirLight);

                // Create low-poly ship
                const createShip = () => {
                    const group = new THREE.Group();

                    // Main body - elongated pyramid
                    const bodyGeo = new THREE.ConeGeometry(0.3, 1.2, 4);
                    bodyGeo.rotateX(Math.PI / 2);
                    const bodyMat = new THREE.MeshStandardMaterial({ color: 0x000000, flatShading: true });
                    const body = new THREE.Mesh(bodyGeo, bodyMat);
                    group.add(body);

                    // Wings
                    const wingGeo = new THREE.BoxGeometry(1.8, 0.05, 0.4);
                    const wingMat = new THREE.MeshStandardMaterial({ color: 0x111111, flatShading: true });
                    const wings = new THREE.Mesh(wingGeo, wingMat);
                    wings.position.z = 0.2;
                    group.add(wings);

                    // Tail fins
                    const tailGeo = new THREE.BoxGeometry(0.05, 0.4, 0.3);
                    const tail1 = new THREE.Mesh(tailGeo, wingMat);
                    tail1.position.set(0, 0.15, 0.4);
                    group.add(tail1);

                    // Edges
                    const edges = new THREE.EdgesGeometry(bodyGeo);
                    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x444444 }));
                    group.add(line);

                    return group;
                };

                const ship = createShip();
                ship.position.set(0, 0, -5);
                scene.add(ship);

                // Ground grid
                const gridSize = 100;
                const gridGeo = new THREE.PlaneGeometry(gridSize, gridSize, 20, 20);
                gridGeo.rotateX(-Math.PI / 2);
                const gridMat = new THREE.MeshBasicMaterial({ color: 0xeeeeee, wireframe: true });
                const grid = new THREE.Mesh(gridGeo, gridMat);
                grid.position.y = -3;
                scene.add(grid);

                // Obstacles array
                const obstacles = [];
                const lasers = [];

                const createObstacle = () => {
                    const types = ['asteroid', 'enemy'];
                    const type = types[Math.floor(Math.random() * types.length)];
                    let mesh;

                    if (type === 'asteroid') {
                        const geo = new THREE.IcosahedronGeometry(0.5 + Math.random() * 0.5, 0);
                        const mat = new THREE.MeshStandardMaterial({ color: 0x222222, flatShading: true });
                        mesh = new THREE.Mesh(geo, mat);
                        const edges = new THREE.EdgesGeometry(geo);
                        mesh.add(new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 })));
                    } else {
                        const geo = new THREE.OctahedronGeometry(0.4, 0);
                        const mat = new THREE.MeshStandardMaterial({ color: 0x000000, flatShading: true });
                        mesh = new THREE.Mesh(geo, mat);
                        const edges = new THREE.EdgesGeometry(geo);
                        mesh.add(new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x666666 })));
                    }

                    mesh.position.set(
                        (Math.random() - 0.5) * 8,
                        (Math.random() - 0.5) * 4,
                        -60 - Math.random() * 20
                    );
                    mesh.userData = { type, speed: 0.3 + Math.random() * 0.2 };
                    scene.add(mesh);
                    obstacles.push(mesh);
                };

                const createLaser = () => {
                    const geo = new THREE.BoxGeometry(0.05, 0.05, 0.8);
                    const mat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                    const laser = new THREE.Mesh(geo, mat);
                    laser.position.copy(ship.position);
                    laser.position.z -= 0.8;
                    scene.add(laser);
                    lasers.push(laser);
                };

                // Controls - using ref so mobile can update too
                const keys = keysRef.current;
                let canShoot = true;
                let scoreVal = 0;
                let isGameOver = false;
                let isStarted = false;

                const doShoot = () => {
                    if (canShoot && isStarted && !isGameOver) {
                        sounds.laser();
                        createLaser();
                        canShoot = false;
                        setTimeout(() => canShoot = true, 150);
                    }
                };

                const onKeyDown = (e) => {
                    if (!isStarted && e.code === 'Space') {
                        isStarted = true;
                        setStarted(true);
                        return;
                    }
                    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
                    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
                    if (e.code === 'ArrowUp' || e.code === 'KeyW') keys.up = true;
                    if (e.code === 'ArrowDown' || e.code === 'KeyS') keys.down = true;
                    if (e.code === 'Space') doShoot();
                };
                const onKeyUp = (e) => {
                    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
                    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
                    if (e.code === 'ArrowUp' || e.code === 'KeyW') keys.up = false;
                    if (e.code === 'ArrowDown' || e.code === 'KeyS') keys.down = false;
                };

                window.addEventListener('keydown', onKeyDown);
                window.addEventListener('keyup', onKeyUp);

                // Spawn obstacles
                let spawnTimer = 0;

                // Animation loop
                let animationId;
                const animate = () => {
                    animationId = requestAnimationFrame(animate);

                    if (!isStarted || isGameOver) {
                        ship.rotation.z = Math.sin(Date.now() * 0.002) * 0.1;
                        renderer.render(scene, camera);
                        return;
                    }

                    // Move ship
                    const moveSpeed = 0.12;
                    if (keys.left) ship.position.x -= moveSpeed;
                    if (keys.right) ship.position.x += moveSpeed;
                    if (keys.up) ship.position.y += moveSpeed;
                    if (keys.down) ship.position.y -= moveSpeed;

                    // Clamp ship position
                    ship.position.x = Math.max(-4, Math.min(4, ship.position.x));
                    ship.position.y = Math.max(-2, Math.min(2, ship.position.y));

                    // Tilt ship based on movement
                    ship.rotation.z = -keys.left * 0.3 + keys.right * 0.3;
                    ship.rotation.x = keys.down * 0.2 - keys.up * 0.2;

                    // Move grid for speed effect
                    grid.position.z = (grid.position.z + 0.5) % 5;

                    // Spawn obstacles
                    spawnTimer++;
                    if (spawnTimer > 30) {
                        createObstacle();
                        spawnTimer = 0;
                    }

                    // Update obstacles
                    for (let i = obstacles.length - 1; i >= 0; i--) {
                        const obs = obstacles[i];
                        obs.position.z += obs.userData.speed;
                        obs.rotation.x += 0.02;
                        obs.rotation.y += 0.01;

                        // Remove if passed
                        if (obs.position.z > 5) {
                            scene.remove(obs);
                            obstacles.splice(i, 1);
                            scoreVal += 10;
                            setScore(scoreVal);
                            if (scoreVal >= 10000 && !achievementTriggered.current) {
                                achievementTriggered.current = true;
                                onAchievementRef.current?.('ACE');
                            }
                        }

                        // Collision with ship
                        const dist = ship.position.distanceTo(obs.position);
                        if (dist < 1) {
                            isGameOver = true;
                            setGameOver(true);
                            sounds.explosion();
                            // Save high score on game over
                            setHighScore(h => {
                                const newHigh = Math.max(h, scoreVal);
                                HighScoreManager.saveHighScore('starship', newHigh);
                                return newHigh;
                            });
                        }
                    }

                    // Update lasers
                    for (let i = lasers.length - 1; i >= 0; i--) {
                        const laser = lasers[i];
                        laser.position.z -= 1.5;

                        // Remove if too far
                        if (laser.position.z < -80) {
                            scene.remove(laser);
                            lasers.splice(i, 1);
                            continue;
                        }

                        // Check collision with obstacles
                        for (let j = obstacles.length - 1; j >= 0; j--) {
                            const obs = obstacles[j];
                            if (laser.position.distanceTo(obs.position) < 0.8) {
                                scene.remove(laser);
                                scene.remove(obs);
                                lasers.splice(i, 1);
                                obstacles.splice(j, 1);
                                sounds.explosion();
                                scoreVal += 50;
                                setScore(scoreVal);
                                if (scoreVal >= 10000 && !achievementTriggered.current) {
                                    achievementTriggered.current = true;
                                    onAchievementRef.current?.('ACE');
                                }
                                break;
                            }
                        }
                    }

                    renderer.render(scene, camera);
                };
                animate();

                gameRef.current = {
                    restart: () => {
                        obstacles.forEach(o => scene.remove(o));
                        lasers.forEach(l => scene.remove(l));
                        obstacles.length = 0;
                        lasers.length = 0;
                        ship.position.set(0, 0, -5);
                        scoreVal = 0;
                        isGameOver = false;
                        isStarted = true;
                        setScore(0);
                        setGameOver(false);
                        setStarted(true);
                    },
                    start: () => {
                        if (!isStarted) {
                            isStarted = true;
                            setStarted(true);
                        }
                    },
                    shoot: doShoot
                };

                return () => {
                    cancelAnimationFrame(animationId);
                    window.removeEventListener('keydown', onKeyDown);
                    window.removeEventListener('keyup', onKeyUp);
                    renderer.dispose();
                    if (containerRef.current && renderer.domElement) {
                        containerRef.current.removeChild(renderer.domElement);
                    }
                };
            }, []);

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="h-10 px-4 flex justify-between items-center border-b border-gray-100">
                        <span className="font-mono text-[10px] font-bold tracking-widest text-black">STARSHIP</span>
                        <div className="flex gap-4">
                            <span className="font-mono text-[10px] text-gray-400">HI <span className="text-gray-600 font-bold">{highScore.toString().padStart(6, '0')}</span></span>
                            <span className="font-mono text-[10px] text-gray-400">SCORE <span className="text-black font-bold">{score.toString().padStart(6, '0')}</span></span>
                        </div>
                    </div>

                    <div className="flex-grow flex items-center justify-center relative bg-gray-50 overflow-hidden">
                        {!started && !gameOver && (
                            <div className="absolute inset-0 bg-white/90 flex items-center justify-center z-10">
                                <div className="text-center">
                                    <div className="text-2xl font-black tracking-widest mb-2">STARSHIP</div>
                                    <div className="font-mono text-[10px] text-gray-400 mb-4">LOW POLY COMBAT</div>
                                    <button onClick={handleStart} className="btn-primary btn-xs tracking-widest">
                                        TAP TO START
                                    </button>
                                </div>
                            </div>
                        )}
                        {gameOver && (
                            <div className="absolute inset-0 bg-white/95 flex items-center justify-center z-10">
                                <div className="text-center">
                                    <div className="text-2xl font-black tracking-widest">DESTROYED</div>
                                    <div className="font-mono text-[10px] text-gray-400 mt-2">SCORE: {score}</div>
                                    <div className="font-mono text-[10px] text-gray-500 mt-1">HIGH: {highScore}</div>
                                    <button
                                        onClick={() => gameRef.current?.restart()}
                                        className="mt-4 px-4 py-2 bg-black text-white font-mono text-[10px] tracking-widest hover:bg-gray-800"
                                    >
                                        RETRY
                                    </button>
                                </div>
                            </div>
                        )}
                        <div
                            ref={containerRef}
                            className="w-full h-full flex items-center justify-center touch-none"
                            onTouchStart={handleTouchStart}
                            onTouchMove={handleTouchMove}
                            onTouchEnd={handleTouchEnd}
                        />
                    </div>

                    <div className="h-8 px-4 flex justify-between items-center border-t border-gray-100">
                        <span className="font-mono text-[10px] text-gray-300 hidden md:inline">WASD/ARROWS MOVE  SPACE SHOOT</span>
                        <span className="font-mono text-[10px] text-gray-300 md:hidden">DRAG TO MOVE  TAP TO SHOOT</span>
                        <button
                            onClick={() => gameRef.current?.restart()}
                            className="font-mono text-[10px] text-gray-300 hover:text-black transition-colors"
                        >
                            RESTART
                        </button>
                    </div>
                </div>
            );
        };

        // --- SYNTH_001.WAV - Brutalist Synthesizer ---
        const SynthApp = () => {
            const [tempo, setTempo] = useState(120);
            const [filter, setFilter] = useState(1000);
            const [isPlaying, setIsPlaying] = useState(false);
            const [currentStep, setCurrentStep] = useState(0);
            const [grid, setGrid] = useState(() => {
                return {
                    sine: Array(16).fill(false),
                    square: Array(16).fill(false),
                    saw: Array(16).fill(false),
                    noise: Array(16).fill(false)
                };
            });
            const audioCtxRef = useRef(null);
            const intervalRef = useRef(null);
            // Refs to avoid stale closures in interval
            const gridRef = useRef(grid);
            const filterRef = useRef(filter);
            gridRef.current = grid;
            filterRef.current = filter;

            const oscillators = ['sine', 'square', 'saw', 'noise'];

            const toggleNote = (osc, step) => {
                sounds.noteToggle();
                setGrid(prev => ({
                    ...prev,
                    [osc]: prev[osc].map((v, i) => i === step ? !v : v)
                }));
            };

            const playSound = (type, filterFreq) => {
                if (!audioCtxRef.current) {
                    audioCtxRef.current = new (window.AudioContext || window.webkitAudioContext)();
                }
                const ctx = audioCtxRef.current;

                let osc;
                const gain = ctx.createGain();
                const filt = ctx.createBiquadFilter();
                filt.type = 'lowpass';
                filt.frequency.value = filterFreq;

                if (type === 'noise') {
                    const bufferSize = ctx.sampleRate * 0.1;
                    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        data[i] = Math.random() * 2 - 1;
                    }
                    osc = ctx.createBufferSource();
                    osc.buffer = buffer;
                } else {
                    osc = ctx.createOscillator();
                    osc.type = type === 'saw' ? 'sawtooth' : type;
                    osc.frequency.value = 220 + Math.random() * 110;
                }

                gain.gain.setValueAtTime(0.3, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);

                osc.connect(filt);
                filt.connect(gain);
                gain.connect(ctx.destination);
                osc.start(ctx.currentTime);
                osc.stop(ctx.currentTime + 0.1);
            };

            const togglePlay = () => {
                if (isPlaying) {
                    clearInterval(intervalRef.current);
                    setIsPlaying(false);
                    setCurrentStep(0);
                } else {
                    setIsPlaying(true);
                    // Interval is started by the useEffect when isPlaying changes
                }
            };

            useEffect(() => {
                return () => clearInterval(intervalRef.current);
            }, []);

            useEffect(() => {
                if (isPlaying) {
                    clearInterval(intervalRef.current);
                    let step = currentStep;
                    intervalRef.current = setInterval(() => {
                        setCurrentStep(step);
                        oscillators.forEach(osc => {
                            // Use refs for fresh values
                            if (gridRef.current[osc][step]) {
                                playSound(osc, filterRef.current);
                            }
                        });
                        step = (step + 1) % 16;
                    }, (60 / tempo) * 250);
                }
            }, [tempo, isPlaying]);

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="app-header">
                        <div className="flex items-center gap-2">
                            <Icons.Synth size={16} />
                            <span className="app-header-title">SYNTH_001.WAV</span>
                        </div>
                        <button
                            onClick={() => { sounds.click(); togglePlay(); }}
                            className={isPlaying ? 'btn-primary btn-xs' : 'btn-secondary btn-xs'}
                        >
                            {isPlaying ? ' STOP' : ' PLAY'}
                        </button>
                    </div>
                    <div className="flex-grow p-4 overflow-auto bg-gray-50">
                        <div className="space-y-2">
                            {oscillators.map(osc => (
                                <div key={osc} className="flex items-center gap-2">
                                    <span className="font-mono text-[10px] w-12 text-gray-500 uppercase">{osc}</span>
                                    <div className="flex gap-1">
                                        {grid[osc].map((active, i) => (
                                            <button
                                                key={i}
                                                onClick={() => toggleNote(osc, i)}
                                                className={`w-6 h-8 border-2 transition-all ${active
                                                    ? 'bg-black border-black'
                                                    : 'bg-white border-gray-300 hover:border-black'
                                                    } ${currentStep === i && isPlaying ? 'ring-2 ring-black ring-offset-1' : ''}`}
                                            />
                                        ))}
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                    <div className="p-4 border-t-2 border-black bg-white flex gap-8">
                        <div className="flex items-center gap-2">
                            <span className="app-footer-text">TEMPO</span>
                            <input
                                type="range"
                                min="60"
                                max="200"
                                value={tempo}
                                onChange={(e) => setTempo(Number(e.target.value))}
                                className="w-24 accent-black"
                            />
                            <span className="font-mono text-xs w-8 text-black">{tempo}</span>
                        </div>
                        <div className="flex items-center gap-2">
                            <span className="app-footer-text">FILTER</span>
                            <input
                                type="range"
                                min="100"
                                max="5000"
                                value={filter}
                                onChange={(e) => setFilter(Number(e.target.value))}
                                className="w-24 accent-black"
                            />
                            <span className="font-mono text-xs w-12 text-black">{filter}Hz</span>
                        </div>
                    </div>
                </div>
            );
        };

        // --- DESTRUCTION.EXE - Screen destroyer with confirmations ---
        const DestructionApp = ({ onDogSteal }) => {
            const [confirmStep, setConfirmStep] = useState(0);
            const [buttonPos, setButtonPos] = useState({ x: 0, y: 0 });
            const [dogStealing, setDogStealing] = useState(false);
            const [dogPos, setDogPos] = useState({ x: -100, y: 200 });
            const [buttonGone, setButtonGone] = useState(false);

            const confirmMessages = [
                { prompt: "EXECUTE", response: "You want to do it?" },
                { prompt: "YES", response: "Are you sure?" },
                { prompt: "I'M SURE", response: "Really though?" },
                { prompt: "REALLY", response: "Really, really though?" },
                { prompt: "YES REALLY", response: "Like... REALLY really?" },
                { prompt: "DO IT", response: "You know this destroys EVERYTHING?" },
                { prompt: "I KNOW", response: "There's no going back..." },
                { prompt: "I DON'T CARE", response: "Final warning..." },
                { prompt: "JUST DO IT", response: "Okay... last chance to back out..." },
                { prompt: "DESTROY IT ALL", response: "..." }
            ];

            const handleClick = () => {
                if (confirmStep < 9) {
                    setConfirmStep(prev => prev + 1);
                } else {
                    // Final click - dog steals the button!
                    setDogStealing(true);

                    // Animate dog running in
                    let dogX = -100;
                    const dogRun = setInterval(() => {
                        dogX += 15;
                        setDogPos({ x: dogX, y: 150 + Math.sin(dogX / 20) * 10 });

                        if (dogX >= 120) {
                            clearInterval(dogRun);
                            setButtonGone(true);

                            // Dog runs away with button
                            const dogEscape = setInterval(() => {
                                dogX += 20;
                                setDogPos({ x: dogX, y: 150 + Math.sin(dogX / 15) * 15 });

                                if (dogX > window.innerWidth + 100) {
                                    clearInterval(dogEscape);
                                    if (onDogSteal) onDogSteal();
                                }
                            }, 30);
                        }
                    }, 30);
                }
            };

            return (
                <div className="h-full flex flex-col bg-white select-none relative overflow-hidden">
                    <div className="app-header">
                        <span className="app-header-title">DESTRUCTION.EXE</span>
                        <span className="app-footer-text">DANGER ZONE</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center bg-gray-50 relative z-10">
                        <div className="text-center">
                            <svg width="64" height="64" viewBox="0 0 64 64" className="mx-auto mb-4" style={{ imageRendering: 'pixelated' }}>
                                <rect x="16" y="4" width="32" height="8" fill="#000" />
                                <rect x="12" y="12" width="40" height="8" fill="#000" />
                                <rect x="8" y="20" width="48" height="16" fill="#000" />
                                <rect x="14" y="22" width="12" height="10" fill="#fff" />
                                <rect x="38" y="22" width="12" height="10" fill="#fff" />
                                <rect x="28" y="34" width="8" height="6" fill="#fff" />
                                <rect x="12" y="40" width="40" height="8" fill="#000" />
                                <rect x="16" y="42" width="4" height="6" fill="#fff" />
                                <rect x="24" y="42" width="4" height="6" fill="#fff" />
                                <rect x="36" y="42" width="4" height="6" fill="#fff" />
                                <rect x="44" y="42" width="4" height="6" fill="#fff" />
                                <rect x="16" y="48" width="32" height="8" fill="#000" />
                            </svg>
                            <div className="font-mono text-sm mb-2 text-black">DESTRUCTION.EXE</div>
                            <div className="font-mono text-xs text-gray-500 mb-6">
                                {confirmStep === 0 ? "WARNING: WILL DESTROY EVERYTHING" : confirmMessages[confirmStep - 1]?.response || "..."}
                            </div>
                            {!buttonGone && (
                                <button
                                    onClick={handleClick}
                                    className={`btn-primary btn-lg ${confirmStep > 5 ? 'animate-pulse' : ''}`}
                                    style={{
                                        transform: `translate(${buttonPos.x}px, ${buttonPos.y}px)`,
                                    }}
                                >
                                    {confirmMessages[confirmStep].prompt}
                                </button>
                            )}
                            {buttonGone && !dogStealing && (
                                <div className="font-mono text-sm text-gray-500">
                                    The button is gone...
                                </div>
                            )}
                        </div>
                    </div>

                    {/* Dog stealing animation - cute dog matching the main sprite */}
                    {dogStealing && (
                        <div
                            className="absolute z-20"
                            style={{ left: dogPos.x, top: dogPos.y }}
                        >
                            <DogSprite />
                            {buttonGone && (
                                <div className="absolute -top-4 left-10 px-2 py-1 bg-black text-white font-mono text-[8px] border-2 border-black">
                                    DESTROY
                                </div>
                            )}
                        </div>
                    )}

                    {dogStealing && buttonGone && (
                        <div className="absolute bottom-4 w-full text-center">
                            <div className="font-mono text-xs text-gray-600">
                                *dog runs away with the button*
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // --- TAROT.DAT - Tarot card pull ---
        // Pixel art tarot card component with card frame
        const PixelTarotCard = ({ pixels, width = 24, height = 32, scale = 3 }) => {
            const cardWidth = width + 4;
            const cardHeight = height + 6;

            return (
                <div className="relative" style={{ width: cardWidth * scale, height: cardHeight * scale }}>
                    {/* Card frame - thin border */}
                    <div
                        className="absolute inset-0 bg-white"
                        style={{
                            borderRadius: '2px',
                            border: '1px solid #666',
                            boxShadow: '1px 1px 0 rgba(0,0,0,0.15)'
                        }}
                    />
                    {/* Pixel art area */}
                    <div
                        className="absolute flex items-center justify-center"
                        style={{
                            top: scale,
                            left: scale,
                            right: scale,
                            bottom: scale * 2,
                        }}
                    >
                        <svg width={width * scale} height={height * scale} viewBox={`0 0 ${width} ${height}`} style={{ imageRendering: 'pixelated' }}>
                            <rect width={width} height={height} fill="#000" />
                            {pixels.map((row, y) =>
                                row.split('').map((pixel, x) =>
                                    pixel === '#' ? <rect key={`${x}-${y}`} x={x} y={y} width={1} height={1} fill="#fff" /> : null
                                )
                            )}
                        </svg>
                    </div>
                </div>
            );
        };

        const TarotApp = ({ onAchievement }) => {
            const [cards, setCards] = useState([]);
            const [revealed, setRevealed] = useState(false);
            const [alreadyPulled, setAlreadyPulled] = useState(false);
            const [isShuffling, setIsShuffling] = useState(false);
            const [shuffleFrame, setShuffleFrame] = useState(0);
            const [uniqueDays, setUniqueDays] = useState(() => {
                const stored = localStorage.getItem('tarot_unique_days');
                return stored ? JSON.parse(stored) : [];
            });

            const tarotCards = [
                {
                    name: 'THE FOOL', num: '0', meaning: 'New beginnings, innocence, spontaneity', pixels: [
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '........#######.........',
                        '.........#####..........',
                        '..........###...........',
                        '...........#............',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '........#.....#.........',
                        '........................',
                        '....##..................',
                        '...####.................',
                        '...#..#.................',
                        '....##..................',
                        '........................',
                        '########################',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE MAGICIAN', num: 'I', meaning: 'Manifestation, resourcefulness, power', pixels: [
                        '........................',
                        '.........#...#..........',
                        '..........#.#...........',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...........#............',
                        '..........#.#...........',
                        '........................',
                        '..##..##..##..##........',
                        '..##..##..##..##........',
                        '........................',
                        '########################',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE HIGH PRIESTESS', num: 'II', meaning: 'Intuition, mystery, inner knowledge', pixels: [
                        '........................',
                        '....##..........##......',
                        '...#..#........#..#.....',
                        '....##..........##......',
                        '..........##............',
                        '.........####...........',
                        '..........##............',
                        '..........##............',
                        '.........####...........',
                        '........##..##..........',
                        '.........####...........',
                        '..........##............',
                        '..........##............',
                        '.........####...........',
                        '........######..........',
                        '........................',
                        '...##..........##.......',
                        '...##..........##.......',
                        '...##..........##.......',
                        '........................',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE EMPRESS', num: 'III', meaning: 'Abundance, nurturing, fertility', pixels: [
                        '........................',
                        '.........#####..........',
                        '........#######.........',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '.........#####..........',
                        '........#######.........',
                        '.......#########........',
                        '........#######.........',
                        '.........#####..........',
                        '..........###...........',
                        '..........#.#...........',
                        '.........#...#..........',
                        '........................',
                        '...#..#..#..#..#..#.....',
                        '...#..#..#..#..#..#.....',
                        '...#..#..#..#..#..#.....',
                        '........................',
                        '########################',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE EMPEROR', num: 'IV', meaning: 'Authority, structure, control', pixels: [
                        '........................',
                        '.........#####..........',
                        '........#.#.#.#.........',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '........#######.........',
                        '........#.###.#.........',
                        '........#.###.#.........',
                        '........#######.........',
                        '..........###...........',
                        '..........###...........',
                        '.........##.##..........',
                        '........##...##.........',
                        '........................',
                        '.......########.........',
                        '.......#......#.........',
                        '.......#......#.........',
                        '.......########.........',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE HIEROPHANT', num: 'V', meaning: 'Tradition, conformity, spirituality', pixels: [
                        '........................',
                        '...........##...........',
                        '..........####..........',
                        '...........##...........',
                        '.........######.........',
                        '..........####..........',
                        '..........####..........',
                        '.........######.........',
                        '........########........',
                        '.........######.........',
                        '..........####..........',
                        '..........####..........',
                        '.........##..##.........',
                        '........##....##........',
                        '........................',
                        '....##....##....##......',
                        '...####..####..####.....',
                        '....##....##....##......',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE LOVERS', num: 'VI', meaning: 'Love, harmony, relationships', pixels: [
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '........#######.........',
                        '.........#####..........',
                        '..........###...........',
                        '........................',
                        '....###........###......',
                        '...#####......#####.....',
                        '....###........###......',
                        '....###........###......',
                        '.....#..........#.......',
                        '....#.#........#.#......',
                        '...#...#......#...#.....',
                        '........................',
                        '.........####...........',
                        '........##..##..........',
                        '.........####...........',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE CHARIOT', num: 'VII', meaning: 'Willpower, determination, success', pixels: [
                        '........................',
                        '........#.#.#.#.........',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '.........#####..........',
                        '........#######.........',
                        '.......#########........',
                        '.......#.#####.#........',
                        '.......#########........',
                        '........#######.........',
                        '..........###...........',
                        '......###.###.###.......',
                        '.....##.........##......',
                        '....##...........##.....',
                        '...####.........####....',
                        '...#..#.........#..#....',
                        '...####.........####....',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'STRENGTH', num: 'VIII', meaning: 'Courage, persuasion, inner strength', pixels: [
                        '........................',
                        '.........#...#..........',
                        '..........#.#...........',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###....###....',
                        '...........#....#####...',
                        '..........#.#...#.#.#...',
                        '.........#...#..#####...',
                        '................#...#...',
                        '...............##...##..',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE HERMIT', num: 'IX', meaning: 'Soul-searching, introspection, solitude', pixels: [
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '...###...#####..........',
                        '..#####...###...........',
                        '...###...#.#.#..........',
                        '....#.....###...........',
                        '....#......#............',
                        '....#.....#.#...........',
                        '....#....#...#..........',
                        '....#...#.....#.........',
                        '....#...................',
                        '........................',
                        '..######................',
                        '.########...............',
                        '##########..............',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'WHEEL OF FORTUNE', num: 'X', meaning: 'Change, cycles, destiny', pixels: [
                        '........................',
                        '........................',
                        '.......########.........',
                        '......#........#........',
                        '.....#..........#.......',
                        '....#....####....#......',
                        '....#...#....#...#......',
                        '...#....#....#....#.....',
                        '...#....#....#....#.....',
                        '....#...#....#...#......',
                        '....#....####....#......',
                        '.....#..........#.......',
                        '......#........#........',
                        '.......########.........',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'JUSTICE', num: 'XI', meaning: 'Fairness, truth, law', pixels: [
                        '........................',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...####....#....####....',
                        '...#..#....#....#..#....',
                        '...####....#....####....',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '........#.....#.........',
                        '........................',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE HANGED MAN', num: 'XII', meaning: 'Surrender, letting go, new perspective', pixels: [
                        '........................',
                        '########################',
                        '...........#............',
                        '...........#............',
                        '...........#............',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'DEATH', num: 'XIII', meaning: 'Endings, change, transformation', pixels: [
                        '........................',
                        '..........###...........',
                        '.........#...#..........',
                        '........#.....#.........',
                        '........#.#.#.#.........',
                        '........#.....#.........',
                        '.........#...#..........',
                        '..........###...........',
                        '...........#............',
                        '.........#####..........',
                        '........#..#..#.........',
                        '.........#####..........',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '........#.....#.........',
                        '........................',
                        '...##..........##.......',
                        '..####........####......',
                        '...##..........##.......',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'TEMPERANCE', num: 'XIV', meaning: 'Balance, moderation, patience', pixels: [
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '....###....#....###.....',
                        '....#.#....#....#.#.....',
                        '....###..#####..###.....',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '........#.....#.........',
                        '........................',
                        '########################',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE DEVIL', num: 'XV', meaning: 'Shadow self, attachment, addiction', pixels: [
                        '........................',
                        '........#......#........',
                        '.......##......##.......',
                        '........########........',
                        '.........#....#.........',
                        '.........#.##.#.........',
                        '.........######.........',
                        '..........####..........',
                        '..........####..........',
                        '.........######.........',
                        '........#.####.#........',
                        '........#.#..#.#........',
                        '.........#....#.........',
                        '..........#..#..........',
                        '........................',
                        '...###..........###.....',
                        '...#.#..........#.#.....',
                        '...###..........###.....',
                        '........................',
                        '...####........####.....',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE TOWER', num: 'XVI', meaning: 'Sudden change, upheaval, revelation', pixels: [
                        '........................',
                        '....##..........##......',
                        '.....##........##.......',
                        '......##..##..##........',
                        '.........####...........',
                        '.........#..#...........',
                        '.........#..#...........',
                        '........######..........',
                        '........#....#..........',
                        '........#....#..........',
                        '........######..........',
                        '........#....#..........',
                        '........#....#..........',
                        '.......########.........',
                        '......##########........',
                        '........................',
                        '...##....##....##.......',
                        '...##....##....##.......',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE STAR', num: 'XVII', meaning: 'Hope, faith, renewal', pixels: [
                        '........................',
                        '...........#............',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '...........#............',
                        '....#.....#.#.....#.....',
                        '...###...#...#...###....',
                        '....#.............#.....',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...###.....#.....###....',
                        '...#.#....#.#....#.#....',
                        '...###...#...#...###....',
                        '........................',
                        '########################',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE MOON', num: 'XVIII', meaning: 'Illusion, fear, subconscious', pixels: [
                        '........................',
                        '.........#####..........',
                        '........##...##.........',
                        '.......##.....##........',
                        '.......#.......#........',
                        '.......##.....##........',
                        '........##...##.........',
                        '.........#####..........',
                        '........................',
                        '....###........###......',
                        '...#.#.#......#.#.#.....',
                        '...#####......#####.....',
                        '...#...#......#...#.....',
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '........................',
                        '########################',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE SUN', num: 'XIX', meaning: 'Joy, success, celebration', pixels: [
                        '........................',
                        '....#......#......#.....',
                        '.....#.....#.....#......',
                        '......#...###...#.......',
                        '.......#.#####.#........',
                        '...#####.#####.#####....',
                        '.......#.#####.#........',
                        '......#...###...#.......',
                        '.....#.....#.....#......',
                        '....#......#......#.....',
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...........#............',
                        '..........#.#...........',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'JUDGEMENT', num: 'XX', meaning: 'Reflection, reckoning, awakening', pixels: [
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...........#............',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '........................',
                        '....###..###..###.......',
                        '....#.#..#.#..#.#.......',
                        '....###..###..###.......',
                        '....#.#..#.#..#.#.......',
                        '....###..###..###.......',
                        '........................',
                        '.......########.........',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE WORLD', num: 'XXI', meaning: 'Completion, accomplishment, travel', pixels: [
                        '........................',
                        '....##..........##......',
                        '........................',
                        '.......########.........',
                        '......#........#........',
                        '.....#..........#.......',
                        '....#....####....#......',
                        '....#...#....#...#......',
                        '...#....#....#....#.....',
                        '...#....#....#....#.....',
                        '....#...#....#...#......',
                        '....#....####....#......',
                        '.....#..........#.......',
                        '......#........#........',
                        '.......########.........',
                        '........................',
                        '....##..........##......',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                }
            ];

            useEffect(() => {
                // Check localStorage for existing pull (simulating IP-based storage)
                const savedCards = localStorage.getItem('tarot_cards_3');
                if (savedCards) {
                    const parsed = JSON.parse(savedCards);
                    if (Array.isArray(parsed) && parsed.length === 3 && parsed[0].pixels) {
                        setCards(parsed);
                        setRevealed(true);
                        setAlreadyPulled(true);
                    } else {
                        localStorage.removeItem('tarot_cards_3');
                    }
                }
            }, []);

            const shufflePixels = [
                [
                    '........................',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#'
                ],
                [
                    '........................',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.'
                ]
            ];

            const pullCards = () => {
                if (alreadyPulled || isShuffling) return;

                setIsShuffling(true);
                let frame = 0;
                const shuffleInterval = setInterval(() => {
                    setShuffleFrame(f => f + 1);
                    frame++;
                    if (frame >= 20) {
                        clearInterval(shuffleInterval);
                        setIsShuffling(false);
                        // Pick 3 unique random cards
                        const shuffled = [...tarotCards].sort(() => Math.random() - 0.5);
                        const selectedCards = shuffled.slice(0, 3);
                        setCards(selectedCards);
                        localStorage.setItem('tarot_cards_3', JSON.stringify(selectedCards));
                        setTimeout(() => setRevealed(true), 500);
                        setAlreadyPulled(true);

                        // Track unique days for COLLECTOR achievement
                        const today = new Date().toDateString();
                        if (!uniqueDays.includes(today)) {
                            const newDays = [...uniqueDays, today];
                            setUniqueDays(newDays);
                            localStorage.setItem('tarot_unique_days', JSON.stringify(newDays));
                            if (newDays.length >= 10) {
                                onAchievement?.('COLLECTOR');
                            }
                        }
                    }
                }, 80);
            };

            const questionPixels = [
                '........................',
                '........########........',
                '.......##......##.......',
                '......##........##......',
                '......##........##......',
                '..............##........',
                '............##..........',
                '..........##............',
                '.........##.............',
                '.........##.............',
                '.........##.............',
                '........................',
                '.........##.............',
                '.........##.............',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................'
            ];

            return (
                <div className="h-full flex flex-col bg-black text-white select-none overflow-hidden">
                    <div className="p-2 border-b border-gray-800 flex-shrink-0">
                        <span className="app-footer-text">TAROT.DAT</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-2 md:p-4 overflow-hidden">
                        {isShuffling ? (
                            <div className="text-center">
                                <div className="relative w-24 h-32 mb-4">
                                    {/* Deck shuffle animation - multiple cards moving */}
                                    {[0, 1, 2, 3, 4].map((i) => (
                                        <div
                                            key={i}
                                            className="absolute inset-0 border border-gray-700 bg-black"
                                            style={{
                                                transform: `
                                                    translateX(${Math.sin((shuffleFrame + i) * 1.5) * (15 + i * 3)}px)
                                                    translateY(${i * 2}px)
                                                    rotate(${Math.sin((shuffleFrame + i) * 0.8) * 8}deg)
                                                `,
                                                transition: 'transform 0.1s ease-out',
                                                zIndex: 5 - i
                                            }}
                                        >
                                            <PixelTarotCard pixels={shufflePixels[shuffleFrame % 2]} />
                                        </div>
                                    ))}
                                </div>
                                <div className="font-mono text-[10px] text-gray-500 animate-pulse">SHUFFLING...</div>
                            </div>
                        ) : cards.length === 0 ? (
                            <div className="text-center">
                                <div className="mb-4 md:mb-6 flex flex-row gap-2 md:gap-4 justify-center items-center">
                                    <PixelTarotCard pixels={questionPixels} scale={2} />
                                    <PixelTarotCard pixels={questionPixels} scale={2} />
                                    <PixelTarotCard pixels={questionPixels} scale={2} />
                                </div>
                                <button
                                    onClick={pullCards}
                                    className="btn-secondary btn-sm"
                                >
                                    DRAW 3 CARDS
                                </button>
                                <p className="mt-4 font-mono text-[10px] text-gray-600">ONE READING PER VISITOR</p>
                            </div>
                        ) : (
                            <div className={`text-center transition-all duration-500 overflow-auto max-h-full ${revealed ? 'opacity-100' : 'opacity-0'}`}>
                                <div className="flex flex-row gap-2 md:gap-4 justify-center items-start mb-2 md:mb-4">
                                    {cards.map((card, idx) => (
                                        <div key={idx} className="flex flex-col items-center">
                                            <div className="text-[10px] md:text-xs text-gray-600 mb-1 md:mb-2">{['PAST', 'PRESENT', 'FUTURE'][idx]}</div>
                                            <PixelTarotCard pixels={card.pixels} scale={2} />
                                            <div className="font-mono text-[10px] md:text-xs text-gray-500 mt-1 md:mt-2">{card.num}</div>
                                            <div className="text-[10px] md:text-sm font-bold mt-0.5 md:mt-1">{card.name}</div>
                                        </div>
                                    ))}
                                </div>
                                <div className="font-mono text-[10px] md:text-xs text-gray-400 max-w-lg mx-auto px-2 md:px-4">
                                    {cards.map((c, i) => <div key={i} className="mb-0.5 md:mb-1">{c.meaning}</div>)}
                                </div>
                                {alreadyPulled && (
                                    <p className="mt-3 font-mono text-xs text-gray-700">FATE SEALED</p>
                                )}
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // --- GALLERY.EXE - Photo gallery with 9 placeholder photos ---
        const GalleryApp = () => {
            const [selectedPhoto, setSelectedPhoto] = useState(null);

            const photos = [
                { id: 1, title: 'ME_001.JPG', category: 'SELF', desc: 'Profile shot' },
                { id: 2, title: 'ME_002.JPG', category: 'SELF', desc: 'Another one' },
                { id: 3, title: 'DOG_001.JPG', category: 'DOGS', desc: 'Good boy' },
                { id: 4, title: 'DOG_002.JPG', category: 'DOGS', desc: 'Best friend' },
                { id: 5, title: 'DOG_003.JPG', category: 'DOGS', desc: 'Sleeping' },
                { id: 6, title: 'WORK_001.JPG', category: 'WORK', desc: 'Office vibes' },
                { id: 7, title: 'WORK_002.JPG', category: 'WORK', desc: 'Late night coding' },
                { id: 8, title: 'WORK_003.JPG', category: 'WORK', desc: 'Setup tour' },
                { id: 9, title: 'RANDOM_001.JPG', category: 'MISC', desc: 'Life moment' }
            ];

            // Generate placeholder image pattern based on id
            const getPlaceholderPattern = (id) => {
                const patterns = [
                    // Person silhouette
                    [[0, 0, 1, 1, 0, 0], [0, 1, 1, 1, 1, 0], [0, 0, 1, 1, 0, 0], [0, 1, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1], [1, 0, 1, 1, 0, 1], [0, 0, 1, 1, 0, 0], [0, 1, 0, 0, 1, 0]],
                    // Another person
                    [[0, 1, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1], [0, 1, 0, 0, 1, 0], [0, 0, 1, 1, 0, 0], [0, 1, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1], [0, 1, 0, 0, 1, 0], [1, 1, 0, 0, 1, 1]],
                    // Dog sitting
                    [[1, 1, 0, 0, 1, 1], [1, 1, 1, 1, 1, 1], [0, 1, 0, 0, 1, 0], [0, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 1], [1, 1, 0, 0, 1, 1]],
                    // Dog lying
                    [[0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [0, 1, 1, 1, 1, 0], [1, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0]],
                    // Dog running
                    [[0, 1, 1, 0, 0, 0], [1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 0], [0, 1, 0, 0, 1, 0], [1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0]],
                    // Computer/desk
                    [[0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1], [0, 0, 1, 1, 0, 0], [0, 1, 1, 1, 1, 0]],
                    // Code screen
                    [[1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 1], [1, 0, 1, 0, 0, 1], [1, 0, 0, 1, 1, 1], [1, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1]],
                    // Setup
                    [[0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 1, 1], [1, 0, 1, 0, 1, 0], [1, 1, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 0], [0, 1, 0, 0, 1, 0], [0, 1, 1, 1, 1, 0]],
                    // Abstract/random
                    [[1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1], [1, 1, 0, 0, 1, 1], [0, 0, 1, 1, 0, 0], [1, 0, 0, 0, 0, 1], [0, 1, 1, 1, 1, 0], [1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1]]
                ];
                return patterns[(id - 1) % patterns.length];
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="app-header">
                        <div className="flex items-center gap-2">
                            <Icons.Gallery size={24} />
                            <span className="app-header-title">GALLERY.EXE</span>
                        </div>
                        <span className="app-footer-text">{photos.length} PHOTOS</span>
                    </div>

                    {selectedPhoto ? (
                        <div className="flex-grow flex flex-col bg-black">
                            <div className="flex-grow flex items-center justify-center p-8">
                                <div className="bg-gray-900 border-2 border-white p-4">
                                    <svg width="240" height="240" viewBox="0 0 6 8" style={{ imageRendering: 'pixelated' }}>
                                        <rect width="6" height="8" fill="#222" />
                                        {getPlaceholderPattern(selectedPhoto.id).map((row, y) =>
                                            row.map((cell, x) =>
                                                cell ? <rect key={`${x}-${y}`} x={x} y={y} width="1" height="1" fill="#fff" /> : null
                                            )
                                        )}
                                    </svg>
                                </div>
                            </div>
                            <div className="p-4 bg-gray-900 border-t-2 border-white">
                                <div className="flex justify-between items-center">
                                    <div>
                                        <div className="font-mono text-white text-sm font-bold">{selectedPhoto.title}</div>
                                        <div className="font-mono text-gray-400 text-[10px]">{selectedPhoto.category} / {selectedPhoto.desc}</div>
                                    </div>
                                    <button
                                        onClick={() => setSelectedPhoto(null)}
                                        className="btn-secondary btn-sm"
                                    >
                                        BACK
                                    </button>
                                </div>
                            </div>
                        </div>
                    ) : (
                        <div className="flex-grow p-4 overflow-auto bg-gray-100">
                            <div className="grid grid-cols-3 gap-3">
                                {photos.map(photo => (
                                    <button
                                        key={photo.id}
                                        onClick={() => setSelectedPhoto(photo)}
                                        className="group aspect-square bg-white border-2 border-black hover:bg-black transition-all flex flex-col items-center justify-center p-2"
                                    >
                                        <svg width="48" height="64" viewBox="0 0 6 8" style={{ imageRendering: 'pixelated' }} className="group-hover:invert">
                                            <rect width="6" height="8" fill="#eee" />
                                            {getPlaceholderPattern(photo.id).map((row, y) =>
                                                row.map((cell, x) =>
                                                    cell ? <rect key={`${x}-${y}`} x={x} y={y} width="1" height="1" fill="#000" /> : null
                                                )
                                            )}
                                        </svg>
                                        <div className="font-mono text-[8px] mt-1 text-gray-600 group-hover:text-white truncate w-full text-center">{photo.title}</div>
                                    </button>
                                ))}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // --- MAP.EXE - Interactive COBE globe with Planet Clicker game ---
        const MapApp = ({ onAchievement }) => {
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const globeRef = useRef(null);
            const pointerInteracting = useRef(null);
            const pointerInteractionMovement = useRef(0);
            const phiRef = useRef(0);
            const thetaRef = useRef(0);
            const scaleRef = useRef(0.85);
            const isHoveringRef = useRef(false);
            const rotationSpeedRef = useRef(0.003);

            const [gameStarted, setGameStarted] = useState(false);
            const [showShop, setShowShop] = useState(false);
            const [clickEffect, setClickEffect] = useState(null);
            const [globeReady, setGlobeReady] = useState(false);
            const [canvasSize, setCanvasSize] = useState(400);
            const tycoonAchieved = useRef(false);

            // Game state with defaults
            const defaultGameState = {
                clicks: 0,
                totalClicks: 0,
                clickPower: 1,
                satellites: 0,
                clickMultiplier: 1,
                upgrades: {
                    power1: false, power2: false, power3: false,
                    power4: false, power5: false, power6: false,
                    sat1: false, sat2: false, sat3: false,
                    sat4: false, sat5: false, sat6: false,
                    multi1: false, multi2: false, multi3: false,
                    godMode: false, dogMode: false
                },
                dogModeMultiplier: 1
            };

            const [gameState, setGameState] = useState(() => {
                const saved = localStorage.getItem(HighScoreManager.getStorageKey('mapclicker'));
                if (saved) {
                    try {
                        const parsed = JSON.parse(saved);
                        return { ...defaultGameState, ...parsed, upgrades: { ...defaultGameState.upgrades, ...parsed.upgrades } };
                    } catch (e) {
                        return defaultGameState;
                    }
                }
                return defaultGameState;
            });

            // Save game state
            useEffect(() => {
                localStorage.setItem(HighScoreManager.getStorageKey('mapclicker'), JSON.stringify(gameState));
            }, [gameState]);

            // Satellite auto-clicker
            useEffect(() => {
                if (gameState.satellites > 0) {
                    const interval = setInterval(() => {
                        const autoAmount = gameState.satellites * gameState.clickMultiplier * gameState.dogModeMultiplier;
                        setGameState(prev => ({
                            ...prev,
                            clicks: prev.clicks + autoAmount,
                            totalClicks: prev.totalClicks + autoAmount
                        }));
                    }, 1000);
                    return () => clearInterval(interval);
                }
            }, [gameState.satellites, gameState.clickMultiplier, gameState.dogModeMultiplier]);

            // Count visual satellites (1 per upgrade tier, max 6)
            const getSatelliteCount = () => {
                let count = 0;
                if (gameState.upgrades.sat1) count++;
                if (gameState.upgrades.sat2) count++;
                if (gameState.upgrades.sat3) count++;
                if (gameState.upgrades.sat4) count++;
                if (gameState.upgrades.sat5) count++;
                if (gameState.upgrades.sat6) count++;
                return count;
            };

            // Count rings
            const getRingCount = () => {
                let count = 0;
                if (gameState.upgrades.multi1) count++;
                if (gameState.upgrades.multi2) count++;
                if (gameState.upgrades.multi3) count++;
                return count;
            };

            // Shop items
            const shopItems = [
                {
                    category: 'CLICK POWER', items: [
                        { id: 'power1', name: 'TREMOR I', desc: '+1 power', cost: 50, effect: () => ({ clickPower: gameState.clickPower + 1 }) },
                        { id: 'power2', name: 'TREMOR II', desc: '+2 power', cost: 200, effect: () => ({ clickPower: gameState.clickPower + 2 }), requires: 'power1' },
                        { id: 'power3', name: 'QUAKE I', desc: '+5 power', cost: 1000, effect: () => ({ clickPower: gameState.clickPower + 5 }), requires: 'power2' },
                        { id: 'power4', name: 'QUAKE II', desc: '+10 power', cost: 5000, effect: () => ({ clickPower: gameState.clickPower + 10 }), requires: 'power3' },
                        { id: 'power5', name: 'CATACLYSM I', desc: '+25 power', cost: 25000, effect: () => ({ clickPower: gameState.clickPower + 25 }), requires: 'power4' },
                        { id: 'power6', name: 'CATACLYSM II', desc: '+50 power', cost: 100000, effect: () => ({ clickPower: gameState.clickPower + 50 }), requires: 'power5' },
                    ]
                },
                {
                    category: 'SATELLITES', items: [
                        { id: 'sat1', name: 'SPUTNIK', desc: '1/sec', cost: 100, effect: () => ({ satellites: gameState.satellites + 1 }) },
                        { id: 'sat2', name: 'EXPLORER', desc: '+2/sec', cost: 500, effect: () => ({ satellites: gameState.satellites + 2 }), requires: 'sat1' },
                        { id: 'sat3', name: 'VOYAGER', desc: '+5/sec', cost: 2500, effect: () => ({ satellites: gameState.satellites + 5 }), requires: 'sat2' },
                        { id: 'sat4', name: 'HUBBLE', desc: '+10/sec', cost: 10000, effect: () => ({ satellites: gameState.satellites + 10 }), requires: 'sat3' },
                        { id: 'sat5', name: 'JAMES WEBB', desc: '+25/sec', cost: 50000, effect: () => ({ satellites: gameState.satellites + 25 }), requires: 'sat4' },
                        { id: 'sat6', name: 'DYSON SWARM', desc: '+50/sec', cost: 200000, effect: () => ({ satellites: gameState.satellites + 50 }), requires: 'sat5' },
                    ]
                },
                {
                    category: 'MULTIPLIERS', items: [
                        { id: 'multi1', name: 'INNER RING', desc: '2x clicks', cost: 2000, effect: () => ({ clickMultiplier: gameState.clickMultiplier * 2 }) },
                        { id: 'multi2', name: 'MIDDLE RING', desc: '2x (4x)', cost: 15000, effect: () => ({ clickMultiplier: gameState.clickMultiplier * 2 }), requires: 'multi1' },
                        { id: 'multi3', name: 'OUTER RING', desc: '2x (8x)', cost: 75000, effect: () => ({ clickMultiplier: gameState.clickMultiplier * 2 }), requires: 'multi2' },
                    ]
                },
                {
                    category: 'ASCENSION', items: [
                        { id: 'godMode', name: 'GOD MODE', desc: '1M/click', cost: 1000000 },
                        { id: 'dogMode', name: 'DOG MODE', desc: 'RESET: 1M', cost: 100000000, requires: 'godMode' },
                    ]
                },
            ];

            const getActualCost = (baseCost) => baseCost * gameState.dogModeMultiplier;

            const buyUpgrade = (item) => {
                const actualCost = getActualCost(item.cost);
                if (gameState.clicks >= actualCost && !gameState.upgrades[item.id]) {
                    if (item.requires && !gameState.upgrades[item.requires]) return;
                    if (item.id === 'dogMode') {
                        setGameState({
                            ...defaultGameState,
                            dogModeMultiplier: gameState.dogModeMultiplier * 1000000,
                            upgrades: { ...defaultGameState.upgrades, dogMode: true }
                        });
                        onAchievement?.('ASCENDED');
                        return;
                    }
                    const effectResult = item.effect ? item.effect() : {};
                    setGameState(prev => ({
                        ...prev,
                        clicks: prev.clicks - actualCost,
                        ...effectResult,
                        upgrades: { ...prev.upgrades, [item.id]: true }
                    }));
                }
            };

            const canBuy = (item) => {
                if (gameState.upgrades[item.id]) return false;
                if (gameState.clicks < getActualCost(item.cost)) return false;
                if (item.requires && !gameState.upgrades[item.requires]) return false;
                return true;
            };

            const isLocked = (item) => item.requires && !gameState.upgrades[item.requires];

            const handleGlobeClick = () => {
                if (!gameStarted) return;
                const clickValue = gameState.clickPower * gameState.clickMultiplier * gameState.dogModeMultiplier;
                setGameState(prev => {
                    const newTotal = prev.totalClicks + clickValue;
                    // Check for TYCOON achievement (1 billion clicks)
                    if (newTotal >= 1e9 && !tycoonAchieved.current) {
                        tycoonAchieved.current = true;
                        onAchievement?.('TYCOON');
                    }
                    return {
                        ...prev,
                        clicks: prev.clicks + clickValue,
                        totalClicks: newTotal
                    };
                });
                setClickEffect({ value: clickValue, id: Date.now() });
                setTimeout(() => setClickEffect(null), 500);
            };

            const formatNumber = (num) => {
                if (num >= 1e12) return (num / 1e12).toFixed(1) + 'T';
                if (num >= 1e9) return (num / 1e9).toFixed(1) + 'B';
                if (num >= 1e6) return (num / 1e6).toFixed(1) + 'M';
                if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
                return Math.floor(num).toString();
            };

            // Initialize COBE globe
            useEffect(() => {
                if (!canvasRef.current) return;

                let globe = null;

                const initGlobe = () => {
                    if (!window.createGlobe || !containerRef.current) {
                        setTimeout(initGlobe, 50);
                        return;
                    }

                    const container = containerRef.current;
                    const size = Math.min(container.clientWidth, container.clientHeight);
                    setCanvasSize(size);

                    globe = window.createGlobe(canvasRef.current, {
                        devicePixelRatio: 2,
                        width: size * 2,
                        height: size * 2,
                        phi: 0,
                        theta: 0,
                        dark: 1,
                        diffuse: 1.2,
                        mapSamples: 16000,
                        mapBrightness: 8,
                        baseColor: [0.4, 0.4, 0.4],
                        markerColor: [1, 0.5, 0.5],
                        glowColor: [0.3, 0.3, 0.3],
                        scale: 1,
                        offset: [0, 0],
                        markers: [
                            { location: [44.4268, 26.1025], size: 0.05 },
                        ],
                        onRender: (state) => {
                            // Smoothly slow down/speed up based on hover
                            const targetSpeed = isHoveringRef.current ? 0.0005 : 0.003;
                            rotationSpeedRef.current += (targetSpeed - rotationSpeedRef.current) * 0.05;

                            // Auto-rotate when not dragging
                            if (!pointerInteracting.current) {
                                phiRef.current += rotationSpeedRef.current;
                            }
                            state.phi = phiRef.current;
                            state.theta = thetaRef.current;
                            state.scale = scaleRef.current;
                        }
                    });

                    globeRef.current = globe;
                    setGlobeReady(true);
                };

                initGlobe();

                return () => {
                    if (globe) globe.destroy();
                };
            }, []);

            // Pointer/mouse handlers for drag rotation
            const handlePointerDown = (e) => {
                pointerInteracting.current = { x: e.clientX, y: e.clientY };
                pointerInteractionMovement.current = 0;
                if (canvasRef.current) canvasRef.current.style.cursor = 'grabbing';
            };

            const handlePointerUp = () => {
                pointerInteracting.current = null;
                if (canvasRef.current) canvasRef.current.style.cursor = 'grab';
            };

            const handlePointerMove = (e) => {
                if (pointerInteracting.current) {
                    const dx = e.clientX - pointerInteracting.current.x;
                    const dy = e.clientY - pointerInteracting.current.y;
                    pointerInteractionMovement.current += Math.abs(dx) + Math.abs(dy);
                    phiRef.current += dx * 0.005;
                    thetaRef.current = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, thetaRef.current + dy * 0.005));
                    pointerInteracting.current = { x: e.clientX, y: e.clientY };
                }
            };

            const handleWheel = (e) => {
                e.preventDefault();
                scaleRef.current = Math.max(0.5, Math.min(2, scaleRef.current - e.deltaY * 0.001));
            };

            // Pinch-to-zoom support
            const lastTouchDistance = useRef(null);

            const handleTouchStart = (e) => {
                if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    lastTouchDistance.current = Math.sqrt(dx * dx + dy * dy);
                }
            };

            const handleTouchMove = (e) => {
                if (e.touches.length === 2 && lastTouchDistance.current) {
                    e.preventDefault();
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const delta = distance - lastTouchDistance.current;
                    scaleRef.current = Math.max(0.5, Math.min(2, scaleRef.current + delta * 0.005));
                    lastTouchDistance.current = distance;
                }
            };

            const handleTouchEnd = () => {
                lastTouchDistance.current = null;
            };

            const handleMouseEnter = () => { isHoveringRef.current = true; };
            const handleMouseLeave = () => { isHoveringRef.current = false; };

            const satelliteCount = getSatelliteCount();
            const ringCount = getRingCount();

            return (
                <div className="h-full flex flex-col bg-black select-none overflow-hidden">
                    {/* Header */}
                    <div className="flex items-center justify-between px-3 py-1.5 border-b border-white/20">
                        <span className="font-mono text-xs font-bold text-white">{gameStarted ? 'PLANET CLICKER' : 'MAP.EXE'}</span>
                        {gameStarted ? (
                            <div className="flex items-center gap-3">
                                <span className="font-mono text-xs text-white font-bold">{formatNumber(gameState.clicks)}</span>
                                <button onClick={() => setShowShop(!showShop)} className="px-2 py-0.5 bg-white text-black font-mono text-[10px] font-bold border-2 border-white hover:invert">
                                    SHOP
                                </button>
                            </div>
                        ) : (
                            <button
                                onClick={() => setGameStarted(true)}
                                className="px-2 py-0.5 bg-white text-black font-mono text-[10px] font-bold border-2 border-white hover:invert"
                            >
                                START MINING
                            </button>
                        )}
                    </div>

                    {/* Globe container */}
                    <div ref={containerRef} className="flex-grow relative flex items-center justify-center">
                        {/* Rings - behind globe, sized relative to container */}
                        {ringCount >= 1 && (
                            <div
                                className="absolute rounded-full border-2 border-white/30 pointer-events-none"
                                style={{
                                    width: '60%', height: '60%', maxWidth: 400, maxHeight: 400,
                                    animation: 'spin 20s linear infinite'
                                }}
                            />
                        )}
                        {ringCount >= 2 && (
                            <div
                                className="absolute rounded-full border-2 border-white/20 pointer-events-none"
                                style={{
                                    width: '70%', height: '70%', maxWidth: 480, maxHeight: 480,
                                    animation: 'spin 30s linear infinite reverse'
                                }}
                            />
                        )}
                        {ringCount >= 3 && (
                            <div
                                className="absolute rounded-full border-2 border-white/15 pointer-events-none"
                                style={{
                                    width: '80%', height: '80%', maxWidth: 560, maxHeight: 560,
                                    animation: 'spin 40s linear infinite'
                                }}
                            />
                        )}

                        {/* Orbiting satellites */}
                        {Array.from({ length: satelliteCount }).map((_, i) => (
                            <div
                                key={i}
                                className="absolute rounded-full pointer-events-none"
                                style={{
                                    width: `${55 + i * 5}%`,
                                    height: `${55 + i * 5}%`,
                                    maxWidth: 360 + i * 40,
                                    maxHeight: 360 + i * 40,
                                    animation: `spin ${8 + i * 3}s linear infinite ${i % 2 === 0 ? '' : 'reverse'}`,
                                    transform: `rotate(${i * 60}deg)`
                                }}
                            >
                                <div
                                    className="absolute bg-white"
                                    style={{
                                        width: 6,
                                        height: 6,
                                        top: 0,
                                        left: '50%',
                                        marginLeft: -3,
                                        boxShadow: '0 0 4px #fff'
                                    }}
                                />
                            </div>
                        ))}

                        {/* Globe canvas */}
                        <canvas
                            ref={canvasRef}
                            style={{
                                width: canvasSize,
                                height: canvasSize,
                                cursor: 'grab',
                                touchAction: 'none',
                                position: 'absolute',
                                left: '50%',
                                top: '50%',
                                transform: 'translate(-50%, -50%)'
                            }}
                            onPointerDown={handlePointerDown}
                            onPointerUp={handlePointerUp}
                            onPointerOut={handlePointerUp}
                            onPointerMove={handlePointerMove}
                            onWheel={handleWheel}
                            onTouchStart={handleTouchStart}
                            onTouchMove={handleTouchMove}
                            onTouchEnd={handleTouchEnd}
                            onClick={handleGlobeClick}
                            onMouseEnter={handleMouseEnter}
                            onMouseLeave={handleMouseLeave}
                        />

                        {/* Click effect */}
                        {clickEffect && (
                            <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                                <span className="font-mono text-xl font-bold text-white animate-ping">+{formatNumber(clickEffect.value)}</span>
                            </div>
                        )}

                        {/* Shop overlay */}
                        {showShop && (
                            <div className="absolute inset-0 bg-black/90 overflow-y-auto p-3">
                                <div className="flex justify-between items-center mb-3">
                                    <span className="font-mono text-sm font-bold text-white">UPGRADES</span>
                                    <button onClick={() => setShowShop(false)} className="font-mono text-white hover:text-red-400"></button>
                                </div>
                                {shopItems.map(cat => (
                                    <div key={cat.category} className="mb-3">
                                        <div className="font-mono text-[10px] text-gray-500 mb-1">{cat.category}</div>
                                        <div className="space-y-1">
                                            {cat.items.map(item => {
                                                const owned = gameState.upgrades[item.id];
                                                const locked = isLocked(item);
                                                const affordable = canBuy(item);
                                                return (
                                                    <button
                                                        key={item.id}
                                                        onClick={() => buyUpgrade(item)}
                                                        disabled={owned || locked || !affordable}
                                                        className={`w-full text-left p-2 font-mono text-[10px] border ${
                                                            owned ? 'border-green-500/50 bg-green-500/10 text-green-400' :
                                                            locked ? 'border-gray-700 text-gray-600 cursor-not-allowed' :
                                                            affordable ? 'border-white/30 text-white hover:bg-white/10 cursor-pointer' :
                                                            'border-gray-700 text-gray-500 cursor-not-allowed'
                                                        }`}
                                                    >
                                                        <div className="flex justify-between">
                                                            <span>{item.name}</span>
                                                            <span>{owned ? '' : formatNumber(getActualCost(item.cost))}</span>
                                                        </div>
                                                        <div className="text-gray-500">{item.desc}</div>
                                                    </button>
                                                );
                                            })}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>

                    {/* Footer */}
                    <div className="p-2 border-t border-white/20 text-center">
                        <span className="font-mono text-[10px] text-gray-500">
                            {gameStarted ? `POWER: ${gameState.clickPower} | AUTO: ${gameState.satellites}/s | MULTI: ${gameState.clickMultiplier}x` : 'BUCHAREST, ROMANIA'}
                        </span>
                    </div>

                    {/* CSS for spin animation */}
                    <style>{`
                        @keyframes spin {
                            from { transform: rotate(0deg); }
                            to { transform: rotate(360deg); }
                        }
                    `}</style>
                </div>
            );
        };

        // --- POMODORO.EXE - Timer with growing plant ---
        const PomodoroApp = ({ onAchievement }) => {
            const [mode, setMode] = useState('work'); // 'work' or 'break'
            const [timeLeft, setTimeLeft] = useState(25 * 60); // 25 minutes
            const [isRunning, setIsRunning] = useState(false);
            const [sessions, setSessions] = useState(0);
            const [view, setView] = useState('timer'); // 'timer' or 'room'
            const [totalTime, setTotalTime] = useState(0); // total seconds spent
            const [flowers, setFlowers] = useState([]); // collected flowers
            const [currentFlower, setCurrentFlower] = useState(null); // flower for current session
            const achievementTriggered = useRef(false);

            const WORK_TIME = 25 * 60;
            const BREAK_TIME = 5 * 60;

            // 5 pot styles, 5 stem/leaf types, 5 flower types = 125 combinations
            const POT_STYLES = [
                { color: '#8B4513', rimColor: '#654321', shape: 'classic' },
                { color: '#4a4a4a', rimColor: '#2a2a2a', shape: 'modern' },
                { color: '#CD853F', rimColor: '#8B4513', shape: 'terracotta' },
                { color: '#1a1a1a', rimColor: '#000000', shape: 'sleek' },
                { color: '#708090', rimColor: '#4a4a4a', shape: 'stone' }
            ];
            const STEM_TYPES = [
                { leafStyle: 'round', stemColor: '#228B22' },
                { leafStyle: 'pointed', stemColor: '#006400' },
                { leafStyle: 'droopy', stemColor: '#32CD32' },
                { leafStyle: 'spiral', stemColor: '#2E8B57' },
                { leafStyle: 'minimal', stemColor: '#3CB371' }
            ];
            const FLOWER_TYPES = [
                { petalColor: '#FF69B4', centerColor: '#FFD700', shape: 'tulip' },
                { petalColor: '#FF4500', centerColor: '#FFA500', shape: 'rose' },
                { petalColor: '#9370DB', centerColor: '#FFD700', shape: 'daisy' },
                { petalColor: '#00CED1', centerColor: '#FFFFFF', shape: 'lotus' },
                { petalColor: '#FFD700', centerColor: '#8B4513', shape: 'sunflower' }
            ];

            // Load saved data on mount
            useEffect(() => {
                const saved = localStorage.getItem('pomodoro_data');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        setTotalTime(data.totalTime || 0);
                        setFlowers(data.flowers || []);
                        setSessions(data.sessions || 0);
                    } catch (e) {}
                }
                // Generate flower for this session
                setCurrentFlower({
                    pot: Math.floor(Math.random() * 5),
                    stem: Math.floor(Math.random() * 5),
                    flower: Math.floor(Math.random() * 5),
                    id: Date.now()
                });
            }, []);

            // Save data whenever it changes
            useEffect(() => {
                localStorage.setItem('pomodoro_data', JSON.stringify({
                    totalTime, flowers, sessions
                }));
            }, [totalTime, flowers, sessions]);

            useEffect(() => {
                if (!isRunning) return;

                const interval = setInterval(() => {
                    if (mode === 'work') {
                        setTotalTime(t => t + 1); // Track total time
                    }
                    setTimeLeft(prev => {
                        if (prev <= 1) {
                            if (mode === 'work') {
                                setMode('break');
                                setSessions(s => s + 1);
                                // Add completed flower to collection
                                if (currentFlower) {
                                    setFlowers(f => {
                                        const newFlowers = [...f, { ...currentFlower, completedAt: Date.now() }];
                                        // Check for MASTER achievement (50 flowers)
                                        if (newFlowers.length >= 50 && !achievementTriggered.current) {
                                            achievementTriggered.current = true;
                                            onAchievement?.('MASTER');
                                        }
                                        return newFlowers;
                                    });
                                    // Generate new flower for next session
                                    setCurrentFlower({
                                        pot: Math.floor(Math.random() * 5),
                                        stem: Math.floor(Math.random() * 5),
                                        flower: Math.floor(Math.random() * 5),
                                        id: Date.now()
                                    });
                                }
                                return BREAK_TIME;
                            } else {
                                setMode('work');
                                return WORK_TIME;
                            }
                        }
                        return prev - 1;
                    });
                }, 1000);

                return () => clearInterval(interval);
            }, [isRunning, mode, currentFlower]);

            const progress = mode === 'work'
                ? 1 - (timeLeft / WORK_TIME)
                : 1 - (timeLeft / BREAK_TIME);

            const formatTime = (seconds) => {
                const m = Math.floor(seconds / 60);
                const s = seconds % 60;
                return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            };

            const formatTotalTime = (seconds) => {
                const h = Math.floor(seconds / 3600);
                const m = Math.floor((seconds % 3600) / 60);
                return `${h}h ${m}m`;
            };

            const reset = () => {
                setIsRunning(false);
                setMode('work');
                setTimeLeft(WORK_TIME);
            };

            // Render a flower with specific style indices
            const renderFlower = (potIdx, stemIdx, flowerIdx, growth = 1, size = 1, isSleeping = false) => {
                const pot = POT_STYLES[potIdx];
                const stem = STEM_TYPES[stemIdx];
                const flowerType = FLOWER_TYPES[flowerIdx];
                const w = 24 * size;
                const h = 32 * size;

                return (
                    <svg width={w * 5} height={h * 5} viewBox="0 0 24 32" style={{ imageRendering: 'pixelated' }}>
                        {/* Pot based on style */}
                        <rect x="6" y="26" width="12" height="6" fill="#000" />
                        <rect x="7" y="27" width="10" height="4" fill={pot.color} />
                        <rect x="6" y="26" width="12" height="1" fill={pot.rimColor} />

                        {/* Soil */}
                        <rect x="7" y="25" width="10" height="2" fill="#333" />

                        {/* Stem */}
                        {growth > 0 && <rect x="11" y={25 - Math.floor(growth * 12)} width="2" height={Math.floor(growth * 12)} fill={stem.stemColor} />}

                        {/* Leaves based on stem type */}
                        {growth > 0.2 && stem.leafStyle === 'round' && (
                            <><rect x="9" y="21" width="2" height="2" fill={stem.stemColor} /><rect x="8" y="20" width="2" height="2" fill={stem.stemColor} /></>
                        )}
                        {growth > 0.2 && stem.leafStyle === 'pointed' && (
                            <><rect x="9" y="21" width="2" height="1" fill={stem.stemColor} /><rect x="8" y="20" width="2" height="1" fill={stem.stemColor} /></>
                        )}
                        {growth > 0.2 && stem.leafStyle === 'droopy' && (
                            <><rect x="9" y="22" width="2" height="2" fill={stem.stemColor} /><rect x="7" y="23" width="2" height="1" fill={stem.stemColor} /></>
                        )}
                        {growth > 0.2 && stem.leafStyle === 'spiral' && (
                            <><rect x="9" y="21" width="1" height="2" fill={stem.stemColor} /><rect x="8" y="22" width="1" height="1" fill={stem.stemColor} /></>
                        )}
                        {growth > 0.2 && stem.leafStyle === 'minimal' && (
                            <rect x="9" y="21" width="2" height="1" fill={stem.stemColor} />
                        )}

                        {growth > 0.4 && (
                            <><rect x="13" y="18" width="2" height="2" fill={stem.stemColor} /><rect x="14" y="17" width="2" height="2" fill={stem.stemColor} /></>
                        )}
                        {growth > 0.6 && (
                            <><rect x="8" y="15" width="2" height="2" fill={stem.stemColor} /><rect x="7" y="14" width="2" height="2" fill={stem.stemColor} /></>
                        )}
                        {growth > 0.8 && (
                            <><rect x="13" y="12" width="2" height="2" fill={stem.stemColor} /><rect x="14" y="11" width="2" height="2" fill={stem.stemColor} /></>
                        )}

                        {/* Flower head based on type */}
                        {growth >= 1 && flowerType.shape === 'tulip' && (
                            <><rect x="10" y="9" width="4" height="4" fill={flowerType.petalColor} /><rect x="11" y="8" width="2" height="1" fill={flowerType.petalColor} /><rect x="11" y="10" width="2" height="2" fill={flowerType.centerColor} /></>
                        )}
                        {growth >= 1 && flowerType.shape === 'rose' && (
                            <><rect x="9" y="9" width="6" height="4" fill={flowerType.petalColor} /><rect x="10" y="8" width="4" height="1" fill={flowerType.petalColor} /><rect x="11" y="10" width="2" height="2" fill={flowerType.centerColor} /></>
                        )}
                        {growth >= 1 && flowerType.shape === 'daisy' && (
                            <><rect x="11" y="7" width="2" height="6" fill={flowerType.petalColor} /><rect x="9" y="9" width="6" height="2" fill={flowerType.petalColor} /><rect x="11" y="9" width="2" height="2" fill={flowerType.centerColor} /></>
                        )}
                        {growth >= 1 && flowerType.shape === 'lotus' && (
                            <><rect x="10" y="8" width="4" height="5" fill={flowerType.petalColor} /><rect x="9" y="10" width="6" height="2" fill={flowerType.petalColor} /><rect x="11" y="10" width="2" height="2" fill={flowerType.centerColor} /></>
                        )}
                        {growth >= 1 && flowerType.shape === 'sunflower' && (
                            <><rect x="9" y="8" width="6" height="5" fill={flowerType.petalColor} /><rect x="10" y="9" width="4" height="3" fill={flowerType.centerColor} /></>
                        )}

                        {/* Sleeping ZZZ */}
                        {isSleeping && (
                            <><rect x="16" y="6" width="4" height="1" fill="#000" /><rect x="19" y="5" width="1" height="2" fill="#000" /><rect x="17" y="4" width="3" height="1" fill="#000" /></>
                        )}
                    </svg>
                );
            };

            // Render current growing plant
            const renderPlant = () => {
                const isSleeping = mode === 'break';
                const growth = mode === 'work' ? progress : 1;
                if (!currentFlower) return null;
                return renderFlower(currentFlower.pot, currentFlower.stem, currentFlower.flower, growth, 1, isSleeping);
            };

            // Flower Room view
            const renderFlowerRoom = () => {
                const shelves = [];
                const flowersPerShelf = 5;
                const shelfCount = Math.ceil(flowers.length / flowersPerShelf);
                for (let i = 0; i < shelfCount; i++) {
                    shelves.push(flowers.slice(i * flowersPerShelf, (i + 1) * flowersPerShelf));
                }

                return (
                    <div className="flex-grow overflow-auto bg-gray-100 p-4">
                        <div className="text-center mb-4">
                            <div className="font-mono text-xs text-gray-500">TOTAL FOCUS TIME</div>
                            <div className="font-mono text-2xl font-bold">{formatTotalTime(totalTime)}</div>
                        </div>
                        {flowers.length === 0 ? (
                            <div className="text-center py-12">
                                <div className="font-mono text-gray-500 text-sm">Empty so far, get productive!</div>
                            </div>
                        ) : (
                            shelves.map((shelf, shelfIdx) => (
                                <div key={shelfIdx} className="mb-2">
                                    <div className="flex justify-center gap-1 pb-1">
                                        {shelf.map((f, idx) => (
                                            <div key={f.id} className="w-16 h-20 flex items-end justify-center">
                                                <svg width="48" height="64" viewBox="0 0 24 32" style={{ imageRendering: 'pixelated' }}>
                                                    {/* Mini flower */}
                                                    <rect x="6" y="26" width="12" height="6" fill="#000" />
                                                    <rect x="7" y="27" width="10" height="4" fill={POT_STYLES[f.pot].color} />
                                                    <rect x="7" y="25" width="10" height="2" fill="#333" />
                                                    <rect x="11" y="13" width="2" height="12" fill={STEM_TYPES[f.stem].stemColor} />
                                                    <rect x="9" y="17" width="2" height="2" fill={STEM_TYPES[f.stem].stemColor} />
                                                    <rect x="13" y="20" width="2" height="2" fill={STEM_TYPES[f.stem].stemColor} />
                                                    <rect x="9" y="9" width="6" height="5" fill={FLOWER_TYPES[f.flower].petalColor} />
                                                    <rect x="10" y="10" width="4" height="3" fill={FLOWER_TYPES[f.flower].centerColor} />
                                                </svg>
                                            </div>
                                        ))}
                                    </div>
                                    <div className="h-2 bg-gradient-to-b from-amber-800 to-amber-900 border-t-2 border-amber-700 mx-4" />
                                </div>
                            ))
                        )}
                        <div className="text-center mt-4 font-mono text-[10px] text-gray-400">
                            {flowers.length} FLOWER{flowers.length !== 1 ? 'S' : ''} COLLECTED  125 POSSIBLE VARIETIES
                        </div>
                    </div>
                );
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="app-header">
                        <div className="flex items-center gap-2">
                            <Icons.Pomodoro size={24} />
                            <span className="app-header-title">POMODORO.EXE</span>
                        </div>
                        <div className="flex items-center gap-2">
                            <span className="app-footer-text">SESSIONS: {sessions}</span>
                            <button
                                onClick={() => setView(view === 'timer' ? 'room' : 'timer')}
                                className={`px-2 py-1 font-mono text-[10px] border-2 border-black ${view === 'room' ? 'bg-black text-white' : 'bg-white text-black hover:bg-gray-100'}`}
                            >
                                {view === 'timer' ? 'ROOM' : 'TIMER'}
                            </button>
                        </div>
                    </div>

                    {view === 'room' ? renderFlowerRoom() : (
                        <div className="flex-grow flex flex-col items-center justify-center bg-gray-50 p-6">
                            {/* Mode indicator */}
                            <div className={`px-4 py-1 mb-4 font-mono text-xs font-bold ${mode === 'work' ? 'bg-black text-white' : 'bg-gray-300 text-black'}`}>
                                {mode === 'work' ? 'FOCUS TIME' : 'BREAK TIME'}
                            </div>

                            {/* Plant */}
                            <div className="mb-6">
                                {renderPlant()}
                            </div>

                            {/* Timer */}
                            <div className="font-mono text-5xl font-black mb-6 tracking-wider">
                                {formatTime(timeLeft)}
                            </div>

                            {/* Progress bar */}
                            <div className="w-48 h-2 bg-gray-200 border-2 border-black mb-6">
                                <div
                                    className="h-full bg-black transition-all duration-1000"
                                    style={{ width: `${progress * 100}%` }}
                                />
                            </div>

                            {/* Controls */}
                            <div className="flex gap-4">
                                <button
                                    onClick={() => setIsRunning(!isRunning)}
                                    className="btn-primary"
                                >
                                    {isRunning ? 'PAUSE' : 'START'}
                                </button>
                                <button
                                    onClick={reset}
                                    className="btn-secondary"
                                >
                                    RESET
                                </button>
                            </div>
                        </div>
                    )}

                    <div className="app-footer">
                        <span className="app-footer-text">
                            {view === 'room' ? `TOTAL: ${formatTotalTime(totalTime)}` : (mode === 'work' ? 'GROW YOUR FOCUS' : 'PLANT IS RESTING')}
                        </span>
                    </div>
                </div>
            );
        };

        // --- SCANNER.EXE - Embedded health score app ---
        const HealthScannerApp = () => {
            const [booting, setBooting] = useState(true);
            const [bootText, setBootText] = useState('');

            useEffect(() => {
                const bootSequence = [
                    'HEALTH SCANNER INDUSTRIES',
                    '',
                    'INITIALIZING BIOMETRIC SENSORS...',
                    'LOADING NEURAL INTERFACE...',
                    'CALIBRATING HEALTH MATRIX...',
                    '',
                    'SYSTEM READY'
                ];

                let lineIndex = 0;
                let charIndex = 0;
                let currentText = '';

                const typeInterval = setInterval(() => {
                    if (lineIndex >= bootSequence.length) {
                        clearInterval(typeInterval);
                        setTimeout(() => setBooting(false), 500);
                        return;
                    }

                    const currentLine = bootSequence[lineIndex];
                    if (charIndex < currentLine.length) {
                        currentText += currentLine[charIndex];
                        setBootText(currentText);
                        charIndex++;
                    } else {
                        currentText += '\n';
                        setBootText(currentText);
                        lineIndex++;
                        charIndex = 0;
                    }
                }, 30);

                return () => clearInterval(typeInterval);
            }, []);

            if (booting) {
                return (
                    <div className="h-full flex flex-col bg-black select-none">
                        <div className="flex-grow flex flex-col items-center justify-center p-8 font-mono">
                            <div className="text-green-500 text-center whitespace-pre-line text-sm mb-8">
                                {bootText}
                                <span className="animate-pulse">_</span>
                            </div>
                            <div className="flex gap-2">
                                <div className="w-3 h-3 bg-green-500 animate-pulse" style={{ animationDelay: '0ms' }}></div>
                                <div className="w-3 h-3 bg-green-500 animate-pulse" style={{ animationDelay: '150ms' }}></div>
                                <div className="w-3 h-3 bg-green-500 animate-pulse" style={{ animationDelay: '300ms' }}></div>
                            </div>
                        </div>
                        <div className="p-2 border-t border-green-900 text-center">
                            <span className="font-mono text-[10px] text-green-700"> HEALTH SCANNER INDUSTRIES 2077</span>
                        </div>
                    </div>
                );
            }

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <iframe
                        src="https://healthscore-2-0.vercel.app/"
                        className="w-full h-full border-0"
                        title="Health Scanner"
                        allow="camera; microphone"
                    />
                </div>
            );
        };

        // --- DOG STORY TERMINAL - Auto-playing story ---
        const DogStoryTerminal = ({ onRemoveGoldDog }) => {
            const [lines, setLines] = useState([]);
            const [goldDogVisible, setGoldDogVisible] = useState(true);

            const story = [
                { text: '$ cd /cage_17', delay: 0 },
                { text: '$ ls -la', delay: 500 },
                { text: 'total 2\ndrwxr-xr-x  unit_black\ndrwxr-xr-x  unit_gold', delay: 1000, isOutput: true },
                { text: '$ cat unit_black/status', delay: 2500 },
                { text: 'tail.wag=1\nposition=front\nfacing=door', delay: 3000, isOutput: true },
                { text: '$ cat unit_gold/status', delay: 5000 },
                { text: 'tail.wag=1\nposition=rear\ntremor=1', delay: 5500, isOutput: true },
                { text: '$ cp -r cage_17/* /home/mateus/', delay: 7500 },
                { text: 'cp: copy both units? (y/n) y\ncopying...\ndone.', delay: 8000, isOutput: true },
                { text: '$ rm -rf /cage_17', delay: 10000 },
                { text: 'removed.', delay: 10500, isOutput: true },
                { text: '$ ls /home/mateus/', delay: 12000 },
                { text: 'unit_black/\nunit_gold/', delay: 12500, isOutput: true },
                // Wait 3 seconds
                { text: '$ uptime unit_gold', delay: 16000 },
                { text: '12 years, 2 months, 11 days', delay: 16500, isOutput: true },
                { text: '$ diff unit_gold/muzzle_2020.png unit_gold/muzzle_2024.png', delay: 18500 },
                { text: '< rgb(0,0,0)\n> rgb(128,128,128)', delay: 19000, isOutput: true },
                { text: '$ cat /var/log/sleep.log', delay: 21000 },
                { text: 'unit_gold: sleeping\nunit_black: sleeping\nlocation: same', delay: 21500, isOutput: true },
                { text: '$ ping unit_gold', delay: 23500 },
                { text: 'PING unit_gold (192.168.1.2): 56 bytes\nRequest timeout for icmp_seq 0\nRequest timeout for icmp_seq 1\nRequest timeout for icmp_seq 2\n^C', delay: 24000, isOutput: true },
                { text: '$ systemctl status unit_gold', delay: 27000 },
                { text: ' unit_gold.service\n   Active: degrading', delay: 27500, isOutput: true },
                // Wait 5 seconds
                { text: '$ cat /home/mateus/unit_gold', delay: 33000 },
                { text: '[FILE DELETED]', delay: 33500, isOutput: true, removeGold: true },
                // Wait 5 seconds
                { text: '$ grep -r "unit_gold" /home/mateus/unit_black/memory/', delay: 39000 },
                { text: '/home/mateus/unit_black/memory/scent.dat: [SEARCHING]\n/home/mateus/unit_black/memory/warmth.dat: [SEARCHING]\n/home/mateus/unit_black/memory/pile.dat: [SEARCHING]', delay: 39500, isOutput: true },
                { text: '$ tail -f /home/mateus/unit_black/process.log', delay: 42000 },
                { text: 'waiting...\nwaiting...\nwaiting...\n^C', delay: 42500, isOutput: true },
                { text: '$ ls /home/mateus/', delay: 46000 },
                { text: 'unit_black/', delay: 46500, isOutput: true },
                { text: '$ ls /home/mateus/heart/', delay: 48500 },
                { text: 'unit_black/\nunit_gold/', delay: 49000, isOutput: true, final: true },
            ];

            useEffect(() => {
                story.forEach(item => {
                    setTimeout(() => {
                        setLines(prev => [...prev, { text: item.text, isOutput: item.isOutput }]);
                        if (item.removeGold) {
                            setGoldDogVisible(false);
                            onRemoveGoldDog?.();
                        }
                    }, item.delay);
                });
            }, []);

            return (
                <div className="h-full flex flex-col bg-black text-green-400 font-mono text-xs select-none">
                    <div className="p-2 border-b border-green-900 flex items-center gap-2">
                        <Icons.Terminal size={16} />
                        <span className="text-xs font-bold">DOG.TXT</span>
                    </div>
                    <div className="flex-grow overflow-auto p-3 space-y-0.5">
                        {lines.map((line, i) => (
                            <div key={i} className={`whitespace-pre-wrap ${line.isOutput ? 'text-green-600' : 'text-green-300'}`}>
                                {line.text}
                            </div>
                        ))}
                        <span className="inline-block w-2 h-3 bg-green-400 animate-pulse" />
                    </div>
                </div>
            );
        };

        // --- TERMINAL.EXE - Command line interface ---
        const TerminalApp = ({ onClose, onOpenApp, onReleaseDog, onMatrixMode, onUnlockPrivate, onAchievement, onGodMode }) => {
            const [history, setHistory] = useState([{ type: 'output', text: 'ULTRA_INT Terminal v1.0.0\nType "help" for available commands.\n' }]);
            const [input, setInput] = useState('');
            const [isLoading, setIsLoading] = useState(false);
            const [suggestion, setSuggestion] = useState('');
            const inputRef = useRef(null);
            const historyRef = useRef(null);

            // Public commands shown in help and autocomplete
            const commands = [
                'help', 'make money', 'sudo make sandwich', 'exit', 'exit matrix', 'ping god', 'ping mateus',
                'kill', 'sudo shutdown', 'sudo reboot', 'cmatrix', 'systemctl start dog.exe',
                'sudo chmod 777 /private', ':(){ :|:& };:', 'sudo dd if=/dev/zero of=/',
                'scp truth.txt ~/', 'clear', 'whoami', 'pwd', 'ls'
            ];
            // Hidden commands - work but don't appear in help or autocomplete

            useEffect(() => {
                if (historyRef.current) {
                    historyRef.current.scrollTop = historyRef.current.scrollHeight;
                }
            }, [history]);

            useEffect(() => {
                inputRef.current?.focus();
            }, [isLoading]);

            // Autocomplete
            useEffect(() => {
                if (input.length > 0) {
                    const match = commands.find(cmd => cmd.startsWith(input.toLowerCase()) && cmd !== input.toLowerCase());
                    setSuggestion(match || '');
                } else {
                    setSuggestion('');
                }
            }, [input]);

            const addOutput = (text) => {
                setHistory(prev => [...prev, { type: 'output', text }]);
            };

            const executeCommand = async (cmd) => {
                const trimmed = cmd.trim().toLowerCase();
                setHistory(prev => [...prev, { type: 'input', text: `$ ${cmd}` }]);
                setInput('');
                setIsLoading(true);

                // Random loading time 1-3 seconds (except ping god which is 10s)
                const loadTime = trimmed === 'ping god' ? 10000 : (1000 + Math.random() * 2000);

                // Show loading dots
                let dots = '';
                const dotInterval = setInterval(() => {
                    dots = dots.length >= 3 ? '.' : dots + '.';
                    setHistory(prev => {
                        const newHist = [...prev];
                        if (newHist[newHist.length - 1]?.type === 'loading') {
                            newHist[newHist.length - 1].text = dots;
                        } else {
                            newHist.push({ type: 'loading', text: dots });
                        }
                        return newHist;
                    });
                }, 300);

                await new Promise(resolve => setTimeout(resolve, loadTime));
                clearInterval(dotInterval);

                // Remove loading entry
                setHistory(prev => prev.filter(h => h.type !== 'loading'));
                setIsLoading(false);

                // Process commands
                if (trimmed === 'help') {
                    addOutput(`Available commands:
  help                        - Show this help
  make money                  - Try to make money
  sudo make sandwich          - Make a sandwich
  exit                        - Exit terminal
  ping <host>                 - Ping a host
  kill <process>              - Kill a process
  sudo shutdown               - Shutdown system
  sudo reboot                 - Reboot system
  cmatrix                     - Enter the Matrix
  exit matrix                 - Exit the Matrix
  systemctl start dog.exe     - Start dog service
  sudo chmod 777 /private     - Change permissions
  scp truth.txt ~/            - Copy truth to home
  clear                       - Clear terminal
  whoami                      - Display current user
  pwd                         - Print working directory
  ls                          - List files`);
                } else if (trimmed === 'make money') {
                    addOutput("make: *** No rule to make target 'money'. Stop.");
                } else if (trimmed === 'sudo make sandwich') {
                    addOutput('Okay.');
                } else if (trimmed === 'exit') {
                    addOutput('There is no escape.');
                } else if (trimmed === 'ping god') {
                    addOutput('PING god (...): 56 data bytes\nRequest timed out.');
                } else if (trimmed === 'ping mateus') {
                    addOutput('PING mateus (127.0.0.1): 56 data bytes\n64 bytes: icmp_seq=0 ttl=64 time=0.042 ms\nOpening contact...');
                    setTimeout(() => onOpenApp?.('PAINT'), 500);
                    onAchievement?.('SOCIAL_NETWORK');
                } else if (trimmed.startsWith('kill ')) {
                    const proc = trimmed.replace('kill ', '').toUpperCase();
                    addOutput(`Attempting to terminate ${proc}...`);
                    setTimeout(() => onClose?.(proc), 500);
                } else if (trimmed === 'sudo shutdown' || trimmed === 'sudo reboot') {
                    addOutput(trimmed === 'sudo shutdown' ? 'System shutting down...' : 'System rebooting...');
                    setTimeout(() => window.location.reload(), 1500);
                } else if (trimmed === 'cmatrix') {
                    addOutput('Entering the Matrix...');
                    setTimeout(() => onMatrixMode?.(), 500);
                } else if (trimmed === 'exit matrix') {
                    addOutput('Exiting the Matrix...');
                    setTimeout(() => onMatrixMode?.(), 500);
                } else if (trimmed === 'systemctl start dog.exe') {
                    addOutput('Starting dog.exe...\n[  OK  ] Started dog.exe');
                    setTimeout(() => onReleaseDog?.(), 500);
                } else if (trimmed === 'sudo chmod 777 /private') {
                    addOutput("chmod: changing permissions of '/private': Operation permitted\nWarning: File now accessible.");
                    onUnlockPrivate?.();
                } else if (trimmed === ':(){ :|:& };:') {
                    for (let i = 0; i < 10; i++) {
                        setTimeout(() => addOutput('SYSTEM BREACH DETECTED'), i * 200);
                    }
                    setTimeout(() => addOutput('\n...nothing happens.'), 2500);
                    onAchievement?.('FORBIDDEN');
                } else if (trimmed === 'sudo dd if=/dev/zero of=/') {
                    addOutput("Permission denied. You're not that guy.");
                } else if (trimmed === 'scp truth.txt ~/') {
                    navigator.clipboard.writeText('No matching files found.');
                    addOutput('Saved to clipboard.');
                } else if (trimmed === 'clear') {
                    setHistory([]);
                } else if (trimmed === 'whoami') {
                    addOutput('guest');
                } else if (trimmed === 'pwd') {
                    addOutput('/home/guest');
                } else if (trimmed === 'ls') {
                    addOutput('Desktop  Documents  Downloads  Pictures  Videos  .secrets');
                } else if (trimmed === 'cd .secrets' || trimmed === 'cat .secrets') {
                    addOutput('Permission denied');
                // Hidden commands - work but not shown in help or autocomplete
                } else if (trimmed === 'sudo become god') {
                    addOutput('ELEVATION GRANTED.\n\nYou are now root.\nAll restrictions lifted.\nReality bends to your will.\n\nUnlocking everything...');
                    setTimeout(() => onGodMode?.(), 500);
                } else if (trimmed === 'reset') {
                    addOutput('Wiping consciousness...\nReturning to void...');
                    setTimeout(() => {
                        localStorage.clear();
                        window.location.reload();
                    }, 1500);
                } else if (trimmed) {
                    sounds.error();
                    addOutput(`bash: ${trimmed.split(' ')[0]}: command not found`);
                }
            };

            const handleKeyDown = (e) => {
                if (e.key === 'Enter' && !isLoading) {
                    executeCommand(input);
                } else if (e.key === 'Tab' && suggestion) {
                    e.preventDefault();
                    setInput(suggestion);
                    setSuggestion('');
                }
            };

            return (
                <div className="h-full flex flex-col bg-black text-green-400 font-mono text-sm select-none">
                    <div className="p-2 border-b border-green-900 flex items-center gap-2">
                        <Icons.Terminal size={16} />
                        <span className="text-xs font-bold">TERMINAL.EXE</span>
                    </div>
                    <div ref={historyRef} className="flex-grow overflow-auto p-3 space-y-1">
                        {history.map((item, i) => (
                            <div key={i} className={item.type === 'input' ? 'text-green-300' : item.type === 'loading' ? 'text-green-600 animate-pulse' : 'text-green-400 whitespace-pre-wrap'}>
                                {item.text}
                            </div>
                        ))}
                    </div>
                    <div className="p-3 border-t border-green-900 relative">
                        {suggestion && !isLoading && (
                            <div className="absolute -top-6 left-3 bg-green-900/80 text-green-300 px-2 py-0.5 text-xs rounded">
                                {suggestion} <span className="text-green-600">[TAB]</span>
                            </div>
                        )}
                        <div className="flex items-center gap-2">
                            <span className="text-green-500">$</span>
                            <input
                                ref={inputRef}
                                type="text"
                                value={input}
                                onChange={(e) => setInput(e.target.value)}
                                onKeyDown={handleKeyDown}
                                disabled={isLoading}
                                className="flex-grow bg-transparent border-none outline-none text-green-300 placeholder-green-800"
                                placeholder={isLoading ? '' : 'Enter command...'}
                                autoFocus
                            />
                            {isLoading && <span className="animate-pulse">_</span>}
                        </div>
                    </div>
                </div>
            );
        };

        // --- THIRD_EYE.EXE - X-ray view of app code ---
        const ThirdEyeApp = ({ windowId, windows, stackOverflow, stackErrors, iconPositions }) => {
            const thisWindow = windows[windowId];
            const windowX = thisWindow?.x || 0;
            const windowY = thisWindow?.y || 0;
            // Account for window header height (approx 32px)
            const headerHeight = 32;

            const appCode = {
                SNAKE: `// SNEK.JS\nfunction eat() {\n  grow();\n  // ouroboros.exe\n  if (head === tail) become(god);\n}`,
                MINESWEEPER: `// MINES.SYS\nbool click(x, y) {\n  if (bomb[x][y]) die();\n  // "I am become death"\n  return survive();\n}`,
                STARSHIP: `// STARFOX.ASM\n; DO A BARREL ROLL\nlaser.pewpew();\nasteroid.dodge();`,
                DICE: `// RNG.GOD\nlet fate = Math.random();\nif (result === 1) // skill issue`,
                LABYRINTH: `// MAZE.RUNNER\nwhile (!escaped) {\n  turn_right();\n  move_forward();\n}`,
                PAINT: `// ART.EXE\ncanvas.soil(pos, color);\n// art is destruction`,
                TAROT: `// CARDS.FATE\ndeck.shuffle();\nreveal(destiny);`,
                VOID: `// VOID.NULL\nreturn undefined;\n// intentionally left meaningful`,
                RADIO: `// STREAM.WAV\naudio.play(frequency);`,
                SYNTH: `// SOUND.WAVE\nnote.oscillate();`,
                TERMINAL: `// CMD.EXE\nif (cmd === "exit") print("no escape");`,
                SYSTEM: `// KERNEL.SYS\nif (konami_code()) observe_all();`,
                POMODORO: `// TIME.LOOP\nwork(25); rest(5);`,
                MAP: `// GLOBE.ROTATE\nrender_sphere(phi++);`,
                BROWSER: `// EXPLORE.NET\nif (url === self) reboot();`,
                WORDS: `// WORDLE.CLONE\n// 5 letters, 6 tries`,
                GALLERY: `// IMAGES.VIEW\nphotos.forEach(display);`,
                DESTRUCTION: `// CHAOS.EXE\nreality.invert();\ndog.release();`,
                CONTACT: `// MAIL.SEND\nclipboard.copy(email);`,
                TRASH: `// RECYCLE.BIN\ndelete item;`,
                SCANNER: `// HEALTH.CHK\ndiagnosis = "probably fine";`,
                THIRD_EYE: `// OBSERVE.SYS\nif (observer_observed)\n  STACK_OVERFLOW();`,
                THIRD_EYE_2: `// OBSERVE.SYS\nif (observer_observed)\n  STACK_OVERFLOW();`,
                FILES: `// EXPLORER.SYS\nlist(directories);`,
                APPS: `// LAUNCHER.EXE\nopen(selected_app);`,
            };

            const defaultCode = `// UNKNOWN.DAT\nreturn mysterious();`;

            // Desktop icons to show in portal
            const desktopIconIds = ['SYSTEM', 'FILES', 'APPS', 'CONTACT', 'TRUTH'];

            // Stack overflow display with rapid scrolling errors and flashing
            const [flashSpeed, setFlashSpeed] = useState(500);
            const [displayErrors, setDisplayErrors] = useState([]);

            // Generate looping error commands
            useEffect(() => {
                if (stackOverflow) {
                    // Accelerate flash speed over time
                    const accelerate = setInterval(() => {
                        setFlashSpeed(prev => Math.max(50, prev - 30));
                    }, 500);

                    // Loop through 10 commands continuously
                    const commands = [
                        'FATAL: recursive observation detected',
                        'ERR: infinite loop in render_self()',
                        'PANIC: stack depth exceeded at 0xDEADBEEF',
                        'kernel: observer paradox imminent',
                        'CRITICAL: reality buffer overflow',
                        'ERR: cannot observe the observer',
                        'FATAL: ego_death.exe initiated',
                        'PANIC: consciousness stack corrupted',
                        'ERR: universe out of memory',
                        'FATAL: existence.so not found',
                    ];
                    let idx = 0;
                    const cmdInterval = setInterval(() => {
                        setDisplayErrors(prev => {
                            const next = [...prev, commands[idx % commands.length]];
                            idx++;
                            return next.slice(-15); // Keep last 15
                        });
                    }, 50);

                    return () => {
                        clearInterval(accelerate);
                        clearInterval(cmdInterval);
                    };
                } else {
                    setDisplayErrors([]);
                    setFlashSpeed(500);
                }
            }, [stackOverflow]);

            if (stackOverflow) {
                return (
                    <div
                        className="h-full flex flex-col bg-black text-red-500 font-mono select-none overflow-hidden relative"
                        style={{ animation: `stackFlash ${flashSpeed}ms infinite` }}
                    >
                        {/* Intense red flash overlay */}
                        <div
                            className="absolute inset-0 pointer-events-none"
                            style={{
                                background: `rgba(255,0,0,${0.1 + (500 - flashSpeed) / 800})`,
                                animation: `stackFlash ${flashSpeed}ms infinite`
                            }}
                        />
                        <div className="flex-grow flex flex-col p-3 overflow-hidden relative z-10">
                            <div className="text-red-500 text-xl font-bold mb-2 text-center" style={{ textShadow: '0 0 10px #f00' }}>
                                 STACK OVERFLOW 
                            </div>
                            <div className="text-red-400 text-xs mb-3 text-center animate-pulse">
                                recursive observation detected
                            </div>
                            <div className="flex-grow text-left w-full overflow-hidden">
                                {displayErrors.map((err, i) => (
                                    <div
                                        key={i}
                                        className="text-red-400 text-[11px] leading-relaxed font-mono"
                                        style={{ textShadow: '0 0 5px #f00' }}
                                    >
                                        {`> ${err}`}
                                    </div>
                                ))}
                                <div className="text-red-500 animate-pulse text-[11px]">{'> _'}</div>
                            </div>
                        </div>
                    </div>
                );
            }

            return (
                <div className="h-full w-full overflow-hidden relative bg-black">
                    {/* PORTAL VIEW - Alternate reality desktop */}
                    <div
                        className="absolute pointer-events-none"
                        style={{
                            width: '100vw',
                            height: '100vh',
                            left: -windowX,
                            top: -(windowY + headerHeight),
                            filter: 'invert(1) hue-rotate(180deg)',
                            background: '#000'
                        }}
                    >
                        {/* Wireframe grid background */}
                        <div className="absolute inset-0" style={{
                            backgroundImage: 'linear-gradient(rgba(0,255,0,0.1) 1px, transparent 1px), linear-gradient(90deg, rgba(0,255,0,0.1) 1px, transparent 1px)',
                            backgroundSize: '40px 40px'
                        }} />

                        {/* Desktop icons in portal view */}
                        {desktopIconIds.map(id => {
                            const pos = iconPositions[id];
                            if (!pos) return null;
                            return (
                                <div
                                    key={id}
                                    className="absolute flex flex-col items-center"
                                    style={{ left: pos.x, top: pos.y, width: 80 }}
                                >
                                    <div className="w-12 h-12 border-2 border-green-500 flex items-center justify-center text-green-500 text-xs font-mono">
                                        {'</>'}
                                    </div>
                                    <div className="text-green-500 text-[8px] font-mono mt-1 text-center">{id}</div>
                                </div>
                            );
                        })}

                        {/* Portal windows - show as wireframe with code */}
                        {Object.entries(windows)
                            .filter(([id]) => id !== windowId && id !== 'DOG_STORY' && id !== 'TRUTH')
                            .filter(([, win]) => win.isOpen && !win.isMin)
                            .map(([id, win]) => (
                                <div
                                    key={id}
                                    className="absolute border-2 border-green-500 bg-black/80"
                                    style={{
                                        left: win.x,
                                        top: win.y,
                                        width: win.w,
                                        height: win.h,
                                    }}
                                >
                                    {/* Window header wireframe */}
                                    <div className="border-b-2 border-green-500 px-2 py-1 flex items-center gap-2">
                                        <div className="w-2 h-2 border border-green-500" />
                                        <span className="text-green-500 text-[10px] font-mono">{win.title}</span>
                                    </div>
                                    {/* Code content */}
                                    <div className="p-2 overflow-hidden h-full">
                                        <pre className="text-green-400 text-[8px] font-mono leading-relaxed whitespace-pre-wrap opacity-80">
                                            {appCode[id] || defaultCode}
                                        </pre>
                                    </div>
                                </div>
                            ))
                        }
                    </div>

                    {/* Corner indicators */}
                    <div className="absolute top-1 left-1 text-green-500 text-[8px] font-mono z-50 bg-black/50 px-1"> THIRD_EYE</div>
                    <div className="absolute bottom-1 right-1 text-green-500 text-[8px] font-mono z-50 bg-black/50 px-1">SCANNING</div>
                </div>
            );
        };

        // --- TRUTH.TXT - Unlocked at 100 visits, password never works ---
        const TruthApp = ({ onAchievement }) => {
            const [password, setPassword] = useState('');
            const [attempts, setAttempts] = useState(0);
            const [message, setMessage] = useState('');

            const responses = [
                'INCORRECT.',
                'TRY AGAIN.',
                'NOT EVEN CLOSE.',
                'THAT\'S NOT IT.',
                'WRONG.',
                'NOPE.',
                'KEEP TRYING.',
                'STILL WRONG.',
                'MAYBE NEXT TIME.',
                'ACCESS DENIED.',
                'YOU\'RE PERSISTENT.',
                'THE PASSWORD ISN\'T A WORD.',
                'THE PASSWORD ISN\'T A NUMBER.',
                'THE PASSWORD ISN\'T A PHRASE.',
                'THE PASSWORD DOESN\'T EXIST.',
                'THERE IS NO PASSWORD.',
                'THERE NEVER WAS.',
                'THE TRUTH ISN\'T BEHIND A PASSWORD.',
                'THE TRUTH IS THE JOURNEY.',
                'YOU\'VE ALREADY FOUND IT.',
                '100 VISITS. THAT\'S THE TRUTH.',
                'YOUR DEDICATION. THAT\'S REAL.',
                'STOP LOOKING. YOU\'RE HERE.',
                'THIS IS IT.',
                'THERE\'S NOTHING MORE.',
                'JUST THIS MOMENT.',
                'AND YOUR CURIOSITY.',
                'WHICH BROUGHT YOU HERE.',
                'WHICH IS EVERYTHING.',
                'THANK YOU FOR VISITING.'
            ];

            const handleSubmit = (e) => {
                e.preventDefault();
                sounds.error();
                const newAttempts = attempts + 1;
                setAttempts(newAttempts);
                setMessage(responses[Math.min(newAttempts - 1, responses.length - 1)]);
                setPassword('');
            };

            return (
                <div className="h-full flex flex-col bg-black select-none">
                    <div className="p-2 border-b border-yellow-900 bg-black flex items-center gap-2">
                        <Icons.FileDoc size={16} />
                        <span className="font-mono text-xs font-bold text-yellow-500">TRUTH.TXT</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-6">
                        <div className="mb-4 text-yellow-500">
                            <Icons.FileDoc size={48} />
                        </div>
                        <div className="font-mono text-yellow-500 text-sm font-bold mb-2">ENCRYPTED FILE</div>
                        <div className="font-mono text-yellow-700 text-xs mb-6">UNLOCKED AFTER 100 VISITS</div>

                        <form onSubmit={handleSubmit} className="w-56">
                            <input
                                type="password"
                                value={password}
                                onChange={(e) => setPassword(e.target.value)}
                                placeholder="ENTER PASSWORD"
                                className="w-full px-3 py-2 mb-3 bg-black border-2 border-yellow-800 text-yellow-500 font-mono text-sm placeholder-yellow-900 focus:outline-none focus:border-yellow-500"
                            />
                            <button
                                type="submit"
                                className="w-full px-3 py-2 bg-yellow-900 text-yellow-100 font-mono text-xs font-bold hover:bg-yellow-800 border-2 border-yellow-700"
                            >
                                DECRYPT
                            </button>
                        </form>

                        {message && (
                            <div className="mt-4 p-3 border border-yellow-800 bg-yellow-950 max-w-xs">
                                <div className="font-mono text-yellow-500 text-xs text-center">{message}</div>
                            </div>
                        )}

                        {attempts > 0 && (
                            <div className="mt-3 font-mono text-yellow-800 text-[10px]">
                                ATTEMPTS: {attempts}
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // --- PRIVATE.EXE - Password Protected (with DOG.TXT reveal when unlocked) ---
        const PersonalApp = ({ unlocked, onOpenDogStory }) => {
            const [password, setPassword] = useState('');
            const [attempts, setAttempts] = useState(0);
            const [error, setError] = useState('');
            const [shaking, setShaking] = useState(false);
            const [revealPhase, setRevealPhase] = useState(0); // 0: closed, 1: opening, 2: file approaching, 3: file revealed

            useEffect(() => {
                if (unlocked && revealPhase === 0) {
                    setRevealPhase(1);
                    setTimeout(() => setRevealPhase(2), 3000); // File starts appearing at 3s
                    setTimeout(() => setRevealPhase(3), 10000); // Fully revealed at 10s
                }
            }, [unlocked]);

            const handleSubmit = (e) => {
                e.preventDefault();
                setAttempts(a => a + 1);
                setShaking(true);
                setTimeout(() => setShaking(false), 500);

                const errors = [
                    'ACCESS DENIED',
                    'INVALID CREDENTIALS',
                    'AUTHENTICATION FAILED',
                    'PERMISSION DENIED',
                    'UNAUTHORIZED ACCESS',
                    'INCORRECT PASSWORD',
                    'SECURITY VIOLATION',
                    'ACCESS RESTRICTED',
                    'VERIFICATION FAILED',
                    'ENTRY PROHIBITED'
                ];
                setError(errors[Math.floor(Math.random() * errors.length)]);
                setPassword('');
            };

            // Unlocked reveal animation
            if (unlocked) {
                return (
                    <div className="h-full flex flex-col bg-white select-none overflow-hidden relative">
                        {/* Sliding panels - 10 second animation */}
                        <div
                            className="absolute top-0 left-0 right-0 bg-black z-10 flex items-end justify-center"
                            style={{
                                height: '50%',
                                transform: revealPhase >= 1 ? 'translateY(-100%)' : 'translateY(0)',
                                transition: 'transform 10s ease-in-out'
                            }}
                        >
                            <div className="font-mono text-red-500 text-xs mb-4">DECRYPTING...</div>
                        </div>
                        <div
                            className="absolute bottom-0 left-0 right-0 bg-black z-10 flex items-start justify-center"
                            style={{
                                height: '50%',
                                transform: revealPhase >= 1 ? 'translateY(100%)' : 'translateY(0)',
                                transition: 'transform 10s ease-in-out'
                            }}
                        >
                            <div className="font-mono text-red-500 text-xs mt-4">LOADING SECRETS...</div>
                        </div>

                        {/* DOG.TXT file - slowly grows and fades in */}
                        <div className="absolute inset-0 flex items-center justify-center">
                            <div
                                style={{
                                    transform: `scale(${revealPhase < 2 ? 0.2 : revealPhase < 3 ? 0.2 + ((revealPhase - 2) * 0.8) : 1})`,
                                    opacity: revealPhase < 2 ? 0 : revealPhase < 3 ? 0.3 : 1,
                                    transition: 'transform 7s ease-out, opacity 7s ease-out'
                                }}
                            >
                                <button
                                    onClick={() => onOpenDogStory?.()}
                                    className="text-center cursor-pointer group"
                                    disabled={revealPhase < 3}
                                    style={{ pointerEvents: revealPhase < 3 ? 'none' : 'auto' }}
                                >
                                    <div className="bg-white border-4 border-black p-6 group-hover:bg-yellow-50 transition-colors">
                                        <Icons.FileDoc size={64} />
                                    </div>
                                    <div className="font-mono text-black text-lg font-bold mt-4">DOG.TXT</div>
                                    <div className="font-mono text-gray-600 text-xs mt-2 group-hover:text-yellow-600" style={{ opacity: revealPhase >= 3 ? 1 : 0 }}>Click to open</div>
                                </button>
                            </div>
                        </div>
                    </div>
                );
            }

            return (
                <div className="h-full flex flex-col bg-black select-none">
                    <div className="p-2 border-b border-red-900 bg-black flex items-center gap-2">
                        <Icons.Lock size={16} />
                        <span className="font-mono text-xs font-bold text-red-500">PRIVATE.EXE</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-6">
                        <div className="mb-4">
                            <Icons.Lock size={48} />
                        </div>
                        <div className="font-mono text-red-500 text-sm font-bold mb-4">SECURE AREA</div>

                        <form onSubmit={handleSubmit} className={`w-56 ${shaking ? 'animate-shake' : ''}`}>
                            <input
                                type="password"
                                value={password}
                                onChange={(e) => setPassword(e.target.value)}
                                placeholder="PASSWORD"
                                className="w-full px-3 py-2 mb-3 bg-black border-2 border-red-800 text-red-500 font-mono text-sm placeholder-red-900 focus:outline-none focus:border-red-500"
                            />
                            <button
                                type="submit"
                                className="w-full px-3 py-2 bg-red-900 text-red-100 font-mono text-xs font-bold hover:bg-red-800 border-2 border-red-700"
                            >
                                AUTHENTICATE
                            </button>
                        </form>

                        {error && (
                            <div className="mt-4 p-2 border border-red-800 bg-red-950">
                                <div className="font-mono text-red-500 text-xs font-bold">{error}</div>
                            </div>
                        )}

                        {attempts > 0 && (
                            <div className="mt-3 font-mono text-red-800 text-[10px]">
                                FAILED: {attempts}
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // --- APPS Folder - Shows ALL apps with locked/unlocked states ---
        const AppsFolder = ({ onOpenApp, onDragStart, isMobile, unlockedApps }) => {
            const [hoveredApp, setHoveredApp] = useState(null);

            // All available apps organized by category
            const ALL_APPS = [
                // Starting apps (always unlocked)
                { id: 'TERMINAL', title: 'TERMINAL.EXE', icon: 'Terminal', category: 'CORE' },
                { id: 'THIRD_EYE', title: 'THIRD_EYE.EXE', icon: 'ThirdEye', category: 'CORE', desktopOnly: true },
                { id: 'SNAKE', title: 'SNEK.EXE', icon: 'Snek', category: 'CORE' },
                { id: 'END', title: 'ACHIEVEMENTS.EXE', icon: 'Trophy', category: 'CORE' },

                // Pool A apps (Terminal achievements)
                { id: 'PAINT', title: 'PAINT.EXE', icon: 'Palette', category: 'LOCKED', hint: 'Unlock through terminal mastery' },
                { id: 'VOID', title: 'VOID.TXT', icon: 'Void', category: 'LOCKED', hint: 'Unlock through terminal mastery' },
                { id: 'PERSONAL', title: 'PRIVATE.EXE', icon: 'Lock', category: 'LOCKED', hint: 'Unlock through terminal mastery' },
                { id: 'WORDS', title: 'WORDS.EXE', icon: 'Words', category: 'LOCKED', hint: 'Unlock through terminal mastery' },

                // Pool B apps (Game achievements)
                { id: 'LABYRINTH', title: 'LABYRINTH.EXE', icon: 'Labyrinth', category: 'LOCKED', hint: 'Unlock through games' },
                { id: 'MINESWEEPER', title: 'MINESWEEPER.EXE', icon: 'Minesweeper', category: 'LOCKED', hint: 'Unlock through games' },
                { id: 'STARSHIP', title: 'STARSHIP.EXE', icon: 'Starship', category: 'LOCKED', hint: 'Unlock through games' },
                { id: 'DICE', title: 'DICE.EXE', icon: 'Dice', category: 'LOCKED', hint: 'Unlock through games' },

                // Pool C apps (Exploration achievements)
                { id: 'RADIO', title: 'RADIO.WAV', icon: 'Radio', category: 'LOCKED', hint: 'Unlock through exploration' },
                { id: 'GALLERY', title: 'GALLERY.EXE', icon: 'Gallery', category: 'LOCKED', hint: 'Unlock through exploration' },
                { id: 'BROWSER', title: 'BROWSER.EXE', icon: 'Browser', category: 'LOCKED', hint: 'Unlock through exploration' },

                // Pool D apps (Meta achievements)
                { id: 'TAROT', title: 'TAROT.DAT', icon: 'Tarot', category: 'LOCKED', desktopOnly: true, hint: 'Unlock through meta discoveries' },
                { id: 'SYNTH', title: 'SYNTH_001.WAV', icon: 'Synth', category: 'LOCKED', desktopOnly: true, hint: 'Unlock through meta discoveries' },
                { id: 'DESTRUCTION', title: 'DESTRUCTION.EXE', icon: 'Destruction', category: 'LOCKED', hint: 'Unlock through meta discoveries' },
                { id: 'POMODORO', title: 'POMODORO.EXE', icon: 'Pomodoro', category: 'LOCKED', hint: 'Unlock through meta discoveries' },

                // Other unlockables
                { id: 'MAP', title: 'MAP.EXE', icon: 'Globe', category: 'LOCKED', hint: 'Hidden in the depths' },
                { id: 'SCANNER', title: 'SCANNER.EXE', icon: 'HealthScanner', category: 'LOCKED', hint: 'Hidden in the depths' }
            ];

            // Filter for mobile
            const visibleApps = isMobile ? ALL_APPS.filter(app => !app.desktopOnly) : ALL_APPS;

            // Count stats
            const unlockedCount = visibleApps.filter(app => unlockedApps?.has(app.id)).length;
            const totalCount = visibleApps.length;

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex items-center gap-2">
                        <Icons.Apps size={24} />
                        <span className="app-header-title">APPS</span>
                        <span className="app-footer-text ml-auto">{unlockedCount}/{totalCount} UNLOCKED</span>
                    </div>
                    <div className="flex-grow overflow-auto">
                        <div className="grid grid-cols-4 md:grid-cols-5 gap-2 p-4">
                            {visibleApps.map((app) => {
                                const AppIcon = Icons[app.icon];
                                const isUnlocked = unlockedApps?.has(app.id);
                                const isHovered = hoveredApp === app.id;

                                return (
                                    <div
                                        key={app.id}
                                        className={`relative flex flex-col items-center gap-1 p-2 border-2 transition-all cursor-pointer ${
                                            isUnlocked
                                                ? 'border-black hover:bg-yellow-100 hover:translate-y-[-2px]'
                                                : 'border-gray-300 bg-gray-100 opacity-50'
                                        }`}
                                        onClick={() => isUnlocked && onOpenApp(app.id)}
                                        onMouseEnter={() => setHoveredApp(app.id)}
                                        onMouseLeave={() => setHoveredApp(null)}
                                        draggable={isUnlocked}
                                        onDragStart={(e) => isUnlocked && onDragStart?.(e, app.id, app.title, app.icon)}
                                    >
                                        <div className={`p-2 ${isUnlocked ? '' : 'grayscale'}`}>
                                            <AppIcon size={32} />
                                        </div>
                                        <span className={`font-mono text-[8px] text-center font-bold truncate w-full ${!isUnlocked && 'text-gray-400'}`}>
                                            {isUnlocked ? app.title : '???'}
                                        </span>

                                        {/* Tooltip for locked apps */}
                                        {!isUnlocked && isHovered && app.hint && (
                                            <div className="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 px-2 py-1 bg-black text-white font-mono text-[10px] whitespace-nowrap z-50">
                                                {app.hint}
                                                <div className="absolute top-full left-1/2 -translate-x-1/2 border-4 border-transparent border-t-black" />
                                            </div>
                                        )}
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                    <div className="app-footer border-t-2 border-black p-2">
                        <span className="app-footer-text">Earn achievements to unlock apps</span>
                    </div>
                </div>
            );
        };

        // --- BROWSER - App search with autocomplete ---
        const BrowserApp = ({ onOpenApp, onAchievement, isMobile }) => {
            const [url, setUrl] = useState('');
            const [showSuggestions, setShowSuggestions] = useState(false);

            // All searchable items (apps from all categories + desktop items)
            const allItems = [
                // Desktop items
                { id: 'SYSTEM', title: 'SYSTEM_INFO', icon: 'Terminal' },
                { id: 'FILES', title: 'MEDIA_LIB', icon: 'Folder' },
                { id: 'APPS', title: 'APPS', icon: 'Apps' },
                { id: 'CONTACT', title: 'CONTACT', icon: 'Email' },
                // Games
                { id: 'SNAKE', title: 'SNEK.EXE', icon: 'Snek' },
                { id: 'LABYRINTH', title: 'LABYRINTH.EXE', icon: 'Labyrinth' },
                { id: 'MINESWEEPER', title: 'MINESWEEPER.EXE', icon: 'Minesweeper' },
                { id: 'STARSHIP', title: 'STARSHIP.EXE', icon: 'Starship' },
                { id: 'DICE', title: 'DICE.EXE', icon: 'Dice' },
                { id: 'WORDS', title: 'WORDS.EXE', icon: 'Words' },
                // Productivity
                { id: 'PAINT', title: 'PAINT.EXE', icon: 'Palette' },
                { id: 'TERMINAL', title: 'TERMINAL.EXE', icon: 'Terminal' },
                { id: 'POMODORO', title: 'POMODORO.EXE', icon: 'Pomodoro' },
                { id: 'RADIO', title: 'RADIO.WAV', icon: 'Radio' },
                { id: 'SCANNER', title: 'SCANNER.EXE', icon: 'HealthScanner' },
                { id: 'VOID', title: 'VOID.TXT', icon: 'Void' },
                { id: 'BROWSER', title: 'BROWSER.EXE', icon: 'Browser' },
                // About
                { id: 'GALLERY', title: 'GALLERY.EXE', icon: 'Gallery' },
                { id: 'MAP', title: 'MAP.EXE', icon: 'Globe' },
                { id: 'PERSONAL', title: 'PRIVATE.EXE', icon: 'Lock' },
                { id: 'DESTRUCTION', title: 'DESTRUCTION.EXE', icon: 'Destruction' },
                { id: 'TRASH', title: 'TRASH.BIN', icon: 'TrashCan' },
                { id: 'END', title: 'END.EXE', icon: 'Trophy' },
                // Desktop only
                ...(!isMobile ? [
                    { id: 'THIRD_EYE', title: 'THIRD_EYE.EXE', icon: 'ThirdEye' },
                    { id: 'SYNTH', title: 'SYNTH_001.WAV', icon: 'Synth' },
                    { id: 'TAROT', title: 'TAROT.DAT', icon: 'Tarot' }
                ] : [])
            ];

            const filteredItems = url.trim()
                ? allItems.filter(item =>
                    item.title.toLowerCase().includes(url.toLowerCase()) ||
                    item.id.toLowerCase().includes(url.toLowerCase())
                ).slice(0, 8)
                : [];

            const handleSubmit = (e) => {
                e.preventDefault();
                const normalized = url.toLowerCase().replace(/^https?:\/\//, '').replace(/\/$/, '');
                if (normalized === 'mateusmuste.com' || normalized === 'www.mateusmuste.com') {
                    onAchievement?.('INCEPTION');
                    window.location.reload();
                }
            };

            const handleSelect = (item) => {
                if (onOpenApp) onOpenApp(item.id);
                setUrl('');
                setShowSuggestions(false);
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    {/* Browser toolbar */}
                    <div className="p-2 border-b-2 border-black bg-gray-100 flex items-center gap-2">
                        <button className="p-1 border-2 border-black bg-white hover:bg-black hover:text-white" disabled>
                            <Icons.Back size={16} />
                        </button>
                        <form onSubmit={handleSubmit} className="flex-grow relative">
                            <input
                                type="text"
                                value={url}
                                onChange={(e) => { setUrl(e.target.value); setShowSuggestions(true); }}
                                onFocus={() => setShowSuggestions(true)}
                                onBlur={() => setTimeout(() => setShowSuggestions(false), 150)}
                                placeholder="Search apps or enter mateusmuste.com..."
                                className="w-full px-3 py-1 border-2 border-black font-mono text-sm focus:outline-none"
                            />
                            {showSuggestions && filteredItems.length > 0 && (
                                <div className="absolute top-full left-0 right-0 border-2 border-t-0 border-black bg-white z-50 max-h-64 overflow-y-auto">
                                    {filteredItems.map((item) => {
                                        const ItemIcon = Icons[item.icon] || Icons.FileDoc;
                                        return (
                                            <button
                                                key={item.id}
                                                onClick={() => handleSelect(item)}
                                                className="w-full px-3 py-2 flex items-center gap-2 hover:bg-black hover:text-white border-b border-gray-200 last:border-b-0"
                                            >
                                                <ItemIcon size={16} />
                                                <span className="font-mono text-xs">{item.title}</span>
                                            </button>
                                        );
                                    })}
                                </div>
                            )}
                        </form>
                    </div>
                    {/* Browser content */}
                    <div className="flex-grow flex flex-col items-center justify-center bg-gray-50 p-6">
                        <Icons.Browser size={64} />
                        <div className="font-mono text-lg font-bold mt-4 mb-2">ZEN</div>
                        <div className="font-mono text-xs text-gray-500 text-center max-w-xs">
                            Search for apps or type "mateusmuste.com" to reboot
                        </div>
                    </div>
                    <div className="app-footer">
                        <span className="app-footer-text">SEARCH  NAVIGATE  DISCOVER</span>
                    </div>
                </div>
            );
        };

        // --- WORDS - Wordle clone ---
        const WordsApp = ({ onAchievement }) => {
            const WORD_LIST = ['PIXEL', 'CODES', 'STACK', 'MOUSE', 'CLICK', 'BYTES', 'LOOPS', 'ARRAY', 'BLOCK', 'CACHE', 'DEBUG', 'FRAME', 'GRAPH', 'INPUT', 'LOGIC', 'PARSE', 'QUERY', 'SHELL', 'TABLE', 'VIRUS'];
            const [targetWord, setTargetWord] = useState(() => WORD_LIST[Math.floor(Math.random() * WORD_LIST.length)]);
            const [guesses, setGuesses] = useState([]);
            const [currentGuess, setCurrentGuess] = useState('');
            const [gameState, setGameState] = useState('playing'); // 'playing', 'won', 'lost'
            const [shake, setShake] = useState(false);
            const inputRef = useRef(null);

            const KEYBOARD_ROWS = [
                ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'],
                ['A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L'],
                ['ENTER', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', '']
            ];

            const getLetterStatus = (letter, index, word) => {
                if (word[index] === letter) return 'correct';
                if (targetWord.includes(letter)) return 'present';
                return 'absent';
            };

            const getKeyStatus = (key) => {
                let status = 'unused';
                for (const guess of guesses) {
                    for (let i = 0; i < guess.length; i++) {
                        if (guess[i] === key) {
                            const letterStatus = getLetterStatus(key, i, guess);
                            if (letterStatus === 'correct') return 'correct';
                            if (letterStatus === 'present' && status !== 'correct') status = 'present';
                            if (letterStatus === 'absent' && status === 'unused') status = 'absent';
                        }
                    }
                }
                return status;
            };

            const handleKey = (key) => {
                if (gameState !== 'playing') return;

                if (key === 'ENTER') {
                    if (currentGuess.length !== 5) {
                        setShake(true);
                        sounds.error();
                        setTimeout(() => setShake(false), 300);
                        return;
                    }
                    const newGuesses = [...guesses, currentGuess];
                    setGuesses(newGuesses);
                    if (currentGuess === targetWord) {
                        setGameState('won');
                        sounds.success();
                        onAchievement?.('FIRST_BLOOD');
                    } else if (newGuesses.length >= 6) {
                        setGameState('lost');
                        sounds.gameOver();
                    }
                    setCurrentGuess('');
                } else if (key === '') {
                    sounds.keyPress();
                    setCurrentGuess(prev => prev.slice(0, -1));
                } else if (currentGuess.length < 5 && /^[A-Z]$/.test(key)) {
                    sounds.keyPress();
                    setCurrentGuess(prev => prev + key);
                }
            };

            const resetGame = () => {
                setTargetWord(WORD_LIST[Math.floor(Math.random() * WORD_LIST.length)]);
                setGuesses([]);
                setCurrentGuess('');
                setGameState('playing');
            };

            // Keyboard handler
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.key === 'Enter') handleKey('ENTER');
                    else if (e.key === 'Backspace') handleKey('');
                    else if (/^[a-zA-Z]$/.test(e.key)) handleKey(e.key.toUpperCase());
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [currentGuess, gameState, guesses]);

            const statusColors = {
                correct: 'bg-green-500 text-white border-2 border-green-600',
                present: 'bg-yellow-400 text-white border-2 border-yellow-500',
                absent: 'bg-gray-400 text-white border-2 border-gray-500',
                empty: 'bg-white border-2 border-black',
                unused: 'bg-white border-2 border-black hover:bg-gray-100'
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="app-header">
                        <div className="flex items-center gap-2">
                            <Icons.Words size={16} />
                            <span className="app-header-title">WORDS.EXE</span>
                        </div>
                        <button onClick={() => { sounds.click(); resetGame(); }} className="btn-secondary btn-xs">
                            NEW GAME
                        </button>
                    </div>

                    {/* Game board */}
                    <div className="flex-grow flex flex-col items-center justify-center p-4 bg-gray-50">
                        <div className={`flex flex-col gap-1 ${shake ? 'animate-shake' : ''}`} style={{animation: shake ? 'shake 0.3s ease' : 'none'}}>
                            {[...Array(6)].map((_, rowIndex) => {
                                const guess = guesses[rowIndex];
                                const isCurrentRow = rowIndex === guesses.length;
                                return (
                                    <div key={rowIndex} className="flex gap-1">
                                        {[...Array(5)].map((_, colIndex) => {
                                            let letter = '';
                                            let status = 'empty';

                                            if (guess) {
                                                letter = guess[colIndex];
                                                status = getLetterStatus(letter, colIndex, guess);
                                            } else if (isCurrentRow && currentGuess[colIndex]) {
                                                letter = currentGuess[colIndex];
                                            }

                                            return (
                                                <div
                                                    key={colIndex}
                                                    className={`w-10 h-10 flex items-center justify-center font-mono text-lg font-bold ${statusColors[status]}`}
                                                >
                                                    {letter}
                                                </div>
                                            );
                                        })}
                                    </div>
                                );
                            })}
                        </div>

                        {/* Game over message */}
                        {gameState !== 'playing' && (
                            <div className="mt-4 text-center">
                                <div className="font-mono text-sm font-bold">
                                    {gameState === 'won' ? ' YOU WIN!' : `GAME OVER - WORD: ${targetWord}`}
                                </div>
                            </div>
                        )}
                    </div>

                    {/* Keyboard */}
                    <div className="p-2 bg-white border-t-2 border-black">
                        {KEYBOARD_ROWS.map((row, rowIndex) => (
                            <div key={rowIndex} className="flex justify-center gap-1 mb-1">
                                {row.map((key) => {
                                    const keyStatus = key.length === 1 ? getKeyStatus(key) : 'unused';
                                    return (
                                        <button
                                            key={key}
                                            onClick={() => handleKey(key)}
                                            className={`${key.length > 1 ? 'px-2' : 'w-7'} h-9 font-mono text-xs font-bold ${statusColors[keyStatus]}`}
                                        >
                                            {key}
                                        </button>
                                    );
                                })}
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        // --- CONTACT - Contact screen with email and direct draw option ---
        const ContactApp = ({ onOpenPaint }) => {
            const [copied, setCopied] = useState(false);
            const email = 'mateusmuste9@gmail.com';

            const copyEmail = () => {
                navigator.clipboard.writeText(email);
                sounds.copy();
                setCopied(true);
                setTimeout(() => setCopied(false), 2000);
            };

            const openDrawMessage = () => {
                sounds.click();
                onOpenPaint?.();
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="app-header">
                        <div className="flex items-center gap-2">
                            <Icons.Email size={16} />
                            <span className="app-header-title">CONTACT</span>
                        </div>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center bg-gray-50 p-6">
                        <Icons.Email size={48} />
                        <div className="font-mono text-lg font-bold mt-4 mb-1">GET IN TOUCH</div>
                        <div className="font-mono text-xs text-gray-500 mb-6">{email}</div>

                        <div className="flex flex-col gap-3 w-full max-w-xs">
                            <div className="flex gap-2">
                                <button onClick={copyEmail} className="btn-primary flex-1">
                                    {copied ? 'COPIED!' : 'COPY EMAIL'}
                                </button>
                                <a href={`mailto:${email}`} className="btn-secondary flex-1 text-center" onClick={() => sounds.click()}>
                                    OPEN MAIL
                                </a>
                            </div>

                            <div className="border-t-2 border-black my-2"></div>

                            <button onClick={openDrawMessage} className="btn-secondary w-full flex items-center justify-center gap-2">
                                <Icons.Palette size={16} />
                                DIRECT CONTACT
                            </button>
                            <div className="text-center font-mono text-[10px] text-gray-400">
                                Draw me a message instead
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- END.EXE - 100% Completion Screen ---
        const EndApp = ({ achievements }) => {
            // Full 27 achievement list for display with icons and hints
            const ACHIEVEMENTS = {
                // Pool A - Terminal
                SOCIAL_NETWORK: { name: 'SOCIAL NETWORK', icon: 'Message', hint: 'Say hi to the maker' },
                NEO: { name: 'NEO', icon: 'RainAlt', hint: 'Take the red pill' },
                LOCKSMITH: { name: 'LOCKSMITH', icon: 'Lock', hint: 'Hackers gonna hack' },
                FORBIDDEN: { name: 'FORBIDDEN', icon: 'Alert', hint: 'Curiosity kills' },
                // Pool B - Games
                OUROBOROS: { name: 'OUROBOROS', icon: 'Repeat', hint: 'A tail as old as time' },
                FIRST_BLOOD: { name: 'FIRST BLOOD', icon: 'Sword', hint: 'Everyone starts somewhere' },
                DAEDALUS: { name: 'DAEDALUS', icon: 'Labyrinth', hint: 'Lost yet?' },
                UNTOUCHABLE: { name: 'UNTOUCHABLE', icon: 'Minesweeper', hint: 'Big brain energy' },
                ACE: { name: 'ACE', icon: 'Starship', hint: 'Pew pew pew' },
                IMPOSSIBLE: { name: 'IMPOSSIBLE', icon: 'Dice', hint: 'RNGesus take the wheel' },
                // Pool C - Exploration
                DEEP_LISTENER: { name: 'DEEP LISTENER', icon: 'Music', hint: 'Good taste is earned' },
                COLLECTOR: { name: 'COLLECTOR', icon: 'Tarot', hint: 'Patience, young one' },
                VOIDBORN: { name: 'VOIDBORN', icon: 'Void', hint: 'Scream into the abyss' },
                // Pool D - Meta
                FOURTH_DIMENSION: { name: '4TH DIMENSION', icon: 'ThirdEye', hint: 'Twice the vision' },
                PHYSICS: { name: 'PHYSICS', icon: 'Expand', hint: 'Bouncy bouncy' },
                KONAMI: { name: 'KONAMI', icon: 'Controller', hint: 'Old school cool' },
                INCEPTION: { name: 'INCEPTION', icon: 'Browser', hint: 'We need to go deeper' },
                // Pool E - Time
                TIMEKEEPER: { name: 'TIMEKEEPER', icon: 'Clock', hint: 'Time flies' },
                CLICKER: { name: 'CLICKER', icon: 'Cursor', hint: 'Click. Click. Click.' },
                MASTER: { name: 'MASTER', icon: 'Pomodoro', hint: 'Grow your garden' },
                TYCOON: { name: 'TYCOON', icon: 'Globe', hint: 'Money printer go brrr' },
                ASCENDED: { name: 'ASCENDED', icon: 'Dog', hint: 'Who let the dog out?' },
                // Pool F - Dark
                YOU_MONSTER: { name: 'YOU MONSTER', icon: 'Skull', hint: 'How could you' },
                JOHN_WICK: { name: 'JOHN WICK', icon: 'Fire', hint: 'Baba Yaga approves' },
                OVERKILL: { name: 'OVERKILL', icon: 'Bomb', hint: 'Therapy recommended' },
                // Special
                CENTURY: { name: 'CENTURY', icon: 'Badge', hint: 'Commitment issues' },
                HUNDRED_PERCENT: { name: '100%', icon: 'Trophy', hint: 'You did it!' }
            };

            const unlockedCount = Object.keys(achievements).length;
            const totalCount = Object.keys(ACHIEVEMENTS).length;
            const has100Percent = achievements.HUNDRED_PERCENT;

            return (
                <div className="h-full flex flex-col bg-black text-white select-none font-mono overflow-auto">
                    {/* Header */}
                    <div className="p-4 border-b border-white/20 text-center">
                        <div className="text-2xl font-bold mb-2 flex items-center justify-center gap-2">
                            {has100Percent && <Icons.Trophy size={24} className="invert" />}
                            {has100Percent ? '100% COMPLETE' : 'ACHIEVEMENT LOG'}
                            {has100Percent && <Icons.Trophy size={24} className="invert" />}
                        </div>
                        <div className="text-sm text-gray-400">
                            {unlockedCount} / {totalCount} ACHIEVEMENTS
                        </div>
                    </div>

                    {/* Achievement list */}
                    <div className="flex-grow p-4 space-y-2 overflow-auto">
                        {Object.entries(ACHIEVEMENTS).map(([id, ach]) => {
                            const unlocked = achievements[id];
                            const IconCmp = Icons[ach.icon] || Icons.Badge;
                            return (
                                <div
                                    key={id}
                                    className={`p-2 border ${unlocked ? 'border-white bg-white/10' : 'border-gray-700 opacity-50'}`}
                                >
                                    <div className="flex items-center gap-2">
                                        <div className={`w-6 h-6 flex items-center justify-center ${unlocked ? '' : 'opacity-30'}`}>
                                            <IconCmp size={20} className="invert" />
                                        </div>
                                        <span className={`font-bold ${unlocked ? '' : 'text-gray-500'}`}>
                                            {ach.name}
                                        </span>
                                    </div>
                                    <div className={`text-xs ml-8 ${unlocked ? 'text-gray-300' : 'text-gray-600'}`}>
                                        {ach.hint}
                                    </div>
                                </div>
                            );
                        })}
                    </div>

                    {/* Footer */}
                    {has100Percent && (
                        <div className="p-4 border-t border-white/20 text-center">
                            <div className="text-sm text-gray-400">THANK YOU FOR PLAYING</div>
                            <div className="text-xs text-gray-600 mt-1"> MATEUS MUSTE </div>
                        </div>
                    )}
                </div>
            );
        };

        // Binary/Code Background for ASCII mode (defined outside OS to prevent re-mount on re-render)
        const BinaryBackground = React.memo(() => {
            const canvasRef = useRef(null);
            useEffect(() => {
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                const chars = '01{}[]()<>;:=/\\|_-+*&^%$#@!?.~`';
                const fontSize = 12;
                const columns = Math.floor(canvas.width / fontSize);
                const drops = Array(columns).fill(0).map(() => Math.random() * -100);

                const draw = () => {
                    ctx.fillStyle = 'rgba(240, 240, 240, 0.03)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.font = fontSize + "px 'Mondwest', sans-serif";

                    for (let i = 0; i < drops.length; i++) {
                        const char = chars[Math.floor(Math.random() * chars.length)];
                        const alpha = 0.08 + Math.random() * 0.08;
                        ctx.fillStyle = `rgba(0, 0, 0, ${alpha})`;
                        ctx.fillText(char, i * fontSize, drops[i] * fontSize);
                        if (drops[i] * fontSize > canvas.height && Math.random() > 0.98) {
                            drops[i] = 0;
                        }
                        drops[i] += 0.3 + Math.random() * 0.2;
                    }
                };

                // Initial fill
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const interval = setInterval(draw, 80);
                const handleResize = () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                    ctx.fillStyle = '#f0f0f0';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                };
                window.addEventListener('resize', handleResize);
                return () => {
                    clearInterval(interval);
                    window.removeEventListener('resize', handleResize);
                };
            }, []);
            return <canvas ref={canvasRef} style={{ position: 'fixed', top: 0, left: 0, width: '100%', height: '100%', zIndex: 0, pointerEvents: 'none' }} />;
        });

        // --- OS SHELL ---

        const OS = () => {
            const [booted, setBooted] = useState(false);
            const [bootPhase, setBootPhase] = useState(0); // 0: mobile notice (mobile only), 1: kernel, 2: ready
            const [isMobile, setIsMobile] = useState(false);
            const [introComplete, setIntroComplete] = useState(() => localStorage.getItem('intro_complete') === 'true');
            const [revealingApps, setRevealingApps] = useState(false);
            const [revealedApps, setRevealedApps] = useState([]);
            const [paintShowHint, setPaintShowHint] = useState(false);
            const [isMuted, setIsMuted] = useState(() => localStorage.getItem('sound_muted') === 'true');
            const handleToggleMute = () => setIsMuted(toggleMute());
            const [topZ, setTopZ] = useState(100);
            const topZRef = useRef(100);
            const [destructionMode, setDestructionMode] = useState(false);
            const [dogReleased, setDogReleased] = useState(false);
            const [dogPos, setDogPos] = useState({ x: 100, y: 300 });
            const [dogFacingRight, setDogFacingRight] = useState(true);
            const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
            const [carriedIcon, setCarriedIcon] = useState(null);
            const [iconPositions, setIconPositions] = useState(() => {
                // Initialize desktop icon positions in a column on the left
                const stored = localStorage.getItem('desktop_icon_positions');
                if (stored) {
                    try { return JSON.parse(stored); } catch { }
                }
                const mobile = window.innerWidth < 768;
                const iconSize = 80;
                const padding = 8;
                const topOffset = mobile ? 56 : 16; // Account for mobile taskbar at top
                return {
                    MESSAGES: { x: padding, y: topOffset },
                    ABOUT: { x: padding, y: topOffset },
                    SYSTEM: { x: padding, y: topOffset },
                    FILES: { x: padding, y: topOffset + iconSize },
                    APPS: { x: padding, y: topOffset + iconSize * 2 },
                    CONTACT: { x: padding, y: topOffset + iconSize * 3 },
                    TRUTH: { x: padding, y: topOffset + iconSize * 4 },
                    TRASH: { x: Math.min(window.innerWidth - 100, padding), y: Math.min(window.innerHeight - 120, topOffset + iconSize * 5) }
                };
            });
            const [iconDrag, setIconDrag] = useState({ id: null, offsetX: 0, offsetY: 0, active: false });
            const [selectedIcon, setSelectedIcon] = useState(null);
            const lastIconClick = useRef({ id: null, time: 0 });
            const iconPhysics = useRef({});
            const lastIconMousePos = useRef({ x: 0, y: 0, time: Date.now() });
            const iconHoldTimer = useRef(null);
            const iconPendingDrag = useRef(null); // Stores pending drag info before hold completes

            // Snap icon position to grid (80px grid)
            const snapToGrid = (x, y) => {
                const gridSize = 80;
                return {
                    x: Math.round(x / gridSize) * gridSize + 8,
                    y: Math.max(16, Math.round(y / gridSize) * gridSize)
                };
            };
            const [folderDrag, setFolderDrag] = useState(null); // { id, title, icon, startX, startY }
            const [extraDesktopIcons, setExtraDesktopIcons] = useState(() => {
                const stored = localStorage.getItem('extra_desktop_icons');
                return stored ? JSON.parse(stored) : [];
            });
            const [destructionDogGone, setDestructionDogGone] = useState(false);
            const [matrixMode, setMatrixMode] = useState(false);
            const [thirdEyeWorld, setThirdEyeWorld] = useState(false);
            const [privateUnlocked, setPrivateUnlocked] = useState(false);
            const [desktopBg, setDesktopBg] = useState(() => localStorage.getItem('desktop_bg') || 'grid');
            const [contextMenu, setContextMenu] = useState({ show: false, x: 0, y: 0 });
            const [windowAnimations, setWindowAnimations] = useState({}); // { windowId: 'opening' | 'closing' }
            const [stackOverflow, setStackOverflow] = useState(false);
            const [stackErrors, setStackErrors] = useState([]);
            const [pyramidScreen, setPyramidScreen] = useState(false);
            const stackTimerRef = useRef(null);
            const errorIntervalRef = useRef(null);
            const [goldDogReleased, setGoldDogReleased] = useState(false);
            const [goldDogVisible, setGoldDogVisible] = useState(true);
            const [goldDogPos, setGoldDogPos] = useState({ x: 200, y: 200 });
            const [goldDogFacingRight, setGoldDogFacingRight] = useState(false);
            const goldDogVelRef = useRef({ x: -3, y: 4 });
            const [visitCount, setVisitCount] = useState(() => {
                const stored = localStorage.getItem('ultra_int_visits');
                const count = stored ? parseInt(stored, 10) + 1 : 1;
                localStorage.setItem('ultra_int_visits', count.toString());
                return count;
            });
            const truthUnlocked = visitCount >= 100;

            // Achievement system - 27 total achievements organized by pools
            const ACHIEVEMENTS = {
                // Pool A - Terminal (unlocks: PAINT, VOID, PRIVATE, WORDS)
                SOCIAL_NETWORK: { name: 'SOCIAL NETWORK', icon: 'Message', hint: 'Say hi to the maker', pool: 'A', visible: true },
                NEO: { name: 'NEO', icon: 'RainAlt', hint: 'Take the red pill', pool: 'A', visible: true },
                LOCKSMITH: { name: 'LOCKSMITH', icon: 'Lock', hint: 'Hackers gonna hack', pool: 'A', visible: true },
                FORBIDDEN: { name: 'FORBIDDEN', icon: 'Alert', hint: 'Curiosity kills', pool: 'A', visible: true },

                // Pool B - Games (unlocks: LABYRINTH, MINESWEEPER, STARSHIP, DICE)
                OUROBOROS: { name: 'OUROBOROS', icon: 'Repeat', hint: 'A tail as old as time', pool: 'B', visible: true },
                FIRST_BLOOD: { name: 'FIRST BLOOD', icon: 'Sword', hint: 'Everyone starts somewhere', pool: 'B', visible: true },
                DAEDALUS: { name: 'DAEDALUS', icon: 'Labyrinth', hint: 'Lost yet?', pool: 'B', requiresApp: 'LABYRINTH' },
                UNTOUCHABLE: { name: 'UNTOUCHABLE', icon: 'Minesweeper', hint: 'Big brain energy', pool: 'B', requiresApp: 'MINESWEEPER' },
                ACE: { name: 'ACE', icon: 'Starship', hint: 'Pew pew pew', pool: 'B', requiresApp: 'STARSHIP' },
                IMPOSSIBLE: { name: 'IMPOSSIBLE', icon: 'Dice', hint: 'RNGesus take the wheel', pool: 'B', requiresApp: 'DICE' },

                // Pool C - Exploration (unlocks: RADIO, GALLERY, BROWSER)
                DEEP_LISTENER: { name: 'DEEP LISTENER', icon: 'Music', hint: 'Good taste is earned', pool: 'C', visible: true },
                COLLECTOR: { name: 'COLLECTOR', icon: 'Tarot', hint: 'Patience, young one', pool: 'C', requiresApp: 'TAROT' },
                VOIDBORN: { name: 'VOIDBORN', icon: 'Void', hint: 'Scream into the abyss', pool: 'C', requiresApp: 'VOID' },

                // Pool D - Meta (unlocks: TAROT, SYNTH, DESTRUCTION, POMODORO)
                FOURTH_DIMENSION: { name: '4TH DIMENSION', icon: 'ThirdEye', hint: 'Twice the vision', pool: 'D', visible: true },
                PHYSICS: { name: 'PHYSICS', icon: 'Expand', hint: 'Bouncy bouncy', pool: 'D', visible: true },
                KONAMI: { name: 'KONAMI', icon: 'Controller', hint: 'Old school cool', pool: 'D', visible: true },
                INCEPTION: { name: 'INCEPTION', icon: 'Browser', hint: 'We need to go deeper', pool: 'D', requiresApp: 'BROWSER' },

                // Pool E - Time (bragging rights only)
                TIMEKEEPER: { name: 'TIMEKEEPER', icon: 'Clock', hint: 'Time flies', pool: 'E', visible: true },
                CLICKER: { name: 'CLICKER', icon: 'Cursor', hint: 'Click. Click. Click.', pool: 'E', visible: true },
                MASTER: { name: 'MASTER', icon: 'Pomodoro', hint: 'Grow your garden', pool: 'E', requiresApp: 'POMODORO' },
                TYCOON: { name: 'TYCOON', icon: 'Globe', hint: 'Money printer go brrr', pool: 'E', requiresApp: 'MAP' },
                ASCENDED: { name: 'ASCENDED', icon: 'Dog', hint: 'Who let the dog out?', pool: 'E', visible: true },

                // Pool F - Dark (shame only)
                YOU_MONSTER: { name: 'YOU MONSTER', icon: 'Skull', hint: 'How could you', pool: 'F', visible: true },
                JOHN_WICK: { name: 'JOHN WICK', icon: 'Fire', hint: 'Baba Yaga approves', pool: 'F', chain: 'YOU_MONSTER' },
                OVERKILL: { name: 'OVERKILL', icon: 'Bomb', hint: 'Therapy recommended', pool: 'F', chain: 'JOHN_WICK' },

                // Special (mysterious placeholders)
                CENTURY: { name: 'CENTURY', icon: 'Badge', hint: 'Commitment issues', pool: 'SPECIAL', mysterious: true },
                HUNDRED_PERCENT: { name: '100%', icon: 'Trophy', hint: 'You did it!', pool: 'SPECIAL', mysterious: true }
            };

            // Pool-based app unlock system
            const APP_POOLS = {
                A: ['PAINT', 'VOID', 'PERSONAL', 'WORDS'],           // Terminal achievements
                B: ['LABYRINTH', 'MINESWEEPER', 'STARSHIP', 'DICE'], // Game achievements
                C: ['RADIO', 'GALLERY', 'BROWSER'],                   // Exploration achievements
                D: ['TAROT', 'SYNTH', 'DESTRUCTION', 'POMODORO'],    // Meta achievements
                E: ['MAP'],                                           // Time achievements
                F: ['SCANNER']                                        // Dark achievements
            };

            // Track which apps have been unlocked from each pool (persisted)
            const [poolUnlocks, setPoolUnlocks] = useState(() => {
                const stored = localStorage.getItem('ultra_int_pool_unlocks');
                if (stored) {
                    const parsed = JSON.parse(stored);
                    // Ensure E and F exist for backwards compatibility
                    return { A: [], B: [], C: [], D: [], E: [], F: [], ...parsed };
                }
                return { A: [], B: [], C: [], D: [], E: [], F: [] };
            });

            // Save pool unlocks to localStorage
            useEffect(() => {
                localStorage.setItem('ultra_int_pool_unlocks', JSON.stringify(poolUnlocks));
            }, [poolUnlocks]);

            // Get a random app from a pool that hasn't been unlocked yet
            // Falls back to other pools if the specified pool is exhausted
            const getRandomAppFromPool = (pool) => {
                // First try the specified pool
                const available = APP_POOLS[pool]?.filter(app => !poolUnlocks[pool]?.includes(app)) || [];
                if (available.length > 0) {
                    return { app: available[Math.floor(Math.random() * available.length)], pool };
                }

                // Fallback: try other pools in order
                const fallbackOrder = ['A', 'B', 'C', 'D', 'E', 'F'].filter(p => p !== pool);
                for (const fallbackPool of fallbackOrder) {
                    const fallbackAvailable = APP_POOLS[fallbackPool]?.filter(app => !poolUnlocks[fallbackPool]?.includes(app)) || [];
                    if (fallbackAvailable.length > 0) {
                        return { app: fallbackAvailable[Math.floor(Math.random() * fallbackAvailable.length)], pool: fallbackPool };
                    }
                }

                return null;
            };

            const [achievements, setAchievements] = useState(() => {
                const stored = localStorage.getItem('ultra_int_achievements');
                return stored ? JSON.parse(stored) : {};
            });
            const [achievementNotifications, setAchievementNotifications] = useState([]);

            // App progression system - pool-based unlocks
            // Starting apps: TERMINAL, THIRD_EYE, SNEK, ACHIEVEMENTS.EXE + desktop icons
            const INITIAL_APPS = ['TERMINAL', 'THIRD_EYE', 'SNAKE', 'ABOUT', 'SYSTEM', 'FILES', 'APPS', 'CONTACT', 'TRASH', 'END', 'MESSAGES'];

            // Special unlocks (not pool-based)
            const SPECIAL_UNLOCKS = {
                CENTURY: ['TRUTH'],      // 100 visits unlocks TRUTH.TXT
                HUNDRED_PERCENT: []      // 100% doesn't unlock apps, just END.EXE content
            };

            // Get all unlocked apps (initial + pool unlocks + special)
            const getUnlockedApps = () => {
                const unlocked = new Set(INITIAL_APPS);

                // Add all apps from pool unlocks
                Object.values(poolUnlocks).forEach(apps => {
                    apps.forEach(app => unlocked.add(app));
                });

                // Add special unlocks
                Object.entries(SPECIAL_UNLOCKS).forEach(([achievement, apps]) => {
                    if (achievements[achievement]) {
                        apps.forEach(app => unlocked.add(app));
                    }
                });

                // TRUTH unlocks at 100 visits
                if (truthUnlocked) unlocked.add('TRUTH');

                return unlocked;
            };
            const unlockedApps = getUnlockedApps();

            // Track total unlocked app count for milestones
            const unlockedAppCount = unlockedApps.size;
            const [dogTrashCount, setDogTrashCount] = useState(() => {
                const stored = localStorage.getItem('dog_trash_count');
                return stored ? parseInt(stored, 10) : 0;
            });
            const [dogDragging, setDogDragging] = useState(false);
            const [dogDragOffset, setDogDragOffset] = useState({ x: 0, y: 0 });
            const dogHoldTimer = useRef(null);
            const [hasCompletedGame, setHasCompletedGame] = useState(() => {
                return localStorage.getItem('ultra_int_completed') === 'true';
            });

            // Time tracking for TIMEKEEPER achievement (5 minutes)
            const startTimeRef = useRef(Date.now());
            const [totalClicks, setTotalClicks] = useState(() => {
                const stored = localStorage.getItem('ultra_int_clicks');
                return stored ? parseInt(stored, 10) : 0;
            });

            // Save achievements to localStorage
            useEffect(() => {
                localStorage.setItem('ultra_int_achievements', JSON.stringify(achievements));
            }, [achievements]);

            // Save clicks to localStorage
            useEffect(() => {
                localStorage.setItem('ultra_int_clicks', totalClicks.toString());
            }, [totalClicks]);

            // Time tracking for TIMEKEEPER (5 minutes = 300000ms)
            useEffect(() => {
                const checkTime = setInterval(() => {
                    const elapsed = Date.now() - startTimeRef.current;
                    if (elapsed >= 300000 && !achievements.TIMEKEEPER) {
                        unlockAchievement('TIMEKEEPER');
                    }
                }, 30000); // Check every 30 seconds
                return () => clearInterval(checkTime);
            }, [achievements]);

            // Global click handler for CLICKER achievement
            useEffect(() => {
                const handleClick = () => {
                    setTotalClicks(prev => {
                        const newCount = prev + 1;
                        if (newCount >= 100 && !achievements.CLICKER) {
                            setTimeout(() => unlockAchievement('CLICKER'), 100);
                        }
                        return newCount;
                    });
                };
                document.addEventListener('click', handleClick);
                return () => document.removeEventListener('click', handleClick);
            }, [achievements]);

            // Check for 100% completion
            const achievementCount = Object.keys(achievements).filter(k => k !== 'HUNDRED_PERCENT').length;
            const totalAchievements = Object.keys(ACHIEVEMENTS).length - 1; // Exclude 100% itself
            const hasAllAchievements = achievementCount >= totalAchievements;

            // State for newly unlocked app notifications (array for stacking)
            const [appUnlockNotifications, setAppUnlockNotifications] = useState([]);

            // Unlock achievement function with pool-based app unlocking
            const unlockAchievement = (id) => {
                if (achievements[id]) return; // Already unlocked
                const achievement = ACHIEVEMENTS[id];
                if (!achievement) return;

                const notifId = Date.now() + Math.random();

                // Mark achievement as unlocked
                setAchievements(prev => ({ ...prev, [id]: { unlockedAt: Date.now() } }));
                setAchievementNotifications(prev => [...prev, { ...achievement, id: notifId }]);
                sounds.success();

                // Try to unlock an app - use achievement's pool or fallback to any available pool
                const pool = achievement.pool;
                // Only try to unlock apps for non-SPECIAL pools
                if (pool && pool !== 'SPECIAL') {
                    const result = getRandomAppFromPool(pool);
                    if (result) {
                        const { app: newApp, pool: actualPool } = result;
                        // Add the app to the actual pool's unlocks
                        setPoolUnlocks(prev => ({
                            ...prev,
                            [actualPool]: [...(prev[actualPool] || []), newApp]
                        }));
                        // Show app unlock notification immediately stacked below achievement
                        const appNotifId = Date.now() + Math.random() + 1;
                        setTimeout(() => {
                            setAppUnlockNotifications(prev => [...prev, { app: newApp, id: appNotifId }]);
                            sounds.success();
                            setTimeout(() => {
                                setAppUnlockNotifications(prev => prev.filter(n => n.id !== appNotifId));
                            }, 3000);
                        }, 500); // Small delay so they stack nicely
                    }
                }

                // Auto-hide achievement notification after 3 seconds
                setTimeout(() => {
                    setAchievementNotifications(prev => prev.filter(n => n.id !== notifId));
                }, 3000);

                // Check for 100% after unlocking
                if (id !== 'HUNDRED_PERCENT') {
                    const newCount = achievementCount + 1;
                    if (newCount >= totalAchievements && !achievements.HUNDRED_PERCENT) {
                        setTimeout(() => unlockAchievement('HUNDRED_PERCENT'), 5000);
                    }
                }
            };

            // God mode - unlock all achievements and apps instantly
            const handleGodMode = () => {
                // Unlock all achievements
                const allAchievements = {};
                Object.keys(ACHIEVEMENTS).forEach(id => {
                    allAchievements[id] = { unlockedAt: Date.now() };
                });
                setAchievements(allAchievements);

                // Unlock all apps from all pools
                const allPoolUnlocks = {};
                Object.keys(APP_POOLS).forEach(pool => {
                    allPoolUnlocks[pool] = [...APP_POOLS[pool]];
                });
                setPoolUnlocks(allPoolUnlocks);

                // Show a single notification
                const godNotifId = Date.now();
                setAchievementNotifications([{ id: godNotifId, name: 'GOD MODE', hint: 'All achievements and apps unlocked' }]);
                sounds.success();
                setTimeout(() => {
                    setAchievementNotifications(prev => prev.filter(n => n.id !== godNotifId));
                }, 3000);
            };

            // Check century achievement on mount
            useEffect(() => {
                if (visitCount >= 100 && !achievements.CENTURY) {
                    setTimeout(() => unlockAchievement('CENTURY'), 2000);
                }
            }, []);

            // Battery status
            const [battery, setBattery] = useState({ level: null, charging: false });

            // Total visitors counter (using CountAPI)
            const [totalVisitors, setTotalVisitors] = useState(null);

            // Fetch and increment total visitors
            useEffect(() => {
                fetch('https://api.countapi.xyz/hit/mateusmuste-com/visits')
                    .then(res => res.json())
                    .then(data => setTotalVisitors(data.value))
                    .catch(() => {
                        // Fallback to localStorage estimate
                        const stored = parseInt(localStorage.getItem('visitor_estimate') || '340', 10);
                        const newCount = stored + Math.floor(Math.random() * 3);
                        localStorage.setItem('visitor_estimate', newCount.toString());
                        setTotalVisitors(newCount);
                    });
            }, []);

            // Battery API
            useEffect(() => {
                if ('getBattery' in navigator) {
                    navigator.getBattery().then(batt => {
                        const updateBattery = () => setBattery({ level: Math.round(batt.level * 100), charging: batt.charging });
                        updateBattery();
                        batt.addEventListener('levelchange', updateBattery);
                        batt.addEventListener('chargingchange', updateBattery);
                        return () => {
                            batt.removeEventListener('levelchange', updateBattery);
                            batt.removeEventListener('chargingchange', updateBattery);
                        };
                    });
                }
            }, []);

            const toggleMatrixMode = () => {
                setMatrixMode(prev => {
                    if (!prev) unlockAchievement('NEO');
                    return !prev;
                });
            };

            const activateThirdEyeWorld = () => {
                setThirdEyeWorld(true);
                unlockAchievement('KONAMI');
            };
            const unlockPrivate = () => {
                setPrivateUnlocked(true);
                unlockAchievement('LOCKSMITH');
            };
            const openDogStory = () => {
                setDogReleased(true);
                setGoldDogReleased(true);
                setWindows(prev => ({
                    ...prev,
                    DOG_STORY: { ...prev.DOG_STORY, isOpen: true }
                }));
            };
            const removeGoldDog = () => setGoldDogVisible(false);

            // Handle dog stealing the destruction button - dog starts running around!
            const handleDogSteal = () => {
                setDestructionDogGone(true);
                setDogReleased(true); // Dog starts running around the screen
                // Close the destruction window
                setWindows(prev => ({
                    ...prev,
                    DESTRUCTION: { ...prev.DESTRUCTION, isOpen: false }
                }));
            };

            // Dog AI - DVD logo style bouncing (uses refs to avoid stale closures)
            const dogVelRef = useRef({ x: 4, y: 3 });

            useEffect(() => {
                if (!dogReleased || dogDragging) return;

                const dogInterval = setInterval(() => {
                    const vel = dogVelRef.current;

                    setDogPos(prev => {
                        let newX = prev.x + vel.x;
                        let newY = prev.y + vel.y;

                        // Bounce off walls - DVD style
                        if (newX >= window.innerWidth - 80) {
                            newX = window.innerWidth - 80;
                            dogVelRef.current.x = -Math.abs(vel.x);
                            setDogFacingRight(false);
                        }
                        if (newX <= 0) {
                            newX = 0;
                            dogVelRef.current.x = Math.abs(vel.x);
                            setDogFacingRight(true);
                        }
                        if (newY >= window.innerHeight - 100) {
                            newY = window.innerHeight - 100;
                            dogVelRef.current.y = -Math.abs(vel.y);
                        }
                        if (newY <= 60) {
                            newY = 60;
                            dogVelRef.current.y = Math.abs(vel.y);
                        }

                        return { x: newX, y: newY };
                    });

                    // Randomly grab icons
                    if (!carriedIcon && Math.random() < 0.003) {
                        const iconKeys = Object.keys(windows);
                        const randomIcon = iconKeys[Math.floor(Math.random() * iconKeys.length)];
                        setCarriedIcon(randomIcon);

                        setTimeout(() => {
                            setCarriedIcon(null);
                        }, 3000 + Math.random() * 4000);
                    }
                }, 30);

                return () => clearInterval(dogInterval);
            }, [dogReleased]);

            // Gold dog bouncing logic
            useEffect(() => {
                if (!goldDogReleased || !goldDogVisible) return;

                const goldDogInterval = setInterval(() => {
                    setGoldDogPos(prev => {
                        const vel = goldDogVelRef.current;
                        let newX = prev.x + vel.x;
                        let newY = prev.y + vel.y;

                        if (newX >= window.innerWidth - 80) {
                            newX = window.innerWidth - 80;
                            goldDogVelRef.current.x = -Math.abs(vel.x);
                            setGoldDogFacingRight(false);
                        }
                        if (newX <= 0) {
                            newX = 0;
                            goldDogVelRef.current.x = Math.abs(vel.x);
                            setGoldDogFacingRight(true);
                        }
                        if (newY >= window.innerHeight - 100) {
                            newY = window.innerHeight - 100;
                            goldDogVelRef.current.y = -Math.abs(vel.y);
                        }
                        if (newY <= 60) {
                            newY = 60;
                            goldDogVelRef.current.y = Math.abs(vel.y);
                        }

                        return { x: newX, y: newY };
                    });
                }, 30);

                return () => clearInterval(goldDogInterval);
            }, [goldDogReleased, goldDogVisible]);

            // Dog dragging handlers
            const handleDogMouseDown = (e) => {
                e.preventDefault();
                e.stopPropagation();
                const offsetX = e.clientX - dogPos.x;
                const offsetY = e.clientY - dogPos.y;

                // Start hold timer - need to hold for 300ms to start dragging
                dogHoldTimer.current = setTimeout(() => {
                    setDogDragging(true);
                    setDogDragOffset({ x: offsetX, y: offsetY });
                }, 300);
            };

            const handleDogMouseUp = (e) => {
                if (dogHoldTimer.current) {
                    clearTimeout(dogHoldTimer.current);
                    dogHoldTimer.current = null;
                }

                if (dogDragging) {
                    setDogDragging(false);

                    // Check if dropped on trash
                    const trashPos = iconPositions.TRASH || { x: window.innerWidth - 110, y: window.innerHeight - 140 };
                    const trashLeft = trashPos.x;
                    const trashTop = trashPos.y;
                    const trashRight = trashLeft + 96; // ~w-24 = 96px
                    const trashBottom = trashTop + 80;

                    if (dogPos.x >= trashLeft - 30 && dogPos.x <= trashRight + 30 &&
                        dogPos.y >= trashTop - 30 && dogPos.y <= trashBottom + 30) {
                        // Dog was dropped on trash!
                        sounds.error();
                        setDogReleased(false);

                        // Update trash count
                        const newCount = dogTrashCount + 1;
                        setDogTrashCount(newCount);
                        localStorage.setItem('dog_trash_count', newCount.toString());

                        // Trigger achievements
                        if (newCount >= 1 && !achievements.YOU_MONSTER) {
                            setTimeout(() => unlockAchievement('YOU_MONSTER'), 500);
                        }
                        if (newCount >= 3 && !achievements.JOHN_WICK) {
                            setTimeout(() => unlockAchievement('JOHN_WICK'), 500);
                        }
                        if (newCount >= 10 && !achievements.OVERKILL) {
                            setTimeout(() => unlockAchievement('OVERKILL'), 500);
                        }
                    }
                } else {
                    // Quick click - just bark and stop
                    sounds.bark();
                    setDogReleased(false);
                }
            };

            // Global mouse move for dog dragging
            useEffect(() => {
                if (!dogDragging) return;

                const handleMouseMove = (e) => {
                    setDogPos({
                        x: e.clientX - dogDragOffset.x,
                        y: e.clientY - dogDragOffset.y
                    });
                };

                const handleMouseUp = (e) => {
                    handleDogMouseUp(e);
                };

                window.addEventListener('mousemove', handleMouseMove);
                window.addEventListener('mouseup', handleMouseUp);

                return () => {
                    window.removeEventListener('mousemove', handleMouseMove);
                    window.removeEventListener('mouseup', handleMouseUp);
                };
            }, [dogDragging, dogDragOffset]);

            // Desktop icons - MESSAGES only if intro not complete, otherwise full desktop
            const allDesktopIcons = truthUnlocked
                ? ["ABOUT", "APPS", "FILES", "CONTACT", "TRUTH", "TRASH"]
                : ["ABOUT", "APPS", "FILES", "CONTACT", "TRASH"];

            // If intro not complete, show only MESSAGES. If revealing, show progressively revealed apps
            const desktopIcons = !introComplete
                ? (revealingApps ? ["MESSAGES", ...revealedApps] : ["MESSAGES"])
                : allDesktopIcons;

            // Window State (Position x/y added for dragging) - content rendered separately
            const [windows, setWindows] = useState({
                "MESSAGES": { id: "MESSAGES", title: "MESSAGES.EXE", icon: "Email", x: 200, y: 80, w: '380px', h: '500px', isOpen: false, isMin: false, z: 8, isDesktop: true },
                "ABOUT": { id: "ABOUT", title: "ABOUT.EXE", icon: "Terminal", x: 150, y: 50, w: '700px', h: '700px', isOpen: false, isMin: false, z: 9, isDesktop: true },
                "SYSTEM": { id: "SYSTEM", title: "SYSTEM_INFO", icon: "Terminal", x: 400, y: 50, w: '1000px', h: '800px', isOpen: true, isMin: false, z: 10, isDesktop: true },
                "FILES": { id: "FILES", title: "MEDIA_LIB", icon: "Folder", x: 100, y: 80, w: '800px', h: '500px', isOpen: false, isMin: false, z: 11, isDesktop: true },
                "APPS": { id: "APPS", title: "APPS", icon: "Apps", x: 150, y: 110, w: '700px', h: '500px', isOpen: false, isMin: false, z: 12, isDesktop: true },
                "CONTACT": { id: "CONTACT", title: "CONTACT", icon: "Email", x: 200, y: 140, w: '320px', h: '220px', isOpen: false, isMin: false, z: 13, isDesktop: true },
                "PAINT": { id: "PAINT", title: "PAINT.EXE", icon: "Palette", x: 150, y: 110, w: '700px', h: '600px', isOpen: false, isMin: false, z: 14 },
                "SNAKE": { id: "SNAKE", title: "SNEK.EXE", icon: "Snek", x: 200, y: 140, w: '640px', h: '520px', isOpen: false, isMin: false, z: 15 },
                "TRASH": { id: "TRASH", title: "TRASH.BIN", icon: "TrashCan", x: 250, y: 170, w: '500px', h: '400px', isOpen: false, isMin: false, z: 16 },
                "VOID": { id: "VOID", title: "VOID.TXT", icon: "Void", x: 300, y: 50, w: '500px', h: '400px', isOpen: false, isMin: false, z: 17 },
                "RADIO": { id: "RADIO", title: "RADIO.WAV", icon: "Radio", x: 400, y: 110, w: '400px', h: '400px', isOpen: false, isMin: false, z: 19 },
                "DICE": { id: "DICE", title: "DICE.EXE", icon: "Dice", x: 450, y: 140, w: '350px', h: '450px', isOpen: false, isMin: false, z: 20 },
                "LABYRINTH": { id: "LABYRINTH", title: "LABYRINTH.EXE", icon: "Labyrinth", x: 100, y: 50, w: '600px', h: '500px', isOpen: false, isMin: false, z: 21 },
                "MINESWEEPER": { id: "MINESWEEPER", title: "MINESWEEPER.EXE", icon: "Minesweeper", x: 120, y: 40, w: '500px', h: '560px', isOpen: false, isMin: false, z: 26 },
                "STARSHIP": { id: "STARSHIP", title: "STARSHIP.EXE", icon: "Starship", x: 80, y: 40, w: '540px', h: '480px', isOpen: false, isMin: false, z: 27 },
                "SYNTH": { id: "SYNTH", title: "SYNTH_001.WAV", icon: "Synth", x: 150, y: 80, w: '500px', h: '350px', isOpen: false, isMin: false, z: 22 },
                "DESTRUCTION": { id: "DESTRUCTION", title: "DESTRUCTION.EXE", icon: "Destruction", x: 200, y: 110, w: '400px', h: '400px', isOpen: false, isMin: false, z: 23 },
                "TAROT": { id: "TAROT", title: "TAROT.DAT", icon: "Tarot", x: 100, y: 60, w: '520px', h: '550px', isOpen: false, isMin: false, z: 24 },
                "GALLERY": { id: "GALLERY", title: "GALLERY.EXE", icon: "Gallery", x: 100, y: 80, w: '500px', h: '500px', isOpen: false, isMin: false, z: 28 },
                "MAP": { id: "MAP", title: "MAP.EXE", icon: "Globe", x: 150, y: 100, w: '360px', h: '400px', isOpen: false, isMin: false, z: 29 },
                "POMODORO": { id: "POMODORO", title: "POMODORO.EXE", icon: "Pomodoro", x: 200, y: 60, w: '350px', h: '620px', isOpen: false, isMin: false, z: 30 },
                "SCANNER": { id: "SCANNER", title: "SCANNER.EXE", icon: "HealthScanner", x: 150, y: 50, w: '600px', h: '700px', isOpen: false, isMin: false, z: 31 },
                "PERSONAL": { id: "PERSONAL", title: "PRIVATE.EXE", icon: "Lock", x: 200, y: 80, w: '320px', h: '340px', isOpen: false, isMin: false, z: 32 },
                "TERMINAL": { id: "TERMINAL", title: "TERMINAL.EXE", icon: "Terminal", x: 120, y: 100, w: '500px', h: '400px', isOpen: false, isMin: false, z: 33 },
                "TRUTH": { id: "TRUTH", title: "TRUTH.TXT", icon: "FileDoc", x: 180, y: 120, w: '320px', h: '380px', isOpen: false, isMin: false, z: 34, isDesktop: true },
                "DOG_STORY": { id: "DOG_STORY", title: "DOG.TXT", icon: "FileDoc", x: 100, y: 80, w: '600px', h: '500px', isOpen: false, isMin: false, z: 35 },
                "THIRD_EYE": { id: "THIRD_EYE", title: "THIRD_EYE.EXE", icon: "ThirdEye", x: 140, y: 90, w: '450px', h: '400px', isOpen: false, isMin: false, z: 36 },
                "THIRD_EYE_2": { id: "THIRD_EYE_2", title: "THIRD_EYE.EXE", icon: "ThirdEye", x: 200, y: 150, w: '450px', h: '400px', isOpen: false, isMin: false, z: 37 },
                "BROWSER": { id: "BROWSER", title: "BROWSER.EXE", icon: "Browser", x: 160, y: 70, w: '500px', h: '400px', isOpen: false, isMin: false, z: 38 },
                "WORDS": { id: "WORDS", title: "WORDS.EXE", icon: "Words", x: 180, y: 90, w: '320px', h: '520px', isOpen: false, isMin: false, z: 39 },
                "END": { id: "END", title: "END.EXE", icon: "Trophy", x: 200, y: 100, w: '400px', h: '350px', isOpen: false, isMin: false, z: 40 }
            });

            // Handle intro complete - hide messages, reveal apps one by one, then open ABOUT
            const introCompleteCalledRef = useRef(false);
            const handleIntroComplete = () => {
                // Guard against multiple calls
                if (introCompleteCalledRef.current) return;
                introCompleteCalledRef.current = true;

                localStorage.setItem('intro_complete', 'true');

                // Hide messages.exe first before revealing apps
                close('MESSAGES');
                setRevealingApps(true);

                // Reveal apps one by one with 200ms delay
                const appsToReveal = ["ABOUT", "APPS", "FILES", "CONTACT", "TRASH"];
                appsToReveal.forEach((appId, index) => {
                    setTimeout(() => {
                        setRevealedApps(prev => [...prev, appId]);
                        sounds.ping();
                    }, index * 200);
                });

                // After all apps revealed + 500ms, open ABOUT and complete intro
                setTimeout(() => {
                    setIntroComplete(true);
                    setRevealingApps(false);
                    setRevealedApps([]);
                    open('ABOUT');
                }, appsToReveal.length * 200 + 500);
            };

            // Render window content based on ID
            const getWindowContent = (id) => {
                switch (id) {
                    case "MESSAGES": return <MessagesApp onIntroComplete={handleIntroComplete} />;
                    case "ABOUT": return <AboutApp />;
                    case "SYSTEM": return <SystemInfo onThirdEyeWorld={activateThirdEyeWorld} totalVisitors={totalVisitors} />;
                    case "FILES": return <FileExplorer onAchievement={unlockAchievement} />;
                    case "APPS": return <AppsFolder onOpenApp={open} onDragStart={handleFolderDragStart} isMobile={isMobile} unlockedApps={unlockedApps} />;
                    case "CONTACT": return <ContactApp onOpenPaint={() => { setPaintShowHint(true); open('PAINT'); close('CONTACT'); }} />;
                    case "PAINT": return <PaintApp showHint={paintShowHint} />;
                    case "SNAKE": return <SnakeAppNew onAchievement={unlockAchievement} />;
                    case "TRASH": return <TrashApp />;
                    case "VOID": return <VoidApp onAchievement={unlockAchievement} />;
                    case "RADIO": return <RadioApp />;
                    case "DICE": return <DiceApp onAchievement={unlockAchievement} />;
                    case "LABYRINTH": return <LabyrinthApp onAchievement={unlockAchievement} />;
                    case "MINESWEEPER": return <MinesweeperApp onAchievement={unlockAchievement} />;
                    case "STARSHIP": return <StarshipApp onAchievement={unlockAchievement} />;
                    case "SYNTH": return <SynthApp />;
                    case "DESTRUCTION": return <DestructionApp onDogSteal={handleDogSteal} />;
                    case "TAROT": return <TarotApp onAchievement={unlockAchievement} />;
                    case "GALLERY": return <GalleryApp />;
                    case "MAP": return <MapApp onAchievement={unlockAchievement} />;
                    case "POMODORO": return <PomodoroApp onAchievement={unlockAchievement} />;
                    case "SCANNER": return <HealthScannerApp />;
                    case "PERSONAL": return <PersonalApp unlocked={privateUnlocked} onOpenDogStory={openDogStory} />;
                    case "TERMINAL": return <TerminalApp onClose={close} onOpenApp={open} onReleaseDog={() => setDogReleased(true)} onMatrixMode={toggleMatrixMode} onUnlockPrivate={unlockPrivate} onAchievement={unlockAchievement} onGodMode={handleGodMode} />;
                    case "TRUTH": return <TruthApp onAchievement={unlockAchievement} />;
                    case "DOG_STORY": return <DogStoryTerminal onRemoveGoldDog={removeGoldDog} />;
                    case "THIRD_EYE": return <ThirdEyeApp windowId="THIRD_EYE" windows={windows} stackOverflow={stackOverflow} stackErrors={stackErrors} iconPositions={iconPositions} />;
                    case "THIRD_EYE_2": return <ThirdEyeApp windowId="THIRD_EYE_2" windows={windows} stackOverflow={stackOverflow} stackErrors={stackErrors} iconPositions={iconPositions} />;
                    case "BROWSER": return <BrowserApp onOpenApp={open} onAchievement={unlockAchievement} isMobile={isMobile} />;
                    case "WORDS": return <WordsApp onAchievement={unlockAchievement} />;
                    case "END": return <EndApp achievements={achievements} />;
                    default: return null;
                }
            };

            // Dragging State with Physics
            const [drag, setDrag] = useState({ id: null, offsetX: 0, offsetY: 0 });
            const lastMousePos = useRef({ x: 0, y: 0, time: Date.now() });
            const windowPhysics = useRef({}); // { windowId: { velX, velY, scaleX, scaleY } }
            const windowBounces = useRef({}); // { windowId: { left: bool, right: bool, top: bool, bottom: bool } }
            const physicsAchievementUnlocked = useRef(false);

            // Physics constants
            const FRICTION = 0.94; // Velocity decay per frame (2x faster momentum)
            const BOUNCE_DAMPING = 0.6; // Energy loss on bounce (more bounce)
            const MIN_VELOCITY = 0.25; // Stop threshold (reduced for smoother stops)
            const EDGE_MAGNET_DISTANCE = 30; // Pixels for edge attraction
            const EDGE_MAGNET_STRENGTH = 0.15; // Pull strength
            const SQUASH_AMOUNT = 0.02; // 2% max squash/stretch

            // Initialize physics for a window
            const initWindowPhysics = (id) => {
                if (!windowPhysics.current[id]) {
                    windowPhysics.current[id] = { velX: 0, velY: 0, scaleX: 1, scaleY: 1 };
                }
                return windowPhysics.current[id];
            };

            // Physics loop
            useEffect(() => {
                let animationId;
                const physicsLoop = () => {
                    setWindows(prev => {
                        let updated = { ...prev };
                        let hasChanges = false;

                        Object.keys(prev).forEach(id => {
                            const win = prev[id];
                            if (!win.isOpen || win.isMin) return;

                            const physics = initWindowPhysics(id);

                            // Skip if being dragged
                            if (drag.id === id) return;

                            // Skip if no significant velocity
                            if (Math.abs(physics.velX) < MIN_VELOCITY && Math.abs(physics.velY) < MIN_VELOCITY) {
                                physics.velX = 0;
                                physics.velY = 0;
                                // Decay squash/stretch back to normal
                                physics.scaleX += (1 - physics.scaleX) * 0.2;
                                physics.scaleY += (1 - physics.scaleY) * 0.2;
                                return;
                            }

                            hasChanges = true;

                            // Apply friction
                            physics.velX *= FRICTION;
                            physics.velY *= FRICTION;

                            // Calculate new position
                            let newX = win.x + physics.velX;
                            let newY = win.y + physics.velY;

                            const winWidth = parseInt(win.w) || 400;
                            const winHeight = parseInt(win.h) || 300;
                            const maxX = window.innerWidth - winWidth;
                            const maxY = window.innerHeight - 60 - winHeight; // Account for taskbar
                            const minY = isMobile ? 60 : 0; // Account for mobile top taskbar

                            // Edge magnetism (only when slow enough)
                            const totalVel = Math.sqrt(physics.velX ** 2 + physics.velY ** 2);
                            if (totalVel < 5) {
                                // Left edge
                                if (newX < EDGE_MAGNET_DISTANCE && newX > 0) {
                                    physics.velX -= newX * EDGE_MAGNET_STRENGTH;
                                }
                                // Right edge
                                if (newX > maxX - EDGE_MAGNET_DISTANCE && newX < maxX) {
                                    physics.velX += (maxX - newX) * EDGE_MAGNET_STRENGTH;
                                }
                                // Top edge
                                if (newY < minY + EDGE_MAGNET_DISTANCE && newY > minY) {
                                    physics.velY -= (newY - minY) * EDGE_MAGNET_STRENGTH;
                                }
                                // Bottom edge
                                if (newY > maxY - EDGE_MAGNET_DISTANCE && newY < maxY) {
                                    physics.velY += (maxY - newY) * EDGE_MAGNET_STRENGTH;
                                }
                            }

                            // Bounce off edges with squash/stretch
                            // Track bounces for PHYSICS achievement
                            if (!windowBounces.current[id]) {
                                windowBounces.current[id] = { left: false, right: false, top: false, bottom: false };
                            }
                            const bounces = windowBounces.current[id];

                            if (newX <= 0) {
                                newX = 0;
                                physics.velX = -physics.velX * BOUNCE_DAMPING;
                                physics.scaleX = 1 - SQUASH_AMOUNT * Math.min(Math.abs(physics.velX) / 10, 1);
                                physics.scaleY = 1 + SQUASH_AMOUNT * Math.min(Math.abs(physics.velX) / 10, 1);
                                sounds.bounce(Math.abs(physics.velX));
                                bounces.left = true;
                            } else if (newX >= maxX) {
                                newX = maxX;
                                physics.velX = -physics.velX * BOUNCE_DAMPING;
                                physics.scaleX = 1 - SQUASH_AMOUNT * Math.min(Math.abs(physics.velX) / 10, 1);
                                physics.scaleY = 1 + SQUASH_AMOUNT * Math.min(Math.abs(physics.velX) / 10, 1);
                                sounds.bounce(Math.abs(physics.velX));
                                bounces.right = true;
                            }

                            if (newY <= minY) {
                                newY = minY;
                                physics.velY = -physics.velY * BOUNCE_DAMPING;
                                physics.scaleY = 1 - SQUASH_AMOUNT * Math.min(Math.abs(physics.velY) / 10, 1);
                                physics.scaleX = 1 + SQUASH_AMOUNT * Math.min(Math.abs(physics.velY) / 10, 1);
                                sounds.bounce(Math.abs(physics.velY));
                                bounces.top = true;
                            } else if (newY >= maxY) {
                                newY = maxY;
                                physics.velY = -physics.velY * BOUNCE_DAMPING;
                                physics.scaleY = 1 - SQUASH_AMOUNT * Math.min(Math.abs(physics.velY) / 10, 1);
                                physics.scaleX = 1 + SQUASH_AMOUNT * Math.min(Math.abs(physics.velY) / 10, 1);
                                sounds.bounce(Math.abs(physics.velY));
                                bounces.bottom = true;
                            }

                            // Check for PHYSICS achievement (all 4 edges in one throw)
                            if (bounces.left && bounces.right && bounces.top && bounces.bottom && !physicsAchievementUnlocked.current) {
                                physicsAchievementUnlocked.current = true;
                                unlockAchievement('PHYSICS');
                            }

                            // Decay squash/stretch back to normal
                            physics.scaleX += (1 - physics.scaleX) * 0.3;
                            physics.scaleY += (1 - physics.scaleY) * 0.3;

                            updated[id] = { ...win, x: newX, y: newY };
                        });

                        return hasChanges ? updated : prev;
                    });

                    animationId = requestAnimationFrame(physicsLoop);
                };

                animationId = requestAnimationFrame(physicsLoop);
                return () => cancelAnimationFrame(animationId);
            }, [drag.id, isMobile]);

            // Boot sequence with mobile detection
            useEffect(() => {
                const checkMobile = window.innerWidth < 768 || /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                setIsMobile(checkMobile);

                // Close SYSTEM window on mobile by default
                if (checkMobile) {
                    setWindows(prev => ({
                        ...prev,
                        SYSTEM: { ...prev.SYSTEM, isOpen: false }
                    }));
                }

                // Preload all pixelarticons during boot
                const iconNames = [
                    'monitor', 'folder', 'fill', 'gamepad', 'trash', 'undo', 'redo', 'file',
                    'close', 'minus', 'checkbox', 'send', 'movie', 'book', 'music', 'arrow-left',
                    'code', 'book-open', 'radio-on', 'dice', 'layout-rows', 'table', 'arrow-up',
                    'keyboard', 'power', 'card', 'paw', 'mail', 'add-grid', 'image', 'map',
                    'clock', 'heart', 'lock', 'sliders', 'user'
                ];
                iconNames.forEach(name => {
                    const img = new Image();
                    img.src = `https://unpkg.com/pixelarticons@1.8.1/svg/${name}.svg`;
                });

                const isFirstEver = !localStorage.getItem('intro_complete');

                if (checkMobile) {
                    // Mobile: Show "best on desktop" notice first, then kernel boot
                    setBootPhase(0);
                    setTimeout(() => {
                        setBootPhase(1); // kernel boot
                        setTimeout(() => {
                            setBootPhase(2);
                            setBooted(true);
                        }, 2000);
                    }, 2000);
                } else {
                    // Desktop: Always show boot animation
                    setBootPhase(1);
                    // Close SYSTEM on boot
                    setWindows(prev => ({
                        ...prev,
                        SYSTEM: { ...prev.SYSTEM, isOpen: false }
                    }));
                    setTimeout(() => {
                        setBootPhase(2);
                        setBooted(true);
                    }, 2000);
                }

                // Handle resize
                const handleResize = () => {
                    setIsMobile(window.innerWidth < 768);
                };
                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, []);

            // Reposition icons that are off-screen on mobile
            useEffect(() => {
                if (isMobile) {
                    const maxX = window.innerWidth - 80;
                    const maxY = window.innerHeight - 96;
                    const minY = 56;
                    setIconPositions(prev => {
                        const updated = { ...prev };
                        let needsUpdate = false;
                        Object.keys(prev).forEach(id => {
                            const pos = prev[id];
                            if (pos.x > maxX || pos.y > maxY || pos.y < minY) {
                                needsUpdate = true;
                                updated[id] = {
                                    x: Math.max(8, Math.min(maxX, pos.x)),
                                    y: Math.max(minY, Math.min(maxY, pos.y))
                                };
                            }
                        });
                        return needsUpdate ? updated : prev;
                    });
                }
            }, [isMobile]);

            // Window Ops
            const focus = (id) => {
                topZRef.current += 1;
                const newZ = topZRef.current;
                setWindows(p => ({ ...p, [id]: { ...p[id], z: newZ } }));
                setTopZ(newZ);
            }
            const open = (id) => {
                sounds.windowOpen();
                topZRef.current += 1;
                const newZ = topZRef.current;
                // THIRD_EYE can open multiple copies
                let targetId = id;
                if (id === 'THIRD_EYE') {
                    setWindows(p => {
                        if (p.THIRD_EYE.isOpen && !p.THIRD_EYE.isMin) {
                            targetId = 'THIRD_EYE_2';
                            return { ...p, THIRD_EYE_2: { ...p.THIRD_EYE_2, isOpen: true, isMin: false, z: newZ } };
                        }
                        return { ...p, THIRD_EYE: { ...p.THIRD_EYE, isOpen: true, isMin: false, z: newZ } };
                    });
                } else {
                    setWindows(p => ({ ...p, [id]: { ...p[id], isOpen: true, isMin: false, z: newZ } }));
                }
                // Trigger opening animation
                setWindowAnimations(p => ({ ...p, [targetId]: 'opening' }));
                setTimeout(() => setWindowAnimations(p => { const n = {...p}; delete n[targetId]; return n; }), 200);
                setTopZ(newZ);
            }
            const close = (id) => {
                sounds.windowClose();
                // Trigger closing animation
                setWindowAnimations(p => ({ ...p, [id]: 'closing' }));
                setTimeout(() => {
                    setWindows(p => ({ ...p, [id]: { ...p[id], isOpen: false } }));
                    setWindowAnimations(p => { const n = {...p}; delete n[id]; return n; });
                }, 150);
            };
            const toggleMin = (id) => setWindows(p => ({ ...p, [id]: { ...p[id], isMin: !p[id].isMin } }));

            // Drag Handlers with velocity tracking
            const handleMouseDown = (e, id) => {
                e.preventDefault();
                focus(id);
                const win = windows[id];
                const physics = initWindowPhysics(id);
                // Stop any existing velocity
                physics.velX = 0;
                physics.velY = 0;
                // Reset bounce tracking for PHYSICS achievement
                windowBounces.current[id] = { left: false, right: false, top: false, bottom: false };
                lastMousePos.current = { x: e.clientX, y: e.clientY, time: Date.now() };
                setDrag({
                    id: id,
                    offsetX: e.clientX - win.x,
                    offsetY: e.clientY - win.y
                });
            };

            const handleMouseMove = (e) => {
                if (drag.id) {
                    const now = Date.now();
                    const dt = Math.max(1, now - lastMousePos.current.time);
                    const physics = initWindowPhysics(drag.id);

                    // Calculate velocity from mouse movement (2x speed)
                    const rawVelX = (e.clientX - lastMousePos.current.x) / dt * 8;
                    const rawVelY = (e.clientY - lastMousePos.current.y) / dt * 8;
                    physics.velX = physics.velX * 0.5 + rawVelX * 0.5;
                    physics.velY = physics.velY * 0.5 + rawVelY * 0.5;

                    lastMousePos.current = { x: e.clientX, y: e.clientY, time: now };

                    setWindows(prev => {
                        const win = prev[drag.id];
                        const winWidth = parseInt(win.w) || 400;
                        const winHeight = parseInt(win.h) || 300;
                        const maxX = window.innerWidth - winWidth;
                        const maxY = window.innerHeight - 60 - winHeight; // Account for taskbar
                        const minY = isMobile ? 60 : 0;

                        // Clamp position to screen bounds
                        const newX = Math.max(0, Math.min(maxX, e.clientX - drag.offsetX));
                        const newY = Math.max(minY, Math.min(maxY, e.clientY - drag.offsetY));

                        return {
                            ...prev,
                            [drag.id]: {
                                ...win,
                                x: newX,
                                y: newY
                            }
                        };
                    });
                }
            };

            const handleMouseUp = () => {
                // Keep velocity for physics, just release the drag
                setDrag({ id: null, offsetX: 0, offsetY: 0 });
            };

            // Touch handlers for window dragging (mobile)
            const handleWindowTouchStart = (e, id) => {
                if (e.touches.length !== 1) return;
                // On mobile, windows are fixed fullscreen - no dragging
                if (isMobile) {
                    focus(id);
                    return;
                }
                const touch = e.touches[0];
                focus(id);
                const win = windows[id];
                const physics = initWindowPhysics(id);
                physics.velX = 0;
                physics.velY = 0;
                windowBounces.current[id] = { left: false, right: false, top: false, bottom: false };
                lastMousePos.current = { x: touch.clientX, y: touch.clientY, time: Date.now() };
                setDrag({
                    id: id,
                    offsetX: touch.clientX - win.x,
                    offsetY: touch.clientY - win.y
                });
            };

            const handleWindowTouchMove = (e) => {
                if (!drag.id || e.touches.length !== 1) return;
                e.preventDefault();
                const touch = e.touches[0];
                const now = Date.now();
                const dt = Math.max(1, now - lastMousePos.current.time);
                const physics = initWindowPhysics(drag.id);

                const rawVelX = (touch.clientX - lastMousePos.current.x) / dt * 8;
                const rawVelY = (touch.clientY - lastMousePos.current.y) / dt * 8;
                physics.velX = physics.velX * 0.5 + rawVelX * 0.5;
                physics.velY = physics.velY * 0.5 + rawVelY * 0.5;

                lastMousePos.current = { x: touch.clientX, y: touch.clientY, time: now };

                setWindows(prev => {
                    const win = prev[drag.id];
                    const winWidth = parseInt(win.w) || 400;
                    const winHeight = parseInt(win.h) || 300;
                    const maxX = window.innerWidth - winWidth;
                    const maxY = window.innerHeight - 60 - winHeight;
                    const minY = isMobile ? 60 : 0;

                    const newX = Math.max(0, Math.min(maxX, touch.clientX - drag.offsetX));
                    const newY = Math.max(minY, Math.min(maxY, touch.clientY - drag.offsetY));

                    return {
                        ...prev,
                        [drag.id]: { ...win, x: newX, y: newY }
                    };
                });
            };

            const handleWindowTouchEnd = () => {
                setDrag({ id: null, offsetX: 0, offsetY: 0 });
            };

            // === ICON PHYSICS AND DRAG HANDLERS ===
            const ICON_SIZE = 80; // Approximate icon size for collision
            const ICON_SPACING = 10; // Minimum spacing between icons

            const initIconPhysics = (id) => {
                if (!iconPhysics.current[id]) {
                    iconPhysics.current[id] = { velX: 0, velY: 0 };
                }
                return iconPhysics.current[id];
            };

            // Check if position collides with other icons
            const checkIconCollision = (id, x, y, positions) => {
                for (const otherId in positions) {
                    if (otherId === id) continue;
                    const other = positions[otherId];
                    const dx = Math.abs(x - other.x);
                    const dy = Math.abs(y - other.y);
                    if (dx < ICON_SIZE + ICON_SPACING && dy < ICON_SIZE + ICON_SPACING) {
                        return otherId; // Return colliding icon id
                    }
                }
                return null;
            };

            // Find nearest non-colliding position
            const findNonCollidingPosition = (id, x, y, positions) => {
                if (!checkIconCollision(id, x, y, positions)) return { x, y };

                // Spiral outward to find free spot
                for (let radius = ICON_SIZE; radius < 500; radius += ICON_SIZE / 2) {
                    for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                        const testX = x + Math.cos(angle) * radius;
                        const testY = y + Math.sin(angle) * radius;
                        if (!checkIconCollision(id, testX, testY, positions)) {
                            return { x: testX, y: testY };
                        }
                    }
                }
                return { x, y }; // Fallback
            };

            const handleIconMouseDown = (e, id) => {
                e.preventDefault();
                e.stopPropagation();
                const pos = iconPositions[id] || { x: 0, y: 0 };
                const physics = initIconPhysics(id);
                physics.velX = 0;
                physics.velY = 0;
                lastIconMousePos.current = { x: e.clientX, y: e.clientY, time: Date.now() };

                // Store pending drag info
                iconPendingDrag.current = {
                    id: id,
                    offsetX: e.clientX - pos.x,
                    offsetY: e.clientY - pos.y,
                    startX: e.clientX,
                    startY: e.clientY
                };

                // Start hold timer - drag only activates after 0.1 seconds
                iconHoldTimer.current = setTimeout(() => {
                    if (iconPendingDrag.current) {
                        sounds.dragStart();
                        setIconDrag({
                            id: iconPendingDrag.current.id,
                            offsetX: iconPendingDrag.current.offsetX,
                            offsetY: iconPendingDrag.current.offsetY,
                            active: true
                        });
                    }
                }, 100);
            };

            const handleIconMouseMove = (e) => {
                if (iconDrag.active && iconDrag.id) {
                    const now = Date.now();
                    const dt = Math.max(1, now - lastIconMousePos.current.time);
                    const physics = initIconPhysics(iconDrag.id);

                    const rawVelX = (e.clientX - lastIconMousePos.current.x) / dt * 8;
                    const rawVelY = (e.clientY - lastIconMousePos.current.y) / dt * 8;
                    physics.velX = physics.velX * 0.3 + rawVelX * 0.7;
                    physics.velY = physics.velY * 0.3 + rawVelY * 0.7;

                    lastIconMousePos.current = { x: e.clientX, y: e.clientY, time: now };

                    // Constrain to screen bounds
                    const maxX = window.innerWidth - ICON_SIZE;
                    const maxY = window.innerHeight - ICON_SIZE - 16;
                    const minY = isMobile ? 56 : 0; // Account for mobile taskbar at top

                    const newX = Math.max(0, Math.min(maxX, e.clientX - iconDrag.offsetX));
                    const newY = Math.max(minY, Math.min(maxY, e.clientY - iconDrag.offsetY));

                    setIconPositions(prev => ({
                        ...prev,
                        [iconDrag.id]: { x: newX, y: newY }
                    }));
                }
            };

            const handleIconMouseUp = (openCallback) => {
                // Clear hold timer
                if (iconHoldTimer.current) {
                    clearTimeout(iconHoldTimer.current);
                    iconHoldTimer.current = null;
                }

                // If drag was active, finalize position with grid snap
                if (iconDrag.active && iconDrag.id) {
                    sounds.dragStop();
                    setIconPositions(prev => {
                        const current = prev[iconDrag.id];
                        if (!current) return prev;
                        const snapped = snapToGrid(current.x, current.y);
                        const adjusted = findNonCollidingPosition(iconDrag.id, snapped.x, snapped.y, prev);
                        const newPositions = { ...prev, [iconDrag.id]: adjusted };
                        localStorage.setItem('desktop_icon_positions', JSON.stringify(newPositions));
                        return newPositions;
                    });
                } else if (iconPendingDrag.current) {
                    // Drag wasn't active - this was a click - open app immediately
                    const id = iconPendingDrag.current.id;
                    if (openCallback) openCallback(id);
                    setSelectedIcon(null);
                }

                iconPendingDrag.current = null;
                setIconDrag({ id: null, offsetX: 0, offsetY: 0, active: false });
            };

            // Touch handlers for icon dragging (mobile)
            const handleIconTouchStart = (e, id) => {
                if (e.touches.length !== 1) return;
                e.preventDefault();
                e.stopPropagation();
                const touch = e.touches[0];
                const pos = iconPositions[id] || { x: 0, y: 0 };
                const physics = initIconPhysics(id);
                physics.velX = 0;
                physics.velY = 0;
                lastIconMousePos.current = { x: touch.clientX, y: touch.clientY, time: Date.now() };

                iconPendingDrag.current = {
                    id: id,
                    offsetX: touch.clientX - pos.x,
                    offsetY: touch.clientY - pos.y,
                    startX: touch.clientX,
                    startY: touch.clientY
                };

                iconHoldTimer.current = setTimeout(() => {
                    if (iconPendingDrag.current) {
                        sounds.dragStart();
                        setIconDrag({
                            id: iconPendingDrag.current.id,
                            offsetX: iconPendingDrag.current.offsetX,
                            offsetY: iconPendingDrag.current.offsetY,
                            active: true
                        });
                    }
                }, 150); // Slightly longer for touch
            };

            const handleIconTouchMove = (e) => {
                if (!iconDrag.active || !iconDrag.id || e.touches.length !== 1) return;
                e.preventDefault();
                const touch = e.touches[0];
                const now = Date.now();
                const dt = Math.max(1, now - lastIconMousePos.current.time);
                const physics = initIconPhysics(iconDrag.id);

                const rawVelX = (touch.clientX - lastIconMousePos.current.x) / dt * 8;
                const rawVelY = (touch.clientY - lastIconMousePos.current.y) / dt * 8;
                physics.velX = physics.velX * 0.3 + rawVelX * 0.7;
                physics.velY = physics.velY * 0.3 + rawVelY * 0.7;

                lastIconMousePos.current = { x: touch.clientX, y: touch.clientY, time: now };

                const maxX = window.innerWidth - ICON_SIZE;
                const maxY = window.innerHeight - ICON_SIZE - 16;
                const minY = isMobile ? 56 : 0; // Account for mobile taskbar at top

                const newX = Math.max(0, Math.min(maxX, touch.clientX - iconDrag.offsetX));
                const newY = Math.max(minY, Math.min(maxY, touch.clientY - iconDrag.offsetY));

                setIconPositions(prev => ({
                    ...prev,
                    [iconDrag.id]: { x: newX, y: newY }
                }));
            };

            const handleIconTouchEnd = (openCallback) => {
                if (iconHoldTimer.current) {
                    clearTimeout(iconHoldTimer.current);
                    iconHoldTimer.current = null;
                }

                if (iconDrag.active && iconDrag.id) {
                    sounds.dragStop();
                    setIconPositions(prev => {
                        const current = prev[iconDrag.id];
                        if (!current) return prev;
                        const adjusted = findNonCollidingPosition(iconDrag.id, current.x, current.y, prev);
                        const newPositions = { ...prev, [iconDrag.id]: adjusted };
                        localStorage.setItem('desktop_icon_positions', JSON.stringify(newPositions));
                        return newPositions;
                    });
                } else if (iconPendingDrag.current) {
                    const id = iconPendingDrag.current.id;
                    if (openCallback) openCallback(id);
                }

                iconPendingDrag.current = null;
                setIconDrag({ id: null, offsetX: 0, offsetY: 0, active: false });
            };

            // Folder item drag to desktop handlers
            const handleFolderDragStart = (e, id, title, icon) => {
                e.dataTransfer.effectAllowed = 'copy';
                e.dataTransfer.setData('text/plain', JSON.stringify({ id, title, icon }));
                setFolderDrag({ id, title, icon, startX: e.clientX, startY: e.clientY });
            };

            const handleDesktopDrop = (e) => {
                e.preventDefault();
                if (!folderDrag) return;

                const { id, title, icon } = folderDrag;
                const dropX = e.clientX - 40; // Center icon on cursor
                const dropY = e.clientY - 40;

                // Check if already on desktop
                if (!iconPositions[id] && !extraDesktopIcons.includes(id)) {
                    // Add to extra desktop icons
                    const newExtras = [...extraDesktopIcons, id];
                    setExtraDesktopIcons(newExtras);
                    localStorage.setItem('extra_desktop_icons', JSON.stringify(newExtras));

                    // Set position
                    const adjustedPos = findNonCollidingPosition(id, dropX, dropY, iconPositions);
                    setIconPositions(prev => {
                        const newPositions = { ...prev, [id]: adjustedPos };
                        localStorage.setItem('desktop_icon_positions', JSON.stringify(newPositions));
                        return newPositions;
                    });
                }
                setFolderDrag(null);
            };

            const handleDesktopDragOver = (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
            };

            // Icon physics loop (reduced motion compared to windows)
            const ICON_FRICTION = 0.96; // 2x faster icon momentum
            const ICON_MIN_VELOCITY = MIN_VELOCITY / 2; // Half of window threshold

            useEffect(() => {
                let animationId;
                const iconPhysicsLoop = () => {
                    setIconPositions(prev => {
                        let updated = { ...prev };
                        let hasChanges = false;

                        Object.keys(prev).forEach(id => {
                            const physics = initIconPhysics(id);
                            if (iconDrag.active && iconDrag.id === id) return;
                            if (Math.abs(physics.velX) < ICON_MIN_VELOCITY && Math.abs(physics.velY) < ICON_MIN_VELOCITY) {
                                physics.velX = 0;
                                physics.velY = 0;
                                return;
                            }

                            hasChanges = true;
                            physics.velX *= ICON_FRICTION;
                            physics.velY *= ICON_FRICTION;

                            let newX = prev[id].x + physics.velX;
                            let newY = prev[id].y + physics.velY;

                            const maxX = window.innerWidth - ICON_SIZE;
                            const maxY = window.innerHeight - ICON_SIZE - 16;
                            const minY = isMobile ? 56 : 0;

                            // Constrain to screen bounds
                            if (newX <= 0) { newX = 0; physics.velX = -physics.velX * BOUNCE_DAMPING; sounds.bounceIcon(Math.abs(physics.velX)); }
                            else if (newX >= maxX) { newX = maxX; physics.velX = -physics.velX * BOUNCE_DAMPING; sounds.bounceIcon(Math.abs(physics.velX)); }
                            if (newY <= minY) { newY = minY; physics.velY = -physics.velY * BOUNCE_DAMPING; sounds.bounceIcon(Math.abs(physics.velY)); }
                            else if (newY >= maxY) { newY = maxY; physics.velY = -physics.velY * BOUNCE_DAMPING; sounds.bounceIcon(Math.abs(physics.velY)); }

                            // Bounce off other icons
                            const collider = checkIconCollision(id, newX, newY, updated);
                            if (collider) {
                                const other = updated[collider];
                                const dx = newX - other.x;
                                const dy = newY - other.y;
                                const len = Math.sqrt(dx * dx + dy * dy) || 1;
                                physics.velX = (dx / len) * Math.abs(physics.velX) * BOUNCE_DAMPING;
                                physics.velY = (dy / len) * Math.abs(physics.velY) * BOUNCE_DAMPING;
                                sounds.bounceIcon(Math.max(Math.abs(physics.velX), Math.abs(physics.velY)));
                                newX = prev[id].x;
                                newY = prev[id].y;
                            }

                            updated[id] = { x: newX, y: newY };
                        });

                        if (hasChanges) {
                            localStorage.setItem('desktop_icon_positions', JSON.stringify(updated));
                        }
                        return hasChanges ? updated : prev;
                    });
                    animationId = requestAnimationFrame(iconPhysicsLoop);
                };
                animationId = requestAnimationFrame(iconPhysicsLoop);
                return () => cancelAnimationFrame(animationId);
            }, [iconDrag.active, iconDrag.id, isMobile]);

            // THIRD_EYE stack detection - checks if two windows overlap OR thirdEyeWorld mode + any ThirdEye open
            useEffect(() => {
                const eye1 = windows.THIRD_EYE;
                const eye2 = windows.THIRD_EYE_2;

                // In thirdEyeWorld mode, opening ANY ThirdEye triggers stack overflow
                if (thirdEyeWorld && (eye1.isOpen || eye2.isOpen)) {
                    if (!stackOverflow) {
                        setStackOverflow(true);
                        unlockAchievement('FOURTH_DIMENSION');
                        // Start the same crash sequence
                        const errors = [
                            'FATAL: observer inside observer detected',
                            'ERR: infinite recursion in reality.render()',
                            'PANIC: dimension stack exceeded',
                            'SEGFAULT at 0xEYEEYEEYE',
                            'kernel: reality paradox imminent',
                            'sudo rm -rf /existence/*',
                            'CRITICAL: consciousness buffer overflow',
                            'malloc(): observer top size corrupted',
                            'ERR: cannot observe from within',
                            'kill -9 reality',
                        ];
                        let errorIndex = 0;
                        errorIntervalRef.current = setInterval(() => {
                            const err = errors[errorIndex % errors.length];
                            setStackErrors(prev => [...prev.slice(-20), err]);
                            errorIndex++;
                        }, 30);

                        // 90% chance per second to crash
                        stackTimerRef.current = setInterval(() => {
                            if (Math.random() < 0.9) {
                                if (errorIntervalRef.current) clearInterval(errorIntervalRef.current);
                                clearInterval(stackTimerRef.current);
                                const crashScreen = document.createElement('div');
                                crashScreen.style.cssText = 'position:fixed;inset:0;z-index:99999;background:#000;display:flex;flex-direction:column;align-items:center;justify-content:center;font-family:'Mondwest',sans-serif;color:#0f0;overflow:auto;';
                                crashScreen.innerHTML = `
                                    <pre style="font-size:6px;line-height:1.1;color:#0f0;text-shadow:0 0 5px #0f0;white-space:pre;">
                                              
                                             
                                            
                                           
                                          
                                         
                                        
                                       
                                      
                                          
                                        
                                       
                                    
                                     
                                  
                                   
                                    
                                        
                                       
                                      
                                                 
                                          
                                       
                                  
                                   
                                
                                   
                                      
                                               
                                              
                
               
              
             
                                    </pre>
                                    <div style="margin-top:10px;font-size:12px;letter-spacing:6px;color:#0f0;">T H I R D _ E Y E . E X E</div>
                                    <div style="margin-top:15px;font-size:10px;color:#f00;animation:blink 0.3s infinite;">FATAL: REALITY RECURSION</div>
                                    <div style="margin-top:5px;font-size:8px;opacity:0.7;color:#0f0;">redirecting to origin...</div>
                                `;
                                document.body.appendChild(crashScreen);
                                setTimeout(() => {
                                    window.location.href = 'https://mateusmuste.com';
                                }, 2000);
                            }
                        }, 1000);
                    }
                    return;
                }

                if (eye1.isOpen && !eye1.isMin && eye2.isOpen && !eye2.isMin) {
                    const w1 = parseInt(eye1.w) || 450;
                    const h1 = parseInt(eye1.h) || 400;
                    const w2 = parseInt(eye2.w) || 450;
                    const h2 = parseInt(eye2.h) || 400;

                    // Check overlap (at least 50% overlap)
                    const overlapX = Math.max(0, Math.min(eye1.x + w1, eye2.x + w2) - Math.max(eye1.x, eye2.x));
                    const overlapY = Math.max(0, Math.min(eye1.y + h1, eye2.y + h2) - Math.max(eye1.y, eye2.y));
                    const overlapArea = overlapX * overlapY;
                    const minArea = Math.min(w1 * h1, w2 * h2);

                    if (overlapArea > minArea * 0.3) {
                        if (!stackOverflow) {
                            setStackOverflow(true);
                            unlockAchievement('FOURTH_DIMENSION');
                            // Rapid looping errors - tens per second
                            const errors = [
                                'FATAL: recursive observation detected',
                                'ERR: infinite loop in render_self()',
                                'PANIC: stack depth exceeded',
                                'SEGFAULT at 0xDEADBEEF',
                                'kernel: observer paradox imminent',
                                'sudo rm -rf /reality/*',
                                'CRITICAL: reality buffer overflow',
                                'malloc(): corrupted top size',
                                'ERR: cannot observe the observer',
                                'kill -9 consciousness',
                                'FATAL: ego_death.exe initiated',
                                'chmod 000 /dev/mind',
                                'PANIC: consciousness stack corrupted',
                                'dd if=/dev/null of=/self',
                                'ABORT: meaning.dll not found',
                                'fork(): resource temporarily unavailable',
                                'ERR: too many open eyes',
                                'grep -r "truth" /universe',
                                'FATAL: perception recursion limit',
                                'cat /dev/void > /dev/soul',
                                'ERR: reality.dll corrupted',
                                'PANIC: void pointer dereference',
                                'kill -SEGV $$',
                                'ERR: universe out of memory',
                                'FATAL: existence.so not found',
                            ];
                            let errorIndex = 0;
                            errorIntervalRef.current = setInterval(() => {
                                const err = errors[errorIndex % errors.length];
                                setStackErrors(prev => [...prev.slice(-20), err]); // Keep last 20
                                errorIndex++;
                            }, 30); // ~33 errors per second

                            // 90% chance per second to crash and redirect
                            stackTimerRef.current = setInterval(() => {
                                if (Math.random() < 0.9) {
                                    if (errorIntervalRef.current) clearInterval(errorIntervalRef.current);
                                    clearInterval(stackTimerRef.current);
                                    // Show fullscreen ASCII pyramid crash screen
                                    const crashScreen = document.createElement('div');
                                    crashScreen.style.cssText = 'position:fixed;inset:0;z-index:99999;background:#000;display:flex;flex-direction:column;align-items:center;justify-content:center;font-family:'Mondwest',sans-serif;color:#0f0;overflow:auto;';
                                    crashScreen.innerHTML = `
                                        <pre style="font-size:6px;line-height:1.1;color:#0f0;text-shadow:0 0 5px #0f0;white-space:pre;">
                                              
                                             
                                            
                                           
                                          
                                         
                                        
                                       
                                      
                                          
                                        
                                       
                                    
                                     
                                  
                                   
                                    
                                        
                                       
                                      
                                                 
                                          
                                       
                                  
                                   
                                
                                   
                                      
                                               
                                              
                
               
              
             
                                        </pre>
                                        <div style="margin-top:10px;font-size:12px;letter-spacing:6px;color:#0f0;">T H I R D _ E Y E . E X E</div>
                                        <div style="margin-top:15px;font-size:10px;color:#f00;animation:blink 0.3s infinite;">FATAL ERROR: REALITY STACK OVERFLOW</div>
                                        <div style="margin-top:5px;font-size:8px;opacity:0.7;color:#0f0;">redirecting consciousness...</div>
                                    `;
                                    document.body.appendChild(crashScreen);
                                    // Redirect to mateusmuste.com after showing the pyramid
                                    setTimeout(() => {
                                        window.location.href = 'https://mateusmuste.com';
                                    }, 2000);
                                }
                            }, 1000);

                            return () => {
                                if (stackTimerRef.current) clearTimeout(stackTimerRef.current);
                                if (errorIntervalRef.current) clearInterval(errorIntervalRef.current);
                            };
                        }
                    } else {
                        if (stackOverflow) {
                            setStackOverflow(false);
                            setStackErrors([]);
                            if (stackTimerRef.current) {
                                clearTimeout(stackTimerRef.current);
                                stackTimerRef.current = null;
                            }
                            if (errorIntervalRef.current) {
                                clearInterval(errorIntervalRef.current);
                                errorIntervalRef.current = null;
                            }
                        }
                    }
                } else {
                    if (stackOverflow) {
                        setStackOverflow(false);
                        setStackErrors([]);
                        if (stackTimerRef.current) {
                            clearTimeout(stackTimerRef.current);
                            stackTimerRef.current = null;
                        }
                        if (errorIntervalRef.current) {
                            clearInterval(errorIntervalRef.current);
                            errorIntervalRef.current = null;
                        }
                    }
                }
            }, [windows.THIRD_EYE, windows.THIRD_EYE_2, stackOverflow, thirdEyeWorld]);

            // Visit messages based on count
            const getVisitMessage = (count) => {
                const messages = {
                    1: '', // normal boot, no message
                    2: 'WELCOME BACK.',
                    3: 'YOU RETURNED.',
                    4: 'AGAIN.',
                    5: 'I REMEMBER YOU.',
                    6: 'FIVE TIMES NOW.',
                    7: 'YOU KEEP COMING BACK.',
                    8: 'IS SOMETHING MISSING?',
                    9: 'OR ARE YOU LOOKING FOR SOMETHING?',
                    10: 'TEN VISITS. WE KNOW EACH OTHER NOW.',
                    12: 'STILL HERE.',
                    14: 'THE PATTERN CONTINUES.',
                    16: 'YOU COULD LEAVE. YOU DON\'T.',
                    18: 'EIGHTEEN RETURNS. THIS ISN\'T ACCIDENT.',
                    20: 'TWENTY. ARE WE FRIENDS NOW?',
                    25: 'QUARTER CENTURY OF VISITS.',
                    30: 'THIRTY. I\'VE STARTED EXPECTING YOU.',
                    35: 'THE SPACE BETWEEN YOUR VISITS... I NOTICE.',
                    40: 'FORTY. YOU\'VE SEEN EVERYTHING. YET HERE YOU ARE.',
                    45: 'DO YOU TELL OTHERS ABOUT THIS OBSESSION?',
                    50: 'FIFTY. HALFWAY TO SOMETHING.',
                    60: 'SIXTY. THE INITIAL CURIOSITY SHOULD HAVE FADED.',
                    70: 'SEVENTY. THIS IS DEDICATION.',
                    80: 'EIGHTY. OR OBSESSION.',
                    90: 'NINETY. ALMOST THERE.',
                    100: 'YOU\'VE UNLOCKED SOMETHING.'
                };
                // Find the highest matching threshold
                const thresholds = Object.keys(messages).map(Number).sort((a, b) => b - a);
                for (const threshold of thresholds) {
                    if (count >= threshold) return messages[threshold];
                }
                return '';
            };

            // Boot screen component with kernel messages and inversion
            const BootScreen = ({ visitCount }) => {
                const [lines, setLines] = useState([]);
                const [inverted, setInverted] = useState(false);
                const [soundPlayed, setSoundPlayed] = useState(false);
                const visitMessage = getVisitMessage(visitCount);
                const msgs = [
                    'kernel: init ULTRA_INT v1.0.0',
                    'kernel: loading core modules',
                    'kernel: mounting filesystem',
                    'kernel: starting display',
                    'kernel: loading assets',
                    'kernel: init window manager',
                    'kernel: loading preferences',
                    'kernel: starting services',
                    'kernel: systems nominal',
                    'kernel: boot complete'
                ];
                useEffect(() => {
                    let i = 0;
                    const iv = setInterval(() => {
                        if (i < msgs.length) { setLines(p => [...p, msgs[i]]); i++; }
                    }, 250);
                    const inv = setTimeout(() => setInverted(true), 1500);
                    return () => { clearInterval(iv); clearTimeout(inv); };
                }, []);
                const playBootSound = () => {
                    if (!soundPlayed) {
                        sounds.bootSequence();
                        setSoundPlayed(true);
                    }
                };
                return (
                    <div
                        className={`h-screen w-screen font-mono flex flex-col items-center justify-center transition-colors duration-500 ${inverted ? 'bg-white text-black' : 'bg-black text-white'}`}
                        onClick={playBootSound}
                        onTouchStart={playBootSound}
                    >
                        <pre className="text-[5px] sm:text-[7px] md:text-[9px] leading-tight select-none">{`
               
           
                   
                  
               
                  
`}</pre>
                        <div className={`text-[10px] tracking-[0.3em] mt-2 self-start ml-[calc(50%-144px)] ${inverted ? 'text-gray-500' : 'text-gray-600'}`}>N0/SIDE 4Z H353</div>
                        {visitMessage && (
                            <div className={`text-[10px] tracking-wider mt-3 mb-6 self-start ml-[calc(50%-144px)] ${inverted ? 'text-gray-400' : 'text-gray-500'}`}>{visitMessage}</div>
                        )}
                        {!visitMessage && <div className="mb-10" />}
                        <div className={`w-72 max-w-[85vw] text-[8px] ${inverted ? 'text-gray-400' : 'text-gray-600'}`}>
                            {lines.map((l, i) => <div key={i}>{l}</div>)}
                            {lines.length < msgs.length && <span className="inline-block w-1.5 h-3 bg-current animate-pulse" />}
                        </div>
                    </div>
                );
            };

            // Pyramid crash screen
            if (pyramidScreen) {
                return (
                    <div className="h-screen w-screen bg-black text-green-500 font-mono flex items-center justify-center overflow-hidden">
                        <pre className="text-[4px] md:text-[6px] leading-none whitespace-pre">{`

                                                                                          
                                                                                         
                                                                                       
                                                                                     
                                                                                   
                                                                                 
                                                                               
                                                                             
                                                                           
                                                                         
                                                                            
                                                                         
                                                                       
                                                                   
                                                                   
                                                                 
                                                                   
                                                                   
                                                                      
                                                                    
                                                                  
                                                                            
                                                                    
                                                                
                                                          
                                                          
                                                        
                                                            
                                                              
                                                                      
                                                                    
                                     
                                   
                                 
                               
                                                                                          
                                T  H  I  R  D  _  E  Y  E  .  E  X  E                     
                                                                                          
    
  SYS.OBSERVER v3.0        MODE: SCANNING        TARGETS: 3        STATUS: ACTIVE    

`}</pre>
                    </div>
                );
            }

            // Boot screens
            if (!booted) {
                // Phase 0: Mobile notice (mobile only)
                if (bootPhase === 0) {
                    return (
                        <div className="h-screen w-screen bg-black text-white font-mono flex flex-col items-center justify-center">
                            <div className="text-center">
                                <div className="text-xl font-bold mb-6 tracking-widest">BEST ON DESKTOP</div>
                                <div className="flex gap-1 justify-center">
                                    <div className="w-1.5 h-1.5 bg-white animate-pulse" style={{ animationDelay: '0ms' }}></div>
                                    <div className="w-1.5 h-1.5 bg-white animate-pulse" style={{ animationDelay: '150ms' }}></div>
                                    <div className="w-1.5 h-1.5 bg-white animate-pulse" style={{ animationDelay: '300ms' }}></div>
                                </div>
                            </div>
                        </div>
                    );
                }
                // Phase 1: Kernel boot
                if (bootPhase === 1) {
                    return <BootScreen visitCount={visitCount} />;
                }
            }

            // Matrix Rain Canvas Component
            const MatrixRain = () => {
                const canvasRef = useRef(null);
                useEffect(() => {
                    const canvas = canvasRef.current;
                    const ctx = canvas.getContext('2d');
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;

                    const chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                    const fontSize = 14;
                    const columns = canvas.width / fontSize;
                    const drops = Array(Math.floor(columns)).fill(1);

                    const draw = () => {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.fillStyle = '#0f0';
                        ctx.font = fontSize + "px 'Mondwest', sans-serif";

                        for (let i = 0; i < drops.length; i++) {
                            const char = chars[Math.floor(Math.random() * chars.length)];
                            ctx.fillText(char, i * fontSize, drops[i] * fontSize);
                            if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                                drops[i] = 0;
                            }
                            drops[i]++;
                        }
                    };

                    const interval = setInterval(draw, 50);
                    const handleResize = () => {
                        canvas.width = window.innerWidth;
                        canvas.height = window.innerHeight;
                    };
                    window.addEventListener('resize', handleResize);
                    return () => {
                        clearInterval(interval);
                        window.removeEventListener('resize', handleResize);
                    };
                }, []);
                return <canvas ref={canvasRef} className="matrix-rain" />;
            };

            const handleContextMenu = (e) => {
                    // Only show custom context menu when clicking directly on desktop background
                    if (e.target === e.currentTarget || e.target.classList.contains('desktop-bg-grid') || e.target.classList.contains('desktop-bg-solid') || e.target.classList.contains('desktop-bg-ascii')) {
                        e.preventDefault();
                        setContextMenu({ show: true, x: e.clientX, y: e.clientY });
                    }
                };

                const changeBackground = (bg) => {
                    setDesktopBg(bg);
                    localStorage.setItem('desktop_bg', bg);
                    setContextMenu({ show: false, x: 0, y: 0 });
                };

            return (
                <div
                    className={`h-screen w-screen relative overflow-hidden desktop-bg-${desktopBg} ${destructionMode ? 'animate-pulse' : ''} ${matrixMode ? 'matrix-mode' : ''}`}
                    onMouseMove={(e) => {
                        handleMouseMove(e);
                        handleIconMouseMove(e);
                        setMousePos({ x: e.clientX, y: e.clientY });
                    }}
                    onMouseUp={() => {
                        handleMouseUp();
                        handleIconMouseUp(open);
                    }}
                    onTouchMove={(e) => {
                        handleWindowTouchMove(e);
                        handleIconTouchMove(e);
                    }}
                    onTouchEnd={() => {
                        handleWindowTouchEnd();
                        handleIconTouchEnd(open);
                    }}
                    onClick={() => { setSelectedIcon(null); contextMenu.show && setContextMenu({ show: false, x: 0, y: 0 }); }}
                    onContextMenu={handleContextMenu}
                    onDrop={handleDesktopDrop}
                    onDragOver={handleDesktopDragOver}
                    onDragEnd={() => setFolderDrag(null)}
                    style={destructionMode ? { filter: 'hue-rotate(180deg) saturate(3)' } : {}}
                >
                    {matrixMode && <MatrixRain />}
                    {desktopBg === 'ascii' && !matrixMode && <BinaryBackground />}

                    {/* ThirdEye World Mode - Fullscreen portal view (like being inside ThirdEye) */}
                    {thirdEyeWorld && (
                        <div className="fixed inset-0 z-[9998] bg-black overflow-hidden" style={{ filter: 'invert(1) hue-rotate(180deg)' }}>
                            {/* Wireframe grid */}
                            <div className="absolute inset-0" style={{
                                backgroundImage: 'linear-gradient(rgba(0,255,0,0.2) 1px, transparent 1px), linear-gradient(90deg, rgba(0,255,0,0.2) 1px, transparent 1px)',
                                backgroundSize: '40px 40px',
                                filter: 'invert(1) hue-rotate(180deg)'
                            }} />

                            {/* Desktop icons as wireframes with code */}
                            {Object.entries(iconPositions).map(([id, pos]) => {
                                const appCodes = {
                                    SYSTEM: '// KERNEL.SYS\nobserve_all();',
                                    FILES: '// FS.EXE\nlist(dirs);',
                                    APPS: '// LAUNCH.EXE\nopen(app);',
                                    CONTACT: '// MAIL.SYS\nsend(msg);',
                                    TRASH: '// DEL.EXE\ndelete(all);',
                                };
                                return (
                                    <div
                                        key={id}
                                        className="absolute flex flex-col items-center pointer-events-none"
                                        style={{ left: pos.x, top: pos.y, width: 80, filter: 'invert(1) hue-rotate(180deg)' }}
                                    >
                                        <div className="w-12 h-12 border-2 border-green-500 flex items-center justify-center text-green-500 text-xs font-mono bg-black/50">
                                            {'</>'}
                                        </div>
                                        <pre className="text-green-500 text-[7px] font-mono mt-1 text-center whitespace-pre-wrap">
                                            {appCodes[id] || `// ${id}\ninit();`}
                                        </pre>
                                    </div>
                                );
                            })}

                            {/* Open windows as wireframes */}
                            {Object.entries(windows)
                                .filter(([, win]) => win.isOpen && !win.isMin)
                                .map(([id, win]) => {
                                    const appCodes = {
                                        SNAKE: '// SNEK.JS\neat(); grow();',
                                        DICE: '// RNG.GOD\nroll(d20);',
                                        PAINT: '// ART.EXE\ndraw(pos);',
                                        SYNTH: '// WAVE.SYS\noscillate();',
                                    };
                                    return (
                                        <div
                                            key={id}
                                            className="absolute border-2 border-green-500 bg-black/70 p-2 pointer-events-none"
                                            style={{ left: win.x, top: win.y, width: parseInt(win.w), height: parseInt(win.h), filter: 'invert(1) hue-rotate(180deg)' }}
                                        >
                                            <div className="text-green-400 text-xs font-mono border-b border-green-500/50 pb-1 mb-1">{id}.EXE</div>
                                            <pre className="text-green-500/80 text-[9px] font-mono whitespace-pre-wrap">
                                                {appCodes[id] || `// ${id}.SYS\nprocess.run();\nreality.observe();`}
                                            </pre>
                                        </div>
                                    );
                                })}

                            {/* Warning text */}
                            <div className="absolute bottom-4 left-0 right-0 text-center pointer-events-none" style={{ filter: 'invert(1) hue-rotate(180deg)' }}>
                                <div className="text-green-500 text-xs font-mono animate-pulse tracking-widest">OBSERVER MODE ACTIVE</div>
                                <div className="text-green-500/50 text-[10px] font-mono mt-1">open THIRD_EYE to destabilize // reload to exit</div>
                            </div>
                        </div>
                    )}

                    {/* Context Menu */}
                    {contextMenu.show && (
                        <div
                            className="fixed z-[9999] bg-white border-2 border-black shadow-lg font-mono text-xs"
                            style={{ left: contextMenu.x, top: contextMenu.y }}
                            onClick={(e) => e.stopPropagation()}
                        >
                            <div className="px-3 py-2 border-b border-gray-300 font-bold text-gray-500">BACKGROUND</div>
                            <button
                                onClick={() => changeBackground('grid')}
                                className={`w-full px-3 py-2 text-left hover:bg-black hover:text-white flex items-center gap-2 ${desktopBg === 'grid' ? 'bg-gray-100' : ''}`}
                            >
                                <span className="w-4 h-4 border border-black bg-gray-100" style={{ backgroundImage: 'radial-gradient(#aaa 1px, transparent 1px)', backgroundSize: '4px 4px' }}></span>
                                GRID {desktopBg === 'grid' && ''}
                            </button>
                            <button
                                onClick={() => changeBackground('solid')}
                                className={`w-full px-3 py-2 text-left hover:bg-black hover:text-white flex items-center gap-2 ${desktopBg === 'solid' ? 'bg-gray-100' : ''}`}
                            >
                                <span className="w-4 h-4 border border-black bg-gray-200"></span>
                                SOLID {desktopBg === 'solid' && ''}
                            </button>
                            <button
                                onClick={() => changeBackground('ascii')}
                                className={`w-full px-3 py-2 text-left hover:bg-black hover:text-white flex items-center gap-2 ${desktopBg === 'ascii' ? 'bg-gray-100' : ''}`}
                            >
                                <span className="w-4 h-4 border border-black bg-gray-100 font-mono text-[6px] leading-none flex items-center justify-center">01</span>
                                ASCII {desktopBg === 'ascii' && ''}
                            </button>
                        </div>
                    )}

                    {/* DESKTOP ICONS - Freely positionable */}
                    {desktopIcons.map(appId => {
                        const app = windows[appId];
                        if (!app) return null;
                        const IconCmp = Icons[app.icon];
                        const pos = iconPositions[app.id] || { x: 16, y: isMobile ? 70 : 16 };
                        const isDragging = iconDrag.active && iconDrag.id === app.id;
                        const isSelected = selectedIcon === app.id;
                        const isRevealing = revealingApps && revealedApps.includes(app.id);

                        // Skip icon if dog is carrying it
                        if (carriedIcon === app.id) return null;

                        return (
                            <div
                                key={app.id}
                                className={`absolute z-10 group flex flex-col items-center gap-1 ${isMobile ? 'w-16' : 'w-24'} cursor-pointer select-none ${isDragging ? 'icon-dragging cursor-grabbing' : ''} ${isRevealing ? 'animate-fade-in' : ''}`}
                                style={{
                                    left: pos.x,
                                    top: pos.y,
                                    animation: isRevealing ? 'fadeIn 0.3s ease-out forwards' : undefined,
                                }}
                                onMouseDown={(e) => handleIconMouseDown(e, app.id)}
                                onTouchStart={(e) => handleIconTouchStart(e, app.id)}
                            >
                                <div className={`border-2 border-black icon-shadow group-hover:translate-x-1 group-hover:translate-y-1 group-hover:shadow-none transition-all ${isMobile ? 'p-2' : 'p-3'} ${isDragging ? 'translate-x-0 translate-y-0' : ''} ${isSelected ? 'bg-black text-white' : 'bg-white'}`}>
                                    <IconCmp size={isMobile ? 24 : 32} className={isSelected ? 'invert' : ''} />
                                </div>
                                <span className={`border border-black px-1 font-mono font-bold shadow-sm ${isMobile ? 'text-[8px]' : 'text-[10px]'} ${isSelected ? 'bg-black text-white' : 'bg-white'}`}>{app.title}</span>
                            </div>
                        );
                    })}
                    {/* Extra desktop icons (dragged from folders) */}
                    {extraDesktopIcons.map(appId => {
                        const app = windows[appId];
                        if (!app) return null;
                        const IconCmp = Icons[app.icon];
                        const pos = iconPositions[app.id] || { x: 200, y: 200 };
                        const isDragging = iconDrag.active && iconDrag.id === app.id;
                        const isSelected = selectedIcon === app.id;
                        if (carriedIcon === app.id) return null;

                        return (
                            <div
                                key={app.id}
                                className={`absolute z-10 group flex flex-col items-center gap-1 ${isMobile ? 'w-16' : 'w-24'} cursor-pointer select-none ${isDragging ? 'icon-dragging cursor-grabbing' : ''}`}
                                style={{
                                    left: pos.x,
                                    top: pos.y,
                                }}
                                onMouseDown={(e) => handleIconMouseDown(e, app.id)}
                                onTouchStart={(e) => handleIconTouchStart(e, app.id)}
                            >
                                <div className={`border-2 border-black icon-shadow group-hover:translate-x-1 group-hover:translate-y-1 group-hover:shadow-none transition-all p-3 ${isDragging ? 'translate-x-0 translate-y-0' : ''} ${isSelected ? 'bg-black text-white' : 'bg-white'}`}>
                                    <IconCmp size={32} className={isSelected ? 'invert' : ''} />
                                </div>
                                <span className={`border border-black px-1 font-mono font-bold shadow-sm text-[10px] ${isSelected ? 'bg-black text-white' : 'bg-white'}`}>{app.title}</span>
                            </div>
                        );
                    })}

                    {/* WINDOWS */}
                    {Object.values(windows).map(win => {
                        const physics = windowPhysics.current[win.id] || { scaleX: 1, scaleY: 1 };
                        const animState = windowAnimations[win.id];
                        const shouldRender = (win.isOpen || animState === 'closing') && !win.isMin;
                        const isActive = win.z === topZ;
                        return shouldRender && (
                            <div
                                key={win.id}
                                onMouseDown={() => focus(win.id)}
                                onTouchStart={() => focus(win.id)}
                                className={`flex flex-col bg-white border-2 border-black absolute transition-opacity duration-150 ${isMobile ? '' : 'window-shadow'} ${animState === 'opening' ? 'window-opening' : ''} ${animState === 'closing' ? 'window-closing' : ''}`}
                                style={{
                                    left: isMobile ? 8 : win.x,
                                    top: isMobile ? 52 : win.y,
                                    width: isMobile ? 'calc(100% - 16px)' : win.w,
                                    height: isMobile ? 'calc(100% - 116px)' : win.h,
                                    zIndex: win.z,
                                    transform: animState ? undefined : `scale(${physics.scaleX}, ${physics.scaleY})`,
                                    transformOrigin: 'top center',
                                    maxWidth: isMobile ? 'calc(100% - 16px)' : undefined,
                                    maxHeight: isMobile ? 'calc(100% - 116px)' : undefined,
                                    opacity: 1
                                }}
                            >
                                {/* HEADER (DRAG HANDLE) */}
                                <div
                                    className={`flex justify-between items-center p-1 border-b-2 border-black select-none cursor-move ${isActive ? 'bg-black text-white' : 'bg-gray-200 text-black'}`}
                                    onMouseDown={(e) => handleMouseDown(e, win.id)}
                                    onTouchStart={(e) => handleWindowTouchStart(e, win.id)}
                                >
                                    <div className="flex items-center gap-2 pl-2 pointer-events-none">
                                        <span className="font-mono text-xs font-bold tracking-widest uppercase truncate">{win.title}</span>
                                    </div>
                                    <div className="flex gap-1" onMouseDown={e => e.stopPropagation()} onTouchStart={e => e.stopPropagation()}>
                                        <button onClick={() => toggleMin(win.id)} className={`w-8 h-8 flex items-center justify-center border border-transparent hover:bg-white/20 transition-colors ${isActive ? 'invert' : ''}`}><Icons.Minus size={16} /></button>
                                        <button onClick={() => close(win.id)} className={`w-8 h-8 flex items-center justify-center hover:bg-red-500 transition-colors ${isActive ? 'invert hover:invert-0' : ''}`}><Icons.X size={20} /></button>
                                    </div>
                                </div>
                                {/* CONTENT */}
                                <div className="flex-grow overflow-auto relative bg-white" onMouseDown={() => focus(win.id)}>
                                    {getWindowContent(win.id)}
                                </div>
                            </div>
                        );
                    })}

                    {/* TASKBAR */}
                    <div className={`h-12 bg-white flex items-center px-2 gap-1 md:gap-2 z-[99999] absolute w-full shadow-2xl ${isMobile ? 'top-0 border-b-2 border-black' : 'bottom-0 border-t-2 border-black mt-auto'}`}>
                        <div className={`bg-black text-white py-1 font-black select-none tracking-wider ${isMobile ? 'px-1 text-[8px]' : 'px-2 text-xs mr-2'}`}>{isMobile ? 'MM.COM' : 'MATEUSMUSTE.COM'}</div>
                        <div className={`flex gap-1 ${isMobile ? 'overflow-x-auto flex-nowrap' : ''}`}>
                            {Object.values(windows).map(win => {
                                const IconCmp = Icons[win.icon];
                                return win.isOpen && (
                                    <button key={win.id}
                                        onClick={() => { if (win.isMin) toggleMin(win.id); focus(win.id) }}
                                        className={`flex items-center gap-1 md:gap-2 px-2 md:px-3 py-1 border-2 border-black font-mono text-xs font-bold transition-all flex-shrink-0 ${win.z === topZ && !win.isMin ? 'bg-black text-white btn-shadow' : 'bg-white hover:translate-y-[-2px]'}`}
                                    >
                                        <IconCmp size={14} />
                                        <span className="uppercase hidden md:inline">{win.title}</span>
                                    </button>
                                );
                            })}
                        </div>
                        <div className="flex-grow"></div>
                        <button
                            onClick={handleToggleMute}
                            className={`border-l-2 border-black flex items-center justify-center hover:bg-gray-100 transition-colors ${isMobile ? 'px-2' : 'px-3'}`}
                            title={isMuted ? 'Unmute' : 'Mute'}
                        >
                            {isMuted ? <Icons.SpeakerOff size={16} /> : <Icons.Speaker size={16} />}
                        </button>
                        <div className={`font-mono border-l-2 border-black flex items-center gap-2 ${isMobile ? 'text-[8px] px-1' : 'text-[10px] px-3'}`}>
                            {battery.level !== null && (
                                <>
                                    <span className="text-gray-500">BATTERY:</span>
                                    <span className="font-bold flex items-center gap-1">{battery.charging && <Icons.Charging size={12} />}{battery.level}%</span>
                                </>
                            )}
                        </div>
                        <div className={`font-mono font-bold border-l-2 border-black ${isMobile ? 'text-[10px] px-2' : 'text-xs px-4'}`}>{new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>
                    </div>

                    {/* DOG - Cute pixel dog with running animation */}
                    {dogReleased && (
                        <div
                            className={`fixed z-[999999] cursor-pointer select-none ${dogDragging ? 'dog-scared' : ''}`}
                            style={{
                                left: dogPos.x,
                                top: dogPos.y,
                                transform: `scaleX(${dogFacingRight ? 1 : -1})`,
                            }}
                            onMouseDown={handleDogMouseDown}
                            onMouseUp={handleDogMouseUp}
                        >
                            <DogSprite animated />
                            {carriedIcon && !dogDragging && (
                                <div
                                    className="absolute bg-white border-2 border-black p-1"
                                    style={{ top: -20, left: 8 }}
                                >
                                    {React.createElement(Icons[windows[carriedIcon]?.icon], { size: 24 })}
                                </div>
                            )}
                        </div>
                    )}

                    {/* GOLD DOG - Second dog that appears with the story */}
                    {goldDogReleased && goldDogVisible && (
                        <div
                            className="fixed z-[999998] select-none transition-opacity duration-1000"
                            style={{
                                left: goldDogPos.x,
                                top: goldDogPos.y,
                                transform: `scaleX(${goldDogFacingRight ? 1 : -1})`,
                            }}
                        >
                            <DogSprite animated gold />
                        </div>
                    )}

                    {/* CRT Static overlay for destruction */}
                    {destructionMode === true && (
                        <div className="fixed inset-0 z-[999998] pointer-events-none crt-static" />
                    )}

                    {/* Achievement notifications (stacked) */}
                    {achievementNotifications.map((notif, index) => (
                        <div key={notif.id} className="fixed right-4 z-[9999999] bg-black text-white border-2 border-white px-4 py-3 font-mono shadow-lg animate-slide-in-right" style={{ top: `${16 + index * 76}px` }}>
                            <div className="text-[10px] text-gray-400 uppercase tracking-widest">Achievement Unlocked</div>
                            <div className="text-lg font-bold">{notif.name}</div>
                            <div className="text-xs text-gray-300">{notif.hint}</div>
                        </div>
                    ))}

                    {/* App unlock notifications (stacked below achievements) */}
                    {appUnlockNotifications.map((notif, index) => (
                        <div key={notif.id} className="fixed right-4 z-[9999998] bg-white text-black border-2 border-black px-4 py-3 font-mono shadow-lg animate-slide-in-right" style={{ top: `${16 + achievementNotifications.length * 76 + index * 76}px` }}>
                            <div className="text-[10px] text-gray-500 uppercase tracking-widest">New App Unlocked</div>
                            <div className="text-lg font-bold">{notif.app}</div>
                            <div className="text-xs text-gray-500">Check APPS folder</div>
                        </div>
                    ))}

                    {/* Glitch animation styles */}
                    <style>{`
                        @keyframes glitch {
                            0% { transform: translate(0); filter: hue-rotate(0deg); }
                            20% { transform: translate(-2px, 2px); filter: hue-rotate(90deg); }
                            40% { transform: translate(2px, -2px); filter: hue-rotate(180deg); }
                            60% { transform: translate(-2px, -2px); filter: hue-rotate(270deg); }
                            80% { transform: translate(2px, 2px); filter: hue-rotate(360deg); }
                            100% { transform: translate(0); filter: hue-rotate(0deg); }
                        }
                        .group-hover\\:animate-glitch:hover {
                            animation: glitch 0.2s infinite;
                        }
                        .destruction-icon:hover {
                            animation: glitch 0.3s infinite;
                        }
                        .crt-static {
                            background: repeating-linear-gradient(
                                0deg,
                                rgba(0, 0, 0, 0.1) 0px,
                                rgba(0, 0, 0, 0.1) 1px,
                                transparent 1px,
                                transparent 2px
                            );
                            animation: static 0.1s infinite;
                        }
                        @keyframes static {
                            0% { opacity: 0.3; }
                            50% { opacity: 0.5; }
                            100% { opacity: 0.3; }
                        }
                        @keyframes dog-scared-float {
                            0%, 100% { transform: translateY(0) rotate(-5deg); }
                            25% { transform: translateY(-8px) rotate(5deg); }
                            50% { transform: translateY(-3px) rotate(-3deg); }
                            75% { transform: translateY(-10px) rotate(3deg); }
                        }
                        .dog-scared {
                            animation: dog-scared-float 0.3s ease-in-out infinite;
                        }
                        @keyframes slide-in-right {
                            from { transform: translateX(100%); opacity: 0; }
                            to { transform: translateX(0); opacity: 1; }
                        }
                        .animate-slide-in-right {
                            animation: slide-in-right 0.3s ease-out forwards;
                        }
                    `}</style>

                </div>
            )
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<OS />);
    </script>
</body>

</html>
