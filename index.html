<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MATEUSMUSTE // OS</title>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script src="https://cdn.tailwindcss.com"></script>

    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script type="module">
        import createGlobe from 'https://cdn.skypack.dev/cobe';
        window.createGlobe = createGlobe;
    </script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Geist:wght@400;700;900&family=Geist+Mono:wght@400;700&display=swap"
        rel="stylesheet">

    <style>
        :root {
            --bg: #e5e5e5;
            --fg: #000000;
        }

        body {
            background-color: var(--bg);
            color: var(--fg);
            font-family: 'Geist', sans-serif;
            overflow: hidden;
            margin: 0;
            padding: 0;
            user-select: none;
            -webkit-font-smoothing: antialiased;
        }

        .font-mono {
            font-family: 'Geist Mono', monospace;
        }

        /* Brutalist Styles */
        .window-shadow {
            box-shadow: 10px 10px 0px 0px #000000;
        }

        .icon-shadow {
            box-shadow: 4px 4px 0px 0px #000000;
        }

        .btn-shadow {
            box-shadow: 2px 2px 0px 0px #000000;
        }

        /* Design System - Standardized Components */

        /* Primary Button: solid black */
        .btn-primary {
            padding: 0.75rem 1.5rem;
            background: #000;
            color: #fff;
            font-family: 'Geist Mono', monospace;
            font-size: 0.875rem;
            font-weight: 700;
            border: 2px solid #000;
            cursor: pointer;
            transition: filter 0.15s;
        }
        .btn-primary:hover { filter: invert(1); }
        .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Secondary Button: outlined */
        .btn-secondary {
            padding: 0.75rem 1.5rem;
            background: #fff;
            color: #000;
            font-family: 'Geist Mono', monospace;
            font-size: 0.875rem;
            font-weight: 700;
            border: 2px solid #000;
            cursor: pointer;
            transition: all 0.15s;
        }
        .btn-secondary:hover { background: #000; color: #fff; }

        /* Button Sizes */
        .btn-xs { padding: 0.25rem 0.5rem; font-size: 0.625rem; }
        .btn-sm { padding: 0.5rem 1rem; font-size: 0.75rem; }
        .btn-lg { padding: 1rem 2rem; font-size: 1.125rem; }
        .btn-full { width: 100%; }

        /* Icon Button (square, compact) */
        .btn-icon {
            padding: 0.25rem;
            background: #fff;
            border: 1px solid #000;
            cursor: pointer;
        }
        .btn-icon:hover { background: #f3f3f3; }

        /* Toolbar Button (selectable toggle) */
        .btn-toolbar {
            padding: 0.25rem 0.5rem;
            font-family: 'Geist Mono', monospace;
            font-size: 0.625rem;
            font-weight: 700;
            text-transform: uppercase;
            border: 1px solid #000;
            cursor: pointer;
            background: #fff;
        }
        .btn-toolbar:hover { background: #f3f3f3; }
        .btn-toolbar.active { background: #000; color: #fff; }

        /* App Header */
        .app-header {
            padding: 0.5rem;
            border-bottom: 2px solid #000;
            background: #fff;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .app-header-title {
            font-family: 'Geist Mono', monospace;
            font-size: 0.75rem;
            font-weight: 700;
        }
        .app-header-subtitle {
            font-family: 'Geist Mono', monospace;
            font-size: 10px;
            color: #6b7280;
        }

        /* App Footer/Status Bar */
        .app-footer {
            padding: 0.5rem;
            border-top: 2px solid #000;
            background: #fff;
            text-align: center;
        }
        .app-footer-text {
            font-family: 'Geist Mono', monospace;
            font-size: 10px;
            color: #6b7280;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }

        ::-webkit-scrollbar-track {
            background: #fff;
            border-left: 2px solid #000;
            border-top: 2px solid #000;
        }

        ::-webkit-scrollbar-thumb {
            background: #000;
            border: 2px solid #fff;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #333;
        }

        /* Background Pattern */
        .desktop-bg {
            background-color: #f0f0f0;
            background-image: radial-gradient(#aaa 1px, transparent 1px);
            background-size: 20px 20px;
        }

        canvas {
            touch-action: none;
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            10%,
            30%,
            50%,
            70%,
            90% {
                transform: translateX(-5px);
            }

            20%,
            40%,
            60%,
            80% {
                transform: translateX(5px);
            }
        }

        .animate-shake {
            animation: shake 0.5s ease-in-out;
        }
    </style>
</head>

<body>

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- IP-BASED HIGH SCORE SYSTEM ---
        const HighScoreManager = {
            userIP: null,

            async fetchIP() {
                if (this.userIP) return this.userIP;
                try {
                    const res = await fetch('https://api.ipify.org?format=json');
                    const data = await res.json();
                    this.userIP = data.ip;
                    return this.userIP;
                } catch (e) {
                    // Fallback to anonymous if IP fetch fails
                    this.userIP = 'anonymous';
                    return this.userIP;
                }
            },

            getStorageKey(game) {
                return `highscore_${game}_${this.userIP || 'anonymous'}`;
            },

            saveHighScore(game, score) {
                const key = this.getStorageKey(game);
                const current = localStorage.getItem(key);
                if (!current || score > parseInt(current, 10)) {
                    localStorage.setItem(key, score.toString());
                    return true;
                }
                return false;
            },

            getHighScore(game) {
                const key = this.getStorageKey(game);
                return parseInt(localStorage.getItem(key) || '0', 10);
            }
        };

        // Initialize IP on load
        HighScoreManager.fetchIP();

        // --- PIXELARTICONS (from unpkg CDN) ---
        const PixelartIcon = ({ name, size = 64, style = {}, className = '', ...props }) => (
            <img
                src={`https://unpkg.com/pixelarticons@1.8.1/svg/${name}.svg`}
                width={size}
                height={size}
                alt={name}
                style={{ imageRendering: 'pixelated', ...style }}
                className={className}
                {...props}
            />
        );

        const Icons = {
            // System Info - Monitor
            Terminal: (p) => <PixelartIcon name="monitor" {...p} />,
            // Media Library - Folder
            Folder: (p) => <PixelartIcon name="folder" {...p} />,
            // Paint - Fill bucket
            Palette: (p) => <PixelartIcon name="fill" {...p} />,
            // Snake Game - Gamepad
            Snek: (p) => <PixelartIcon name="gamepad" {...p} />,
            // Trash Can
            TrashCan: (p) => <PixelartIcon name="trash" {...p} />,
            // Undo arrow
            Undo: (p) => <PixelartIcon name="undo" {...p} />,
            // Redo arrow
            Redo: (p) => <PixelartIcon name="redo" {...p} />,
            // File document
            FileDoc: (p) => <PixelartIcon name="file" {...p} />,
            // Window controls
            X: ({ size = 24, ...p }) => <PixelartIcon name="close" size={size} {...p} />,
            Minus: ({ size = 24, ...p }) => <PixelartIcon name="minus" size={size} {...p} />,
            Square: ({ size = 24, ...p }) => <PixelartIcon name="checkbox" size={size} {...p} />,
            Trash: (p) => <PixelartIcon name="trash" {...p} />,
            Send: (p) => <PixelartIcon name="send" {...p} />,
            // Media folder icons
            Movies: (p) => <PixelartIcon name="movie" {...p} />,
            Books: (p) => <PixelartIcon name="book" {...p} />,
            Games: (p) => <PixelartIcon name="gamepad" {...p} />,
            Music: (p) => <PixelartIcon name="music" {...p} />,
            Back: (p) => <PixelartIcon name="arrow-left" {...p} />,
            // App Icons
            Void: (p) => <PixelartIcon name="code" {...p} />,
            Oracle: (p) => <PixelartIcon name="book-open" {...p} />,
            Radio: (p) => <PixelartIcon name="radio-on" {...p} />,
            Dice: (p) => <PixelartIcon name="dice" {...p} />,
            Labyrinth: (p) => <PixelartIcon name="layout-rows" {...p} />,
            Minesweeper: (p) => <PixelartIcon name="table" {...p} />,
            Starship: (p) => <PixelartIcon name="arrow-up" {...p} />,
            Synth: (p) => <PixelartIcon name="keyboard" {...p} />,
            Destruction: (p) => <PixelartIcon name="power" {...p} />,
            Tarot: (p) => <PixelartIcon name="card" {...p} />,
            Dog: (p) => <PixelartIcon name="paw" {...p} />,
            // Email icon
            Email: (p) => <PixelartIcon name="mail" {...p} />,
            // Apps folder icon
            Apps: (p) => <PixelartIcon name="add-grid" {...p} />,
            // Gallery
            Gallery: (p) => <PixelartIcon name="image" {...p} />,
            // Globe
            Globe: (p) => <PixelartIcon name="map" {...p} />,
            // Pomodoro timer
            Pomodoro: (p) => <PixelartIcon name="clock" {...p} />,
            // Health scanner
            HealthScanner: (p) => <PixelartIcon name="heart" {...p} />,
            // Lock icon
            Lock: (p) => <PixelartIcon name="lock" {...p} />,
            // Folder icons for app categories
            FolderClosed: (p) => <PixelartIcon name="folder" {...p} />,
            GamesFolder: (p) => <PixelartIcon name="gamepad" {...p} />,
            ProductivityFolder: (p) => <PixelartIcon name="sliders" {...p} />,
            AboutFolder: (p) => <PixelartIcon name="user" {...p} />,
        };

        // --- DATA ---
        const MEDIA_DB = {
            "CINEMA_TV": [
                { title: "Blade Runner 2049" },
                { title: "Mr. Robot" },
                { title: "True Detective S1" },
                { title: "Succession" },
                { title: "The Bear" },
                { title: "Ex Machina" },
                { title: "Fight Club" },
                { title: "Arcane" },
                { title: "Interstellar" },
                { title: "Chernobyl" },
                { title: "Better Call Saul" },
                { title: "Atlanta" },
                { title: "Whiplash" },
                { title: "There Will Be Blood" },
                { title: "Sicario" },
                { title: "Black Mirror" }
            ],
            "LITERATURE": [
                { title: "Brothers Karamazov", rating: "10/10" },
                { title: "Looking for Alaska", rating: "10/10" },
                { title: "Atlas Shrugged", rating: "10/10" },
                { title: "Pale Blue Dot", rating: "10/10" },
                { title: "Lean Startup", rating: "9/10" },
                { title: "Fight Club", rating: "9/10" },
                { title: "Principles by Ray Dalio", rating: "9/10" },
                { title: "The Fountainhead", rating: "9/10" },
                { title: "Crime & Punishment", rating: "8/10" },
                { title: "1984", rating: "8/10" },
                { title: "Master & Margarita", rating: "8/10" },
                { title: "American Psycho", rating: "8/10" },
                { title: "Elon Musk Biography", rating: "8/10" },
                { title: "How to Get Filthy Rich in Rising Asia", rating: "8/10" },
                { title: "Fathers and Sons", rating: "8/10" },
                { title: "The Long Walk", rating: "8/10" },
                { title: "What's Our Problem?", rating: "7/10" },
                { title: "The Alchemist", rating: "7/10" },
                { title: "Kafka on the Shore", rating: "6/10" },
                { title: "Geometry for Ocelots", rating: "READING" }
            ],
            "GAMES": [
                { title: "Dark Souls III", rating: "10/10" },
                { title: "The Last of Us Pt II", rating: "10/10" },
                { title: "Outer Wilds", rating: "10/10" },
                { title: "God of War Ragnarok", rating: "10/10" },
                { title: "Blue Prince", rating: "10/10" },
                { title: "Cyberpunk 2077", rating: "9.5/10" },
                { title: "Night in the Woods", rating: "9.5/10" },
                { title: "Silent Hill 2", rating: "8/10" },
                { title: "Returnal", rating: "8/10" },
                { title: "Hollow Knight (Silksong)", rating: "8/10" },
                { title: "Deltarune", rating: "9/10" }
            ],
            "AUDIO": [
                { title: "Ison", artist: "Sevdaliza" },
                { title: "Mr. Morale...", artist: "Kendrick Lamar" },
                { title: "LP!", artist: "JPEGMAFIA" },
                { title: "Take Care", artist: "Drake" },
                { title: "The Life of Pablo", artist: "Kanye West" },
                { title: "Miss Anthropocene", artist: "Grimes" },
                { title: "The Eminem Show", artist: "Eminem" },
                { title: "4 Your Eyez Only", artist: "J. Cole" },
                { title: "Yeezus", artist: "Kanye West" },
                { title: "This story is dedicated...", artist: "Grimes" }
            ]
        };

        // --- APP COMPONENTS ---

        const PaintApp = () => {
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const [tool, setTool] = useState('brush');
            const [color, setColor] = useState('#000000');
            const [size, setSize] = useState(4);
            const [isDrawing, setIsDrawing] = useState(false);
            const [status, setStatus] = useState("READY");
            const [startPos, setStartPos] = useState({ x: 0, y: 0 });
            const [textInput, setTextInput] = useState('');
            const [showTextInput, setShowTextInput] = useState(false);
            const [textPos, setTextPos] = useState({ x: 0, y: 0 });
            const snapshotRef = useRef(null);
            const historyRef = useRef([]);
            const historyIndexRef = useRef(-1);

            // Get accurate mouse/touch position relative to canvas
            const getMousePos = (e) => {
                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                // Handle both mouse and touch events
                let clientX, clientY;
                if (e.touches && e.touches.length > 0) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else if (e.changedTouches && e.changedTouches.length > 0) {
                    clientX = e.changedTouches[0].clientX;
                    clientY = e.changedTouches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                return {
                    x: (clientX - rect.left) * scaleX,
                    y: (clientY - rect.top) * scaleY
                };
            };

            // Touch event handlers
            const handleTouchStart = (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    startDraw(e);
                }
            };
            const handleTouchMove = (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    draw(e);
                }
            };
            const handleTouchEnd = (e) => {
                e.preventDefault();
                endDraw();
            };

            const saveToHistory = () => {
                const canvas = canvasRef.current;
                const data = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
                historyRef.current = historyRef.current.slice(0, historyIndexRef.current + 1);
                historyRef.current.push(data);
                if (historyRef.current.length > 50) historyRef.current.shift();
                historyIndexRef.current = historyRef.current.length - 1;
            };

            const undo = () => {
                if (historyIndexRef.current > 0) {
                    historyIndexRef.current--;
                    canvasRef.current.getContext('2d').putImageData(historyRef.current[historyIndexRef.current], 0, 0);
                    setStatus("UNDO");
                }
            };

            const redo = () => {
                if (historyIndexRef.current < historyRef.current.length - 1) {
                    historyIndexRef.current++;
                    canvasRef.current.getContext('2d').putImageData(historyRef.current[historyIndexRef.current], 0, 0);
                    setStatus("REDO");
                }
            };

            useEffect(() => {
                const initCanvas = () => {
                    if (!containerRef.current) return;
                    const canvas = canvasRef.current;
                    const container = containerRef.current;
                    // Set fixed canvas size for proper pixel drawing
                    canvas.width = container.clientWidth - 4;
                    canvas.height = container.clientHeight - 4;
                    const ctx = canvas.getContext("2d");
                    ctx.fillStyle = "#ffffff";
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    saveToHistory();
                };
                initCanvas();
                window.addEventListener('resize', initCanvas);
                return () => window.removeEventListener('resize', initCanvas);
            }, []);

            const floodFill = (x, y, fillColor) => {
                const ctx = canvasRef.current.getContext('2d');
                const w = ctx.canvas.width;
                const h = ctx.canvas.height;
                const imgData = ctx.getImageData(0, 0, w, h);
                const data = imgData.data;
                const r = parseInt(fillColor.slice(1, 3), 16);
                const g = parseInt(fillColor.slice(3, 5), 16);
                const b = parseInt(fillColor.slice(5, 7), 16);
                const startIdx = (y * w + x) * 4;
                const sr = data[startIdx], sg = data[startIdx + 1], sb = data[startIdx + 2];
                if (sr === r && sg === g && sb === b) return;
                const stack = [[x, y]];
                while (stack.length) {
                    const [cx, cy] = stack.pop();
                    const idx = (cy * w + cx) * 4;
                    if (cx < 0 || cx >= w || cy < 0 || cy >= h) continue;
                    if (data[idx] === sr && data[idx + 1] === sg && data[idx + 2] === sb) {
                        data[idx] = r; data[idx + 1] = g; data[idx + 2] = b; data[idx + 3] = 255;
                        stack.push([cx + 1, cy], [cx - 1, cy], [cx, cy + 1], [cx, cy - 1]);
                    }
                }
                ctx.putImageData(imgData, 0, 0);
                saveToHistory();
            };

            const saveSnapshot = () => {
                const canvas = canvasRef.current;
                snapshotRef.current = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
            };

            const restoreSnapshot = () => {
                if (snapshotRef.current) {
                    canvasRef.current.getContext('2d').putImageData(snapshotRef.current, 0, 0);
                }
            };

            const startDraw = (e) => {
                const pos = getMousePos(e);
                if (tool === 'bucket') {
                    floodFill(Math.floor(pos.x), Math.floor(pos.y), color);
                    setStatus("FILLED");
                } else if (tool === 'text') {
                    setTextPos(pos);
                    setShowTextInput(true);
                    setStatus("TYPE TEXT");
                } else if (['rect', 'circle', 'line'].includes(tool)) {
                    setIsDrawing(true);
                    setStartPos(pos);
                    saveSnapshot();
                } else {
                    setIsDrawing(true);
                    setStartPos(pos);
                    const ctx = canvasRef.current.getContext('2d');
                    ctx.beginPath();
                    ctx.moveTo(pos.x, pos.y);
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.lineWidth = size;
                    ctx.strokeStyle = tool === 'eraser' ? '#ffffff' : color;
                }
            };

            const draw = (e) => {
                if (!isDrawing) return;
                const ctx = canvasRef.current.getContext('2d');
                const pos = getMousePos(e);

                if (tool === 'brush' || tool === 'eraser') {
                    ctx.lineTo(pos.x, pos.y);
                    ctx.stroke();
                } else if (['rect', 'circle', 'line'].includes(tool)) {
                    restoreSnapshot();
                    ctx.strokeStyle = color;
                    ctx.fillStyle = color;
                    ctx.lineWidth = size;

                    if (tool === 'rect') {
                        ctx.strokeRect(startPos.x, startPos.y, pos.x - startPos.x, pos.y - startPos.y);
                    } else if (tool === 'circle') {
                        const rx = Math.abs(pos.x - startPos.x) / 2;
                        const ry = Math.abs(pos.y - startPos.y) / 2;
                        const cx = startPos.x + (pos.x - startPos.x) / 2;
                        const cy = startPos.y + (pos.y - startPos.y) / 2;
                        ctx.beginPath();
                        ctx.ellipse(cx, cy, rx, ry, 0, 0, 2 * Math.PI);
                        ctx.stroke();
                    } else if (tool === 'line') {
                        ctx.beginPath();
                        ctx.moveTo(startPos.x, startPos.y);
                        ctx.lineTo(pos.x, pos.y);
                        ctx.stroke();
                    }
                }
            };

            const endDraw = () => {
                if (isDrawing) {
                    setIsDrawing(false);
                    if (tool === 'brush' || tool === 'eraser') {
                        canvasRef.current.getContext('2d').closePath();
                    }
                    saveToHistory();
                }
            };

            const placeText = () => {
                if (textInput.trim()) {
                    const ctx = canvasRef.current.getContext('2d');
                    ctx.fillStyle = color;
                    ctx.font = `${size * 4}px 'Geist Mono', monospace`;
                    ctx.fillText(textInput, textPos.x, textPos.y);
                    setStatus("TEXT PLACED");
                    saveToHistory();
                }
                setShowTextInput(false);
                setTextInput('');
            };

            const send = () => {
                setStatus("ENCRYPTING...");
                setTimeout(() => setStatus("UPLOADING..."), 500);
                setTimeout(() => setStatus("SENT TO MATEUS"), 1200);
            };

            const clear = () => {
                const ctx = canvasRef.current.getContext('2d');
                ctx.fillStyle = "#ffffff";
                ctx.fillRect(0, 0, canvasRef.current.width, canvasRef.current.height);
                setStatus("CLEARED");
                saveToHistory();
            };

            // Pixel knob component
            const PixelKnob = ({ value, onChange, min, max }) => {
                const knobSize = 24;
                const rotation = ((value - min) / (max - min)) * 270 - 135;
                return (
                    <div
                        className="relative cursor-pointer select-none"
                        style={{ width: knobSize, height: knobSize }}
                        onMouseDown={(e) => {
                            e.preventDefault();
                            const startY = e.clientY;
                            const startVal = value;
                            const onMove = (ev) => {
                                const diff = startY - ev.clientY;
                                const newVal = Math.min(max, Math.max(min, startVal + Math.floor(diff / 5)));
                                onChange(newVal);
                            };
                            const onUp = () => {
                                window.removeEventListener('mousemove', onMove);
                                window.removeEventListener('mouseup', onUp);
                            };
                            window.addEventListener('mousemove', onMove);
                            window.addEventListener('mouseup', onUp);
                        }}
                    >
                        <svg width={knobSize} height={knobSize} viewBox="0 0 24 24" style={{ imageRendering: 'pixelated' }}>
                            <rect x="4" y="4" width="16" height="16" fill="#000" />
                            <rect x="6" y="6" width="12" height="12" fill="#fff" />
                            <rect x="10" y="6" width="4" height="6" fill="#000" transform={`rotate(${rotation}, 12, 12)`} />
                        </svg>
                    </div>
                );
            };

            const tools = ['brush', 'eraser', 'bucket', 'line', 'rect', 'circle', 'text'];
            const colors = ['#000000', '#ffffff', '#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ff8800', '#8800ff'];

            return (
                <div className="h-full flex flex-col bg-gray-100 select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex flex-wrap gap-2 items-center">
                        <div className="flex gap-1">
                            <button onClick={undo} className="btn-icon" title="Undo"><Icons.Undo size={16} /></button>
                            <button onClick={redo} className="btn-icon" title="Redo"><Icons.Redo size={16} /></button>
                        </div>
                        <div className="w-px h-4 bg-black"></div>
                        <div className="flex gap-1 flex-wrap">
                            {tools.map(t => (
                                <button key={t} onClick={() => setTool(t)} className={`btn-toolbar ${tool === t ? 'active' : ''}`}>{t}</button>
                            ))}
                        </div>
                        <div className="w-px h-4 bg-black"></div>
                        <div className="flex gap-1 flex-wrap">
                            {colors.map(c => (
                                <button key={c} onClick={() => setColor(c)} className={`w-5 h-5 border border-black ${color === c ? 'ring-2 ring-offset-1 ring-black' : ''}`} style={{ backgroundColor: c }} />
                            ))}
                        </div>
                        <div className="w-px h-4 bg-black"></div>
                        <div className="flex items-center gap-1">
                            <PixelKnob value={size} onChange={setSize} min={1} max={20} />
                            <span className="text-[10px] font-mono w-4">{size}</span>
                        </div>
                        <div className="flex-grow"></div>
                        <button onClick={send} className="btn-primary btn-sm flex items-center gap-1"><Icons.Send size={12} /> SEND</button>
                    </div>
                    <div className="flex-grow relative cursor-crosshair bg-gray-300 p-[2px] overflow-hidden" ref={containerRef}>
                        <canvas
                            ref={canvasRef}
                            onMouseDown={startDraw}
                            onMouseMove={draw}
                            onMouseUp={endDraw}
                            onMouseLeave={endDraw}
                            onTouchStart={handleTouchStart}
                            onTouchMove={handleTouchMove}
                            onTouchEnd={handleTouchEnd}
                            className="block bg-white border border-gray-400 touch-none"
                            style={{ width: '100%', height: '100%' }}
                        />
                        {showTextInput && (
                            <div className="absolute top-2 left-2 bg-white border-2 border-black p-2 flex gap-2">
                                <input
                                    type="text"
                                    value={textInput}
                                    onChange={(e) => setTextInput(e.target.value)}
                                    onKeyDown={(e) => e.key === 'Enter' && placeText()}
                                    placeholder="Type text..."
                                    className="border border-black px-2 py-1 text-xs font-mono"
                                    autoFocus
                                />
                                <button onClick={placeText} className="btn-primary btn-xs">OK</button>
                            </div>
                        )}
                        <div className="absolute bottom-1 left-1 bg-black text-white text-[10px] px-2 font-mono">{status}</div>
                    </div>
                </div>
            )
        }

        const FileExplorer = () => {
            const [selectedFolder, setSelectedFolder] = useState(null);

            const folders = [
                { key: 'CINEMA_TV', name: 'TV', icon: 'Movies' },
                { key: 'LITERATURE', name: 'BOOKS', icon: 'Books' },
                { key: 'GAMES', name: 'GAMES', icon: 'Games' },
                { key: 'AUDIO', name: 'MUSIC', icon: 'Music' }
            ];

            if (selectedFolder) {
                const FolderIcon = Icons[folders.find(f => f.key === selectedFolder)?.icon || 'Folder'];
                return (
                    <div className="h-full flex flex-col bg-white select-none">
                        <div className="p-2 border-b-2 border-black bg-white flex items-center gap-3">
                            <button onClick={() => setSelectedFolder(null)} className="p-1 border-2 border-black hover:bg-black hover:text-white">
                                <Icons.Back size={16} />
                            </button>
                            <FolderIcon size={24} />
                            <span className="font-mono text-xs font-bold uppercase">{folders.find(f => f.key === selectedFolder)?.name}</span>
                            <span className="app-footer-text">({MEDIA_DB[selectedFolder].length} ITEMS)</span>
                        </div>
                        <div className="flex-grow overflow-auto">
                            <table className="w-full text-left border-collapse">
                                <thead className="bg-black text-white text-xs font-mono sticky top-0">
                                    <tr><th className="p-2">TITLE</th><th className="p-2 border-l border-gray-600">NOTE</th></tr>
                                </thead>
                                <tbody className="font-mono text-xs">
                                    {MEDIA_DB[selectedFolder].map((i, idx) => (
                                        <tr key={idx} className="border-b border-gray-200 hover:bg-yellow-100">
                                            <td className="p-2 font-bold">{i.title}</td>
                                            <td className="p-2 border-l border-gray-200">{i.rating || i.artist}</td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                        <div className="app-footer">
                            <span className="app-footer-text">CLICK TO VIEW • HOVER TO PREVIEW</span>
                        </div>
                    </div>
                );
            }

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex items-center gap-2">
                        <Icons.Folder size={24} />
                        <span className="app-header-title">MEDIA_LIB</span>
                        <span className="app-footer-text">/ROOT/MEDIA</span>
                    </div>
                    <div className="flex-grow p-6 flex items-start justify-center bg-gray-50">
                        <div className="grid grid-cols-4 gap-8">
                            {folders.map(folder => {
                                const FolderIcon = Icons[folder.icon];
                                return (
                                    <button
                                        key={folder.key}
                                        onClick={() => setSelectedFolder(folder.key)}
                                        className="group flex flex-col items-center gap-2 p-4 hover:bg-white border-2 border-transparent hover:border-black transition-all"
                                    >
                                        <div className="bg-white border-2 border-black p-3 icon-shadow group-hover:translate-x-1 group-hover:translate-y-1 group-hover:shadow-none transition-all">
                                            <FolderIcon size={48} />
                                        </div>
                                        <span className="font-mono text-xs font-bold uppercase">{folder.name}</span>
                                        <span className="app-footer-text">{MEDIA_DB[folder.key].length} ITEMS</span>
                                    </button>
                                );
                            })}
                        </div>
                    </div>
                    <div className="app-footer">
                        <span className="app-footer-text">MOVIES • BOOKS • GAMES • MUSIC</span>
                    </div>
                </div>
            );
        }

        const SystemInfo = () => (
            <div className="p-6 md:p-12 font-sans select-text">
                <header className="mb-12 border-b-4 border-black pb-8">
                    <h1 className="text-6xl md:text-8xl font-black uppercase tracking-tighter leading-none">Mateus<br />Muste</h1>
                    <div className="mt-4 flex flex-wrap gap-4 font-mono text-sm">
                        <span className="bg-black text-white px-2 py-1">DIGITAL DESIGNER</span>
                        <span className="bg-black text-white px-2 py-1">RADICAL OPTIMIST</span>
                        <span className="border border-black px-2 py-1">ROMANIA</span>
                    </div>
                </header>
                <div className="grid md:grid-cols-2 gap-12">
                    <div className="space-y-8">
                        <section>
                            <h3 className="text-2xl font-black uppercase mb-4 border-b-2 border-black">App Stack</h3>
                            <div className="grid grid-cols-4 gap-1">
                                {[
                                    { name: 'PHOTOSHOP', yrs: 9 },
                                    { name: 'PREMIERE', yrs: 8 },
                                    { name: 'AFTER EFFECTS', yrs: 6 },
                                    { name: 'EXCEL', yrs: 5 },
                                    { name: 'META ADS', yrs: 5 },
                                    { name: 'DAVINCI', yrs: 4 },
                                    { name: 'ARCHICAD', yrs: 3 },
                                    { name: 'SQUARESPACE', yrs: 3 },
                                    { name: 'UNREAL', yrs: 3 },
                                    { name: 'WEBFLOW', yrs: 3 },
                                    { name: 'MIDJOURNEY', yrs: 2 },
                                    { name: 'GOOGLE ADS', yrs: 2 },
                                    { name: 'BLENDER', yrs: 1 },
                                    { name: 'CURSOR', yrs: 1 },
                                    { name: 'COMFYUI', yrs: 1 },
                                    { name: 'N8N', yrs: 1 }
                                ].map((app, i, arr) => (
                                    <div
                                        key={i}
                                        className="border-2 border-black aspect-square flex flex-col items-center justify-center p-1 cursor-default"
                                        style={{ opacity: 1 - (i / (arr.length - 1)) * 0.66 }}
                                    >
                                        <span className="font-black text-[8px] text-center leading-tight">{app.name}</span>
                                        <span className="font-mono text-[8px] mt-1">{app.yrs} YRS</span>
                                    </div>
                                ))}
                            </div>
                        </section>
                        <section><h3 className="text-2xl font-black uppercase mb-4 border-b-2 border-black">Metrics</h3>
                            <div className="flex gap-4">
                                <div className="p-4 border-2 border-black text-center"><div className="text-3xl font-black">C2</div><div className="font-mono text-[10px]">CAMBRIDGE</div></div>
                                <div className="p-4 border-2 border-black text-center"><div className="text-3xl font-black">1570</div><div className="font-mono text-[10px]">SAT</div></div>
                            </div>
                        </section>
                    </div>
                    <div className="space-y-4">
                        <h3 className="text-2xl font-black uppercase mb-4 border-b-2 border-black">Projects</h3>
                        {[
                            { t: "BIOBUILDS", num: "01", s: "Web / Video / Marketing", d: "Sustainable construction across Europe. Entered 3 markets." },
                            { t: "ROMANIA OLYMPICS 2024", num: "02", s: "Premiere / After Effects", d: "National contest winner. Cluj-Napoca." },
                            { t: "ULT", num: "03", s: "Documentary / Editing", d: "Self-directed channel. Skill laboratory." }
                        ].map((p, i) => (
                            <div key={i} className="group border-2 border-black p-4 hover:bg-black hover:text-white cursor-pointer">
                                <div className="flex justify-between mb-1"><h4 className="font-bold uppercase">{p.t}</h4><span className="font-mono text-xs">{p.num}</span></div>
                                <p className="font-mono text-xs opacity-70 mb-1">{p.s}</p><p className="text-sm italic">{p.d}</p>
                            </div>
                        ))}
                    </div>
                </div>
            </div>
        )

        const TrashApp = () => {
            const [shakingFile, setShakingFile] = useState(null);

            const trashFiles = [
                { name: 'MY_BITCOIN_WALLET.txt', icon: 'FileDoc' },
                { name: 'sleep_schedule.ics', icon: 'FileDoc' },
                { name: 'NYU_acceptance_letter.pdf', icon: 'FileDoc' }
            ];

            const handleFileClick = (fileName) => {
                setShakingFile(fileName);
                setTimeout(() => setShakingFile(null), 500);
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-3 border-b-2 border-black bg-gray-50 flex items-center gap-2">
                        <Icons.TrashCan size={24} />
                        <span className="font-mono text-sm font-bold uppercase">RECYCLE BIN</span>
                        <span className="font-mono text-xs text-gray-400">({trashFiles.length} items)</span>
                    </div>
                    <div className="flex-grow p-6">
                        <div className="grid grid-cols-3 gap-6">
                            {trashFiles.map(file => (
                                <button
                                    key={file.name}
                                    onClick={() => handleFileClick(file.name)}
                                    className="group flex flex-col items-center gap-2 p-4 cursor-not-allowed"
                                    style={{
                                        animation: shakingFile === file.name ? 'shake 0.5s ease-in-out' : 'none'
                                    }}
                                >
                                    <div className="bg-white border-2 border-black p-3 icon-shadow opacity-50">
                                        <Icons.FileDoc size={32} />
                                    </div>
                                    <span className="font-mono text-[10px] font-bold text-center break-all opacity-70">{file.name}</span>
                                </button>
                            ))}
                        </div>
                        <div className="mt-8 p-4 border-2 border-dashed border-gray-300 text-center">
                            <span className="font-mono text-xs text-gray-400">ITEMS CANNOT BE RECOVERED</span>
                        </div>
                    </div>
                    <style>{`
                        @keyframes shake {
                            0%, 100% { transform: translateX(0); }
                            10%, 30%, 50%, 70%, 90% { transform: translateX(-4px); }
                            20%, 40%, 60%, 80% { transform: translateX(4px); }
                        }
                    `}</style>
                </div>
            );
        }

        // --- VOID.TXT - Text encrypts then fades into the void ---
        const VoidApp = () => {
            // Each char: { id, char, timestamp, phase: 'visible'|'encrypting'|'fading', opacity }
            const [chars, setChars] = useState([]);
            const inputRef = useRef(null);
            const charIdRef = useRef(0);

            const encryptChar = () => {
                const symbols = '▓▒░█▄▀■□●○◆◇★☆@#$%&*';
                return symbols[Math.floor(Math.random() * symbols.length)];
            };

            // Process loop - runs every 50ms to update char states
            useEffect(() => {
                const interval = setInterval(() => {
                    const now = Date.now();
                    setChars(prev => {
                        let updated = false;
                        const newChars = prev.map(c => {
                            // After 1.5s, start encrypting
                            if (c.phase === 'visible' && now - c.timestamp >= 1500) {
                                updated = true;
                                return { ...c, phase: 'encrypting', displayChar: encryptChar() };
                            }
                            // After encrypting for 300ms, start fading
                            if (c.phase === 'encrypting' && now - c.timestamp >= 1800) {
                                updated = true;
                                return { ...c, phase: 'fading', opacity: 0.8 };
                            }
                            // Fade out
                            if (c.phase === 'fading') {
                                const newOpacity = c.opacity - 0.15;
                                if (newOpacity <= 0) {
                                    updated = true;
                                    return null; // Mark for removal
                                }
                                updated = true;
                                return { ...c, opacity: newOpacity, displayChar: encryptChar() };
                            }
                            return c;
                        }).filter(Boolean);
                        return updated ? newChars : prev;
                    });
                }, 50);
                return () => clearInterval(interval);
            }, []);

            const handleKeyDown = (e) => {
                if (e.key === 'Backspace') {
                    // Remove most recent visible char
                    setChars(prev => {
                        const visibleChars = prev.filter(c => c.phase === 'visible');
                        if (visibleChars.length === 0) return prev;
                        const lastVisible = visibleChars[visibleChars.length - 1];
                        return prev.filter(c => c.id !== lastVisible.id);
                    });
                    e.preventDefault();
                } else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
                    // Add new character
                    const newChar = {
                        id: charIdRef.current++,
                        char: e.key,
                        displayChar: e.key,
                        timestamp: Date.now(),
                        phase: 'visible',
                        opacity: 1
                    };
                    setChars(prev => [...prev, newChar]);
                    e.preventDefault();
                }
            };

            // Render chars grouped - visible chars are white, encrypting are green
            const renderChars = () => {
                return chars.map(c => (
                    <span
                        key={c.id}
                        style={{
                            color: c.phase === 'encrypting' ? '#0f0' :
                                c.phase === 'fading' ? `rgba(0,255,0,${c.opacity})` : 'white',
                            textShadow: c.phase !== 'visible' ? '0 0 5px #0f0' : 'none'
                        }}
                    >
                        {c.displayChar}
                    </span>
                ));
            };

            return (
                <div
                    className="h-full flex flex-col bg-black select-none cursor-text"
                    onClick={() => inputRef.current?.focus()}
                    onCopy={(e) => e.preventDefault()}
                    onCut={(e) => e.preventDefault()}
                >
                    <div className="p-2 border-b border-gray-800 bg-black flex justify-between items-center">
                        <span className="font-mono text-xs font-bold text-white">VOID.TXT</span>
                        <span className="font-mono text-[10px] text-gray-600">NO SAVE // NO COPY // JUST VOID</span>
                    </div>
                    <div className="flex-grow p-4 overflow-auto font-mono text-sm">
                        <div className="flex flex-wrap items-start">
                            <span className="mr-2 text-gray-600">{'>'}</span>
                            <div className="flex-grow">
                                {renderChars()}
                                <span className="animate-pulse text-white">_</span>
                            </div>
                        </div>
                        <input
                            ref={inputRef}
                            type="text"
                            className="absolute opacity-0 pointer-events-none"
                            onKeyDown={handleKeyDown}
                            onPaste={(e) => e.preventDefault()}
                            autoFocus
                        />
                    </div>
                    <div className="p-2 border-t border-gray-800 bg-black text-center">
                        <span className="font-mono text-[10px] text-gray-600">TYPE INTO THE VOID. WATCH IT DISAPPEAR BEHIND YOU.</span>
                    </div>
                </div>
            );
        };

        // --- ORACLE.EXE - Philosophical quotes ---
        const OracleApp = () => {
            const quotes = [
                "The soul is healed by being with children.",
                "Man is condemned to be free.",
                "He who has a why to live can bear almost any how.",
                "The question isn't who is going to let me; it's who is going to stop me.",
                "One must imagine Sisyphus happy.",
                "Pain and suffering are always inevitable for a large intelligence and a deep heart.",
                "God is dead. God remains dead. And we have killed him.",
                "I swear by my life and my love of it that I will never live for the sake of another man.",
                "In the depth of winter, I finally learned that within me there lay an invincible summer.",
                "The higher we soar the smaller we appear to those who cannot fly.",
                "The soul that sees beauty may sometimes walk alone.",
                "Should I kill myself, or have a cup of coffee?",
                "To live is to suffer, to survive is to find some meaning in the suffering.",
                "The only thing I know is that I know nothing.",
                "Beauty will save the world.",
                "There is always some madness in love. But there is also always some reason in madness.",
                "Man is the only creature who refuses to be what he is.",
                "A is A. A thing is itself.",
                "What does not kill me makes me stronger.",
                "The absurd is born of the confrontation between the human call and the unreasonable silence of the world.",
                "The best way to find yourself is to lose yourself in the service of others.",
                "Every deep thinker is more afraid of being understood than of being misunderstood.",
                "Money is only a tool. It will take you wherever you wish, but it will not replace you as the driver.",
                "We are all in the gutter, but some of us are looking at the stars.",
                "The only way to deal with an unfree world is to become so absolutely free that your very existence is an act of rebellion.",
                "Above all, don't lie to yourself.",
                "Whoever fights monsters should see to it that in the process he does not become a monster.",
                "I rebel; therefore I exist.",
                "The secret of happiness is freedom, the secret of freedom is courage.",
                "There is but one truly serious philosophical problem, and that is suicide."
            ];

            const [question, setQuestion] = useState('');
            const [answer, setAnswer] = useState(null);
            const [isThinking, setIsThinking] = useState(false);

            const askOracle = () => {
                if (!question.trim()) return;
                setIsThinking(true);
                setAnswer(null);

                setTimeout(() => {
                    const randomQuote = quotes[Math.floor(Math.random() * quotes.length)];
                    setAnswer(randomQuote);
                    setIsThinking(false);
                    setQuestion('');
                }, 1500 + Math.random() * 1000);
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="app-header">
                        <span className="app-header-title">ORACLE.EXE</span>
                        <span className="app-footer-text">ASK THE DEAD</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-8 bg-gray-50">
                        {answer && (
                            <div className="mb-8 text-center max-w-lg">
                                <div className="text-xl font-serif italic leading-relaxed mb-4 text-black">"{answer}"</div>
                                <div className="text-xs text-gray-500 font-mono">— THE ORACLE HAS SPOKEN</div>
                            </div>
                        )}
                        {isThinking && (
                            <div className="mb-8 text-center">
                                <div className="font-mono text-sm text-gray-500 animate-pulse">
                                    CONSULTING THE VOID...
                                </div>
                            </div>
                        )}
                        <div className="w-full max-w-md">
                            <input
                                type="text"
                                value={question}
                                onChange={(e) => setQuestion(e.target.value)}
                                onKeyDown={(e) => e.key === 'Enter' && askOracle()}
                                placeholder="ASK YOUR QUESTION..."
                                className="w-full bg-white border-2 border-black px-4 py-3 font-mono text-sm text-black placeholder-gray-400 focus:ring-2 focus:ring-black outline-none"
                                disabled={isThinking}
                            />
                            <button
                                onClick={askOracle}
                                disabled={isThinking}
                                className="btn-primary btn-full mt-2"
                            >
                                SEEK TRUTH
                            </button>
                        </div>
                    </div>
                    <div className="app-footer">
                        <span className="app-footer-text">DOSTOEVSKY • NIETZSCHE • RAND • CAMUS</span>
                    </div>
                </div>
            );
        };

        // --- RADIO.WAV - Playlist link ---
        const RadioApp = () => {
            const [isPlaying, setIsPlaying] = useState(false);
            const [visualizer, setVisualizer] = useState([]);

            useEffect(() => {
                const interval = setInterval(() => {
                    if (isPlaying) {
                        setVisualizer(Array(16).fill(0).map(() => Math.random() * 100));
                    }
                }, 100);
                return () => clearInterval(interval);
            }, [isPlaying]);

            const openPlaylist = () => {
                window.open('https://music.youtube.com/playlist?list=PLeIQRsOWZUhKaD53FTvwZCxsNWzjq0lfO&si=92O5A6kAPjk8Vzmg', '_blank');
                setIsPlaying(true);
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="app-header">
                        <span className="app-header-title">RADIO.WAV</span>
                        <span className="app-footer-text">MATEUS_PLAYLIST</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-8 bg-gray-50">
                        <div className="flex items-end justify-center gap-1 h-32 mb-8 p-4 border-2 border-black bg-white">
                            {(isPlaying ? visualizer : Array(16).fill(10)).map((h, i) => (
                                <div
                                    key={i}
                                    className="w-3 bg-black transition-all duration-100"
                                    style={{ height: `${h}%`, minHeight: '4px' }}
                                />
                            ))}
                        </div>
                        <button
                            onClick={openPlaylist}
                            className="btn-primary btn-lg"
                        >
                            {isPlaying ? '► NOW PLAYING' : '► TUNE IN'}
                        </button>
                        <div className="mt-4 font-mono text-xs text-gray-500">
                            OPENS YOUTUBE MUSIC
                        </div>
                    </div>
                    <div className="p-2 border-t-2 border-black bg-white">
                        <div className="font-mono text-[10px] text-gray-500 text-center">
                            BROADCASTING FROM THE VOID
                        </div>
                    </div>
                </div>
            );
        };

        // --- DICE.EXE - D20 Roller with Three.js ---
        const DiceApp = () => {
            const [result, setResult] = useState(null);
            const [isRolling, setIsRolling] = useState(false);
            const containerRef = useRef(null);
            const sceneRef = useRef(null);
            const diceRef = useRef(null);
            const animationRef = useRef(null);

            const getResultStyle = () => {
                if (!result) return '';
                if (result === 20) return 'bg-black text-white';
                if (result === 1) return 'border-2 border-black';
                return '';
            };

            // Initialize Three.js scene
            useEffect(() => {
                if (!containerRef.current || sceneRef.current) return;

                const width = 200;
                const height = 200;

                // Scene
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xffffff);

                // Camera
                const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
                camera.position.z = 4;

                // Renderer
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                renderer.setPixelRatio(window.devicePixelRatio);
                containerRef.current.appendChild(renderer.domElement);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(2, 2, 2);
                scene.add(directionalLight);

                const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
                backLight.position.set(-2, -2, -2);
                scene.add(backLight);

                // D20 (Icosahedron)
                const geometry = new THREE.IcosahedronGeometry(1.2, 0);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x111111,
                    metalness: 0.1,
                    roughness: 0.4,
                    flatShading: true
                });
                const dice = new THREE.Mesh(geometry, material);
                scene.add(dice);

                // Edge lines
                const edges = new THREE.EdgesGeometry(geometry);
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0x444444 });
                const wireframe = new THREE.LineSegments(edges, lineMaterial);
                dice.add(wireframe);

                diceRef.current = dice;
                sceneRef.current = { scene, camera, renderer };

                // Initial render
                renderer.render(scene, camera);

                // Idle animation
                const idleAnimate = () => {
                    if (!isRolling) {
                        dice.rotation.x += 0.003;
                        dice.rotation.y += 0.005;
                    }
                    renderer.render(scene, camera);
                    animationRef.current = requestAnimationFrame(idleAnimate);
                };
                idleAnimate();

                return () => {
                    cancelAnimationFrame(animationRef.current);
                    renderer.dispose();
                    if (containerRef.current && renderer.domElement) {
                        containerRef.current.removeChild(renderer.domElement);
                    }
                };
            }, []);

            const rollDice = () => {
                if (isRolling || !diceRef.current || !sceneRef.current) return;
                setIsRolling(true);
                setResult(null);

                const dice = diceRef.current;
                const { renderer, scene, camera } = sceneRef.current;

                // Random target rotation
                const targetRotX = dice.rotation.x + Math.PI * (4 + Math.random() * 4);
                const targetRotY = dice.rotation.y + Math.PI * (4 + Math.random() * 4);
                const targetRotZ = dice.rotation.z + Math.PI * (2 + Math.random() * 2);

                const startRotX = dice.rotation.x;
                const startRotY = dice.rotation.y;
                const startRotZ = dice.rotation.z;

                const duration = 1500;
                const startTime = Date.now();

                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // Easing - decelerate
                    const eased = 1 - Math.pow(1 - progress, 3);

                    dice.rotation.x = startRotX + (targetRotX - startRotX) * eased;
                    dice.rotation.y = startRotY + (targetRotY - startRotY) * eased;
                    dice.rotation.z = startRotZ + (targetRotZ - startRotZ) * eased;

                    renderer.render(scene, camera);

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        setResult(Math.floor(Math.random() * 20) + 1);
                        setIsRolling(false);
                    }
                };

                animate();
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-2 border-b border-gray-200 bg-white flex justify-between items-center">
                        <span className="font-mono text-[10px] font-bold tracking-wider">DICE.EXE</span>
                        <span className="font-mono text-[10px] text-gray-400">D20</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-8 bg-white">
                        <div className="mb-8" ref={containerRef} style={{ width: 200, height: 200 }} />
                        {result && !isRolling && (
                            <div className={`font-mono text-[10px] tracking-widest mb-6 px-4 py-2 ${getResultStyle()}`}>
                                {result === 20 ? 'CRITICAL' : result === 1 ? 'FAIL' : `RESULT: ${result}`}
                            </div>
                        )}
                        <button
                            onClick={rollDice}
                            disabled={isRolling}
                            className="bg-black text-white px-6 py-2 font-mono text-[10px] tracking-widest hover:bg-gray-800 disabled:bg-gray-300 transition-colors"
                        >
                            {isRolling ? 'ROLLING' : 'ROLL'}
                        </button>
                    </div>
                    <div className="p-2 border-t border-gray-200 bg-white">
                        <div className="flex justify-between font-mono text-[10px] text-gray-400">
                            <span>20 = CRIT</span>
                            <span>1 = FAIL</span>
                        </div>
                    </div>
                </div>
            );
        };

        // --- SNEK.EXE ---
        const SnakeAppNew = () => {
            const canvasRef = useRef(null);
            const [score, setScore] = useState(0);
            const [highScore, setHighScore] = useState(() => HighScoreManager.getHighScore('snake'));
            const [gameOver, setGameOver] = useState(false);
            const [gameStarted, setGameStarted] = useState(false);
            const snake = useRef([{ x: 15, y: 10 }]);
            const food = useRef({ x: 20, y: 10 });
            const dir = useRef({ x: 1, y: 0 });
            const nextDir = useRef({ x: 1, y: 0 });
            const runningRef = useRef(false);
            const lastTimeRef = useRef(0);
            const frameRef = useRef(null);

            const GRID_W = 30;
            const GRID_H = 20;
            const CELL = 20;

            // Load high score from storage when IP is ready
            useEffect(() => {
                const loadHighScore = async () => {
                    await HighScoreManager.fetchIP();
                    setHighScore(HighScoreManager.getHighScore('snake'));
                };
                loadHighScore();
            }, []);

            const start = () => {
                snake.current = [{ x: 15, y: 10 }, { x: 14, y: 10 }, { x: 13, y: 10 }];
                dir.current = { x: 1, y: 0 };
                nextDir.current = { x: 1, y: 0 };
                food.current = { x: Math.floor(Math.random() * GRID_W), y: Math.floor(Math.random() * GRID_H) };
                setScore(0);
                setGameOver(false);
                setGameStarted(true);
                runningRef.current = true;
                lastTimeRef.current = 0;
            };

            const update = () => {
                const ctx = canvasRef.current?.getContext('2d');
                if (!ctx) return;

                dir.current = nextDir.current;
                const head = {
                    x: snake.current[0].x + dir.current.x,
                    y: snake.current[0].y + dir.current.y
                };

                // Wall collision
                if (head.x < 0 || head.x >= GRID_W || head.y < 0 || head.y >= GRID_H) {
                    endGame();
                    return;
                }

                // Self collision
                if (snake.current.some(s => s.x === head.x && s.y === head.y)) {
                    endGame();
                    return;
                }

                snake.current.unshift(head);

                // Eat food
                if (head.x === food.current.x && head.y === food.current.y) {
                    setScore(s => {
                        const newScore = s + 10;
                        setHighScore(h => {
                            const newHigh = Math.max(h, newScore);
                            HighScoreManager.saveHighScore('snake', newHigh);
                            return newHigh;
                        });
                        return newScore;
                    });
                    food.current = {
                        x: Math.floor(Math.random() * GRID_W),
                        y: Math.floor(Math.random() * GRID_H)
                    };
                } else {
                    snake.current.pop();
                }

                // Draw - light theme
                ctx.fillStyle = '#f5f5f5';
                ctx.fillRect(0, 0, GRID_W * CELL, GRID_H * CELL);

                // Grid lines (subtle)
                ctx.strokeStyle = '#e0e0e0';
                for (let i = 0; i <= GRID_W; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * CELL, 0);
                    ctx.lineTo(i * CELL, GRID_H * CELL);
                    ctx.stroke();
                }
                for (let i = 0; i <= GRID_H; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, i * CELL);
                    ctx.lineTo(GRID_W * CELL, i * CELL);
                    ctx.stroke();
                }

                // Snake - black
                snake.current.forEach((s, i) => {
                    ctx.fillStyle = i === 0 ? '#000' : '#333';
                    ctx.fillRect(s.x * CELL + 1, s.y * CELL + 1, CELL - 2, CELL - 2);
                });

                // Food - black dot
                ctx.fillStyle = '#000';
                ctx.fillRect(food.current.x * CELL + 6, food.current.y * CELL + 6, CELL - 12, CELL - 12);
            };

            const endGame = () => {
                runningRef.current = false;
                setGameOver(true);
                setGameStarted(false);
            };

            // Game loop using requestAnimationFrame
            useEffect(() => {
                const gameLoop = (timestamp) => {
                    if (!runningRef.current) {
                        frameRef.current = requestAnimationFrame(gameLoop);
                        return;
                    }

                    if (timestamp - lastTimeRef.current >= 100) {
                        lastTimeRef.current = timestamp;
                        update();
                    }

                    frameRef.current = requestAnimationFrame(gameLoop);
                };

                frameRef.current = requestAnimationFrame(gameLoop);

                return () => {
                    if (frameRef.current) cancelAnimationFrame(frameRef.current);
                };
            }, []);

            useEffect(() => {
                const handle = (e) => {
                    if (!runningRef.current) return;
                    if (e.key === 'ArrowUp' && dir.current.y === 0) nextDir.current = { x: 0, y: -1 };
                    if (e.key === 'ArrowDown' && dir.current.y === 0) nextDir.current = { x: 0, y: 1 };
                    if (e.key === 'ArrowLeft' && dir.current.x === 0) nextDir.current = { x: -1, y: 0 };
                    if (e.key === 'ArrowRight' && dir.current.x === 0) nextDir.current = { x: 1, y: 0 };
                };
                window.addEventListener('keydown', handle);
                return () => window.removeEventListener('keydown', handle);
            }, []);

            // Initial canvas draw - light theme
            useEffect(() => {
                const ctx = canvasRef.current?.getContext('2d');
                if (ctx) {
                    ctx.fillStyle = '#f5f5f5';
                    ctx.fillRect(0, 0, GRID_W * CELL, GRID_H * CELL);

                    // Draw grid lines
                    ctx.strokeStyle = '#e0e0e0';
                    for (let i = 0; i <= GRID_W; i++) {
                        ctx.beginPath();
                        ctx.moveTo(i * CELL, 0);
                        ctx.lineTo(i * CELL, GRID_H * CELL);
                        ctx.stroke();
                    }
                    for (let i = 0; i <= GRID_H; i++) {
                        ctx.beginPath();
                        ctx.moveTo(0, i * CELL);
                        ctx.lineTo(GRID_W * CELL, i * CELL);
                        ctx.stroke();
                    }
                }
            }, []);

            // Touch controls for mobile
            const handleDirection = (newDir) => {
                if (!runningRef.current) return;
                if (newDir === 'up' && dir.current.y === 0) nextDir.current = { x: 0, y: -1 };
                if (newDir === 'down' && dir.current.y === 0) nextDir.current = { x: 0, y: 1 };
                if (newDir === 'left' && dir.current.x === 0) nextDir.current = { x: -1, y: 0 };
                if (newDir === 'right' && dir.current.x === 0) nextDir.current = { x: 1, y: 0 };
            };

            // Swipe detection
            const touchStartRef = useRef({ x: 0, y: 0 });
            const handleTouchStart = (e) => {
                touchStartRef.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            };
            const handleTouchEnd = (e) => {
                if (!runningRef.current) return;
                const dx = e.changedTouches[0].clientX - touchStartRef.current.x;
                const dy = e.changedTouches[0].clientY - touchStartRef.current.y;
                if (Math.abs(dx) > Math.abs(dy)) {
                    if (dx > 30) handleDirection('right');
                    else if (dx < -30) handleDirection('left');
                } else {
                    if (dy > 30) handleDirection('down');
                    else if (dy < -30) handleDirection('up');
                }
            };

            return (
                <div className="h-full flex flex-col bg-white select-none" onTouchStart={handleTouchStart} onTouchEnd={handleTouchEnd}>
                    <div className="app-header">
                        <span className="app-header-title">SNEK.EXE</span>
                        <div className="flex gap-4 font-mono text-xs">
                            <span>SCORE: <span className="font-bold">{score}</span></span>
                            <span>HIGH: <span className="font-bold">{highScore}</span></span>
                            <span className={gameOver ? 'text-red-600' : gameStarted ? 'text-green-600' : 'text-gray-500'}>
                                {gameOver ? 'DEAD' : gameStarted ? 'ALIVE' : 'READY'}
                            </span>
                        </div>
                    </div>
                    <div className="flex-grow flex items-center justify-center p-2 md:p-4 bg-gray-50 overflow-hidden">
                        <div className="relative border-2 border-black" style={{ width: 'min(100%, 600px)', aspectRatio: '3/2' }}>
                            <canvas ref={canvasRef} width={600} height={400} className="block w-full h-full" style={{ imageRendering: 'pixelated' }} />
                            {!gameStarted && (
                                <div className="absolute inset-0 bg-white/95 flex flex-col items-center justify-center">
                                    <div className="text-4xl font-black mb-2 tracking-widest">SNEK</div>
                                    {gameOver && <p className="text-red-600 mb-4 font-mono text-sm">GAME OVER</p>}
                                    <button
                                        onClick={start}
                                        className="btn-primary"
                                    >
                                        {gameOver ? 'RETRY' : 'START'}
                                    </button>
                                    <p className="mt-4 text-gray-500 font-mono text-xs text-center px-4 hidden md:block">ARROW KEYS TO MOVE</p>
                                    <p className="mt-4 text-gray-500 font-mono text-xs text-center px-4 md:hidden">SWIPE TO MOVE</p>
                                </div>
                            )}
                        </div>
                    </div>
                    <div className="app-footer">
                        <span className="app-footer-text">EAT FOOD • GROW LONGER • DON'T DIE</span>
                    </div>
                </div>
            );
        };

        // --- LABYRINTH.EXE - Procedural Maze ---
        const LabyrinthApp = () => {
            const canvasRef = useRef(null);
            const [level, setLevel] = useState(1);
            const [score, setScore] = useState(0);
            const [highScore, setHighScore] = useState(() => HighScoreManager.getHighScore('labyrinth'));
            const [won, setWon] = useState(false);
            const [showingMaze, setShowingMaze] = useState(false);
            const mazeRef = useRef(null);
            const playerRef = useRef({ x: 1, y: 1 });
            const exitRef = useRef({ x: 0, y: 0 });

            const CELL_SIZE = 8; // Thinner walls

            // Load high score from storage when IP is ready
            useEffect(() => {
                const loadHighScore = async () => {
                    await HighScoreManager.fetchIP();
                    setHighScore(HighScoreManager.getHighScore('labyrinth'));
                };
                loadHighScore();
            }, []);

            const generateMaze = (width, height) => {
                const maze = Array(height).fill(null).map(() => Array(width).fill(1));

                const carve = (x, y) => {
                    maze[y][x] = 0;
                    const directions = [[0, -2], [0, 2], [-2, 0], [2, 0]].sort(() => Math.random() - 0.5);

                    for (const [dx, dy] of directions) {
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx > 0 && nx < width - 1 && ny > 0 && ny < height - 1 && maze[ny][nx] === 1) {
                            maze[y + dy / 2][x + dx / 2] = 0;
                            carve(nx, ny);
                        }
                    }
                };

                carve(1, 1);
                return maze;
            };

            const startLevel = (lvl) => {
                // Start big and get MUCH harder - exponential growth
                const size = 31 + Math.floor(lvl * lvl * 4);
                const cappedSize = Math.min(size, 151); // Cap at 151 for performance
                const maze = generateMaze(cappedSize | 1, cappedSize | 1);
                mazeRef.current = maze;
                playerRef.current = { x: 1, y: 1 };

                // Find exit (bottom-right area)
                for (let y = maze.length - 2; y > maze.length / 2; y--) {
                    for (let x = maze[0].length - 2; x > maze[0].length / 2; x--) {
                        if (maze[y][x] === 0) {
                            exitRef.current = { x, y };
                            break;
                        }
                    }
                    if (exitRef.current.x !== 0) break;
                }

                setWon(false);
                setShowingMaze(false);
                draw();
            };

            const draw = () => {
                const canvas = canvasRef.current;
                if (!canvas || !mazeRef.current) return;
                const ctx = canvas.getContext('2d');
                const maze = mazeRef.current;

                canvas.width = maze[0].length * CELL_SIZE;
                canvas.height = maze.length * CELL_SIZE;

                // Draw maze - clean minimal style
                for (let y = 0; y < maze.length; y++) {
                    for (let x = 0; x < maze[0].length; x++) {
                        ctx.fillStyle = maze[y][x] === 1 ? '#111' : '#fafafa';
                        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }

                // Draw exit - simple square
                const ex = exitRef.current.x * CELL_SIZE;
                const ey = exitRef.current.y * CELL_SIZE;
                ctx.fillStyle = '#fafafa';
                ctx.fillRect(ex, ey, CELL_SIZE, CELL_SIZE);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(ex + 2, ey + 2, CELL_SIZE - 4, CELL_SIZE - 4);

                // Draw player - simple filled square
                const px = playerRef.current.x * CELL_SIZE;
                const py = playerRef.current.y * CELL_SIZE;
                ctx.fillStyle = '#000';
                ctx.fillRect(px + 2, py + 2, CELL_SIZE - 4, CELL_SIZE - 4);
            };

            const move = (dx, dy) => {
                if (won || showingMaze) return;
                const maze = mazeRef.current;
                if (!maze) return;

                const nx = playerRef.current.x + dx;
                const ny = playerRef.current.y + dy;

                if (nx >= 0 && nx < maze[0].length && ny >= 0 && ny < maze.length && maze[ny][nx] === 0) {
                    playerRef.current = { x: nx, y: ny };
                    draw();

                    if (nx === exitRef.current.x && ny === exitRef.current.y) {
                        const points = level * 100;
                        setScore(s => {
                            const newScore = s + points;
                            setHighScore(h => {
                                const newHigh = Math.max(h, newScore);
                                HighScoreManager.saveHighScore('labyrinth', newHigh);
                                return newHigh;
                            });
                            return newScore;
                        });
                        setWon(true);

                        // Show full maze then start next level
                        setTimeout(() => {
                            setShowingMaze(true);
                            setTimeout(() => {
                                setLevel(l => l + 1);
                                startLevel(level + 1);
                            }, 2000);
                        }, 1000);
                    }
                }
            };

            const giveUp = () => {
                setLevel(1);
                setScore(0);
                startLevel(1);
            };

            useEffect(() => {
                const handle = (e) => {
                    if (e.key === 'ArrowUp') move(0, -1);
                    if (e.key === 'ArrowDown') move(0, 1);
                    if (e.key === 'ArrowLeft') move(-1, 0);
                    if (e.key === 'ArrowRight') move(1, 0);
                };
                window.addEventListener('keydown', handle);
                startLevel(1);
                return () => window.removeEventListener('keydown', handle);
            }, []);

            // Touch/swipe controls for mobile
            const touchStartRef = useRef({ x: 0, y: 0 });
            const handleTouchStart = (e) => {
                touchStartRef.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            };
            const handleTouchEnd = (e) => {
                const dx = e.changedTouches[0].clientX - touchStartRef.current.x;
                const dy = e.changedTouches[0].clientY - touchStartRef.current.y;
                const threshold = 20;
                if (Math.abs(dx) > Math.abs(dy)) {
                    if (dx > threshold) move(1, 0);
                    else if (dx < -threshold) move(-1, 0);
                } else {
                    if (dy > threshold) move(0, 1);
                    else if (dy < -threshold) move(0, -1);
                }
            };

            return (
                <div className="h-full flex flex-col bg-white select-none" onTouchStart={handleTouchStart} onTouchEnd={handleTouchEnd}>
                    <div className="h-8 px-3 flex justify-between items-center">
                        <span className="font-mono text-[10px] font-bold tracking-widest text-black">LABYRINTH</span>
                        <div className="flex gap-6 font-mono text-[10px]">
                            <span className="text-gray-400">LVL <span className="text-black font-bold">{level}</span></span>
                            <span className="text-gray-400">PTS <span className="text-black font-bold">{score}</span></span>
                        </div>
                    </div>
                    <div className="flex-grow flex items-center justify-center relative bg-white">
                        {won && !showingMaze && (
                            <div className="absolute inset-0 bg-white/95 flex items-center justify-center z-10">
                                <div className="text-center">
                                    <div className="text-2xl font-black tracking-widest">CLEAR</div>
                                    <div className="font-mono text-[10px] text-gray-400 mt-1">+{level * 100}</div>
                                </div>
                            </div>
                        )}
                        {showingMaze && (
                            <div className="absolute inset-0 bg-white flex items-center justify-center z-10">
                                <div className="font-mono text-[10px] text-gray-400 tracking-widest animate-pulse">
                                    GENERATING LEVEL {level}
                                </div>
                            </div>
                        )}
                        <canvas ref={canvasRef} className="block" style={{ imageRendering: 'pixelated' }} />
                    </div>
                    <div className="h-8 px-3 flex justify-between items-center">
                        <span className="font-mono text-[10px] text-gray-300 hidden md:inline">↑↓←→</span>
                        <span className="font-mono text-[10px] text-gray-300 md:hidden">SWIPE TO MOVE</span>
                        <button
                            onClick={giveUp}
                            className="font-mono text-[10px] text-gray-300 hover:text-black transition-colors"
                        >
                            RESTART
                        </button>
                    </div>
                </div>
            );
        };

        // --- MINESWEEPER.EXE - Ultra Clean Minesweeper ---
        const MinesweeperApp = () => {
            const [grid, setGrid] = useState([]);
            const [revealed, setRevealed] = useState([]);
            const [flagged, setFlagged] = useState([]);
            const [gameOver, setGameOver] = useState(false);
            const [won, setWon] = useState(false);
            const [mineCount, setMineCount] = useState(0);
            const [time, setTime] = useState(0);
            const [started, setStarted] = useState(false);
            const timerRef = useRef(null);

            const ROWS = 12;
            const COLS = 16;
            const MINES = 30;

            const initGame = () => {
                // Create empty grid
                const newGrid = Array(ROWS).fill(null).map(() => Array(COLS).fill(0));
                const newRevealed = Array(ROWS).fill(null).map(() => Array(COLS).fill(false));
                const newFlagged = Array(ROWS).fill(null).map(() => Array(COLS).fill(false));

                // Place mines
                let placed = 0;
                while (placed < MINES) {
                    const r = Math.floor(Math.random() * ROWS);
                    const c = Math.floor(Math.random() * COLS);
                    if (newGrid[r][c] !== -1) {
                        newGrid[r][c] = -1;
                        placed++;
                    }
                }

                // Calculate numbers
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (newGrid[r][c] === -1) continue;
                        let count = 0;
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                const nr = r + dr, nc = c + dc;
                                if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && newGrid[nr][nc] === -1) {
                                    count++;
                                }
                            }
                        }
                        newGrid[r][c] = count;
                    }
                }

                setGrid(newGrid);
                setRevealed(newRevealed);
                setFlagged(newFlagged);
                setGameOver(false);
                setWon(false);
                setMineCount(MINES);
                setTime(0);
                setStarted(false);
                if (timerRef.current) clearInterval(timerRef.current);
            };

            useEffect(() => {
                initGame();
                return () => { if (timerRef.current) clearInterval(timerRef.current); };
            }, []);

            useEffect(() => {
                if (started && !gameOver && !won) {
                    timerRef.current = setInterval(() => setTime(t => t + 1), 1000);
                }
                return () => { if (timerRef.current) clearInterval(timerRef.current); };
            }, [started, gameOver, won]);

            const reveal = (r, c) => {
                if (gameOver || won || revealed[r][c] || flagged[r][c]) return;

                if (!started) setStarted(true);

                const newRevealed = revealed.map(row => [...row]);

                if (grid[r][c] === -1) {
                    // Hit mine - reveal all mines
                    for (let i = 0; i < ROWS; i++) {
                        for (let j = 0; j < COLS; j++) {
                            if (grid[i][j] === -1) newRevealed[i][j] = true;
                        }
                    }
                    setRevealed(newRevealed);
                    setGameOver(true);
                    return;
                }

                // Flood fill for empty cells
                const flood = (row, col) => {
                    if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return;
                    if (newRevealed[row][col] || flagged[row][col]) return;
                    newRevealed[row][col] = true;
                    if (grid[row][col] === 0) {
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                flood(row + dr, col + dc);
                            }
                        }
                    }
                };

                flood(r, c);
                setRevealed(newRevealed);

                // Check win
                let unrevealed = 0;
                for (let i = 0; i < ROWS; i++) {
                    for (let j = 0; j < COLS; j++) {
                        if (!newRevealed[i][j]) unrevealed++;
                    }
                }
                if (unrevealed === MINES) setWon(true);
            };

            const flag = (e, r, c) => {
                e.preventDefault();
                if (gameOver || won || revealed[r][c]) return;
                if (!started) setStarted(true);

                const newFlagged = flagged.map(row => [...row]);
                newFlagged[r][c] = !newFlagged[r][c];
                setFlagged(newFlagged);
                setMineCount(m => newFlagged[r][c] ? m - 1 : m + 1);
            };

            const getCellContent = (r, c) => {
                if (flagged[r][c]) return '⚑';
                if (!revealed[r][c]) return '';
                if (grid[r][c] === -1) return '●';
                if (grid[r][c] === 0) return '';
                return grid[r][c];
            };

            const getCellStyle = (r, c) => {
                if (flagged[r][c]) return 'bg-gray-100 text-black';
                if (!revealed[r][c]) return 'bg-gray-200 hover:bg-gray-300';
                if (grid[r][c] === -1) return 'bg-black text-white';
                return 'bg-white text-black';
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="h-10 px-4 flex justify-between items-center border-b border-gray-100">
                        <span className="font-mono text-[10px] font-bold tracking-widest text-black">MINESWEEPER</span>
                        <div className="flex gap-8 font-mono text-[10px]">
                            <span className="text-gray-400">MINES <span className="text-black font-bold">{mineCount.toString().padStart(3, '0')}</span></span>
                            <span className="text-gray-400">TIME <span className="text-black font-bold">{time.toString().padStart(3, '0')}</span></span>
                        </div>
                    </div>

                    <div className="flex-grow flex items-center justify-center relative bg-gray-50 p-4">
                        {(gameOver || won) && (
                            <div className="absolute inset-0 bg-white/95 flex items-center justify-center z-10">
                                <div className="text-center">
                                    <div className="text-2xl font-black tracking-widest">{won ? 'CLEARED' : 'DETONATED'}</div>
                                    <div className="font-mono text-[10px] text-gray-400 mt-2">{time}s</div>
                                    <button
                                        onClick={initGame}
                                        className="mt-4 px-4 py-2 bg-black text-white font-mono text-[10px] tracking-widest hover:bg-gray-800"
                                    >
                                        RETRY
                                    </button>
                                </div>
                            </div>
                        )}

                        <div className="border border-gray-200">
                            {grid.map((row, r) => (
                                <div key={r} className="flex">
                                    {row.map((cell, c) => (
                                        <button
                                            key={c}
                                            onClick={() => reveal(r, c)}
                                            onContextMenu={(e) => flag(e, r, c)}
                                            className={`w-6 h-6 border border-gray-100 font-mono text-[10px] font-bold flex items-center justify-center transition-colors ${getCellStyle(r, c)}`}
                                        >
                                            {getCellContent(r, c)}
                                        </button>
                                    ))}
                                </div>
                            ))}
                        </div>
                    </div>

                    <div className="h-8 px-4 flex justify-between items-center border-t border-gray-100">
                        <span className="font-mono text-[10px] text-gray-300">LEFT CLICK REVEAL · RIGHT CLICK FLAG</span>
                        <button
                            onClick={initGame}
                            className="font-mono text-[10px] text-gray-300 hover:text-black transition-colors"
                        >
                            NEW GAME
                        </button>
                    </div>
                </div>
            );
        };

        // --- STARSHIP.EXE - Low Poly Star Fox Style Game ---
        const StarshipApp = () => {
            const containerRef = useRef(null);
            const gameRef = useRef(null);
            const keysRef = useRef({ left: false, right: false, up: false, down: false, shoot: false });
            const touchRef = useRef({ startX: 0, startY: 0, startTime: 0, isDragging: false });
            const [score, setScore] = useState(0);
            const [highScore, setHighScore] = useState(() => HighScoreManager.getHighScore('starship'));
            const [gameOver, setGameOver] = useState(false);
            const [started, setStarted] = useState(false);

            // Load high score from storage when IP is ready
            useEffect(() => {
                const loadHighScore = async () => {
                    await HighScoreManager.fetchIP();
                    setHighScore(HighScoreManager.getHighScore('starship'));
                };
                loadHighScore();
            }, []);

            // Mobile control handlers
            const handleStart = () => {
                if (gameRef.current) {
                    if (gameOver) gameRef.current.restart();
                    else gameRef.current.start();
                }
            };

            // Touch-based drag controls
            const handleTouchStart = (e) => {
                const touch = e.touches[0];
                touchRef.current = {
                    startX: touch.clientX,
                    startY: touch.clientY,
                    startTime: Date.now(),
                    isDragging: false
                };
            };

            const handleTouchMove = (e) => {
                if (!started || gameOver) return;
                e.preventDefault();
                const touch = e.touches[0];
                const dx = touch.clientX - touchRef.current.startX;
                const dy = touch.clientY - touchRef.current.startY;
                touchRef.current.isDragging = true;

                // Set movement based on drag position (relative to start)
                const threshold = 20;
                keysRef.current.left = dx < -threshold;
                keysRef.current.right = dx > threshold;
                keysRef.current.up = dy < -threshold;
                keysRef.current.down = dy > threshold;
            };

            const handleTouchEnd = (e) => {
                // Reset all movement
                keysRef.current.left = false;
                keysRef.current.right = false;
                keysRef.current.up = false;
                keysRef.current.down = false;

                // Tap to shoot (short touch without much movement)
                const elapsed = Date.now() - touchRef.current.startTime;
                if (elapsed < 200 && !touchRef.current.isDragging) {
                    if (!started && !gameOver) {
                        handleStart();
                    } else if (gameRef.current && started && !gameOver) {
                        gameRef.current.shoot();
                    }
                }
            };

            useEffect(() => {
                if (!containerRef.current || gameRef.current) return;

                const width = 500;
                const height = 350;

                // Scene
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xffffff);
                scene.fog = new THREE.Fog(0xffffff, 20, 80);

                // Camera
                const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
                camera.position.set(0, 2, 0);
                camera.lookAt(0, 0, -20);

                // Renderer
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                containerRef.current.appendChild(renderer.domElement);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
                scene.add(ambientLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(5, 10, 5);
                scene.add(dirLight);

                // Create low-poly ship
                const createShip = () => {
                    const group = new THREE.Group();

                    // Main body - elongated pyramid
                    const bodyGeo = new THREE.ConeGeometry(0.3, 1.2, 4);
                    bodyGeo.rotateX(Math.PI / 2);
                    const bodyMat = new THREE.MeshStandardMaterial({ color: 0x000000, flatShading: true });
                    const body = new THREE.Mesh(bodyGeo, bodyMat);
                    group.add(body);

                    // Wings
                    const wingGeo = new THREE.BoxGeometry(1.8, 0.05, 0.4);
                    const wingMat = new THREE.MeshStandardMaterial({ color: 0x111111, flatShading: true });
                    const wings = new THREE.Mesh(wingGeo, wingMat);
                    wings.position.z = 0.2;
                    group.add(wings);

                    // Tail fins
                    const tailGeo = new THREE.BoxGeometry(0.05, 0.4, 0.3);
                    const tail1 = new THREE.Mesh(tailGeo, wingMat);
                    tail1.position.set(0, 0.15, 0.4);
                    group.add(tail1);

                    // Edges
                    const edges = new THREE.EdgesGeometry(bodyGeo);
                    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x444444 }));
                    group.add(line);

                    return group;
                };

                const ship = createShip();
                ship.position.set(0, 0, -5);
                scene.add(ship);

                // Ground grid
                const gridSize = 100;
                const gridGeo = new THREE.PlaneGeometry(gridSize, gridSize, 20, 20);
                gridGeo.rotateX(-Math.PI / 2);
                const gridMat = new THREE.MeshBasicMaterial({ color: 0xeeeeee, wireframe: true });
                const grid = new THREE.Mesh(gridGeo, gridMat);
                grid.position.y = -3;
                scene.add(grid);

                // Obstacles array
                const obstacles = [];
                const lasers = [];

                const createObstacle = () => {
                    const types = ['asteroid', 'enemy'];
                    const type = types[Math.floor(Math.random() * types.length)];
                    let mesh;

                    if (type === 'asteroid') {
                        const geo = new THREE.IcosahedronGeometry(0.5 + Math.random() * 0.5, 0);
                        const mat = new THREE.MeshStandardMaterial({ color: 0x222222, flatShading: true });
                        mesh = new THREE.Mesh(geo, mat);
                        const edges = new THREE.EdgesGeometry(geo);
                        mesh.add(new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 })));
                    } else {
                        const geo = new THREE.OctahedronGeometry(0.4, 0);
                        const mat = new THREE.MeshStandardMaterial({ color: 0x000000, flatShading: true });
                        mesh = new THREE.Mesh(geo, mat);
                        const edges = new THREE.EdgesGeometry(geo);
                        mesh.add(new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x666666 })));
                    }

                    mesh.position.set(
                        (Math.random() - 0.5) * 8,
                        (Math.random() - 0.5) * 4,
                        -60 - Math.random() * 20
                    );
                    mesh.userData = { type, speed: 0.3 + Math.random() * 0.2 };
                    scene.add(mesh);
                    obstacles.push(mesh);
                };

                const createLaser = () => {
                    const geo = new THREE.BoxGeometry(0.05, 0.05, 0.8);
                    const mat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                    const laser = new THREE.Mesh(geo, mat);
                    laser.position.copy(ship.position);
                    laser.position.z -= 0.8;
                    scene.add(laser);
                    lasers.push(laser);
                };

                // Controls - using ref so mobile can update too
                const keys = keysRef.current;
                let canShoot = true;
                let scoreVal = 0;
                let isGameOver = false;
                let isStarted = false;

                const doShoot = () => {
                    if (canShoot && isStarted && !isGameOver) {
                        createLaser();
                        canShoot = false;
                        setTimeout(() => canShoot = true, 150);
                    }
                };

                const onKeyDown = (e) => {
                    if (!isStarted && e.code === 'Space') {
                        isStarted = true;
                        setStarted(true);
                        return;
                    }
                    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
                    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
                    if (e.code === 'ArrowUp' || e.code === 'KeyW') keys.up = true;
                    if (e.code === 'ArrowDown' || e.code === 'KeyS') keys.down = true;
                    if (e.code === 'Space') doShoot();
                };
                const onKeyUp = (e) => {
                    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
                    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
                    if (e.code === 'ArrowUp' || e.code === 'KeyW') keys.up = false;
                    if (e.code === 'ArrowDown' || e.code === 'KeyS') keys.down = false;
                };

                window.addEventListener('keydown', onKeyDown);
                window.addEventListener('keyup', onKeyUp);

                // Spawn obstacles
                let spawnTimer = 0;

                // Animation loop
                let animationId;
                const animate = () => {
                    animationId = requestAnimationFrame(animate);

                    if (!isStarted || isGameOver) {
                        ship.rotation.z = Math.sin(Date.now() * 0.002) * 0.1;
                        renderer.render(scene, camera);
                        return;
                    }

                    // Move ship
                    const moveSpeed = 0.12;
                    if (keys.left) ship.position.x -= moveSpeed;
                    if (keys.right) ship.position.x += moveSpeed;
                    if (keys.up) ship.position.y += moveSpeed;
                    if (keys.down) ship.position.y -= moveSpeed;

                    // Clamp ship position
                    ship.position.x = Math.max(-4, Math.min(4, ship.position.x));
                    ship.position.y = Math.max(-2, Math.min(2, ship.position.y));

                    // Tilt ship based on movement
                    ship.rotation.z = -keys.left * 0.3 + keys.right * 0.3;
                    ship.rotation.x = keys.down * 0.2 - keys.up * 0.2;

                    // Move grid for speed effect
                    grid.position.z = (grid.position.z + 0.5) % 5;

                    // Spawn obstacles
                    spawnTimer++;
                    if (spawnTimer > 30) {
                        createObstacle();
                        spawnTimer = 0;
                    }

                    // Update obstacles
                    for (let i = obstacles.length - 1; i >= 0; i--) {
                        const obs = obstacles[i];
                        obs.position.z += obs.userData.speed;
                        obs.rotation.x += 0.02;
                        obs.rotation.y += 0.01;

                        // Remove if passed
                        if (obs.position.z > 5) {
                            scene.remove(obs);
                            obstacles.splice(i, 1);
                            scoreVal += 10;
                            setScore(scoreVal);
                        }

                        // Collision with ship
                        const dist = ship.position.distanceTo(obs.position);
                        if (dist < 1) {
                            isGameOver = true;
                            setGameOver(true);
                            // Save high score on game over
                            setHighScore(h => {
                                const newHigh = Math.max(h, scoreVal);
                                HighScoreManager.saveHighScore('starship', newHigh);
                                return newHigh;
                            });
                        }
                    }

                    // Update lasers
                    for (let i = lasers.length - 1; i >= 0; i--) {
                        const laser = lasers[i];
                        laser.position.z -= 1.5;

                        // Remove if too far
                        if (laser.position.z < -80) {
                            scene.remove(laser);
                            lasers.splice(i, 1);
                            continue;
                        }

                        // Check collision with obstacles
                        for (let j = obstacles.length - 1; j >= 0; j--) {
                            const obs = obstacles[j];
                            if (laser.position.distanceTo(obs.position) < 0.8) {
                                scene.remove(laser);
                                scene.remove(obs);
                                lasers.splice(i, 1);
                                obstacles.splice(j, 1);
                                scoreVal += 50;
                                setScore(scoreVal);
                                break;
                            }
                        }
                    }

                    renderer.render(scene, camera);
                };
                animate();

                gameRef.current = {
                    restart: () => {
                        obstacles.forEach(o => scene.remove(o));
                        lasers.forEach(l => scene.remove(l));
                        obstacles.length = 0;
                        lasers.length = 0;
                        ship.position.set(0, 0, -5);
                        scoreVal = 0;
                        isGameOver = false;
                        isStarted = true;
                        setScore(0);
                        setGameOver(false);
                        setStarted(true);
                    },
                    start: () => {
                        if (!isStarted) {
                            isStarted = true;
                            setStarted(true);
                        }
                    },
                    shoot: doShoot
                };

                return () => {
                    cancelAnimationFrame(animationId);
                    window.removeEventListener('keydown', onKeyDown);
                    window.removeEventListener('keyup', onKeyUp);
                    renderer.dispose();
                    if (containerRef.current && renderer.domElement) {
                        containerRef.current.removeChild(renderer.domElement);
                    }
                };
            }, []);

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="h-10 px-4 flex justify-between items-center border-b border-gray-100">
                        <span className="font-mono text-[10px] font-bold tracking-widest text-black">STARSHIP</span>
                        <div className="flex gap-4">
                            <span className="font-mono text-[10px] text-gray-400">HI <span className="text-gray-600 font-bold">{highScore.toString().padStart(6, '0')}</span></span>
                            <span className="font-mono text-[10px] text-gray-400">SCORE <span className="text-black font-bold">{score.toString().padStart(6, '0')}</span></span>
                        </div>
                    </div>

                    <div className="flex-grow flex items-center justify-center relative bg-gray-50 overflow-hidden">
                        {!started && !gameOver && (
                            <div className="absolute inset-0 bg-white/90 flex items-center justify-center z-10">
                                <div className="text-center">
                                    <div className="text-2xl font-black tracking-widest mb-2">STARSHIP</div>
                                    <div className="font-mono text-[10px] text-gray-400 mb-4">LOW POLY COMBAT</div>
                                    <button onClick={handleStart} className="btn-primary btn-xs tracking-widest">
                                        TAP TO START
                                    </button>
                                </div>
                            </div>
                        )}
                        {gameOver && (
                            <div className="absolute inset-0 bg-white/95 flex items-center justify-center z-10">
                                <div className="text-center">
                                    <div className="text-2xl font-black tracking-widest">DESTROYED</div>
                                    <div className="font-mono text-[10px] text-gray-400 mt-2">SCORE: {score}</div>
                                    <div className="font-mono text-[10px] text-gray-500 mt-1">HIGH: {highScore}</div>
                                    <button
                                        onClick={() => gameRef.current?.restart()}
                                        className="mt-4 px-4 py-2 bg-black text-white font-mono text-[10px] tracking-widest hover:bg-gray-800"
                                    >
                                        RETRY
                                    </button>
                                </div>
                            </div>
                        )}
                        <div
                            ref={containerRef}
                            className="w-full h-full flex items-center justify-center touch-none"
                            onTouchStart={handleTouchStart}
                            onTouchMove={handleTouchMove}
                            onTouchEnd={handleTouchEnd}
                        />
                    </div>

                    <div className="h-8 px-4 flex justify-between items-center border-t border-gray-100">
                        <span className="font-mono text-[10px] text-gray-300 hidden md:inline">WASD/ARROWS MOVE · SPACE SHOOT</span>
                        <span className="font-mono text-[10px] text-gray-300 md:hidden">DRAG TO MOVE · TAP TO SHOOT</span>
                        <button
                            onClick={() => gameRef.current?.restart()}
                            className="font-mono text-[10px] text-gray-300 hover:text-black transition-colors"
                        >
                            RESTART
                        </button>
                    </div>
                </div>
            );
        };

        // --- SYNTH_001.WAV - Brutalist Synthesizer ---
        const SynthApp = () => {
            const [tempo, setTempo] = useState(120);
            const [filter, setFilter] = useState(1000);
            const [isPlaying, setIsPlaying] = useState(false);
            const [currentStep, setCurrentStep] = useState(0);
            const [grid, setGrid] = useState(() => {
                return {
                    sine: Array(16).fill(false),
                    square: Array(16).fill(false),
                    saw: Array(16).fill(false),
                    noise: Array(16).fill(false)
                };
            });
            const audioCtxRef = useRef(null);
            const intervalRef = useRef(null);

            const oscillators = ['sine', 'square', 'saw', 'noise'];

            const toggleNote = (osc, step) => {
                setGrid(prev => ({
                    ...prev,
                    [osc]: prev[osc].map((v, i) => i === step ? !v : v)
                }));
            };

            const playSound = (type, filterFreq) => {
                if (!audioCtxRef.current) {
                    audioCtxRef.current = new (window.AudioContext || window.webkitAudioContext)();
                }
                const ctx = audioCtxRef.current;

                let osc;
                const gain = ctx.createGain();
                const filt = ctx.createBiquadFilter();
                filt.type = 'lowpass';
                filt.frequency.value = filterFreq;

                if (type === 'noise') {
                    const bufferSize = ctx.sampleRate * 0.1;
                    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        data[i] = Math.random() * 2 - 1;
                    }
                    osc = ctx.createBufferSource();
                    osc.buffer = buffer;
                } else {
                    osc = ctx.createOscillator();
                    osc.type = type === 'saw' ? 'sawtooth' : type;
                    osc.frequency.value = 220 + Math.random() * 110;
                }

                gain.gain.setValueAtTime(0.3, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);

                osc.connect(filt);
                filt.connect(gain);
                gain.connect(ctx.destination);
                osc.start(ctx.currentTime);
                osc.stop(ctx.currentTime + 0.1);
            };

            const togglePlay = () => {
                if (isPlaying) {
                    clearInterval(intervalRef.current);
                    setIsPlaying(false);
                    setCurrentStep(0);
                } else {
                    setIsPlaying(true);
                    let step = 0;
                    intervalRef.current = setInterval(() => {
                        setCurrentStep(step);
                        oscillators.forEach(osc => {
                            if (grid[osc][step]) {
                                playSound(osc, filter);
                            }
                        });
                        step = (step + 1) % 16;
                    }, (60 / tempo) * 250);
                }
            };

            useEffect(() => {
                return () => clearInterval(intervalRef.current);
            }, []);

            useEffect(() => {
                if (isPlaying) {
                    clearInterval(intervalRef.current);
                    let step = currentStep;
                    intervalRef.current = setInterval(() => {
                        setCurrentStep(step);
                        oscillators.forEach(osc => {
                            if (grid[osc][step]) {
                                playSound(osc, filter);
                            }
                        });
                        step = (step + 1) % 16;
                    }, (60 / tempo) * 250);
                }
            }, [tempo, filter, grid]);

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="app-header">
                        <span className="app-header-title">SYNTH_001.WAV</span>
                        <button
                            onClick={togglePlay}
                            className={`px-4 py-1 font-mono text-xs font-bold border-2 border-black ${isPlaying ? 'bg-black text-white' : 'bg-white text-black hover:bg-black hover:text-white'}`}
                        >
                            {isPlaying ? '■ STOP' : '► PLAY'}
                        </button>
                    </div>
                    <div className="flex-grow p-4 overflow-auto bg-gray-50">
                        <div className="space-y-2">
                            {oscillators.map(osc => (
                                <div key={osc} className="flex items-center gap-2">
                                    <span className="font-mono text-[10px] w-12 text-gray-500 uppercase">{osc}</span>
                                    <div className="flex gap-1">
                                        {grid[osc].map((active, i) => (
                                            <button
                                                key={i}
                                                onClick={() => toggleNote(osc, i)}
                                                className={`w-6 h-8 border-2 transition-all ${active
                                                    ? 'bg-black border-black'
                                                    : 'bg-white border-gray-300 hover:border-black'
                                                    } ${currentStep === i && isPlaying ? 'ring-2 ring-black ring-offset-1' : ''}`}
                                            />
                                        ))}
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                    <div className="p-4 border-t-2 border-black bg-white flex gap-8">
                        <div className="flex items-center gap-2">
                            <span className="app-footer-text">TEMPO</span>
                            <input
                                type="range"
                                min="60"
                                max="200"
                                value={tempo}
                                onChange={(e) => setTempo(Number(e.target.value))}
                                className="w-24 accent-black"
                            />
                            <span className="font-mono text-xs w-8 text-black">{tempo}</span>
                        </div>
                        <div className="flex items-center gap-2">
                            <span className="app-footer-text">FILTER</span>
                            <input
                                type="range"
                                min="100"
                                max="5000"
                                value={filter}
                                onChange={(e) => setFilter(Number(e.target.value))}
                                className="w-24 accent-black"
                            />
                            <span className="font-mono text-xs w-12 text-black">{filter}Hz</span>
                        </div>
                    </div>
                </div>
            );
        };

        // --- DESTRUCTION.EXE - Screen destroyer with confirmations ---
        const DestructionApp = ({ onDogSteal }) => {
            const [confirmStep, setConfirmStep] = useState(0);
            const [buttonPos, setButtonPos] = useState({ x: 0, y: 0 });
            const [dogStealing, setDogStealing] = useState(false);
            const [dogPos, setDogPos] = useState({ x: -100, y: 200 });
            const [buttonGone, setButtonGone] = useState(false);

            const confirmMessages = [
                { prompt: "EXECUTE", response: "You want to do it?" },
                { prompt: "YES", response: "Are you sure?" },
                { prompt: "I'M SURE", response: "Really though?" },
                { prompt: "REALLY", response: "Really, really though?" },
                { prompt: "YES REALLY", response: "Like... REALLY really?" },
                { prompt: "DO IT", response: "You know this destroys EVERYTHING?" },
                { prompt: "I KNOW", response: "There's no going back..." },
                { prompt: "I DON'T CARE", response: "Final warning..." },
                { prompt: "JUST DO IT", response: "Okay... last chance to back out..." },
                { prompt: "DESTROY IT ALL", response: "..." }
            ];

            const handleClick = () => {
                if (confirmStep < 9) {
                    setConfirmStep(prev => prev + 1);
                } else {
                    // Final click - dog steals the button!
                    setDogStealing(true);

                    // Animate dog running in
                    let dogX = -100;
                    const dogRun = setInterval(() => {
                        dogX += 15;
                        setDogPos({ x: dogX, y: 150 + Math.sin(dogX / 20) * 10 });

                        if (dogX >= 120) {
                            clearInterval(dogRun);
                            setButtonGone(true);

                            // Dog runs away with button
                            const dogEscape = setInterval(() => {
                                dogX += 20;
                                setDogPos({ x: dogX, y: 150 + Math.sin(dogX / 15) * 15 });

                                if (dogX > window.innerWidth + 100) {
                                    clearInterval(dogEscape);
                                    if (onDogSteal) onDogSteal();
                                }
                            }, 30);
                        }
                    }, 30);
                }
            };

            return (
                <div className="h-full flex flex-col bg-white select-none relative overflow-hidden">
                    <div className="app-header">
                        <span className="app-header-title">DESTRUCTION.EXE</span>
                        <span className="app-footer-text">DANGER ZONE</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center bg-gray-50 relative z-10">
                        <div className="text-center">
                            <svg width="64" height="64" viewBox="0 0 64 64" className="mx-auto mb-4" style={{ imageRendering: 'pixelated' }}>
                                <rect x="16" y="4" width="32" height="8" fill="#000" />
                                <rect x="12" y="12" width="40" height="8" fill="#000" />
                                <rect x="8" y="20" width="48" height="16" fill="#000" />
                                <rect x="14" y="22" width="12" height="10" fill="#fff" />
                                <rect x="38" y="22" width="12" height="10" fill="#fff" />
                                <rect x="28" y="34" width="8" height="6" fill="#fff" />
                                <rect x="12" y="40" width="40" height="8" fill="#000" />
                                <rect x="16" y="42" width="4" height="6" fill="#fff" />
                                <rect x="24" y="42" width="4" height="6" fill="#fff" />
                                <rect x="36" y="42" width="4" height="6" fill="#fff" />
                                <rect x="44" y="42" width="4" height="6" fill="#fff" />
                                <rect x="16" y="48" width="32" height="8" fill="#000" />
                            </svg>
                            <div className="font-mono text-sm mb-2 text-black">DESTRUCTION.EXE</div>
                            <div className="font-mono text-xs text-gray-500 mb-6">
                                {confirmStep === 0 ? "WARNING: WILL DESTROY EVERYTHING" : confirmMessages[confirmStep - 1]?.response || "..."}
                            </div>
                            {!buttonGone && (
                                <button
                                    onClick={handleClick}
                                    className={`btn-primary btn-lg ${confirmStep > 5 ? 'animate-pulse' : ''}`}
                                    style={{
                                        transform: `translate(${buttonPos.x}px, ${buttonPos.y}px)`,
                                    }}
                                >
                                    {confirmMessages[confirmStep].prompt}
                                </button>
                            )}
                            {buttonGone && !dogStealing && (
                                <div className="font-mono text-sm text-gray-500">
                                    The button is gone...
                                </div>
                            )}
                        </div>
                    </div>

                    {/* Dog stealing animation - cute dog matching the main sprite */}
                    {dogStealing && (
                        <div
                            className="absolute z-20"
                            style={{ left: dogPos.x, top: dogPos.y }}
                        >
                            <svg width="64" height="48" viewBox="0 0 64 48" style={{ imageRendering: 'pixelated' }}>
                                {/* Cute dog - full black, same as released dog */}
                                {/* Body */}
                                <rect x="16" y="16" width="32" height="16" fill="#000" />
                                {/* Head - rounder, cuter */}
                                <rect x="4" y="12" width="16" height="16" fill="#000" />
                                {/* Floppy ears */}
                                <rect x="2" y="4" width="6" height="14" fill="#000" />
                                <rect x="14" y="4" width="6" height="14" fill="#000" />
                                {/* Eye - big cute eye */}
                                <rect x="8" y="16" width="6" height="6" fill="#fff" />
                                <rect x="10" y="18" width="3" height="3" fill="#000" />
                                {/* Nose */}
                                <rect x="4" y="22" width="4" height="4" fill="#000" />
                                {/* Running legs */}
                                <rect x="16" y="32" width="6" height="12" fill="#000" />
                                <rect x="26" y="32" width="6" height="10" fill="#000" />
                                <rect x="34" y="32" width="6" height="12" fill="#000" />
                                <rect x="42" y="32" width="6" height="10" fill="#000" />
                                {/* Tail - wagging */}
                                <rect x="48" y="12" width="12" height="4" fill="#000" />
                                <rect x="58" y="8" width="4" height="6" fill="#000" />
                            </svg>
                            {buttonGone && (
                                <div className="absolute -top-4 left-10 px-2 py-1 bg-black text-white font-mono text-[8px] border-2 border-black">
                                    DESTROY
                                </div>
                            )}
                        </div>
                    )}

                    {dogStealing && buttonGone && (
                        <div className="absolute bottom-4 w-full text-center">
                            <div className="font-mono text-xs text-gray-600">
                                *dog runs away with the button*
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // --- TAROT.DAT - Tarot card pull ---
        // Pixel art tarot card component with card frame
        const PixelTarotCard = ({ pixels, width = 24, height = 32, scale = 3 }) => {
            const cardWidth = width + 4;
            const cardHeight = height + 6;

            return (
                <div className="relative" style={{ width: cardWidth * scale, height: cardHeight * scale }}>
                    {/* Card frame - thin border */}
                    <div
                        className="absolute inset-0 bg-white"
                        style={{
                            borderRadius: '2px',
                            border: '1px solid #666',
                            boxShadow: '1px 1px 0 rgba(0,0,0,0.15)'
                        }}
                    />
                    {/* Pixel art area */}
                    <div
                        className="absolute flex items-center justify-center"
                        style={{
                            top: scale,
                            left: scale,
                            right: scale,
                            bottom: scale * 2,
                        }}
                    >
                        <svg width={width * scale} height={height * scale} viewBox={`0 0 ${width} ${height}`} style={{ imageRendering: 'pixelated' }}>
                            <rect width={width} height={height} fill="#000" />
                            {pixels.map((row, y) =>
                                row.split('').map((pixel, x) =>
                                    pixel === '#' ? <rect key={`${x}-${y}`} x={x} y={y} width={1} height={1} fill="#fff" /> : null
                                )
                            )}
                        </svg>
                    </div>
                </div>
            );
        };

        const TarotApp = () => {
            const [cards, setCards] = useState([]);
            const [revealed, setRevealed] = useState(false);
            const [alreadyPulled, setAlreadyPulled] = useState(false);
            const [isShuffling, setIsShuffling] = useState(false);
            const [shuffleFrame, setShuffleFrame] = useState(0);

            const tarotCards = [
                {
                    name: 'THE FOOL', num: '0', meaning: 'New beginnings, innocence, spontaneity', pixels: [
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '........#######.........',
                        '.........#####..........',
                        '..........###...........',
                        '...........#............',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '........#.....#.........',
                        '........................',
                        '....##..................',
                        '...####.................',
                        '...#..#.................',
                        '....##..................',
                        '........................',
                        '########################',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE MAGICIAN', num: 'I', meaning: 'Manifestation, resourcefulness, power', pixels: [
                        '........................',
                        '.........#...#..........',
                        '..........#.#...........',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...........#............',
                        '..........#.#...........',
                        '........................',
                        '..##..##..##..##........',
                        '..##..##..##..##........',
                        '........................',
                        '########################',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE HIGH PRIESTESS', num: 'II', meaning: 'Intuition, mystery, inner knowledge', pixels: [
                        '........................',
                        '....##..........##......',
                        '...#..#........#..#.....',
                        '....##..........##......',
                        '..........##............',
                        '.........####...........',
                        '..........##............',
                        '..........##............',
                        '.........####...........',
                        '........##..##..........',
                        '.........####...........',
                        '..........##............',
                        '..........##............',
                        '.........####...........',
                        '........######..........',
                        '........................',
                        '...##..........##.......',
                        '...##..........##.......',
                        '...##..........##.......',
                        '........................',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE EMPRESS', num: 'III', meaning: 'Abundance, nurturing, fertility', pixels: [
                        '........................',
                        '.........#####..........',
                        '........#######.........',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '.........#####..........',
                        '........#######.........',
                        '.......#########........',
                        '........#######.........',
                        '.........#####..........',
                        '..........###...........',
                        '..........#.#...........',
                        '.........#...#..........',
                        '........................',
                        '...#..#..#..#..#..#.....',
                        '...#..#..#..#..#..#.....',
                        '...#..#..#..#..#..#.....',
                        '........................',
                        '########################',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE EMPEROR', num: 'IV', meaning: 'Authority, structure, control', pixels: [
                        '........................',
                        '.........#####..........',
                        '........#.#.#.#.........',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '........#######.........',
                        '........#.###.#.........',
                        '........#.###.#.........',
                        '........#######.........',
                        '..........###...........',
                        '..........###...........',
                        '.........##.##..........',
                        '........##...##.........',
                        '........................',
                        '.......########.........',
                        '.......#......#.........',
                        '.......#......#.........',
                        '.......########.........',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE HIEROPHANT', num: 'V', meaning: 'Tradition, conformity, spirituality', pixels: [
                        '........................',
                        '...........##...........',
                        '..........####..........',
                        '...........##...........',
                        '.........######.........',
                        '..........####..........',
                        '..........####..........',
                        '.........######.........',
                        '........########........',
                        '.........######.........',
                        '..........####..........',
                        '..........####..........',
                        '.........##..##.........',
                        '........##....##........',
                        '........................',
                        '....##....##....##......',
                        '...####..####..####.....',
                        '....##....##....##......',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE LOVERS', num: 'VI', meaning: 'Love, harmony, relationships', pixels: [
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '........#######.........',
                        '.........#####..........',
                        '..........###...........',
                        '........................',
                        '....###........###......',
                        '...#####......#####.....',
                        '....###........###......',
                        '....###........###......',
                        '.....#..........#.......',
                        '....#.#........#.#......',
                        '...#...#......#...#.....',
                        '........................',
                        '.........####...........',
                        '........##..##..........',
                        '.........####...........',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE CHARIOT', num: 'VII', meaning: 'Willpower, determination, success', pixels: [
                        '........................',
                        '........#.#.#.#.........',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '.........#####..........',
                        '........#######.........',
                        '.......#########........',
                        '.......#.#####.#........',
                        '.......#########........',
                        '........#######.........',
                        '..........###...........',
                        '......###.###.###.......',
                        '.....##.........##......',
                        '....##...........##.....',
                        '...####.........####....',
                        '...#..#.........#..#....',
                        '...####.........####....',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'STRENGTH', num: 'VIII', meaning: 'Courage, persuasion, inner strength', pixels: [
                        '........................',
                        '.........#...#..........',
                        '..........#.#...........',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###....###....',
                        '...........#....#####...',
                        '..........#.#...#.#.#...',
                        '.........#...#..#####...',
                        '................#...#...',
                        '...............##...##..',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE HERMIT', num: 'IX', meaning: 'Soul-searching, introspection, solitude', pixels: [
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '...###...#####..........',
                        '..#####...###...........',
                        '...###...#.#.#..........',
                        '....#.....###...........',
                        '....#......#............',
                        '....#.....#.#...........',
                        '....#....#...#..........',
                        '....#...#.....#.........',
                        '....#...................',
                        '........................',
                        '..######................',
                        '.########...............',
                        '##########..............',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'WHEEL OF FORTUNE', num: 'X', meaning: 'Change, cycles, destiny', pixels: [
                        '........................',
                        '........................',
                        '.......########.........',
                        '......#........#........',
                        '.....#..........#.......',
                        '....#....####....#......',
                        '....#...#....#...#......',
                        '...#....#....#....#.....',
                        '...#....#....#....#.....',
                        '....#...#....#...#......',
                        '....#....####....#......',
                        '.....#..........#.......',
                        '......#........#........',
                        '.......########.........',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'JUSTICE', num: 'XI', meaning: 'Fairness, truth, law', pixels: [
                        '........................',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...####....#....####....',
                        '...#..#....#....#..#....',
                        '...####....#....####....',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '........#.....#.........',
                        '........................',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE HANGED MAN', num: 'XII', meaning: 'Surrender, letting go, new perspective', pixels: [
                        '........................',
                        '########################',
                        '...........#............',
                        '...........#............',
                        '...........#............',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'DEATH', num: 'XIII', meaning: 'Endings, change, transformation', pixels: [
                        '........................',
                        '..........###...........',
                        '.........#...#..........',
                        '........#.....#.........',
                        '........#.#.#.#.........',
                        '........#.....#.........',
                        '.........#...#..........',
                        '..........###...........',
                        '...........#............',
                        '.........#####..........',
                        '........#..#..#.........',
                        '.........#####..........',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '........#.....#.........',
                        '........................',
                        '...##..........##.......',
                        '..####........####......',
                        '...##..........##.......',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'TEMPERANCE', num: 'XIV', meaning: 'Balance, moderation, patience', pixels: [
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '....###....#....###.....',
                        '....#.#....#....#.#.....',
                        '....###..#####..###.....',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '........#.....#.........',
                        '........................',
                        '########################',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE DEVIL', num: 'XV', meaning: 'Shadow self, attachment, addiction', pixels: [
                        '........................',
                        '........#......#........',
                        '.......##......##.......',
                        '........########........',
                        '.........#....#.........',
                        '.........#.##.#.........',
                        '.........######.........',
                        '..........####..........',
                        '..........####..........',
                        '.........######.........',
                        '........#.####.#........',
                        '........#.#..#.#........',
                        '.........#....#.........',
                        '..........#..#..........',
                        '........................',
                        '...###..........###.....',
                        '...#.#..........#.#.....',
                        '...###..........###.....',
                        '........................',
                        '...####........####.....',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE TOWER', num: 'XVI', meaning: 'Sudden change, upheaval, revelation', pixels: [
                        '........................',
                        '....##..........##......',
                        '.....##........##.......',
                        '......##..##..##........',
                        '.........####...........',
                        '.........#..#...........',
                        '.........#..#...........',
                        '........######..........',
                        '........#....#..........',
                        '........#....#..........',
                        '........######..........',
                        '........#....#..........',
                        '........#....#..........',
                        '.......########.........',
                        '......##########........',
                        '........................',
                        '...##....##....##.......',
                        '...##....##....##.......',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE STAR', num: 'XVII', meaning: 'Hope, faith, renewal', pixels: [
                        '........................',
                        '...........#............',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '...........#............',
                        '....#.....#.#.....#.....',
                        '...###...#...#...###....',
                        '....#.............#.....',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...###.....#.....###....',
                        '...#.#....#.#....#.#....',
                        '...###...#...#...###....',
                        '........................',
                        '########################',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE MOON', num: 'XVIII', meaning: 'Illusion, fear, subconscious', pixels: [
                        '........................',
                        '.........#####..........',
                        '........##...##.........',
                        '.......##.....##........',
                        '.......#.......#........',
                        '.......##.....##........',
                        '........##...##.........',
                        '.........#####..........',
                        '........................',
                        '....###........###......',
                        '...#.#.#......#.#.#.....',
                        '...#####......#####.....',
                        '...#...#......#...#.....',
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '........................',
                        '########################',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE SUN', num: 'XIX', meaning: 'Joy, success, celebration', pixels: [
                        '........................',
                        '....#......#......#.....',
                        '.....#.....#.....#......',
                        '......#...###...#.......',
                        '.......#.#####.#........',
                        '...#####.#####.#####....',
                        '.......#.#####.#........',
                        '......#...###...#.......',
                        '.....#.....#.....#......',
                        '....#......#......#.....',
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...........#............',
                        '..........#.#...........',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'JUDGEMENT', num: 'XX', meaning: 'Reflection, reckoning, awakening', pixels: [
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...........#............',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '........................',
                        '....###..###..###.......',
                        '....#.#..#.#..#.#.......',
                        '....###..###..###.......',
                        '....#.#..#.#..#.#.......',
                        '....###..###..###.......',
                        '........................',
                        '.......########.........',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE WORLD', num: 'XXI', meaning: 'Completion, accomplishment, travel', pixels: [
                        '........................',
                        '....##..........##......',
                        '........................',
                        '.......########.........',
                        '......#........#........',
                        '.....#..........#.......',
                        '....#....####....#......',
                        '....#...#....#...#......',
                        '...#....#....#....#.....',
                        '...#....#....#....#.....',
                        '....#...#....#...#......',
                        '....#....####....#......',
                        '.....#..........#.......',
                        '......#........#........',
                        '.......########.........',
                        '........................',
                        '....##..........##......',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                }
            ];

            useEffect(() => {
                // Check localStorage for existing pull (simulating IP-based storage)
                const savedCards = localStorage.getItem('tarot_cards_3');
                if (savedCards) {
                    const parsed = JSON.parse(savedCards);
                    if (Array.isArray(parsed) && parsed.length === 3 && parsed[0].pixels) {
                        setCards(parsed);
                        setRevealed(true);
                        setAlreadyPulled(true);
                    } else {
                        localStorage.removeItem('tarot_cards_3');
                    }
                }
            }, []);

            const shufflePixels = [
                [
                    '........................',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#'
                ],
                [
                    '........................',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.'
                ]
            ];

            const pullCards = () => {
                if (alreadyPulled || isShuffling) return;

                setIsShuffling(true);
                let frame = 0;
                const shuffleInterval = setInterval(() => {
                    setShuffleFrame(f => f + 1);
                    frame++;
                    if (frame >= 20) {
                        clearInterval(shuffleInterval);
                        setIsShuffling(false);
                        // Pick 3 unique random cards
                        const shuffled = [...tarotCards].sort(() => Math.random() - 0.5);
                        const selectedCards = shuffled.slice(0, 3);
                        setCards(selectedCards);
                        localStorage.setItem('tarot_cards_3', JSON.stringify(selectedCards));
                        setTimeout(() => setRevealed(true), 500);
                        setAlreadyPulled(true);
                    }
                }, 80);
            };

            const questionPixels = [
                '........................',
                '........########........',
                '.......##......##.......',
                '......##........##......',
                '......##........##......',
                '..............##........',
                '............##..........',
                '..........##............',
                '.........##.............',
                '.........##.............',
                '.........##.............',
                '........................',
                '.........##.............',
                '.........##.............',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................'
            ];

            return (
                <div className="h-full flex flex-col bg-black text-white select-none">
                    <div className="p-2 border-b border-gray-800">
                        <span className="app-footer-text">TAROT.DAT</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-4">
                        {isShuffling ? (
                            <div className="text-center">
                                <div className="relative w-24 h-32 mb-4">
                                    {/* Deck shuffle animation - multiple cards moving */}
                                    {[0, 1, 2, 3, 4].map((i) => (
                                        <div
                                            key={i}
                                            className="absolute inset-0 border border-gray-700 bg-black"
                                            style={{
                                                transform: `
                                                    translateX(${Math.sin((shuffleFrame + i) * 1.5) * (15 + i * 3)}px)
                                                    translateY(${i * 2}px)
                                                    rotate(${Math.sin((shuffleFrame + i) * 0.8) * 8}deg)
                                                `,
                                                transition: 'transform 0.1s ease-out',
                                                zIndex: 5 - i
                                            }}
                                        >
                                            <PixelTarotCard pixels={shufflePixels[shuffleFrame % 2]} />
                                        </div>
                                    ))}
                                </div>
                                <div className="font-mono text-[10px] text-gray-500 animate-pulse">SHUFFLING...</div>
                            </div>
                        ) : cards.length === 0 ? (
                            <div className="text-center">
                                <div className="mb-6 flex flex-col md:flex-row gap-4 justify-center items-center">
                                    <PixelTarotCard pixels={questionPixels} scale={3} />
                                    <PixelTarotCard pixels={questionPixels} scale={3} />
                                    <PixelTarotCard pixels={questionPixels} scale={3} />
                                </div>
                                <button
                                    onClick={pullCards}
                                    className="btn-secondary btn-sm"
                                >
                                    DRAW 3 CARDS
                                </button>
                                <p className="mt-4 font-mono text-[10px] text-gray-600">ONE READING PER VISITOR</p>
                            </div>
                        ) : (
                            <div className={`text-center transition-all duration-500 ${revealed ? 'opacity-100' : 'opacity-0'}`}>
                                <div className="flex flex-col md:flex-row gap-4 justify-center items-center mb-4">
                                    {cards.map((card, idx) => (
                                        <div key={idx} className="flex flex-col items-center">
                                            <div className="text-xs text-gray-600 mb-2">{['PAST', 'PRESENT', 'FUTURE'][idx]}</div>
                                            <PixelTarotCard pixels={card.pixels} scale={3} />
                                            <div className="font-mono text-xs text-gray-500 mt-2">{card.num}</div>
                                            <div className="text-sm font-bold mt-1">{card.name}</div>
                                        </div>
                                    ))}
                                </div>
                                <div className="font-mono text-xs text-gray-400 max-w-lg mx-auto px-4">
                                    {cards.map((c, i) => <div key={i} className="mb-1">{c.meaning}</div>)}
                                </div>
                                {alreadyPulled && (
                                    <p className="mt-3 font-mono text-xs text-gray-700">FATE SEALED</p>
                                )}
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // --- GALLERY.EXE - Photo gallery with 9 placeholder photos ---
        const GalleryApp = () => {
            const [selectedPhoto, setSelectedPhoto] = useState(null);

            const photos = [
                { id: 1, title: 'ME_001.JPG', category: 'SELF', desc: 'Profile shot' },
                { id: 2, title: 'ME_002.JPG', category: 'SELF', desc: 'Another one' },
                { id: 3, title: 'DOG_001.JPG', category: 'DOGS', desc: 'Good boy' },
                { id: 4, title: 'DOG_002.JPG', category: 'DOGS', desc: 'Best friend' },
                { id: 5, title: 'DOG_003.JPG', category: 'DOGS', desc: 'Sleeping' },
                { id: 6, title: 'WORK_001.JPG', category: 'WORK', desc: 'Office vibes' },
                { id: 7, title: 'WORK_002.JPG', category: 'WORK', desc: 'Late night coding' },
                { id: 8, title: 'WORK_003.JPG', category: 'WORK', desc: 'Setup tour' },
                { id: 9, title: 'RANDOM_001.JPG', category: 'MISC', desc: 'Life moment' }
            ];

            // Generate placeholder image pattern based on id
            const getPlaceholderPattern = (id) => {
                const patterns = [
                    // Person silhouette
                    [[0, 0, 1, 1, 0, 0], [0, 1, 1, 1, 1, 0], [0, 0, 1, 1, 0, 0], [0, 1, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1], [1, 0, 1, 1, 0, 1], [0, 0, 1, 1, 0, 0], [0, 1, 0, 0, 1, 0]],
                    // Another person
                    [[0, 1, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1], [0, 1, 0, 0, 1, 0], [0, 0, 1, 1, 0, 0], [0, 1, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1], [0, 1, 0, 0, 1, 0], [1, 1, 0, 0, 1, 1]],
                    // Dog sitting
                    [[1, 1, 0, 0, 1, 1], [1, 1, 1, 1, 1, 1], [0, 1, 0, 0, 1, 0], [0, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 1], [1, 1, 0, 0, 1, 1]],
                    // Dog lying
                    [[0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [0, 1, 1, 1, 1, 0], [1, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0]],
                    // Dog running
                    [[0, 1, 1, 0, 0, 0], [1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 0], [0, 1, 0, 0, 1, 0], [1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0]],
                    // Computer/desk
                    [[0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1], [0, 0, 1, 1, 0, 0], [0, 1, 1, 1, 1, 0]],
                    // Code screen
                    [[1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 1], [1, 0, 1, 0, 0, 1], [1, 0, 0, 1, 1, 1], [1, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1]],
                    // Setup
                    [[0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 1, 1], [1, 0, 1, 0, 1, 0], [1, 1, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 0], [0, 1, 0, 0, 1, 0], [0, 1, 1, 1, 1, 0]],
                    // Abstract/random
                    [[1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1], [1, 1, 0, 0, 1, 1], [0, 0, 1, 1, 0, 0], [1, 0, 0, 0, 0, 1], [0, 1, 1, 1, 1, 0], [1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1]]
                ];
                return patterns[(id - 1) % patterns.length];
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="app-header">
                        <div className="flex items-center gap-2">
                            <Icons.Gallery size={24} />
                            <span className="app-header-title">GALLERY.EXE</span>
                        </div>
                        <span className="app-footer-text">{photos.length} PHOTOS</span>
                    </div>

                    {selectedPhoto ? (
                        <div className="flex-grow flex flex-col bg-black">
                            <div className="flex-grow flex items-center justify-center p-8">
                                <div className="bg-gray-900 border-2 border-white p-4">
                                    <svg width="240" height="240" viewBox="0 0 6 8" style={{ imageRendering: 'pixelated' }}>
                                        <rect width="6" height="8" fill="#222" />
                                        {getPlaceholderPattern(selectedPhoto.id).map((row, y) =>
                                            row.map((cell, x) =>
                                                cell ? <rect key={`${x}-${y}`} x={x} y={y} width="1" height="1" fill="#fff" /> : null
                                            )
                                        )}
                                    </svg>
                                </div>
                            </div>
                            <div className="p-4 bg-gray-900 border-t-2 border-white">
                                <div className="flex justify-between items-center">
                                    <div>
                                        <div className="font-mono text-white text-sm font-bold">{selectedPhoto.title}</div>
                                        <div className="font-mono text-gray-400 text-[10px]">{selectedPhoto.category} / {selectedPhoto.desc}</div>
                                    </div>
                                    <button
                                        onClick={() => setSelectedPhoto(null)}
                                        className="btn-secondary btn-sm"
                                    >
                                        BACK
                                    </button>
                                </div>
                            </div>
                        </div>
                    ) : (
                        <div className="flex-grow p-4 overflow-auto bg-gray-100">
                            <div className="grid grid-cols-3 gap-3">
                                {photos.map(photo => (
                                    <button
                                        key={photo.id}
                                        onClick={() => setSelectedPhoto(photo)}
                                        className="group aspect-square bg-white border-2 border-black hover:bg-black transition-all flex flex-col items-center justify-center p-2"
                                    >
                                        <svg width="48" height="64" viewBox="0 0 6 8" style={{ imageRendering: 'pixelated' }} className="group-hover:invert">
                                            <rect width="6" height="8" fill="#eee" />
                                            {getPlaceholderPattern(photo.id).map((row, y) =>
                                                row.map((cell, x) =>
                                                    cell ? <rect key={`${x}-${y}`} x={x} y={y} width="1" height="1" fill="#000" /> : null
                                                )
                                            )}
                                        </svg>
                                        <div className="font-mono text-[8px] mt-1 text-gray-600 group-hover:text-white truncate w-full text-center">{photo.title}</div>
                                    </button>
                                ))}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // --- MAP.EXE - Interactive COBE globe with Planet Clicker game ---
        const MapApp = () => {
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const globeRef = useRef(null);
            const pointerInteracting = useRef(null);
            const pointerInteractionMovement = useRef(0);
            const phiRef = useRef(0);
            const thetaRef = useRef(0.3);
            const scaleRef = useRef(1);

            const [gameStarted, setGameStarted] = useState(false);
            const [showShop, setShowShop] = useState(false);
            const [clickEffect, setClickEffect] = useState(null);
            const [globeReady, setGlobeReady] = useState(false);

            // Game state with defaults
            const defaultGameState = {
                clicks: 0,
                totalClicks: 0,
                clickPower: 1,
                satellites: 0,
                clickMultiplier: 1,
                upgrades: {
                    power1: false, power2: false, power3: false,
                    power4: false, power5: false, power6: false,
                    sat1: false, sat2: false, sat3: false,
                    sat4: false, sat5: false, sat6: false,
                    multi1: false, multi2: false, multi3: false,
                    godMode: false, dogMode: false
                },
                dogModeMultiplier: 1
            };

            const [gameState, setGameState] = useState(() => {
                const saved = localStorage.getItem(HighScoreManager.getStorageKey('mapclicker'));
                if (saved) {
                    try {
                        const parsed = JSON.parse(saved);
                        return { ...defaultGameState, ...parsed, upgrades: { ...defaultGameState.upgrades, ...parsed.upgrades } };
                    } catch (e) {
                        return defaultGameState;
                    }
                }
                return defaultGameState;
            });

            // Save game state
            useEffect(() => {
                localStorage.setItem(HighScoreManager.getStorageKey('mapclicker'), JSON.stringify(gameState));
            }, [gameState]);

            // Satellite auto-clicker
            useEffect(() => {
                if (gameState.satellites > 0) {
                    const interval = setInterval(() => {
                        const autoAmount = gameState.satellites * gameState.clickMultiplier * gameState.dogModeMultiplier;
                        setGameState(prev => ({
                            ...prev,
                            clicks: prev.clicks + autoAmount,
                            totalClicks: prev.totalClicks + autoAmount
                        }));
                    }, 1000);
                    return () => clearInterval(interval);
                }
            }, [gameState.satellites, gameState.clickMultiplier, gameState.dogModeMultiplier]);

            // Shop items
            const shopItems = [
                {
                    category: 'CLICK POWER', items: [
                        { id: 'power1', name: 'TREMOR I', desc: '+1 power', cost: 50, effect: () => ({ clickPower: gameState.clickPower + 1 }) },
                        { id: 'power2', name: 'TREMOR II', desc: '+2 power', cost: 200, effect: () => ({ clickPower: gameState.clickPower + 2 }), requires: 'power1' },
                        { id: 'power3', name: 'QUAKE I', desc: '+5 power', cost: 1000, effect: () => ({ clickPower: gameState.clickPower + 5 }), requires: 'power2' },
                        { id: 'power4', name: 'QUAKE II', desc: '+10 power', cost: 5000, effect: () => ({ clickPower: gameState.clickPower + 10 }), requires: 'power3' },
                        { id: 'power5', name: 'CATACLYSM I', desc: '+25 power', cost: 25000, effect: () => ({ clickPower: gameState.clickPower + 25 }), requires: 'power4' },
                        { id: 'power6', name: 'CATACLYSM II', desc: '+50 power', cost: 100000, effect: () => ({ clickPower: gameState.clickPower + 50 }), requires: 'power5' },
                    ]
                },
                {
                    category: 'SATELLITES', items: [
                        { id: 'sat1', name: 'SPUTNIK', desc: '1/sec', cost: 100, effect: () => ({ satellites: gameState.satellites + 1 }) },
                        { id: 'sat2', name: 'EXPLORER', desc: '+2/sec', cost: 500, effect: () => ({ satellites: gameState.satellites + 2 }), requires: 'sat1' },
                        { id: 'sat3', name: 'VOYAGER', desc: '+5/sec', cost: 2500, effect: () => ({ satellites: gameState.satellites + 5 }), requires: 'sat2' },
                        { id: 'sat4', name: 'HUBBLE', desc: '+10/sec', cost: 10000, effect: () => ({ satellites: gameState.satellites + 10 }), requires: 'sat3' },
                        { id: 'sat5', name: 'JAMES WEBB', desc: '+25/sec', cost: 50000, effect: () => ({ satellites: gameState.satellites + 25 }), requires: 'sat4' },
                        { id: 'sat6', name: 'DYSON SWARM', desc: '+50/sec', cost: 200000, effect: () => ({ satellites: gameState.satellites + 50 }), requires: 'sat5' },
                    ]
                },
                {
                    category: 'MULTIPLIERS', items: [
                        { id: 'multi1', name: 'INNER RING', desc: '2x clicks', cost: 2000, effect: () => ({ clickMultiplier: gameState.clickMultiplier * 2 }) },
                        { id: 'multi2', name: 'MIDDLE RING', desc: '2x (4x)', cost: 15000, effect: () => ({ clickMultiplier: gameState.clickMultiplier * 2 }), requires: 'multi1' },
                        { id: 'multi3', name: 'OUTER RING', desc: '2x (8x)', cost: 75000, effect: () => ({ clickMultiplier: gameState.clickMultiplier * 2 }), requires: 'multi2' },
                    ]
                },
                {
                    category: 'ASCENSION', items: [
                        { id: 'godMode', name: 'GOD MODE', desc: '1M/click', cost: 1000000 },
                        { id: 'dogMode', name: 'DOG MODE', desc: 'RESET: 1M×', cost: 100000000, requires: 'godMode' },
                    ]
                },
            ];

            const getActualCost = (baseCost) => baseCost * gameState.dogModeMultiplier;

            const buyUpgrade = (item) => {
                const actualCost = getActualCost(item.cost);
                if (gameState.clicks >= actualCost && !gameState.upgrades[item.id]) {
                    if (item.requires && !gameState.upgrades[item.requires]) return;
                    if (item.id === 'dogMode') {
                        setGameState({
                            ...defaultGameState,
                            dogModeMultiplier: gameState.dogModeMultiplier * 1000000,
                            upgrades: { ...defaultGameState.upgrades, dogMode: true }
                        });
                        return;
                    }
                    const effectResult = item.effect ? item.effect() : {};
                    setGameState(prev => ({
                        ...prev,
                        clicks: prev.clicks - actualCost,
                        ...effectResult,
                        upgrades: { ...prev.upgrades, [item.id]: true }
                    }));
                }
            };

            const canBuy = (item) => {
                if (gameState.upgrades[item.id]) return false;
                if (gameState.clicks < getActualCost(item.cost)) return false;
                if (item.requires && !gameState.upgrades[item.requires]) return false;
                return true;
            };

            const isLocked = (item) => item.requires && !gameState.upgrades[item.requires];

            const handleGlobeClick = () => {
                if (!gameStarted) return;
                const clickValue = gameState.clickPower * gameState.clickMultiplier * gameState.dogModeMultiplier;
                setGameState(prev => ({
                    ...prev,
                    clicks: prev.clicks + clickValue,
                    totalClicks: prev.totalClicks + clickValue
                }));
                setClickEffect({ value: clickValue, id: Date.now() });
                setTimeout(() => setClickEffect(null), 500);
            };

            const formatNumber = (num) => {
                if (num >= 1e12) return (num / 1e12).toFixed(1) + 'T';
                if (num >= 1e9) return (num / 1e9).toFixed(1) + 'B';
                if (num >= 1e6) return (num / 1e6).toFixed(1) + 'M';
                if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
                return Math.floor(num).toString();
            };

            // Initialize COBE globe
            useEffect(() => {
                if (!canvasRef.current) return;

                let globe = null;
                const canvasSize = 280;

                const initGlobe = () => {
                    if (!window.createGlobe) {
                        setTimeout(initGlobe, 50);
                        return;
                    }

                    globe = window.createGlobe(canvasRef.current, {
                        devicePixelRatio: 2,
                        width: canvasSize * 2,
                        height: canvasSize * 2,
                        phi: 0,
                        theta: 0.3,
                        dark: 1,
                        diffuse: 1.2,
                        mapSamples: 16000,
                        mapBrightness: 6,
                        baseColor: [0.3, 0.3, 0.3],
                        markerColor: [1, 0.5, 0.5],
                        glowColor: [0.15, 0.15, 0.15],
                        scale: 1,
                        markers: [
                            { location: [44.4268, 26.1025], size: 0.05 },
                        ],
                        onRender: (state) => {
                            // Auto-rotate when not dragging
                            if (!pointerInteracting.current) {
                                phiRef.current += 0.003;
                            }
                            state.phi = phiRef.current;
                            state.theta = thetaRef.current;
                            state.scale = scaleRef.current;
                        }
                    });

                    globeRef.current = globe;
                    setGlobeReady(true);
                };

                initGlobe();

                return () => {
                    if (globe) globe.destroy();
                };
            }, []);

            // Pointer/mouse handlers for drag rotation
            const handlePointerDown = (e) => {
                pointerInteracting.current = { x: e.clientX, y: e.clientY };
                pointerInteractionMovement.current = 0;
                if (canvasRef.current) canvasRef.current.style.cursor = 'grabbing';
            };

            const handlePointerUp = () => {
                pointerInteracting.current = null;
                if (canvasRef.current) canvasRef.current.style.cursor = 'grab';
            };

            const handlePointerMove = (e) => {
                if (pointerInteracting.current) {
                    const dx = e.clientX - pointerInteracting.current.x;
                    const dy = e.clientY - pointerInteracting.current.y;
                    pointerInteractionMovement.current += Math.abs(dx) + Math.abs(dy);
                    phiRef.current += dx * 0.005;
                    thetaRef.current = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, thetaRef.current + dy * 0.005));
                    pointerInteracting.current = { x: e.clientX, y: e.clientY };
                }
            };

            const handleWheel = (e) => {
                e.preventDefault();
                scaleRef.current = Math.max(0.5, Math.min(2, scaleRef.current - e.deltaY * 0.001));
            };

            return (
                <div className="h-full flex flex-col bg-black select-none overflow-hidden">
                    {/* Header */}
                    <div className="flex items-center justify-between px-3 py-1.5 border-b border-white/20">
                        <span className="font-mono text-xs font-bold text-white">{gameStarted ? 'PLANET CLICKER' : 'MAP.EXE'}</span>
                        {gameStarted ? (
                            <div className="flex items-center gap-3">
                                <span className="font-mono text-xs text-white font-bold">{formatNumber(gameState.clicks)}</span>
                                <button onClick={() => setShowShop(!showShop)} className="px-2 py-0.5 bg-white text-black font-mono text-[10px] font-bold hover:bg-gray-200">
                                    SHOP
                                </button>
                            </div>
                        ) : (
                            <span className="font-mono text-[10px] text-gray-500">DRAG • SCROLL • CLICK</span>
                        )}
                    </div>

                    {/* Globe container */}
                    <div ref={containerRef} className="flex-grow relative flex items-center justify-center">
                        <canvas
                            ref={canvasRef}
                            style={{ width: 280, height: 280, cursor: 'grab' }}
                            onPointerDown={handlePointerDown}
                            onPointerUp={handlePointerUp}
                            onPointerOut={handlePointerUp}
                            onPointerMove={handlePointerMove}
                            onWheel={handleWheel}
                            onClick={handleGlobeClick}
                        />

                        {/* Start button */}
                        {!gameStarted && globeReady && (
                            <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                                <button
                                    onClick={() => setGameStarted(true)}
                                    className="pointer-events-auto px-4 py-2 bg-red-600 hover:bg-red-500 text-white font-mono text-xs font-bold border border-red-400"
                                >
                                    START MINING
                                </button>
                            </div>
                        )}

                        {/* Click effect */}
                        {clickEffect && (
                            <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                                <span className="font-mono text-xl font-bold text-white animate-ping">+{formatNumber(clickEffect.value)}</span>
                            </div>
                        )}

                        {/* Shop overlay */}
                        {showShop && (
                            <div className="absolute inset-0 bg-black/90 overflow-y-auto p-3">
                                <div className="flex justify-between items-center mb-3">
                                    <span className="font-mono text-sm font-bold text-white">UPGRADES</span>
                                    <button onClick={() => setShowShop(false)} className="font-mono text-white hover:text-red-400">✕</button>
                                </div>
                                {shopItems.map(cat => (
                                    <div key={cat.category} className="mb-3">
                                        <div className="font-mono text-[10px] text-gray-500 mb-1">{cat.category}</div>
                                        <div className="space-y-1">
                                            {cat.items.map(item => {
                                                const owned = gameState.upgrades[item.id];
                                                const locked = isLocked(item);
                                                const affordable = canBuy(item);
                                                return (
                                                    <button
                                                        key={item.id}
                                                        onClick={() => buyUpgrade(item)}
                                                        disabled={owned || locked || !affordable}
                                                        className={`w-full text-left p-2 font-mono text-[10px] border ${
                                                            owned ? 'border-green-500/50 bg-green-500/10 text-green-400' :
                                                            locked ? 'border-gray-700 text-gray-600 cursor-not-allowed' :
                                                            affordable ? 'border-white/30 text-white hover:bg-white/10 cursor-pointer' :
                                                            'border-gray-700 text-gray-500 cursor-not-allowed'
                                                        }`}
                                                    >
                                                        <div className="flex justify-between">
                                                            <span>{item.name}</span>
                                                            <span>{owned ? '✓' : formatNumber(getActualCost(item.cost))}</span>
                                                        </div>
                                                        <div className="text-gray-500">{item.desc}</div>
                                                    </button>
                                                );
                                            })}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>

                    {/* Footer */}
                    <div className="p-2 border-t border-white/20 text-center">
                        <span className="font-mono text-[10px] text-gray-500">
                            {gameStarted ? `POWER: ${gameState.clickPower} | AUTO: ${gameState.satellites}/s | MULTI: ${gameState.clickMultiplier}x` : 'BUCHAREST, ROMANIA'}
                        </span>
                    </div>
                </div>
            );
        };

        // --- POMODORO.EXE - Timer with growing plant ---
        const PomodoroApp = () => {
            const [mode, setMode] = useState('work'); // 'work' or 'break'
            const [timeLeft, setTimeLeft] = useState(25 * 60); // 25 minutes
            const [isRunning, setIsRunning] = useState(false);
            const [sessions, setSessions] = useState(0);
            const [view, setView] = useState('timer'); // 'timer' or 'room'
            const [totalTime, setTotalTime] = useState(0); // total seconds spent
            const [flowers, setFlowers] = useState([]); // collected flowers
            const [currentFlower, setCurrentFlower] = useState(null); // flower for current session

            const WORK_TIME = 25 * 60;
            const BREAK_TIME = 5 * 60;

            // 5 pot styles, 5 stem/leaf types, 5 flower types = 125 combinations
            const POT_STYLES = [
                { color: '#8B4513', rimColor: '#654321', shape: 'classic' },
                { color: '#4a4a4a', rimColor: '#2a2a2a', shape: 'modern' },
                { color: '#CD853F', rimColor: '#8B4513', shape: 'terracotta' },
                { color: '#1a1a1a', rimColor: '#000000', shape: 'sleek' },
                { color: '#708090', rimColor: '#4a4a4a', shape: 'stone' }
            ];
            const STEM_TYPES = [
                { leafStyle: 'round', stemColor: '#228B22' },
                { leafStyle: 'pointed', stemColor: '#006400' },
                { leafStyle: 'droopy', stemColor: '#32CD32' },
                { leafStyle: 'spiral', stemColor: '#2E8B57' },
                { leafStyle: 'minimal', stemColor: '#3CB371' }
            ];
            const FLOWER_TYPES = [
                { petalColor: '#FF69B4', centerColor: '#FFD700', shape: 'tulip' },
                { petalColor: '#FF4500', centerColor: '#FFA500', shape: 'rose' },
                { petalColor: '#9370DB', centerColor: '#FFD700', shape: 'daisy' },
                { petalColor: '#00CED1', centerColor: '#FFFFFF', shape: 'lotus' },
                { petalColor: '#FFD700', centerColor: '#8B4513', shape: 'sunflower' }
            ];

            // Load saved data on mount
            useEffect(() => {
                const saved = localStorage.getItem('pomodoro_data');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        setTotalTime(data.totalTime || 0);
                        setFlowers(data.flowers || []);
                        setSessions(data.sessions || 0);
                    } catch (e) {}
                }
                // Generate flower for this session
                setCurrentFlower({
                    pot: Math.floor(Math.random() * 5),
                    stem: Math.floor(Math.random() * 5),
                    flower: Math.floor(Math.random() * 5),
                    id: Date.now()
                });
            }, []);

            // Save data whenever it changes
            useEffect(() => {
                localStorage.setItem('pomodoro_data', JSON.stringify({
                    totalTime, flowers, sessions
                }));
            }, [totalTime, flowers, sessions]);

            useEffect(() => {
                if (!isRunning) return;

                const interval = setInterval(() => {
                    if (mode === 'work') {
                        setTotalTime(t => t + 1); // Track total time
                    }
                    setTimeLeft(prev => {
                        if (prev <= 1) {
                            if (mode === 'work') {
                                setMode('break');
                                setSessions(s => s + 1);
                                // Add completed flower to collection
                                if (currentFlower) {
                                    setFlowers(f => [...f, { ...currentFlower, completedAt: Date.now() }]);
                                    // Generate new flower for next session
                                    setCurrentFlower({
                                        pot: Math.floor(Math.random() * 5),
                                        stem: Math.floor(Math.random() * 5),
                                        flower: Math.floor(Math.random() * 5),
                                        id: Date.now()
                                    });
                                }
                                return BREAK_TIME;
                            } else {
                                setMode('work');
                                return WORK_TIME;
                            }
                        }
                        return prev - 1;
                    });
                }, 1000);

                return () => clearInterval(interval);
            }, [isRunning, mode, currentFlower]);

            const progress = mode === 'work'
                ? 1 - (timeLeft / WORK_TIME)
                : 1 - (timeLeft / BREAK_TIME);

            const formatTime = (seconds) => {
                const m = Math.floor(seconds / 60);
                const s = seconds % 60;
                return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            };

            const formatTotalTime = (seconds) => {
                const h = Math.floor(seconds / 3600);
                const m = Math.floor((seconds % 3600) / 60);
                return `${h}h ${m}m`;
            };

            const reset = () => {
                setIsRunning(false);
                setMode('work');
                setTimeLeft(WORK_TIME);
            };

            // Render a flower with specific style indices
            const renderFlower = (potIdx, stemIdx, flowerIdx, growth = 1, size = 1, isSleeping = false) => {
                const pot = POT_STYLES[potIdx];
                const stem = STEM_TYPES[stemIdx];
                const flowerType = FLOWER_TYPES[flowerIdx];
                const w = 24 * size;
                const h = 32 * size;

                return (
                    <svg width={w * 5} height={h * 5} viewBox="0 0 24 32" style={{ imageRendering: 'pixelated' }}>
                        {/* Pot based on style */}
                        <rect x="6" y="26" width="12" height="6" fill="#000" />
                        <rect x="7" y="27" width="10" height="4" fill={pot.color} />
                        <rect x="6" y="26" width="12" height="1" fill={pot.rimColor} />

                        {/* Soil */}
                        <rect x="7" y="25" width="10" height="2" fill="#333" />

                        {/* Stem */}
                        {growth > 0 && <rect x="11" y={25 - Math.floor(growth * 12)} width="2" height={Math.floor(growth * 12)} fill={stem.stemColor} />}

                        {/* Leaves based on stem type */}
                        {growth > 0.2 && stem.leafStyle === 'round' && (
                            <><rect x="9" y="21" width="2" height="2" fill={stem.stemColor} /><rect x="8" y="20" width="2" height="2" fill={stem.stemColor} /></>
                        )}
                        {growth > 0.2 && stem.leafStyle === 'pointed' && (
                            <><rect x="9" y="21" width="2" height="1" fill={stem.stemColor} /><rect x="8" y="20" width="2" height="1" fill={stem.stemColor} /></>
                        )}
                        {growth > 0.2 && stem.leafStyle === 'droopy' && (
                            <><rect x="9" y="22" width="2" height="2" fill={stem.stemColor} /><rect x="7" y="23" width="2" height="1" fill={stem.stemColor} /></>
                        )}
                        {growth > 0.2 && stem.leafStyle === 'spiral' && (
                            <><rect x="9" y="21" width="1" height="2" fill={stem.stemColor} /><rect x="8" y="22" width="1" height="1" fill={stem.stemColor} /></>
                        )}
                        {growth > 0.2 && stem.leafStyle === 'minimal' && (
                            <rect x="9" y="21" width="2" height="1" fill={stem.stemColor} />
                        )}

                        {growth > 0.4 && (
                            <><rect x="13" y="18" width="2" height="2" fill={stem.stemColor} /><rect x="14" y="17" width="2" height="2" fill={stem.stemColor} /></>
                        )}
                        {growth > 0.6 && (
                            <><rect x="8" y="15" width="2" height="2" fill={stem.stemColor} /><rect x="7" y="14" width="2" height="2" fill={stem.stemColor} /></>
                        )}
                        {growth > 0.8 && (
                            <><rect x="13" y="12" width="2" height="2" fill={stem.stemColor} /><rect x="14" y="11" width="2" height="2" fill={stem.stemColor} /></>
                        )}

                        {/* Flower head based on type */}
                        {growth >= 1 && flowerType.shape === 'tulip' && (
                            <><rect x="10" y="9" width="4" height="4" fill={flowerType.petalColor} /><rect x="11" y="8" width="2" height="1" fill={flowerType.petalColor} /><rect x="11" y="10" width="2" height="2" fill={flowerType.centerColor} /></>
                        )}
                        {growth >= 1 && flowerType.shape === 'rose' && (
                            <><rect x="9" y="9" width="6" height="4" fill={flowerType.petalColor} /><rect x="10" y="8" width="4" height="1" fill={flowerType.petalColor} /><rect x="11" y="10" width="2" height="2" fill={flowerType.centerColor} /></>
                        )}
                        {growth >= 1 && flowerType.shape === 'daisy' && (
                            <><rect x="11" y="7" width="2" height="6" fill={flowerType.petalColor} /><rect x="9" y="9" width="6" height="2" fill={flowerType.petalColor} /><rect x="11" y="9" width="2" height="2" fill={flowerType.centerColor} /></>
                        )}
                        {growth >= 1 && flowerType.shape === 'lotus' && (
                            <><rect x="10" y="8" width="4" height="5" fill={flowerType.petalColor} /><rect x="9" y="10" width="6" height="2" fill={flowerType.petalColor} /><rect x="11" y="10" width="2" height="2" fill={flowerType.centerColor} /></>
                        )}
                        {growth >= 1 && flowerType.shape === 'sunflower' && (
                            <><rect x="9" y="8" width="6" height="5" fill={flowerType.petalColor} /><rect x="10" y="9" width="4" height="3" fill={flowerType.centerColor} /></>
                        )}

                        {/* Sleeping ZZZ */}
                        {isSleeping && (
                            <><rect x="16" y="6" width="4" height="1" fill="#000" /><rect x="19" y="5" width="1" height="2" fill="#000" /><rect x="17" y="4" width="3" height="1" fill="#000" /></>
                        )}
                    </svg>
                );
            };

            // Render current growing plant
            const renderPlant = () => {
                const isSleeping = mode === 'break';
                const growth = mode === 'work' ? progress : 1;
                if (!currentFlower) return null;
                return renderFlower(currentFlower.pot, currentFlower.stem, currentFlower.flower, growth, 1, isSleeping);
            };

            // Flower Room view
            const renderFlowerRoom = () => {
                const shelves = [];
                const flowersPerShelf = 5;
                const shelfCount = Math.ceil(flowers.length / flowersPerShelf);
                for (let i = 0; i < shelfCount; i++) {
                    shelves.push(flowers.slice(i * flowersPerShelf, (i + 1) * flowersPerShelf));
                }

                return (
                    <div className="flex-grow overflow-auto bg-gray-100 p-4">
                        <div className="text-center mb-4">
                            <div className="font-mono text-xs text-gray-500">TOTAL FOCUS TIME</div>
                            <div className="font-mono text-2xl font-bold">{formatTotalTime(totalTime)}</div>
                        </div>
                        {flowers.length === 0 ? (
                            <div className="text-center py-12">
                                <div className="font-mono text-gray-500 text-sm">Empty so far, get productive!</div>
                            </div>
                        ) : (
                            shelves.map((shelf, shelfIdx) => (
                                <div key={shelfIdx} className="mb-2">
                                    <div className="flex justify-center gap-1 pb-1">
                                        {shelf.map((f, idx) => (
                                            <div key={f.id} className="w-16 h-20 flex items-end justify-center">
                                                <svg width="48" height="64" viewBox="0 0 24 32" style={{ imageRendering: 'pixelated' }}>
                                                    {/* Mini flower */}
                                                    <rect x="6" y="26" width="12" height="6" fill="#000" />
                                                    <rect x="7" y="27" width="10" height="4" fill={POT_STYLES[f.pot].color} />
                                                    <rect x="7" y="25" width="10" height="2" fill="#333" />
                                                    <rect x="11" y="13" width="2" height="12" fill={STEM_TYPES[f.stem].stemColor} />
                                                    <rect x="9" y="17" width="2" height="2" fill={STEM_TYPES[f.stem].stemColor} />
                                                    <rect x="13" y="20" width="2" height="2" fill={STEM_TYPES[f.stem].stemColor} />
                                                    <rect x="9" y="9" width="6" height="5" fill={FLOWER_TYPES[f.flower].petalColor} />
                                                    <rect x="10" y="10" width="4" height="3" fill={FLOWER_TYPES[f.flower].centerColor} />
                                                </svg>
                                            </div>
                                        ))}
                                    </div>
                                    <div className="h-2 bg-gradient-to-b from-amber-800 to-amber-900 border-t-2 border-amber-700 mx-4" />
                                </div>
                            ))
                        )}
                        <div className="text-center mt-4 font-mono text-[10px] text-gray-400">
                            {flowers.length} FLOWER{flowers.length !== 1 ? 'S' : ''} COLLECTED • 125 POSSIBLE VARIETIES
                        </div>
                    </div>
                );
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="app-header">
                        <div className="flex items-center gap-2">
                            <Icons.Pomodoro size={24} />
                            <span className="app-header-title">POMODORO.EXE</span>
                        </div>
                        <div className="flex items-center gap-2">
                            <span className="app-footer-text">SESSIONS: {sessions}</span>
                            <button
                                onClick={() => setView(view === 'timer' ? 'room' : 'timer')}
                                className={`px-2 py-1 font-mono text-[10px] border-2 border-black ${view === 'room' ? 'bg-black text-white' : 'bg-white text-black hover:bg-gray-100'}`}
                            >
                                {view === 'timer' ? 'ROOM' : 'TIMER'}
                            </button>
                        </div>
                    </div>

                    {view === 'room' ? renderFlowerRoom() : (
                        <div className="flex-grow flex flex-col items-center justify-center bg-gray-50 p-6">
                            {/* Mode indicator */}
                            <div className={`px-4 py-1 mb-4 font-mono text-xs font-bold ${mode === 'work' ? 'bg-black text-white' : 'bg-gray-300 text-black'}`}>
                                {mode === 'work' ? 'FOCUS TIME' : 'BREAK TIME'}
                            </div>

                            {/* Plant */}
                            <div className="mb-6">
                                {renderPlant()}
                            </div>

                            {/* Timer */}
                            <div className="font-mono text-5xl font-black mb-6 tracking-wider">
                                {formatTime(timeLeft)}
                            </div>

                            {/* Progress bar */}
                            <div className="w-48 h-2 bg-gray-200 border-2 border-black mb-6">
                                <div
                                    className="h-full bg-black transition-all duration-1000"
                                    style={{ width: `${progress * 100}%` }}
                                />
                            </div>

                            {/* Controls */}
                            <div className="flex gap-4">
                                <button
                                    onClick={() => setIsRunning(!isRunning)}
                                    className="btn-primary"
                                >
                                    {isRunning ? 'PAUSE' : 'START'}
                                </button>
                                <button
                                    onClick={reset}
                                    className="btn-secondary"
                                >
                                    RESET
                                </button>
                            </div>
                        </div>
                    )}

                    <div className="app-footer">
                        <span className="app-footer-text">
                            {view === 'room' ? `TOTAL: ${formatTotalTime(totalTime)}` : (mode === 'work' ? 'GROW YOUR FOCUS' : 'PLANT IS RESTING')}
                        </span>
                    </div>
                </div>
            );
        };

        // --- SCANNER.EXE - Embedded health score app ---
        const HealthScannerApp = () => {
            const [booting, setBooting] = useState(true);
            const [bootText, setBootText] = useState('');

            useEffect(() => {
                const bootSequence = [
                    'HEALTH SCANNER INDUSTRIES',
                    '',
                    'INITIALIZING BIOMETRIC SENSORS...',
                    'LOADING NEURAL INTERFACE...',
                    'CALIBRATING HEALTH MATRIX...',
                    '',
                    'SYSTEM READY'
                ];

                let lineIndex = 0;
                let charIndex = 0;
                let currentText = '';

                const typeInterval = setInterval(() => {
                    if (lineIndex >= bootSequence.length) {
                        clearInterval(typeInterval);
                        setTimeout(() => setBooting(false), 500);
                        return;
                    }

                    const currentLine = bootSequence[lineIndex];
                    if (charIndex < currentLine.length) {
                        currentText += currentLine[charIndex];
                        setBootText(currentText);
                        charIndex++;
                    } else {
                        currentText += '\n';
                        setBootText(currentText);
                        lineIndex++;
                        charIndex = 0;
                    }
                }, 30);

                return () => clearInterval(typeInterval);
            }, []);

            if (booting) {
                return (
                    <div className="h-full flex flex-col bg-black select-none">
                        <div className="flex-grow flex flex-col items-center justify-center p-8 font-mono">
                            <div className="text-green-500 text-center whitespace-pre-line text-sm mb-8">
                                {bootText}
                                <span className="animate-pulse">_</span>
                            </div>
                            <div className="flex gap-2">
                                <div className="w-3 h-3 bg-green-500 animate-pulse" style={{ animationDelay: '0ms' }}></div>
                                <div className="w-3 h-3 bg-green-500 animate-pulse" style={{ animationDelay: '150ms' }}></div>
                                <div className="w-3 h-3 bg-green-500 animate-pulse" style={{ animationDelay: '300ms' }}></div>
                            </div>
                        </div>
                        <div className="p-2 border-t border-green-900 text-center">
                            <span className="font-mono text-[10px] text-green-700">© HEALTH SCANNER INDUSTRIES 2077</span>
                        </div>
                    </div>
                );
            }

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <iframe
                        src="https://healthscore-2-0.vercel.app/"
                        className="w-full h-full border-0"
                        title="Health Scanner"
                        allow="camera; microphone"
                    />
                </div>
            );
        };

        // --- PERSONAL.EXE - Password Protected (never opens) ---
        const PersonalApp = () => {
            const [password, setPassword] = useState('');
            const [attempts, setAttempts] = useState(0);
            const [error, setError] = useState('');
            const [shaking, setShaking] = useState(false);

            const handleSubmit = (e) => {
                e.preventDefault();
                setAttempts(a => a + 1);
                setShaking(true);
                setTimeout(() => setShaking(false), 500);

                const errors = [
                    'ACCESS DENIED',
                    'INVALID CREDENTIALS',
                    'AUTHENTICATION FAILED',
                    'PERMISSION DENIED',
                    'UNAUTHORIZED ACCESS',
                    'INCORRECT PASSWORD',
                    'SECURITY VIOLATION',
                    'ACCESS RESTRICTED',
                    'VERIFICATION FAILED',
                    'ENTRY PROHIBITED'
                ];
                setError(errors[Math.floor(Math.random() * errors.length)]);
                setPassword('');
            };

            return (
                <div className="h-full flex flex-col bg-black select-none">
                    <div className="p-2 border-b border-red-900 bg-black flex items-center gap-2">
                        <Icons.Lock size={20} />
                        <span className="font-mono text-xs font-bold text-red-500">PERSONAL.EXE</span>
                        <span className="font-mono text-[10px] text-red-700">ENCRYPTED</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-8">
                        <div className="mb-8">
                            <Icons.Lock size={64} />
                        </div>
                        <div className="font-mono text-red-500 text-lg font-bold mb-2">SECURE AREA</div>
                        <div className="font-mono text-red-700 text-[10px] mb-6">AUTHORIZATION REQUIRED</div>

                        <form onSubmit={handleSubmit} className={`w-64 ${shaking ? 'animate-shake' : ''}`}>
                            <div className="mb-4">
                                <input
                                    type="password"
                                    value={password}
                                    onChange={(e) => setPassword(e.target.value)}
                                    placeholder="ENTER PASSWORD"
                                    className="w-full px-4 py-2 bg-black border-2 border-red-800 text-red-500 font-mono text-sm placeholder-red-900 focus:outline-none focus:border-red-500"
                                />
                            </div>
                            <button
                                type="submit"
                                className="w-full px-4 py-2 bg-red-900 text-red-100 font-mono text-sm font-bold hover:bg-red-800 border-2 border-red-700"
                            >
                                AUTHENTICATE
                            </button>
                        </form>

                        {error && (
                            <div className="mt-6 p-3 border border-red-800 bg-red-950">
                                <div className="font-mono text-red-500 text-sm font-bold">{error}</div>
                            </div>
                        )}

                        {attempts > 0 && (
                            <div className="mt-4 font-mono text-red-800 text-[10px]">
                                FAILED ATTEMPTS: {attempts}
                            </div>
                        )}

                        {attempts >= 5 && (
                            <div className="mt-2 font-mono text-red-600 text-[10px] animate-pulse">
                                WARNING: SECURITY PROTOCOL ACTIVATED
                            </div>
                        )}
                    </div>
                    <div className="p-2 border-t border-red-900 text-center">
                        <span className="font-mono text-[10px] text-red-800">CLASSIFIED • TOP SECRET • EYES ONLY</span>
                    </div>
                </div>
            );
        };

        // --- APPS Folder - Grid of all apps organized in folders ---
        const AppsFolder = ({ onOpenApp }) => {
            const [selectedFolder, setSelectedFolder] = useState(null);

            const folders = [
                { key: 'GAMES', name: 'GAMES', icon: 'GamesFolder' },
                { key: 'PRODUCTIVITY', name: 'PRODUCTIVITY', icon: 'ProductivityFolder' },
                { key: 'ABOUT', name: 'ABOUT', icon: 'AboutFolder' }
            ];

            const APP_CATEGORIES = {
                GAMES: [
                    { id: 'SNAKE', title: 'SNEK.EXE', icon: 'Snek' },
                    { id: 'LABYRINTH', title: 'LABYRINTH.EXE', icon: 'Labyrinth' },
                    { id: 'MINESWEEPER', title: 'MINESWEEPER.EXE', icon: 'Minesweeper' },
                    { id: 'STARSHIP', title: 'STARSHIP.EXE', icon: 'Starship' },
                    { id: 'DICE', title: 'DICE.EXE', icon: 'Dice' }
                ],
                PRODUCTIVITY: [
                    { id: 'PAINT', title: 'PAINT.EXE', icon: 'Palette' },
                    { id: 'POMODORO', title: 'POMODORO.EXE', icon: 'Pomodoro' },
                    { id: 'SYNTH', title: 'SYNTH_001.WAV', icon: 'Synth' },
                    { id: 'RADIO', title: 'RADIO.WAV', icon: 'Radio' },
                    { id: 'SCANNER', title: 'SCANNER.EXE', icon: 'HealthScanner' },
                    { id: 'ORACLE', title: 'ORACLE.EXE', icon: 'Oracle' },
                    { id: 'TAROT', title: 'TAROT.DAT', icon: 'Tarot' },
                    { id: 'VOID', title: 'VOID.TXT', icon: 'Void' }
                ],
                ABOUT: [
                    { id: 'SYSTEM', title: 'ABOUT_SHORTCUT.EXE', icon: 'Terminal', isShortcut: true },
                    { id: 'GALLERY', title: 'GALLERY.EXE', icon: 'Gallery' },
                    { id: 'MAP', title: 'MAP.EXE', icon: 'Globe' },
                    { id: 'PERSONAL', title: 'PERSONAL.EXE', icon: 'Lock' },
                    { id: 'DESTRUCTION', title: 'DESTRUCTION.EXE', icon: 'Destruction' },
                    { id: 'TRASH', title: 'TRASH.BIN', icon: 'TrashCan' }
                ]
            };

            if (selectedFolder) {
                const FolderIcon = Icons[folders.find(f => f.key === selectedFolder)?.icon || 'FolderClosed'];
                const apps = APP_CATEGORIES[selectedFolder];
                return (
                    <div className="h-full flex flex-col bg-white select-none">
                        <div className="p-2 border-b-2 border-black bg-white flex items-center gap-3">
                            <button onClick={() => setSelectedFolder(null)} className="p-1 border-2 border-black hover:bg-black hover:text-white">
                                <Icons.Back size={16} />
                            </button>
                            <FolderIcon size={24} />
                            <span className="font-mono text-xs font-bold uppercase">{folders.find(f => f.key === selectedFolder)?.name}</span>
                            <span className="app-footer-text">({apps.length} ITEMS)</span>
                        </div>
                        <div className="flex-grow overflow-auto">
                            <table className="w-full text-left border-collapse">
                                <thead className="bg-black text-white text-xs font-mono sticky top-0">
                                    <tr><th className="p-2">NAME</th><th className="p-2 border-l border-gray-600">TYPE</th></tr>
                                </thead>
                                <tbody className="font-mono text-xs">
                                    {apps.map((app, idx) => {
                                        const AppIcon = Icons[app.icon];
                                        return (
                                            <tr key={idx}
                                                onClick={() => onOpenApp(app.id)}
                                                className="border-b border-gray-200 hover:bg-yellow-100 cursor-pointer"
                                            >
                                                <td className="p-2 font-bold flex items-center gap-2">
                                                    <AppIcon size={20} />
                                                    {app.title}
                                                    {app.isShortcut && <span className="text-[8px] text-gray-400 ml-1">(SHORTCUT)</span>}
                                                </td>
                                                <td className="p-2 border-l border-gray-200 text-gray-500">
                                                    {app.title.split('.').pop()}
                                                </td>
                                            </tr>
                                        );
                                    })}
                                </tbody>
                            </table>
                        </div>
                        <div className="app-footer">
                            <span className="app-footer-text">CLICK TO OPEN • DOUBLE-CLICK TO RUN</span>
                        </div>
                    </div>
                );
            }

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex items-center gap-2">
                        <Icons.Apps size={24} />
                        <span className="app-header-title">APPS</span>
                        <span className="app-footer-text">/ROOT/APPS</span>
                    </div>
                    <div className="flex-grow p-6 flex items-start justify-center bg-gray-50">
                        <div className="grid grid-cols-3 gap-8">
                            {folders.map(folder => {
                                const FolderIcon = Icons[folder.icon];
                                return (
                                    <button
                                        key={folder.key}
                                        onClick={() => setSelectedFolder(folder.key)}
                                        className="group flex flex-col items-center gap-2 p-4 hover:bg-white border-2 border-transparent hover:border-black transition-all"
                                    >
                                        <div className="bg-white border-2 border-black p-3 icon-shadow group-hover:translate-x-1 group-hover:translate-y-1 group-hover:shadow-none transition-all">
                                            <FolderIcon size={48} />
                                        </div>
                                        <span className="font-mono text-xs font-bold uppercase">{folder.name}</span>
                                        <span className="app-footer-text">{APP_CATEGORIES[folder.key].length} ITEMS</span>
                                    </button>
                                );
                            })}
                        </div>
                    </div>
                    <div className="app-footer">
                        <span className="app-footer-text">GAMES • PRODUCTIVITY • ABOUT</span>
                    </div>
                </div>
            );
        };

        // --- CONTACT - Simple email contact ---
        const ContactApp = () => {
            const [copied, setCopied] = useState(false);
            const email = 'mateusmuste9@gmail.com';

            const copyEmail = () => {
                navigator.clipboard.writeText(email);
                setCopied(true);
                setTimeout(() => setCopied(false), 2000);
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="flex-grow flex flex-col items-center justify-center bg-gray-50 p-6">
                        <Icons.Email size={48} />
                        <div className="font-mono text-lg font-bold mt-4 mb-1">GET IN TOUCH</div>
                        <div className="font-mono text-xs text-gray-500 mb-4">{email}</div>
                        <div className="flex gap-2">
                            <button onClick={copyEmail} className="btn-primary">
                                {copied ? 'COPIED!' : 'COPY EMAIL'}
                            </button>
                            <a href={`mailto:${email}`} className="btn-primary">
                                OPEN MAIL
                            </a>
                        </div>
                    </div>
                </div>
            );
        };

        // --- OS SHELL ---

        const OS = () => {
            const [booted, setBooted] = useState(false);
            const [bootPhase, setBootPhase] = useState(0); // 0: kernel, 1: mobile warning, 2: ready
            const [isMobile, setIsMobile] = useState(false);
            const [topZ, setTopZ] = useState(100);
            const topZRef = useRef(100);
            const [destructionMode, setDestructionMode] = useState(false);
            const [dogReleased, setDogReleased] = useState(false);
            const [dogPos, setDogPos] = useState({ x: 100, y: 300 });
            const [dogVel, setDogVel] = useState({ x: 4, y: 3 });
            const [dogOnGround, setDogOnGround] = useState(true);
            const [dogFacingRight, setDogFacingRight] = useState(true);
            const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
            const [carriedIcon, setCarriedIcon] = useState(null);
            const [iconPositions, setIconPositions] = useState({});
            const [destructionDogGone, setDestructionDogGone] = useState(false);

            // Physics constants
            const GRAVITY = 0.8;
            const JUMP_FORCE = -12;
            const GROUND_Y = window.innerHeight - 120;
            const FRICTION = 0.95;

            // Handle dog stealing the destruction button - dog starts running around!
            const handleDogSteal = () => {
                setDestructionDogGone(true);
                setDogReleased(true); // Dog starts running around the screen
                // Close the destruction window
                setWindows(prev => ({
                    ...prev,
                    DESTRUCTION: { ...prev.DESTRUCTION, isOpen: false }
                }));
            };

            // Dog AI - DVD logo style bouncing
            useEffect(() => {
                if (!dogReleased) return;

                const DOG_SPEED_X = 4;
                const DOG_SPEED_Y = 3;

                const dogInterval = setInterval(() => {
                    setDogVel(prevVel => {
                        let newVelX = prevVel.x;
                        let newVelY = prevVel.y;

                        // Initialize velocity if zero
                        if (newVelX === 0) newVelX = DOG_SPEED_X;
                        if (newVelY === 0) newVelY = DOG_SPEED_Y;

                        return { x: newVelX, y: newVelY };
                    });

                    setDogPos(prev => {
                        let newX = prev.x + dogVel.x;
                        let newY = prev.y + dogVel.y;

                        // Bounce off walls - DVD style
                        if (newX >= window.innerWidth - 80) {
                            newX = window.innerWidth - 80;
                            setDogVel(v => ({ ...v, x: -Math.abs(v.x) }));
                            setDogFacingRight(false);
                        }
                        if (newX <= 0) {
                            newX = 0;
                            setDogVel(v => ({ ...v, x: Math.abs(v.x) }));
                            setDogFacingRight(true);
                        }
                        if (newY >= window.innerHeight - 100) {
                            newY = window.innerHeight - 100;
                            setDogVel(v => ({ ...v, y: -Math.abs(v.y) }));
                        }
                        if (newY <= 60) {
                            newY = 60;
                            setDogVel(v => ({ ...v, y: Math.abs(v.y) }));
                        }

                        return { x: newX, y: newY };
                    });

                    // Randomly grab icons
                    if (!carriedIcon && Math.random() < 0.003) {
                        const iconKeys = Object.keys(windows);
                        const randomIcon = iconKeys[Math.floor(Math.random() * iconKeys.length)];
                        setCarriedIcon(randomIcon);

                        setTimeout(() => {
                            setCarriedIcon(null);
                        }, 3000 + Math.random() * 4000);
                    }
                }, 30);

                return () => clearInterval(dogInterval);
            }, [dogReleased, dogVel, carriedIcon]);

            // Desktop icons - only show main folders
            const desktopIcons = ["SYSTEM", "FILES", "APPS", "CONTACT"];

            // Window State (Position x/y added for dragging) - content rendered separately
            const [windows, setWindows] = useState({
                "SYSTEM": { id: "SYSTEM", title: "SYSTEM_INFO", icon: "Terminal", x: 400, y: 50, w: '1000px', h: '800px', isOpen: true, isMin: false, z: 10, isDesktop: true },
                "FILES": { id: "FILES", title: "MEDIA_LIB", icon: "Folder", x: 100, y: 80, w: '800px', h: '500px', isOpen: false, isMin: false, z: 11, isDesktop: true },
                "APPS": { id: "APPS", title: "APPS", icon: "Apps", x: 150, y: 110, w: '700px', h: '500px', isOpen: false, isMin: false, z: 12, isDesktop: true },
                "CONTACT": { id: "CONTACT", title: "CONTACT", icon: "Email", x: 200, y: 140, w: '320px', h: '220px', isOpen: false, isMin: false, z: 13, isDesktop: true },
                "PAINT": { id: "PAINT", title: "PAINT.EXE", icon: "Palette", x: 150, y: 110, w: '700px', h: '600px', isOpen: false, isMin: false, z: 14 },
                "SNAKE": { id: "SNAKE", title: "SNEK.EXE", icon: "Snek", x: 200, y: 140, w: '640px', h: '520px', isOpen: false, isMin: false, z: 15 },
                "TRASH": { id: "TRASH", title: "TRASH.BIN", icon: "TrashCan", x: 250, y: 170, w: '500px', h: '400px', isOpen: false, isMin: false, z: 16 },
                "VOID": { id: "VOID", title: "VOID.TXT", icon: "Void", x: 300, y: 50, w: '500px', h: '400px', isOpen: false, isMin: false, z: 17 },
                "ORACLE": { id: "ORACLE", title: "ORACLE.EXE", icon: "Oracle", x: 350, y: 80, w: '500px', h: '450px', isOpen: false, isMin: false, z: 18 },
                "RADIO": { id: "RADIO", title: "RADIO.WAV", icon: "Radio", x: 400, y: 110, w: '400px', h: '400px', isOpen: false, isMin: false, z: 19 },
                "DICE": { id: "DICE", title: "DICE.EXE", icon: "Dice", x: 450, y: 140, w: '350px', h: '450px', isOpen: false, isMin: false, z: 20 },
                "LABYRINTH": { id: "LABYRINTH", title: "LABYRINTH.EXE", icon: "Labyrinth", x: 100, y: 50, w: '600px', h: '500px', isOpen: false, isMin: false, z: 21 },
                "MINESWEEPER": { id: "MINESWEEPER", title: "MINESWEEPER.EXE", icon: "Minesweeper", x: 120, y: 40, w: '500px', h: '560px', isOpen: false, isMin: false, z: 26 },
                "STARSHIP": { id: "STARSHIP", title: "STARSHIP.EXE", icon: "Starship", x: 80, y: 40, w: '540px', h: '480px', isOpen: false, isMin: false, z: 27 },
                "SYNTH": { id: "SYNTH", title: "SYNTH_001.WAV", icon: "Synth", x: 150, y: 80, w: '500px', h: '350px', isOpen: false, isMin: false, z: 22 },
                "DESTRUCTION": { id: "DESTRUCTION", title: "DESTRUCTION.EXE", icon: "Destruction", x: 200, y: 110, w: '400px', h: '400px', isOpen: false, isMin: false, z: 23 },
                "TAROT": { id: "TAROT", title: "TAROT.DAT", icon: "Tarot", x: 100, y: 60, w: '520px', h: '550px', isOpen: false, isMin: false, z: 24 },
                "GALLERY": { id: "GALLERY", title: "GALLERY.EXE", icon: "Gallery", x: 100, y: 80, w: '500px', h: '500px', isOpen: false, isMin: false, z: 28 },
                "MAP": { id: "MAP", title: "MAP.EXE", icon: "Globe", x: 150, y: 100, w: '360px', h: '400px', isOpen: false, isMin: false, z: 29 },
                "POMODORO": { id: "POMODORO", title: "POMODORO.EXE", icon: "Pomodoro", x: 200, y: 60, w: '350px', h: '620px', isOpen: false, isMin: false, z: 30 },
                "SCANNER": { id: "SCANNER", title: "SCANNER.EXE", icon: "HealthScanner", x: 150, y: 50, w: '600px', h: '700px', isOpen: false, isMin: false, z: 31 },
                "PERSONAL": { id: "PERSONAL", title: "PERSONAL.EXE", icon: "Lock", x: 200, y: 80, w: '400px', h: '500px', isOpen: false, isMin: false, z: 32 }
            });

            // Render window content based on ID
            const getWindowContent = (id) => {
                switch (id) {
                    case "SYSTEM": return <SystemInfo />;
                    case "FILES": return <FileExplorer />;
                    case "APPS": return <AppsFolder onOpenApp={open} />;
                    case "CONTACT": return <ContactApp />;
                    case "PAINT": return <PaintApp />;
                    case "SNAKE": return <SnakeAppNew />;
                    case "TRASH": return <TrashApp />;
                    case "VOID": return <VoidApp />;
                    case "ORACLE": return <OracleApp />;
                    case "RADIO": return <RadioApp />;
                    case "DICE": return <DiceApp />;
                    case "LABYRINTH": return <LabyrinthApp />;
                    case "MINESWEEPER": return <MinesweeperApp />;
                    case "STARSHIP": return <StarshipApp />;
                    case "SYNTH": return <SynthApp />;
                    case "DESTRUCTION": return <DestructionApp onDogSteal={handleDogSteal} />;
                    case "TAROT": return <TarotApp />;
                    case "GALLERY": return <GalleryApp />;
                    case "MAP": return <MapApp />;
                    case "POMODORO": return <PomodoroApp />;
                    case "SCANNER": return <HealthScannerApp />;
                    case "PERSONAL": return <PersonalApp />;
                    default: return null;
                }
            };

            // Dragging State
            const [drag, setDrag] = useState({ id: null, offsetX: 0, offsetY: 0 });

            // Boot sequence with mobile detection
            useEffect(() => {
                const checkMobile = window.innerWidth < 768 || /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                setIsMobile(checkMobile);

                // Close SYSTEM window on mobile by default
                if (checkMobile) {
                    setWindows(prev => ({
                        ...prev,
                        SYSTEM: { ...prev.SYSTEM, isOpen: false }
                    }));
                }

                // Preload all pixelarticons during boot
                const iconNames = [
                    'monitor', 'folder', 'fill', 'gamepad', 'trash', 'undo', 'redo', 'file',
                    'close', 'minus', 'checkbox', 'send', 'movie', 'book', 'music', 'arrow-left',
                    'code', 'book-open', 'radio-on', 'dice', 'layout-rows', 'table', 'arrow-up',
                    'keyboard', 'power', 'card', 'paw', 'mail', 'add-grid', 'image', 'map',
                    'clock', 'heart', 'lock', 'sliders', 'user'
                ];
                iconNames.forEach(name => {
                    const img = new Image();
                    img.src = `https://unpkg.com/pixelarticons@1.8.1/svg/${name}.svg`;
                });

                // Phase 0: Show kernel boot for 3 seconds
                setTimeout(() => {
                    if (checkMobile) {
                        // Phase 1: Show mobile warning for 3 seconds
                        setBootPhase(1);
                        setTimeout(() => {
                            setBootPhase(2);
                            setBooted(true);
                        }, 3000);
                    } else {
                        setBootPhase(2);
                        setBooted(true);
                    }
                }, 3000);

                // Handle resize
                const handleResize = () => {
                    setIsMobile(window.innerWidth < 768);
                };
                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, []);

            // Window Ops
            const focus = (id) => {
                topZRef.current += 1;
                const newZ = topZRef.current;
                setWindows(p => ({ ...p, [id]: { ...p[id], z: newZ } }));
                setTopZ(newZ);
            }
            const open = (id) => {
                topZRef.current += 1;
                const newZ = topZRef.current;
                setWindows(p => ({ ...p, [id]: { ...p[id], isOpen: true, isMin: false, z: newZ } }));
                setTopZ(newZ);
            }
            const close = (id) => setWindows(p => ({ ...p, [id]: { ...p[id], isOpen: false } }));
            const toggleMin = (id) => setWindows(p => ({ ...p, [id]: { ...p[id], isMin: !p[id].isMin } }));

            // Drag Handlers
            const handleMouseDown = (e, id) => {
                e.preventDefault();
                focus(id); // bring to front
                const win = windows[id];
                const rect = e.currentTarget.getBoundingClientRect(); // click target is header
                // Calculate offset from the window's top-left corner
                // However, we track window X/Y which is top/left style. 
                // Simple math: MouseX - WindowX
                setDrag({
                    id: id,
                    offsetX: e.clientX - win.x,
                    offsetY: e.clientY - win.y
                });
            };

            const handleMouseMove = (e) => {
                if (drag.id) {
                    setWindows(prev => ({
                        ...prev,
                        [drag.id]: {
                            ...prev[drag.id],
                            x: e.clientX - drag.offsetX,
                            y: e.clientY - drag.offsetY
                        }
                    }));
                }
            };

            const handleMouseUp = () => setDrag({ id: null, offsetX: 0, offsetY: 0 });

            // Boot screen component with kernel messages and inversion
            const BootScreen = () => {
                const [lines, setLines] = useState([]);
                const [inverted, setInverted] = useState(false);
                const msgs = [
                    'kernel: init ULTRA_INT v1.0.0',
                    'kernel: loading core modules',
                    'kernel: mounting filesystem',
                    'kernel: starting display',
                    'kernel: loading assets',
                    'kernel: init window manager',
                    'kernel: loading preferences',
                    'kernel: starting services',
                    'kernel: systems nominal',
                    'kernel: boot complete'
                ];
                useEffect(() => {
                    let i = 0;
                    const iv = setInterval(() => {
                        if (i < msgs.length) { setLines(p => [...p, msgs[i]]); i++; }
                    }, 250);
                    const inv = setTimeout(() => setInverted(true), 2500);
                    return () => { clearInterval(iv); clearTimeout(inv); };
                }, []);
                return (
                    <div className={`h-screen w-screen font-mono flex flex-col items-center justify-center transition-colors duration-500 ${inverted ? 'bg-white text-black' : 'bg-black text-white'}`}>
                        <pre className="text-[5px] sm:text-[7px] md:text-[9px] leading-tight select-none">{`
██╗   ██╗██╗  ████████╗██████╗  █████╗     ██╗███╗   ██╗████████╗
██║   ██║██║  ╚══██╔══╝██╔══██╗██╔══██╗    ██║████╗  ██║╚══██╔══╝
██║   ██║██║     ██║   ██████╔╝███████║    ██║██╔██╗ ██║   ██║
██║   ██║██║     ██║   ██╔══██╗██╔══██║    ██║██║╚██╗██║   ██║
╚██████╔╝███████╗██║   ██║  ██║██║  ██║    ██║██║ ╚████║   ██║
 ╚═════╝ ╚══════╝╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝    ╚═╝╚═╝  ╚═══╝   ╚═╝
`}</pre>
                        <div className={`text-[10px] tracking-[0.3em] mt-2 mb-10 ${inverted ? 'text-gray-500' : 'text-gray-600'}`}>no side industries</div>
                        <div className={`w-72 max-w-[85vw] text-[8px] ${inverted ? 'text-gray-400' : 'text-gray-600'}`}>
                            {lines.map((l, i) => <div key={i}>{l}</div>)}
                            {lines.length < msgs.length && <span className="inline-block w-1.5 h-3 bg-current animate-pulse" />}
                        </div>
                    </div>
                );
            };

            // Boot screens
            if (!booted) {
                if (bootPhase === 0) {
                    return <BootScreen />;
                }
                if (bootPhase === 1) {
                    return (
                        <div className="h-screen w-screen bg-black text-white font-mono flex flex-col items-center justify-center p-8">
                            <div className="text-center">
                                <div className="text-2xl font-bold mb-4 animate-pulse">NOTICE</div>
                                <div className="text-lg mb-2">BEST VIEWED ON DESKTOP</div>
                                <div className="text-xs text-gray-500 mt-4">Mobile experience may be limited...</div>
                                <div className="mt-8 flex gap-1 justify-center">
                                    <div className="w-2 h-2 bg-white animate-pulse" style={{ animationDelay: '0ms' }}></div>
                                    <div className="w-2 h-2 bg-white animate-pulse" style={{ animationDelay: '200ms' }}></div>
                                    <div className="w-2 h-2 bg-white animate-pulse" style={{ animationDelay: '400ms' }}></div>
                                </div>
                            </div>
                        </div>
                    );
                }
            }

            // Destruction overlay
            if (destructionMode === 'black') {
                return <div className="h-screen w-screen bg-black" />;
            }
            if (destructionMode === 'reboot') {
                return (
                    <div className="h-screen w-screen bg-black text-green-500 font-mono flex flex-col items-center justify-center">
                        <pre className="text-xs mb-4">
                            {`
███████╗██╗   ██╗███████╗████████╗███████╗███╗   ███╗
██╔════╝╚██╗ ██╔╝██╔════╝╚══██╔══╝██╔════╝████╗ ████║
███████╗ ╚████╔╝ ███████╗   ██║   █████╗  ██╔████╔██║
╚════██║  ╚██╔╝  ╚════██║   ██║   ██╔══╝  ██║╚██╔╝██║
███████║   ██║   ███████║   ██║   ███████╗██║ ╚═╝ ██║
╚══════╝   ╚═╝   ╚══════╝   ╚═╝   ╚══════╝╚═╝     ╚═╝
`}
                        </pre>
                        <div className="animate-pulse">REBOOTING...</div>
                        <div className="mt-4 text-xs text-green-700">DESTRUCTION COMPLETE</div>
                    </div>
                );
            }

            return (
                <div
                    className={`h-screen w-screen relative overflow-hidden desktop-bg ${destructionMode ? 'animate-pulse' : ''}`}
                    onMouseMove={(e) => {
                        handleMouseMove(e);
                        setMousePos({ x: e.clientX, y: e.clientY });
                    }}
                    onMouseUp={handleMouseUp}
                    style={destructionMode ? { filter: 'hue-rotate(180deg) saturate(3)' } : {}}
                >
                    {/* DESKTOP ICONS - Only show main folders */}
                    <div className={`absolute z-0 ${isMobile ? 'top-4 left-0 right-0 flex flex-row justify-center gap-4 px-2' : 'top-4 left-4 flex flex-col gap-6'}`}>
                        {desktopIcons.map(appId => {
                            const app = windows[appId];
                            if (!app) return null;
                            const IconCmp = Icons[app.icon];
                            const iconOffset = iconPositions[app.id] || { x: 0, y: 0 };

                            // Skip icon if dog is carrying it
                            if (carriedIcon === app.id) return null;

                            return (
                                <button
                                    key={app.id}
                                    onClick={() => open(app.id)}
                                    className={`group flex flex-col items-center gap-1 ${isMobile ? 'w-16' : 'w-24 gap-2'}`}
                                    style={{
                                        transform: isMobile ? 'none' : `translate(${iconOffset.x}px, ${iconOffset.y}px)`,
                                        transition: 'transform 0.3s ease'
                                    }}
                                >
                                    <div className={`bg-white border-2 border-black icon-shadow group-hover:translate-x-1 group-hover:translate-y-1 group-hover:shadow-none transition-all ${isMobile ? 'p-2' : 'p-3'}`}>
                                        <IconCmp size={isMobile ? 24 : 32} />
                                    </div>
                                    <span className={`bg-white border border-black px-1 font-mono font-bold shadow-sm ${isMobile ? 'text-[8px]' : 'text-[10px]'}`}>{isMobile ? app.title.split('_')[0] : app.title}</span>
                                </button>
                            );
                        })}
                    </div>

                    {/* WINDOWS */}
                    {Object.values(windows).map(win => (
                        win.isOpen && !win.isMin && (
                            <div
                                key={win.id}
                                onMouseDown={() => focus(win.id)}
                                className={`flex flex-col bg-white border-2 border-black ${isMobile ? 'fixed inset-0 top-12 bottom-0' : 'absolute window-shadow'}`}
                                style={isMobile ? {
                                    zIndex: win.z
                                } : {
                                    left: win.x,
                                    top: win.y,
                                    width: win.w,
                                    height: win.h,
                                    zIndex: win.z
                                }}
                            >
                                {/* HEADER (DRAG HANDLE) */}
                                <div
                                    className={`flex justify-between items-center p-1 border-b-2 border-black select-none ${isMobile ? '' : 'cursor-move'} ${win.z === topZ ? 'bg-black text-white' : 'bg-gray-200 text-black'}`}
                                    onMouseDown={(e) => !isMobile && handleMouseDown(e, win.id)}
                                >
                                    <div className="flex items-center gap-2 pl-2 pointer-events-none">
                                        <span className="font-mono text-xs font-bold tracking-widest uppercase truncate">{win.title}</span>
                                    </div>
                                    <div className="flex gap-1" onMouseDown={e => e.stopPropagation()} onTouchStart={e => e.stopPropagation()}>
                                        {!isMobile && <button onClick={() => toggleMin(win.id)} className={`w-6 h-6 flex items-center justify-center border border-transparent hover:bg-white/20 ${win.z === topZ ? 'invert' : ''}`}><Icons.Minus size={14} /></button>}
                                        <button onClick={() => close(win.id)} className={`w-10 h-10 md:w-6 md:h-6 flex items-center justify-center hover:bg-red-500 ${win.z === topZ ? 'invert hover:invert-0' : ''}`}><Icons.X size={24} /></button>
                                    </div>
                                </div>
                                {/* CONTENT */}
                                <div className="flex-grow overflow-auto relative bg-white" onMouseDown={() => focus(win.id)}>
                                    {getWindowContent(win.id)}
                                </div>
                            </div>
                        )
                    ))}

                    {/* TASKBAR */}
                    <div className={`h-12 bg-white flex items-center px-2 gap-1 md:gap-2 z-[99999] absolute w-full shadow-2xl ${isMobile ? 'top-0 border-b-2 border-black' : 'bottom-0 border-t-2 border-black mt-auto'}`}>
                        <div className={`bg-black text-white py-1 font-black select-none tracking-wider ${isMobile ? 'px-1 text-[8px]' : 'px-2 text-xs mr-2'}`}>{isMobile ? 'MM.COM' : 'MATEUSMUSTE.COM'}</div>
                        <div className={`flex gap-1 ${isMobile ? 'overflow-x-auto flex-nowrap' : ''}`}>
                            {Object.values(windows).map(win => {
                                const IconCmp = Icons[win.icon];
                                return win.isOpen && (
                                    <button key={win.id}
                                        onClick={() => { if (win.isMin) toggleMin(win.id); focus(win.id) }}
                                        className={`flex items-center gap-1 md:gap-2 px-2 md:px-3 py-1 border-2 border-black font-mono text-xs font-bold transition-all flex-shrink-0 ${win.z === topZ && !win.isMin ? 'bg-black text-white btn-shadow' : 'bg-white hover:translate-y-[-2px]'}`}
                                    >
                                        <IconCmp size={14} />
                                        <span className="uppercase hidden md:inline">{win.title}</span>
                                    </button>
                                );
                            })}
                        </div>
                        <div className="flex-grow"></div>
                        <div className={`font-mono font-bold border-l-2 border-black ${isMobile ? 'text-[10px] px-2' : 'text-xs px-4'}`}>{new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>
                    </div>

                    {/* DOG - Cute pixel dog with running animation */}
                    {dogReleased && (
                        <div
                            className="fixed z-[999999] cursor-pointer select-none"
                            style={{
                                left: dogPos.x,
                                top: dogPos.y,
                                transform: `scaleX(${dogFacingRight ? 1 : -1})`,
                            }}
                            onClick={() => setDogReleased(false)}
                        >
                            <svg width="64" height="48" viewBox="0 0 64 48" style={{ imageRendering: 'pixelated' }}>
                                {/* Cute dog - full black, running animation */}
                                {/* Body */}
                                <rect x="16" y="16" width="32" height="16" fill="#000" />
                                {/* Head - rounder, cuter */}
                                <rect x="4" y="12" width="16" height="16" fill="#000" />
                                {/* Floppy ears */}
                                <rect x="2" y="4" width="6" height="14" fill="#000" />
                                <rect x="14" y="4" width="6" height="14" fill="#000" />
                                {/* Eye - big cute eye */}
                                <rect x="8" y="16" width="6" height="6" fill="#fff" />
                                <rect x="10" y="18" width="3" height="3" fill="#000" />
                                {/* Nose */}
                                <rect x="4" y="22" width="4" height="4" fill="#000" />
                                {/* Tongue when running */}
                                <rect x="2" y="26" width="4" height="2" fill="#000" />
                                {/* Running legs animation using frame counter */}
                                <rect x="16" y="32" width="6" height={Math.sin(Date.now() / 100) > 0 ? 10 : 14} fill="#000" />
                                <rect x="26" y="32" width="6" height={Math.sin(Date.now() / 100) > 0 ? 14 : 10} fill="#000" />
                                <rect x="34" y="32" width="6" height={Math.sin(Date.now() / 100) > 0 ? 10 : 14} fill="#000" />
                                <rect x="42" y="32" width="6" height={Math.sin(Date.now() / 100) > 0 ? 14 : 10} fill="#000" />
                                {/* Tail - wagging */}
                                <rect x="48" y={12 + Math.sin(Date.now() / 150) * 4} width="12" height="4" fill="#000" />
                                <rect x="58" y={8 + Math.sin(Date.now() / 150) * 4} width="4" height="6" fill="#000" />
                            </svg>
                            {carriedIcon && (
                                <div
                                    className="absolute bg-white border-2 border-black p-1"
                                    style={{ top: -20, left: 8 }}
                                >
                                    {React.createElement(Icons[windows[carriedIcon]?.icon], { size: 24 })}
                                </div>
                            )}
                        </div>
                    )}

                    {/* CRT Static overlay for destruction */}
                    {destructionMode === true && (
                        <div className="fixed inset-0 z-[999998] pointer-events-none crt-static" />
                    )}

                    {/* Glitch animation styles */}
                    <style>{`
                        @keyframes glitch {
                            0% { transform: translate(0); filter: hue-rotate(0deg); }
                            20% { transform: translate(-2px, 2px); filter: hue-rotate(90deg); }
                            40% { transform: translate(2px, -2px); filter: hue-rotate(180deg); }
                            60% { transform: translate(-2px, -2px); filter: hue-rotate(270deg); }
                            80% { transform: translate(2px, 2px); filter: hue-rotate(360deg); }
                            100% { transform: translate(0); filter: hue-rotate(0deg); }
                        }
                        .group-hover\\:animate-glitch:hover {
                            animation: glitch 0.2s infinite;
                        }
                        .destruction-icon:hover {
                            animation: glitch 0.3s infinite;
                        }
                        .crt-static {
                            background: repeating-linear-gradient(
                                0deg,
                                rgba(0, 0, 0, 0.1) 0px,
                                rgba(0, 0, 0, 0.1) 1px,
                                transparent 1px,
                                transparent 2px
                            );
                            animation: static 0.1s infinite;
                        }
                        @keyframes static {
                            0% { opacity: 0.3; }
                            50% { opacity: 0.5; }
                            100% { opacity: 0.3; }
                        }
                    `}</style>

                </div>
            )
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<OS />);
    </script>
</body>

</html>
