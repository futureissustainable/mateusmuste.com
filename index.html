<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>MATEUSMUSTE // OS</title>
    <meta name="description" content="Interactive brutalist portfolio OS by Mateus Muste. A creative web experience featuring games, apps, and hidden easter eggs.">
    <meta name="author" content="Mateus Muste">
    <meta name="theme-color" content="#E8E8E8">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://mateusmuste.com/">
    <meta property="og:title" content="MATEUSMUSTE // OS">
    <meta property="og:description" content="Interactive brutalist portfolio OS. A creative web experience featuring games, apps, and hidden easter eggs.">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://mateusmuste.com/">
    <meta name="twitter:title" content="MATEUSMUSTE // OS">
    <meta name="twitter:description" content="Interactive brutalist portfolio OS. A creative web experience featuring games, apps, and hidden easter eggs.">

    <!-- Monospace pixel font for ASCII art -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                fontFamily: {
                    'sans': ['PPNeueBit', 'sans-serif'],
                    'serif': ['PPNeueBit', 'sans-serif'],
                    'mono': ['PPNeueBit', 'sans-serif'],
                },
                extend: {
                    fontFamily: {
                        'heading': ['PPMondwest', 'sans-serif'],
                        'body': ['PPNeueBit', 'sans-serif'],
                    }
                }
            }
        }
    </script>

    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script type="module">
        // Try multiple CDNs for COBE with fallback
        const cdns = [
            'https://cdn.skypack.dev/cobe',
            'https://esm.sh/cobe',
            'https://unpkg.com/cobe?module'
        ];
        async function loadCobe() {
            for (const cdn of cdns) {
                try {
                    const module = await import(cdn);
                    window.createGlobe = module.default;
                    return;
                } catch (e) { /* CDN failed, try next */ }
            }
            // All CDNs failed - globe feature will be unavailable
        }
        loadCobe();
    </script>

    <!-- ASCII Art definitions - edit ascii-art.js to customize -->
    <script src="ascii-art.js"></script>

    <!-- Dog companion dialogues - edit dialogues.js to customize story -->
    <script src="dialogues.js"></script>

    <style>
        /* Local Font Definitions */
        @font-face {
            font-family: 'PPMondwest';
            src: url('fonts/PPMondwest-Regular.otf') format('opentype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        @font-face {
            font-family: 'PPNeueBit';
            src: url('fonts/PPNeueBit-Bold.otf') format('opentype');
            font-weight: bold;
            font-style: normal;
            font-display: swap;
        }
        :root {
            --bg: #E8E8E8;
            --fg: #000000;
            --white: #ffffff;
            --black: #000000;
            /* Warm neutral grays */
            --gray-50: #FAFAFA;
            --gray-100: #F0F0F0;
            --gray-200: #E0E0E0;
            --gray-300: #C0C0C0;
            --gray-400: #909090;
            --gray-500: #606060;
            --gray-600: #333333;
            /* Accent colors */
            --crimson: #DC143C;
            --code-green: #00FF41;
            /* Shadows */
            --shadow-color: var(--black);
            /* Font sizes */
            --font-size-base: 16px;
            --font-size-lg: 20px;
            --font-size-xl: 24px;
        }

        body {
            background-color: var(--bg);
            color: var(--fg);
            font-family: 'PPNeueBit', sans-serif !important;
            overflow: hidden;
            margin: 0;
            padding: 0;
            user-select: none;
            -webkit-font-smoothing: antialiased;
        }

        /* Mobile viewport height fix - accounts for browser chrome */
        .mobile-safe-height {
            height: 100vh; /* fallback */
            height: 100svh; /* small viewport - always safe */
        }

        @supports (height: 100dvh) {
            .mobile-safe-height {
                height: 100dvh; /* dynamic viewport - adjusts with browser chrome */
            }
        }

        /* Mobile safe area support */
        @supports (padding: env(safe-area-inset-top)) {
            .mobile-taskbar-top {
                top: env(safe-area-inset-top, 0px) !important;
                padding-top: 4px;
            }

            /* Bottom safe area for home indicator */
            .mobile-safe-bottom {
                padding-bottom: env(safe-area-inset-bottom, 0px);
            }
        }

        /* Global hover transitions */
        button, a, [role="button"], .cursor-pointer {
            transition: all 50ms ease-out;
        }

        /* Override Tailwind font utilities to use PPNeueBit */
        .font-mono, .font-sans, .font-serif {
            font-family: 'PPNeueBit', sans-serif !important;
        }

        /* Headings use PPNeueBit */
        h1, h2, h3, h4, h5, h6 {
            font-family: 'PPNeueBit', sans-serif !important;
            line-height: 0.6 !important;
            letter-spacing: normal !important;
        }

        /* Heading font utility class - PPMondwest ONLY for MATEUS MUSTE */
        .font-heading {
            font-family: 'PPMondwest', sans-serif !important;
            line-height: 0.6 !important;
            letter-spacing: normal !important;
        }

        /* Body font utility class */
        .font-body {
            font-family: 'PPNeueBit', sans-serif !important;
        }

        /* ASCII art font - TRUE monospace for proper character alignment */
        .ascii-art {
            font-family: 'VT323', 'Courier New', 'Consolas', monospace !important;
            letter-spacing: 0 !important;
        }

        /* Minimum font size enforcement - 16px minimum for all text */
        html {
            font-size: 16px;
        }

        /* Override all small Tailwind text sizes to minimum 16px (except ASCII art) */
        .text-xs:not(.ascii-art), .text-sm:not(.ascii-art),
        [class*="text-[6px]"]:not(.ascii-art), [class*="text-[7px]"]:not(.ascii-art), [class*="text-[8px]"]:not(.ascii-art),
        [class*="text-[9px]"]:not(.ascii-art), [class*="text-[10px]"]:not(.ascii-art), [class*="text-[11px]"]:not(.ascii-art),
        [class*="text-[12px]"]:not(.ascii-art), [class*="text-[13px]"]:not(.ascii-art), [class*="text-[14px]"]:not(.ascii-art),
        [class*="text-[15px]"]:not(.ascii-art) {
            font-size: 16px !important;
        }

        /* Standardized font sizes - multiples of 4 */
        .text-base { font-size: 16px !important; }
        .text-lg { font-size: 20px !important; }
        .text-xl { font-size: 24px !important; }
        .text-2xl { font-size: 28px !important; }
        .text-3xl { font-size: 32px !important; }
        .text-4xl { font-size: 36px !important; }
        .text-5xl { font-size: 40px !important; }

        /* Universal font fallback - ensure ALL text uses our fonts */
        *, *::before, *::after {
            font-family: inherit;
        }

        /* Force PPNeueBit on all form elements and inputs */
        input, textarea, select, button, code, kbd, samp {
            font-family: 'PPNeueBit', sans-serif !important;
        }

        /* Pre elements use PPNeueBit unless they have .ascii-art class */
        pre:not(.ascii-art) {
            font-family: 'PPNeueBit', sans-serif !important;
        }

        /* Ensure bold/black text stays in PPNeueBit */
        .font-bold, .font-black, .font-semibold, .font-medium, .font-extrabold {
            font-family: inherit !important;
        }

        /* Brutalist Styles */
        .window-shadow {
            box-shadow: 10px 10px 0 0 var(--shadow-color);
        }

        .icon-shadow {
            box-shadow: 4px 4px 0 0 var(--shadow-color);
        }

        .btn-shadow {
            box-shadow: 2px 2px 0 0 var(--shadow-color);
        }

        /* Design System - Standardized Components */

        /* Primary Button: solid black */
        .btn-primary {
            padding: 0.75rem 1.5rem;
            background: var(--black);
            color: var(--white);
            font-family: 'PPNeueBit', sans-serif !important;
            font-size: var(--font-size-base);
            font-weight: 700;
            border: 2px solid var(--black);
            cursor: pointer;
            transition: filter 0.15s;
        }
        .btn-primary:hover { filter: invert(1); }
        .btn-primary:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Secondary Button: outlined */
        .btn-secondary {
            padding: 0.75rem 1.5rem;
            background: var(--white);
            color: var(--black);
            font-family: 'PPNeueBit', sans-serif !important;
            font-size: var(--font-size-base);
            font-weight: 700;
            border: 2px solid var(--black);
            cursor: pointer;
            transition: all 0.15s;
        }
        .btn-secondary:hover { background: var(--black); color: var(--white); }

        /* Button Sizes */
        .btn-xs { padding: 0.25rem 0.5rem; font-size: var(--font-size-base); }
        .btn-sm { padding: 0.5rem 1rem; font-size: var(--font-size-base); }
        .btn-lg { padding: 1rem 2rem; font-size: var(--font-size-lg); }
        .btn-full { width: 100%; }

        /* Icon Button (square, compact) */
        .btn-icon {
            padding: 0.25rem;
            background: var(--white);
            border: 1px solid var(--black);
            cursor: pointer;
        }
        .btn-icon:hover { background: var(--gray-100); }

        /* Toolbar Button (selectable toggle) */
        .btn-toolbar {
            padding: 0.25rem 0.5rem;
            font-family: 'PPNeueBit', sans-serif !important;
            font-size: var(--font-size-base);
            font-weight: 700;
            text-transform: uppercase;
            border: 1px solid var(--black);
            cursor: pointer;
            background: var(--white);
        }
        .btn-toolbar:hover { background: var(--gray-100); }
        .btn-toolbar.active { background: var(--black); color: var(--white); }

        /* App Header */
        .app-header {
            padding: 0.5rem;
            border-bottom: 2px solid var(--black);
            background: var(--white);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .app-header-title {
            font-family: 'PPNeueBit', sans-serif !important;
            font-size: var(--font-size-base);
            font-weight: 700;
        }
        .app-header-subtitle {
            font-family: 'PPNeueBit', sans-serif !important;
            font-size: var(--font-size-base);
            color: var(--gray-500);
        }

        /* App Footer/Status Bar */
        .app-footer {
            padding: 0.5rem;
            border-top: 2px solid var(--black);
            background: var(--white);
            text-align: center;
        }
        .app-footer-text {
            font-family: 'PPNeueBit', sans-serif !important;
            font-size: var(--font-size-base);
            color: var(--gray-500);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }

        ::-webkit-scrollbar-track {
            background: var(--white);
            border-left: 2px solid var(--black);
            border-top: 2px solid var(--black);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--black);
            border: 2px solid var(--white);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--gray-600);
        }

        /* Background Patterns */
        .desktop-bg-grid {
            background-color: var(--gray-100);
            background-image: radial-gradient(var(--gray-300) 1px, transparent 1px);
            background-size: 20px 20px;
        }
        .desktop-bg-solid {
            background-color: var(--gray-200);
        }
        .desktop-bg-ascii {
            background-color: var(--gray-100);
        }

        canvas {
            touch-action: none;
        }

        /* Window fold animations */
        @keyframes window-fold-in {
            0% {
                opacity: 0;
                transform: perspective(800px) rotateX(-90deg) scaleY(0);
                transform-origin: top center;
            }
            100% {
                opacity: 1;
                transform: perspective(800px) rotateX(0deg) scaleY(1);
                transform-origin: top center;
            }
        }

        @keyframes window-fold-out {
            0% {
                opacity: 1;
                transform: perspective(800px) rotateX(0deg) scaleY(1);
                transform-origin: top center;
            }
            100% {
                opacity: 0;
                transform: perspective(800px) rotateX(-90deg) scaleY(0);
                transform-origin: top center;
            }
        }

        .window-opening {
            animation: window-fold-in 0.2s cubic-bezier(0.22, 1, 0.36, 1) forwards;
        }

        .window-closing {
            animation: window-fold-out 0.15s cubic-bezier(0.55, 0, 1, 0.45) forwards;
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            10%,
            30%,
            50%,
            70%,
            90% {
                transform: translateX(-5px);
            }

            20%,
            40%,
            60%,
            80% {
                transform: translateX(5px);
            }
        }

        .animate-shake {
            animation: shake 0.5s ease-in-out;
        }

        /* ThirdEye stack overflow animations */
        @keyframes glitch {
            0% { transform: translateX(0); }
            25% { transform: translateX(-2px); }
            50% { transform: translateX(2px); }
            75% { transform: translateX(-1px); }
            100% { transform: translateX(0); }
        }

        /* Matrix Mode - requires !important to override all theme colors */
        .matrix-mode {
            background: var(--black) !important;
            background-image: none !important;
        }
        .matrix-mode * {
            color: var(--code-green) !important;
            border-color: var(--code-green) !important;
        }
        .matrix-mode .bg-white,
        .matrix-mode .bg-gray-50,
        .matrix-mode .bg-gray-100 {
            background-color: var(--black) !important;
        }
        .matrix-mode button,
        .matrix-mode .border,
        .matrix-mode .border-2,
        .matrix-mode .border-4 {
            border-color: var(--code-green) !important;
        }
        .matrix-mode svg {
            filter: brightness(0) invert(1) sepia(1) saturate(50) hue-rotate(70deg);
        }
        .matrix-mode canvas {
            filter: hue-rotate(70deg) saturate(3) brightness(0.8);
        }
        .matrix-rain {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
            opacity: 0.15;
        }

        /* Icon drag shake animation */
        @keyframes iconShake {
            0%, 100% { transform: rotate(-1deg); }
            50% { transform: rotate(1deg); }
        }
        .icon-dragging {
            animation: iconShake 0.15s ease-in-out infinite;
            transform: scale(1.1) translateY(-8px);
            z-index: 99999 !important;
        }

        /* Stack overflow flash animation */
        @keyframes stackFlash {
            0%, 100% { opacity: 1; background: var(--black); }
            50% { opacity: 0.7; background: var(--crimson); }
        }

        /* Fade in animation for revealing apps */
        @keyframes fadeIn {
            0% { opacity: 0; transform: scale(0.8) translateY(10px); }
            100% { opacity: 1; transform: scale(1) translateY(0); }
        }
        .animate-fade-in {
            animation: fadeIn 0.3s ease-out forwards;
        }
    </style>
</head>

<body>

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // --- SOUND SYSTEM ---
        let audioCtx = null;
        let activeDragNodes = null;
        let soundMuted = localStorage.getItem('sound_muted') === 'true';

        const getAudioCtx = () => {
            if (soundMuted) return null;
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            return audioCtx;
        };

        const toggleMute = () => {
            soundMuted = !soundMuted;
            localStorage.setItem('sound_muted', soundMuted.toString());
            return soundMuted;
        };

        const makeDistortion = (ctx, amount) => {
            const dist = ctx.createWaveShaper();
            const curve = new Float32Array(256);
            for (let i = 0; i < 256; i++) {
                const x = (i - 128) / 128;
                curve[i] = Math.tanh(x * amount);
            }
            dist.curve = curve;
            return dist;
        };

        const sounds = {
            dragStart: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                if (activeDragNodes) return;

                const bufferSize = ctx.sampleRate * 2.0;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    b0 = 0.99886 * b0 + white * 0.0555179;
                    b1 = 0.99332 * b1 + white * 0.0750759;
                    b2 = 0.96900 * b2 + white * 0.1538520;
                    b3 = 0.86650 * b3 + white * 0.3104856;
                    b4 = 0.55000 * b4 + white * 0.5329522;
                    b5 = -0.7616 * b5 - white * 0.0168980;
                    data[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.11;
                    b6 = white * 0.115926;
                }

                const noise = ctx.createBufferSource();
                noise.buffer = buffer;
                noise.loop = true;
                const filter = ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 800;
                filter.Q.value = 0.5;
                const hapticOsc = ctx.createOscillator();
                hapticOsc.type = 'sine';
                hapticOsc.frequency.value = 140;
                const lfo = ctx.createOscillator();
                lfo.type = 'sine';
                lfo.frequency.value = 13;
                const mainGain = ctx.createGain();
                const noiseGain = ctx.createGain();
                const hapticGain = ctx.createGain();
                const lfoGain = ctx.createGain();

                noise.connect(filter);
                filter.connect(noiseGain);
                noiseGain.connect(mainGain);
                hapticOsc.connect(hapticGain);
                hapticGain.connect(mainGain);
                mainGain.connect(ctx.destination);
                lfo.connect(lfoGain);
                lfoGain.connect(mainGain.gain);

                noiseGain.gain.value = 1.0;
                hapticGain.gain.value = 0.4;
                const baseVol = 0.012;
                mainGain.gain.setValueAtTime(0, now);
                mainGain.gain.linearRampToValueAtTime(baseVol, now + 0.15);
                lfoGain.gain.value = 0.008;

                noise.start(now);
                hapticOsc.start(now);
                lfo.start(now);
                activeDragNodes = { noise, hapticOsc, lfo, mainGain };
            },

            dragStop: () => {
                if (!activeDragNodes) return;
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                const { noise, hapticOsc, lfo, mainGain } = activeDragNodes;
                mainGain.gain.cancelScheduledValues(now);
                mainGain.gain.setValueAtTime(mainGain.gain.value, now);
                mainGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.1);
                noise.stop(now + 0.1);
                hapticOsc.stop(now + 0.1);
                lfo.stop(now + 0.1);
                activeDragNodes = null;
            },

            windowOpen: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(1200, now + 0.05);
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.3, now + 0.005);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.1);
            },

            windowClose: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(250, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
                gain.gain.setValueAtTime(0.35, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.15);
            },

            success: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                [523.25, 659.25, 783.99, 987.77].forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    const start = now + i * 0.04;
                    gain.gain.setValueAtTime(0, start);
                    gain.gain.linearRampToValueAtTime(0.08, start + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.001, start + 0.4);
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(start);
                    osc.stop(start + 0.4);
                });
            },

            error: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                [150, 154].forEach(freq => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    const filter = ctx.createBiquadFilter();
                    osc.type = 'sawtooth';
                    osc.frequency.value = freq;
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(400, now);
                    filter.frequency.linearRampToValueAtTime(100, now + 0.3);
                    gain.gain.setValueAtTime(0.15, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(now);
                    osc.stop(now + 0.3);
                });
            },

            bounce: (vel = 1) => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                const dist = makeDistortion(ctx, 12);
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(dist);
                dist.connect(gain);
                gain.connect(ctx.destination);
                osc.type = 'sine';
                osc.frequency.setValueAtTime(220 + (vel * 100), now);
                osc.frequency.exponentialRampToValueAtTime(40, now + 0.15);
                gain.gain.setValueAtTime(0.4 * Math.min(vel, 1.2), now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                osc.start(now);
                osc.stop(now + 0.2);
            },

            bounceIcon: (vel = 1) => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600 + (vel * 150), now);
                osc.frequency.exponentialRampToValueAtTime(200, now + 0.06);
                gain.gain.setValueAtTime(0.12 * Math.min(vel, 1), now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
                osc.start(now);
                osc.stop(now + 0.08);
            },

            bootSequence: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;

                // Industrial metallic arpeggio - minor key with tension
                // A minor pentatonic with added industrial resonance
                const notes = [
                    { freq: 110.00, time: 0 },      // A2 - deep foundation
                    { freq: 164.81, time: 0.12 },   // E3 - fifth
                    { freq: 220.00, time: 0.24 },   // A3 - octave
                    { freq: 293.66, time: 0.36 },   // D4 - fourth
                    { freq: 329.63, time: 0.48 },   // E4 - fifth high
                    { freq: 440.00, time: 0.62 },   // A4 - resolution
                    { freq: 523.25, time: 0.78 },   // C5 - minor third color
                    { freq: 659.25, time: 0.95 },   // E5 - final shimmer
                ];

                const masterGain = ctx.createGain();
                masterGain.gain.value = 0.18;
                masterGain.connect(ctx.destination);

                notes.forEach(({ freq, time }, i) => {
                    const start = now + time;
                    const isLast = i === notes.length - 1;
                    const duration = isLast ? 1.2 : 0.4;

                    // Primary oscillator - square for metallic edge
                    const osc1 = ctx.createOscillator();
                    const gain1 = ctx.createGain();
                    osc1.type = 'square';
                    osc1.frequency.value = freq;

                    // Secondary oscillator - detuned for metallic beating
                    const osc2 = ctx.createOscillator();
                    const gain2 = ctx.createGain();
                    osc2.type = 'sawtooth';
                    osc2.frequency.value = freq * 1.002; // slight detune

                    // Third oscillator - sub harmonic for industrial weight
                    const osc3 = ctx.createOscillator();
                    const gain3 = ctx.createGain();
                    osc3.type = 'triangle';
                    osc3.frequency.value = freq * 0.5;

                    // Bandpass filter for metallic resonance
                    const filter = ctx.createBiquadFilter();
                    filter.type = 'bandpass';
                    filter.frequency.value = freq * 2;
                    filter.Q.value = 8;

                    // High shelf for shimmer
                    const highShelf = ctx.createBiquadFilter();
                    highShelf.type = 'highshelf';
                    highShelf.frequency.value = 2000;
                    highShelf.gain.value = 3;

                    // Routing
                    osc1.connect(gain1);
                    osc2.connect(gain2);
                    osc3.connect(gain3);
                    gain1.connect(filter);
                    gain2.connect(filter);
                    gain3.connect(highShelf);
                    filter.connect(highShelf);
                    highShelf.connect(masterGain);

                    // Envelope - sharp attack, metallic decay
                    const vol = isLast ? 0.7 : 0.5 - (i * 0.02);
                    gain1.gain.setValueAtTime(0, start);
                    gain1.gain.linearRampToValueAtTime(vol * 0.6, start + 0.008);
                    gain1.gain.exponentialRampToValueAtTime(vol * 0.3, start + 0.05);
                    gain1.gain.exponentialRampToValueAtTime(0.001, start + duration);

                    gain2.gain.setValueAtTime(0, start);
                    gain2.gain.linearRampToValueAtTime(vol * 0.25, start + 0.008);
                    gain2.gain.exponentialRampToValueAtTime(0.001, start + duration * 0.8);

                    gain3.gain.setValueAtTime(0, start);
                    gain3.gain.linearRampToValueAtTime(vol * 0.15, start + 0.01);
                    gain3.gain.exponentialRampToValueAtTime(0.001, start + duration * 0.6);

                    osc1.start(start);
                    osc2.start(start);
                    osc3.start(start);
                    osc1.stop(start + duration + 0.1);
                    osc2.stop(start + duration + 0.1);
                    osc3.stop(start + duration + 0.1);
                });

                // Industrial noise burst at start
                const noiseBuffer = ctx.createBuffer(1, ctx.sampleRate * 0.08, ctx.sampleRate);
                const noiseData = noiseBuffer.getChannelData(0);
                for (let i = 0; i < noiseData.length; i++) {
                    noiseData[i] = (Math.random() * 2 - 1) * Math.exp(-i / (ctx.sampleRate * 0.02));
                }
                const noiseSource = ctx.createBufferSource();
                noiseSource.buffer = noiseBuffer;
                const noiseFilter = ctx.createBiquadFilter();
                noiseFilter.type = 'highpass';
                noiseFilter.frequency.value = 3000;
                const noiseGain = ctx.createGain();
                noiseGain.gain.value = 0.08;
                noiseSource.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(masterGain);
                noiseSource.start(now);
            },

            laser: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(2000, now);
                osc.frequency.exponentialRampToValueAtTime(200, now + 0.15);
                gain.gain.setValueAtTime(0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.15);
            },

            explosion: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                const dist = makeDistortion(ctx, 20);
                osc.connect(dist);
                dist.connect(gain);
                gain.connect(ctx.destination);
                osc.type = 'sine';
                osc.frequency.setValueAtTime(120, now);
                osc.frequency.exponentialRampToValueAtTime(10, now + 0.5);
                gain.gain.setValueAtTime(0.6, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
                osc.start(now);
                osc.stop(now + 0.6);
            },

            coin: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                [987.77, 1318.51].forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    const t = now + i * 0.08;
                    gain.gain.setValueAtTime(0.05, t);
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(t);
                    osc.stop(t + 0.5);
                });
            },

            gameOver: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                [440, 311, 220, 155].forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'triangle';
                    osc.frequency.value = freq;
                    const start = now + i * 0.3;
                    gain.gain.setValueAtTime(0.1, start);
                    gain.gain.exponentialRampToValueAtTime(0.001, start + 0.4);
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(start);
                    osc.stop(start + 0.4);
                });
            },

            bark: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.linearRampToValueAtTime(150, now + 0.15);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.15);
            },

            // Metallic ping for START.EXE reveals
            ping: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(1200, now);
                osc.frequency.exponentialRampToValueAtTime(800, now + 0.3);
                gain.gain.setValueAtTime(0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.5);
            },

            diceRoll: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                // Rapid clicks that slow down like a dice settling
                for (let i = 0; i < 12; i++) {
                    const delay = i * 0.05 + (i * i * 0.008);
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'square';
                    osc.frequency.value = 800 + Math.random() * 400;
                    gain.gain.setValueAtTime(0.08 * (1 - i * 0.07), now + delay);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.03);
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(now + delay);
                    osc.stop(now + delay + 0.03);
                }
            },

            mineDing: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.value = 1200;
                gain.gain.setValueAtTime(0.06, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.1);
            },

            // UI click sound - subtle, satisfying
            click: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(600, now + 0.05);
                gain.gain.setValueAtTime(0.08, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.05);
            },

            // Copy to clipboard sound
            copy: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                [1000, 1200].forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    const start = now + i * 0.05;
                    gain.gain.setValueAtTime(0.06, start);
                    gain.gain.exponentialRampToValueAtTime(0.001, start + 0.08);
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(start);
                    osc.stop(start + 0.08);
                });
            },

            // Key press sound for typing games
            keyPress: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'square';
                osc.frequency.value = 400 + Math.random() * 100;
                gain.gain.setValueAtTime(0.03, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.03);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.03);
            },

            // Note toggle for synth
            noteToggle: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.value = 880;
                gain.gain.setValueAtTime(0.04, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.04);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.04);
            },

            // ========== NEW SOUNDS ==========

            // Classic Y2K/early 2010s boot chime - warm major chord like Windows XP/Mac startup
            bootWindup: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;

                const master = ctx.createGain();
                master.gain.setValueAtTime(0.5, now);
                master.connect(ctx.destination);

                // Create reverb-like effect with delayed copies
                const createTone = (freq, startTime, duration, volume, type = 'sine') => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    const filter = ctx.createBiquadFilter();

                    osc.type = type;
                    osc.frequency.value = freq;

                    // Warm lowpass filter
                    filter.type = 'lowpass';
                    filter.frequency.value = 2000;
                    filter.Q.value = 0.5;

                    // Smooth envelope
                    gain.gain.setValueAtTime(0, now + startTime);
                    gain.gain.linearRampToValueAtTime(volume, now + startTime + 0.08);
                    gain.gain.setValueAtTime(volume * 0.8, now + startTime + duration * 0.3);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + startTime + duration);

                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(master);

                    osc.start(now + startTime);
                    osc.stop(now + startTime + duration + 0.1);
                };

                // Windows XP / Mac inspired major chord progression
                // Starting with a gentle rising arpeggio into a full major chord

                // Initial rising tones (like Windows XP's hopeful intro)
                createTone(261.63, 0, 0.4, 0.15);      // C4 - gentle start
                createTone(329.63, 0.08, 0.5, 0.18);   // E4 - rising
                createTone(392.00, 0.16, 0.6, 0.20);   // G4 - building

                // Main chord hits (like Mac's clean F major or Windows 7's warm pad)
                // C major chord with octave doubling for richness
                createTone(261.63, 0.25, 2.0, 0.22);   // C4
                createTone(329.63, 0.25, 2.0, 0.20);   // E4
                createTone(392.00, 0.25, 2.0, 0.18);   // G4
                createTone(523.25, 0.25, 2.0, 0.15);   // C5 - octave

                // Subtle triangle wave layer for warmth (like Windows 7)
                createTone(130.81, 0.25, 2.2, 0.12, 'triangle');  // C3 - bass warmth
                createTone(196.00, 0.25, 2.0, 0.10, 'triangle');  // G3 - fifth

                // Soft high shimmer (like Mac's crystalline top)
                createTone(1046.50, 0.3, 1.5, 0.06);   // C6 - shimmer
                createTone(783.99, 0.35, 1.8, 0.08);   // G5 - sparkle

                // Final resolution ping (satisfying confirmation like Windows ready sound)
                setTimeout(() => {
                    const ping = ctx.createOscillator();
                    const pingGain = ctx.createGain();
                    const pingFilter = ctx.createBiquadFilter();

                    ping.type = 'sine';
                    ping.frequency.value = 1046.50;  // C6

                    pingFilter.type = 'lowpass';
                    pingFilter.frequency.value = 3000;

                    pingGain.gain.setValueAtTime(0, ctx.currentTime);
                    pingGain.gain.linearRampToValueAtTime(0.12, ctx.currentTime + 0.02);
                    pingGain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 1.2);

                    ping.connect(pingFilter);
                    pingFilter.connect(pingGain);
                    pingGain.connect(ctx.destination);

                    ping.start();
                    ping.stop(ctx.currentTime + 1.3);
                }, 400);
            },

            // Window minimize - quick descending swoosh
            windowMinimize: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.exponentialRampToValueAtTime(150, now + 0.08);
                gain.gain.setValueAtTime(0.12, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.1);
            },

            // Window restore - quick ascending pop
            windowRestore: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(700, now + 0.06);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.1);
            },

            // Icon select - subtle mechanical tick
            iconSelect: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'square';
                osc.frequency.value = 500;
                gain.gain.setValueAtTime(0.04, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.02);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.02);
            },

            // Achievement unlock fanfare - triumphant ascending arpeggio with shimmer
            achievementUnlock: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                // Ascending fanfare notes (C5, E5, G5, C6)
                const notes = [523.25, 659.25, 783.99, 1046.50];
                notes.forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    const start = now + i * 0.08;
                    gain.gain.setValueAtTime(0, start);
                    gain.gain.linearRampToValueAtTime(0.12, start + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.001, start + 0.5);
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(start);
                    osc.stop(start + 0.5);
                });
                // Shimmer overlay
                for (let i = 0; i < 8; i++) {
                    const shimmer = ctx.createOscillator();
                    const shimmerGain = ctx.createGain();
                    shimmer.type = 'sine';
                    shimmer.frequency.value = 2000 + Math.random() * 2000;
                    const t = now + 0.2 + i * 0.05;
                    shimmerGain.gain.setValueAtTime(0.02, t);
                    shimmerGain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
                    shimmer.connect(shimmerGain);
                    shimmerGain.connect(ctx.destination);
                    shimmer.start(t);
                    shimmer.stop(t + 0.15);
                }
            },

            // App unlock/materialize - magical appearance with noise burst
            appUnlock: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                // Noise burst
                const bufferSize = ctx.sampleRate * 0.1;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
                }
                const noise = ctx.createBufferSource();
                noise.buffer = buffer;
                const noiseGain = ctx.createGain();
                const noiseFilter = ctx.createBiquadFilter();
                noiseFilter.type = 'highpass';
                noiseFilter.frequency.value = 2000;
                noiseGain.gain.setValueAtTime(0.08, now);
                noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                noise.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(ctx.destination);
                noise.start(now);
                // Rising tone
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(300, now);
                osc.frequency.exponentialRampToValueAtTime(900, now + 0.15);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.25);
            },

            // Context menu snap
            menuOpen: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'square';
                osc.frequency.value = 400;
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.03);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.03);
            },

            // Dice critical 20 - golden triumphant shimmer
            diceCrit20: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                // Triumphant chord (C major with high octave)
                [523.25, 659.25, 783.99, 1046.50, 1318.51].forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    gain.gain.setValueAtTime(0.08, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(now);
                    osc.stop(now + 0.8);
                });
                // Golden shimmer
                for (let i = 0; i < 12; i++) {
                    const shimmer = ctx.createOscillator();
                    const shimmerGain = ctx.createGain();
                    shimmer.type = 'sine';
                    shimmer.frequency.value = 1500 + Math.random() * 3000;
                    const t = now + i * 0.04;
                    shimmerGain.gain.setValueAtTime(0.03, t);
                    shimmerGain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
                    shimmer.connect(shimmerGain);
                    shimmerGain.connect(ctx.destination);
                    shimmer.start(t);
                    shimmer.stop(t + 0.2);
                }
            },

            // Dice critical 1 - sad descending wah-wah
            diceCrit1: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.5);
                gain.gain.setValueAtTime(0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.6);
                // Second descending tone for wah-wah effect
                const osc2 = ctx.createOscillator();
                const gain2 = ctx.createGain();
                osc2.type = 'triangle';
                osc2.frequency.setValueAtTime(300, now + 0.15);
                osc2.frequency.exponentialRampToValueAtTime(80, now + 0.6);
                gain2.gain.setValueAtTime(0.12, now + 0.15);
                gain2.gain.exponentialRampToValueAtTime(0.001, now + 0.7);
                osc2.connect(gain2);
                gain2.connect(ctx.destination);
                osc2.start(now + 0.15);
                osc2.stop(now + 0.7);
            },

            // Terminal command submit - typewriter carriage return
            terminalSubmit: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                // Mechanical chunk
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                const dist = makeDistortion(ctx, 5);
                osc.type = 'square';
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(80, now + 0.05);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
                osc.connect(dist);
                dist.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.08);
                // Bell ding
                const bell = ctx.createOscillator();
                const bellGain = ctx.createGain();
                bell.type = 'sine';
                bell.frequency.value = 1400;
                bellGain.gain.setValueAtTime(0.04, now + 0.02);
                bellGain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                bell.connect(bellGain);
                bellGain.connect(ctx.destination);
                bell.start(now + 0.02);
                bell.stop(now + 0.15);
            },

            // Konami code activation - secret unlock whoosh with chime cascade
            konamiActivate: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                // Ethereal sweep
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                const filter = ctx.createBiquadFilter();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.exponentialRampToValueAtTime(1500, now + 0.6);
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(300, now);
                filter.frequency.exponentialRampToValueAtTime(4000, now + 0.6);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.8);
                // Chime cascade
                [880, 1046.50, 1318.51, 1567.98, 1760].forEach((freq, i) => {
                    const chime = ctx.createOscillator();
                    const chimeGain = ctx.createGain();
                    chime.type = 'sine';
                    chime.frequency.value = freq;
                    const t = now + 0.3 + i * 0.1;
                    chimeGain.gain.setValueAtTime(0.08, t);
                    chimeGain.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
                    chime.connect(chimeGain);
                    chimeGain.connect(ctx.destination);
                    chime.start(t);
                    chime.stop(t + 0.4);
                });
            },

            // God mode activation - transcendence with deep bass and ascending harmonics
            godMode: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                // Deep bass foundation
                const bass = ctx.createOscillator();
                const bassGain = ctx.createGain();
                bass.type = 'sine';
                bass.frequency.value = 55;
                bassGain.gain.setValueAtTime(0.2, now);
                bassGain.gain.exponentialRampToValueAtTime(0.001, now + 2);
                bass.connect(bassGain);
                bassGain.connect(ctx.destination);
                bass.start(now);
                bass.stop(now + 2);
                // Ascending harmonic series
                [110, 220, 330, 440, 550, 660, 880, 1100].forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    const t = now + i * 0.15;
                    gain.gain.setValueAtTime(0, t);
                    gain.gain.linearRampToValueAtTime(0.06, t + 0.1);
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 1.5);
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(t);
                    osc.stop(t + 1.5);
                });
            },

            // Tarot shuffle - rapid paper flutter
            tarotShuffle: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                for (let i = 0; i < 20; i++) {
                    const bufferSize = ctx.sampleRate * 0.03;
                    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let j = 0; j < bufferSize; j++) {
                        data[j] = (Math.random() * 2 - 1) * (1 - j / bufferSize);
                    }
                    const noise = ctx.createBufferSource();
                    noise.buffer = buffer;
                    const filter = ctx.createBiquadFilter();
                    filter.type = 'bandpass';
                    filter.frequency.value = 2000 + Math.random() * 1000;
                    filter.Q.value = 1;
                    const gain = ctx.createGain();
                    const t = now + i * 0.025;
                    gain.gain.setValueAtTime(0.04, t);
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.03);
                    noise.connect(filter);
                    filter.connect(gain);
                    gain.connect(ctx.destination);
                    noise.start(t);
                }
            },

            // Tarot card flip - soft thwip with subtle chime
            tarotFlip: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                // Paper thwip
                const bufferSize = ctx.sampleRate * 0.05;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 2);
                }
                const noise = ctx.createBufferSource();
                noise.buffer = buffer;
                const filter = ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 1500;
                const gain = ctx.createGain();
                gain.gain.setValueAtTime(0.08, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(ctx.destination);
                noise.start(now);
                // Subtle mystery chime
                const chime = ctx.createOscillator();
                const chimeGain = ctx.createGain();
                chime.type = 'sine';
                chime.frequency.value = 600 + Math.random() * 200;
                chimeGain.gain.setValueAtTime(0.03, now + 0.03);
                chimeGain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                chime.connect(chimeGain);
                chimeGain.connect(ctx.destination);
                chime.start(now + 0.03);
                chime.stop(now + 0.2);
            },

            // Pomodoro timer start - wind-up click sequence
            pomodoroStart: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                for (let i = 0; i < 4; i++) {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'square';
                    osc.frequency.value = 300 + i * 50;
                    const t = now + i * 0.06;
                    gain.gain.setValueAtTime(0.06, t);
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.04);
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(t);
                    osc.stop(t + 0.04);
                }
            },

            // Pomodoro session complete - gentle bell chime
            pomodoroComplete: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                // Bell-like tones
                [523.25, 659.25, 783.99].forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    const t = now + i * 0.15;
                    gain.gain.setValueAtTime(0.1, t);
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.8);
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(t);
                    osc.stop(t + 0.8);
                });
            },

            // Flower bloom - soft organic pop
            flowerBloom: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                const filter = ctx.createBiquadFilter();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(400, now + 0.05);
                osc.frequency.exponentialRampToValueAtTime(300, now + 0.15);
                filter.type = 'lowpass';
                filter.frequency.value = 800;
                gain.gain.setValueAtTime(0.08, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.2);
            },

            // Snek movement - subtle slither
            snekMove: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                const bufferSize = ctx.sampleRate * 0.02;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * 0.3 * (1 - i / bufferSize);
                }
                const noise = ctx.createBufferSource();
                noise.buffer = buffer;
                const filter = ctx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = 1500;
                filter.Q.value = 2;
                const gain = ctx.createGain();
                gain.gain.setValueAtTime(0.03, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.02);
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(ctx.destination);
                noise.start(now);
            },

            // Snek letter revealed - magical sparkle
            snekLetter: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                [1200, 1500, 1800].forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    const t = now + i * 0.03;
                    gain.gain.setValueAtTime(0.06, t);
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(t);
                    osc.stop(t + 0.15);
                });
            },

            // Labyrinth footstep - soft alternating taps
            labyrinthStep: (isLeft = true) => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.value = isLeft ? 180 : 200;
                gain.gain.setValueAtTime(0.04, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.05);
            },

            // Labyrinth wall bump - blocked thud
            labyrinthBump: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                const dist = makeDistortion(ctx, 3);
                osc.type = 'sine';
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.08);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                osc.connect(dist);
                dist.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.1);
            },

            // Labyrinth exit reached - portal whoosh
            labyrinthExit: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                const filter = ctx.createBiquadFilter();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(800, now + 0.2);
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(500, now);
                filter.frequency.exponentialRampToValueAtTime(3000, now + 0.2);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.3);
                // Success overlay
                [523.25, 783.99].forEach((freq, i) => {
                    const chime = ctx.createOscillator();
                    const chimeGain = ctx.createGain();
                    chime.type = 'sine';
                    chime.frequency.value = freq;
                    chimeGain.gain.setValueAtTime(0.08, now + 0.15);
                    chimeGain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                    chime.connect(chimeGain);
                    chimeGain.connect(ctx.destination);
                    chime.start(now + 0.15);
                    chime.stop(now + 0.5);
                });
            },

            // Starship thrust - low rumble
            starshipThrust: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                // Brown noise for engine rumble
                const bufferSize = ctx.sampleRate * 0.1;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                let lastOut = 0;
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    data[i] = (lastOut + (0.02 * white)) / 1.02;
                    lastOut = data[i];
                    data[i] *= 3.5;
                }
                const noise = ctx.createBufferSource();
                noise.buffer = buffer;
                const filter = ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 200;
                const gain = ctx.createGain();
                gain.gain.setValueAtTime(0.08, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(ctx.destination);
                noise.start(now);
            },

            // Starship damage - alarm crunch
            starshipDamage: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                const dist = makeDistortion(ctx, 15);
                osc.type = 'square';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(50, now + 0.15);
                gain.gain.setValueAtTime(0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                osc.connect(dist);
                dist.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.2);
                // Alarm beep
                const alarm = ctx.createOscillator();
                const alarmGain = ctx.createGain();
                alarm.type = 'square';
                alarm.frequency.value = 880;
                alarmGain.gain.setValueAtTime(0.08, now);
                alarmGain.gain.setValueAtTime(0, now + 0.05);
                alarmGain.gain.setValueAtTime(0.08, now + 0.1);
                alarmGain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                alarm.connect(alarmGain);
                alarmGain.connect(ctx.destination);
                alarm.start(now);
                alarm.stop(now + 0.15);
            },

            // Folder open - soft unfold rustle
            folderOpen: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                const bufferSize = ctx.sampleRate * 0.06;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    const env = Math.sin(Math.PI * i / bufferSize);
                    data[i] = (Math.random() * 2 - 1) * env * 0.5;
                }
                const noise = ctx.createBufferSource();
                noise.buffer = buffer;
                const filter = ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 1000;
                const gain = ctx.createGain();
                gain.gain.value = 0.06;
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(ctx.destination);
                noise.start(now);
            },

            // Folder close - reverse rustle
            folderClose: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                const bufferSize = ctx.sampleRate * 0.04;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    const env = 1 - (i / bufferSize);
                    data[i] = (Math.random() * 2 - 1) * env * 0.4;
                }
                const noise = ctx.createBufferSource();
                noise.buffer = buffer;
                const filter = ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 800;
                const gain = ctx.createGain();
                gain.gain.value = 0.05;
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(ctx.destination);
                noise.start(now);
            },

            // TRUTH reveal - ethereal whisper with deep resonance
            truthReveal: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                // Deep bass drone
                const bass = ctx.createOscillator();
                const bassGain = ctx.createGain();
                bass.type = 'sine';
                bass.frequency.value = 55;
                bassGain.gain.setValueAtTime(0.1, now);
                bassGain.gain.exponentialRampToValueAtTime(0.001, now + 1.5);
                bass.connect(bassGain);
                bassGain.connect(ctx.destination);
                bass.start(now);
                bass.stop(now + 1.5);
                // Ethereal shimmer
                for (let i = 0; i < 6; i++) {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = 400 + i * 200 + Math.random() * 50;
                    const t = now + i * 0.1;
                    gain.gain.setValueAtTime(0.03, t);
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.8);
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(t);
                    osc.stop(t + 0.8);
                }
            },

            // Password incorrect - access denied buzz
            passwordWrong: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'square';
                osc.frequency.value = 150;
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.setValueAtTime(0, now + 0.1);
                gain.gain.setValueAtTime(0.1, now + 0.15);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.25);
            },

            // Password correct - unlock mechanism
            passwordCorrect: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                // Mechanical unlock clicks
                [0, 0.08, 0.15].forEach((delay, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = 300 + i * 100;
                    gain.gain.setValueAtTime(0.08, now + delay);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.05);
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(now + delay);
                    osc.stop(now + delay + 0.05);
                });
                // Final success tone
                const success = ctx.createOscillator();
                const successGain = ctx.createGain();
                success.type = 'sine';
                success.frequency.value = 800;
                successGain.gain.setValueAtTime(0.1, now + 0.2);
                successGain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                success.connect(successGain);
                successGain.connect(ctx.destination);
                success.start(now + 0.2);
                success.stop(now + 0.5);
            },

            // Upgrade purchase - cash register ching
            upgradePurchase: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                // Register click
                const click = ctx.createOscillator();
                const clickGain = ctx.createGain();
                click.type = 'square';
                click.frequency.value = 200;
                clickGain.gain.setValueAtTime(0.08, now);
                clickGain.gain.exponentialRampToValueAtTime(0.001, now + 0.03);
                click.connect(clickGain);
                clickGain.connect(ctx.destination);
                click.start(now);
                click.stop(now + 0.03);
                // Bell ching
                const bell = ctx.createOscillator();
                const bellGain = ctx.createGain();
                bell.type = 'sine';
                bell.frequency.value = 1500;
                bellGain.gain.setValueAtTime(0.1, now + 0.02);
                bellGain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                bell.connect(bellGain);
                bellGain.connect(ctx.destination);
                bell.start(now + 0.02);
                bell.stop(now + 0.4);
            },

            // Visit milestone - special acknowledgment melody
            visitMilestone: () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                // Special ascending melody
                [392, 523.25, 659.25, 783.99, 1046.50].forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    const t = now + i * 0.12;
                    gain.gain.setValueAtTime(0.1, t);
                    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
                    osc.connect(gain);
                    gain.connect(ctx.destination);
                    osc.start(t);
                    osc.stop(t + 0.4);
                });
            }
        };

        // --- HIGH SCORE SYSTEM (local storage based) ---
        const HighScoreManager = {
            userIP: null,
            ipReady: false,

            init() {
                // Try cached IP first for immediate use
                const cachedIP = localStorage.getItem('user_ip_cache');
                if (cachedIP) this.userIP = cachedIP;
                // Fetch fresh IP in background
                this.fetchIP();
            },

            async fetchIP() {
                if (this.ipReady) return this.userIP;
                try {
                    const res = await fetch('https://api.ipify.org?format=json');
                    const data = await res.json();
                    this.userIP = data.ip;
                    localStorage.setItem('user_ip_cache', data.ip);
                } catch (e) {
                    this.userIP = this.userIP || 'local';
                }
                this.ipReady = true;
                return this.userIP;
            },

            getStorageKey(game) {
                // Use cached IP or 'local' - consistent within session
                return `highscore_${game}_${this.userIP || 'local'}`;
            },

            saveHighScore(game, score) {
                const key = this.getStorageKey(game);
                const current = localStorage.getItem(key);
                if (!current || score > parseInt(current, 10)) {
                    localStorage.setItem(key, score.toString());
                    return true;
                }
                return false;
            },

            getHighScore(game) {
                const key = this.getStorageKey(game);
                return parseInt(localStorage.getItem(key) || '0', 10);
            }
        };

        // Initialize on load (uses cached IP, fetches fresh in background)
        HighScoreManager.init();

        // --- ERROR BOUNDARY - Prevents window crashes from taking down the whole app ---
        class WindowErrorBoundary extends React.Component {
            constructor(props) {
                super(props);
                this.state = { hasError: false, error: null };
            }
            static getDerivedStateFromError(error) {
                return { hasError: true, error };
            }
            componentDidCatch(error, errorInfo) {
                console.error('Window Error:', error, errorInfo);
            }
            render() {
                if (this.state.hasError) {
                    return (
                        <div className="h-full flex flex-col items-center justify-center bg-black text-red-500 font-mono p-4">
                            <div className="text-xl font-bold mb-2">ERROR</div>
                            <div className="text-xs text-center mb-4">Window crashed. Close and try again.</div>
                            <div className="text-[10px] text-gray-500 max-w-full overflow-hidden text-ellipsis">
                                {this.state.error?.message || 'Unknown error'}
                            </div>
                        </div>
                    );
                }
                return this.props.children;
            }
        }

        // --- PIXELARTICONS (from unpkg CDN) ---
        const PixelartIcon = ({ name, size = 64, style = {}, className = '', ...props }) => (
            <img
                src={`https://unpkg.com/pixelarticons@1.8.1/svg/${name}.svg`}
                width={size}
                height={size}
                alt={name}
                style={{ imageRendering: 'pixelated', ...style }}
                className={className}
                {...props}
            />
        );

        const Icons = {
            // System Info - Monitor
            Terminal: (p) => <PixelartIcon name="monitor" {...p} />,
            // Media Library - Folder
            Folder: (p) => <PixelartIcon name="folder" {...p} />,
            // Paint - Fill bucket
            Palette: (p) => <PixelartIcon name="fill" {...p} />,
            // Snake Game - Gamepad
            Snek: (p) => <PixelartIcon name="gamepad" {...p} />,
            // Trash Can
            TrashCan: (p) => <PixelartIcon name="trash" {...p} />,
            // Undo arrow
            Undo: (p) => <PixelartIcon name="undo" {...p} />,
            // Redo arrow
            Redo: (p) => <PixelartIcon name="redo" {...p} />,
            // File document
            FileDoc: (p) => <PixelartIcon name="file" {...p} />,
            // Window controls
            X: ({ size = 24, ...p }) => <PixelartIcon name="close" size={size} {...p} />,
            Minus: ({ size = 24, ...p }) => <PixelartIcon name="minus" size={size} {...p} />,
            Square: ({ size = 24, ...p }) => <PixelartIcon name="checkbox" size={size} {...p} />,
            Trash: (p) => <PixelartIcon name="trash" {...p} />,
            Send: (p) => <PixelartIcon name="send" {...p} />,
            // Media folder icons
            Movies: (p) => <PixelartIcon name="movie" {...p} />,
            Books: (p) => <PixelartIcon name="book" {...p} />,
            Games: (p) => <PixelartIcon name="gamepad" {...p} />,
            Music: (p) => <PixelartIcon name="music" {...p} />,
            Back: (p) => <PixelartIcon name="arrow-left" {...p} />,
            // App Icons
            Void: (p) => <PixelartIcon name="code" {...p} />,
            Radio: (p) => <PixelartIcon name="radio-on" {...p} />,
            Dice: (p) => <PixelartIcon name="dice" {...p} />,
            Labyrinth: (p) => <PixelartIcon name="layout-rows" {...p} />,
            Minesweeper: (p) => <PixelartIcon name="table" {...p} />,
            Starship: (p) => <PixelartIcon name="arrow-up" {...p} />,
            Synth: (p) => <PixelartIcon name="keyboard" {...p} />,
            Destruction: (p) => <PixelartIcon name="power" {...p} />,
            Tarot: (p) => <PixelartIcon name="card" {...p} />,
            Dog: (p) => <PixelartIcon name="paw" {...p} />,
            // Email icon
            Email: (p) => <PixelartIcon name="mail" {...p} />,
            // Apps folder icon
            Apps: (p) => <PixelartIcon name="add-grid" {...p} />,
            // Gallery
            Gallery: (p) => <PixelartIcon name="image" {...p} />,
            // Globe
            Globe: (p) => <PixelartIcon name="map" {...p} />,
            // Pomodoro timer
            Pomodoro: (p) => <PixelartIcon name="clock" {...p} />,
            // Charging/power
            Charging: (p) => <PixelartIcon name="power" {...p} />,
            // Sound
            Speaker: (p) => <PixelartIcon name="volume-3" {...p} />,
            SpeakerOff: (p) => <PixelartIcon name="volume-x" {...p} />,
            // Health scanner
            HealthScanner: (p) => <PixelartIcon name="heart" {...p} />,
            // Lock icon
            Lock: (p) => <PixelartIcon name="lock" {...p} />,
            // Folder icons for app categories
            FolderClosed: (p) => <PixelartIcon name="folder" {...p} />,
            GamesFolder: (p) => <PixelartIcon name="gamepad" {...p} />,
            ProductivityFolder: (p) => <PixelartIcon name="sliders" {...p} />,
            AboutFolder: (p) => <PixelartIcon name="user" {...p} />,
            // Third Eye - code viewer
            ThirdEye: (p) => <PixelartIcon name="bullseye" {...p} />,
            // Browser
            Browser: (p) => <PixelartIcon name="layout-sidebar-left" {...p} />,
            // Trophy for achievements
            Trophy: (p) => <PixelartIcon name="trophy" {...p} />,
            // Achievement icons
            Message: (p) => <PixelartIcon name="message" {...p} />,
            RainAlt: (p) => <PixelartIcon name="drop-half" {...p} />,
            Alert: (p) => <PixelartIcon name="alert" {...p} />,
            Repeat: (p) => <PixelartIcon name="reload" {...p} />,
            Sword: (p) => <PixelartIcon name="sliders" {...p} />,
            Expand: (p) => <PixelartIcon name="open" {...p} />,
            Controller: (p) => <PixelartIcon name="gamepad" {...p} />,
            Clock: (p) => <PixelartIcon name="clock" {...p} />,
            Cursor: (p) => <PixelartIcon name="cursor" {...p} />,
            Skull: (p) => <PixelartIcon name="mood-sad" {...p} />,
            Fire: (p) => <PixelartIcon name="zap" {...p} />,
            Bomb: (p) => <PixelartIcon name="close-box" {...p} />,
            Badge: (p) => <PixelartIcon name="calendar" {...p} />,
        };

        // --- DOG COMPANION SPRITE SHEET SYSTEM ---
        // Sprite sheet: DOG_BLACK_SPRITE.png (128x288px, 32x32 sprites)
        // Row layout: idle(4 breathing), speaking(4), happy(2), thinking(4), sad(4), panicked(2), sleeping(2), angry(4), smug(4)
        const DOG_SPRITE_CONFIG = {
            spriteSize: 32,
            sheetWidth: 128,
            sheetHeight: 288,
            fps: 4,
            rows: {
                idle: { row: 0, frames: 4, breathe: true },  // Special breathing animation
                speaking: { row: 1, frames: 4 },
                happy: { row: 2, frames: 2 },
                thinking: { row: 3, frames: 4 },
                sad: { row: 4, frames: 4 },
                panicked: { row: 5, frames: 2 },
                sleeping: { row: 6, frames: 2 },
                angry: { row: 7, frames: 4 },
                smug: { row: 8, frames: 4 }
            }
        };

        // Dog companion sprite using PNG sprite sheet
        const DogCompanionSprite = ({ emotion = 'idle', scale = 2, style = {} }) => {
            const [frame, setFrame] = useState(0);
            const [isBreathing, setIsBreathing] = useState(false);
            const config = DOG_SPRITE_CONFIG.rows[emotion] || DOG_SPRITE_CONFIG.rows.idle;
            const breatheTimerRef = useRef(null);
            const breatheAnimRef = useRef(null);

            // Special idle breathing animation: hold frame 0, every 1s play full 4-frame cycle
            useEffect(() => {
                if (config.breathe) {
                    const startBreatheCycle = () => {
                        setIsBreathing(true);
                        let breatheFrame = 0;

                        // Play 4 frames at 4fps (250ms each)
                        breatheAnimRef.current = setInterval(() => {
                            breatheFrame++;
                            if (breatheFrame >= config.frames) {
                                // Animation complete, return to frame 0
                                clearInterval(breatheAnimRef.current);
                                setFrame(0);
                                setIsBreathing(false);
                            } else {
                                setFrame(breatheFrame);
                            }
                        }, 250);
                    };

                    // Start first breathe after 1 second, then repeat
                    breatheTimerRef.current = setInterval(startBreatheCycle, 1000 + (config.frames * 250));

                    return () => {
                        clearInterval(breatheTimerRef.current);
                        clearInterval(breatheAnimRef.current);
                    };
                } else if (config.frames > 1) {
                    // Normal looping animation at 4fps
                    const interval = setInterval(() => {
                        setFrame(f => (f + 1) % config.frames);
                    }, 250);
                    return () => clearInterval(interval);
                }
            }, [emotion, config.frames, config.breathe]);

            // Reset frame when emotion changes
            useEffect(() => {
                setFrame(0);
                setIsBreathing(false);
            }, [emotion]);

            const spriteX = frame * DOG_SPRITE_CONFIG.spriteSize;
            const spriteY = config.row * DOG_SPRITE_CONFIG.spriteSize;

            return (
                <div style={{
                    width: DOG_SPRITE_CONFIG.spriteSize * scale,
                    height: DOG_SPRITE_CONFIG.spriteSize * scale,
                    backgroundImage: 'url(DOG_BLACK_SPRITE.png)',
                    backgroundPosition: `-${spriteX * scale}px -${spriteY * scale}px`,
                    backgroundSize: `${DOG_SPRITE_CONFIG.sheetWidth * scale}px ${DOG_SPRITE_CONFIG.sheetHeight * scale}px`,
                    imageRendering: 'pixelated',
                    ...style
                }} />
            );
        };

        // Goldy sprite (32x32 cardboard fake dog that folds down when clicked)
        const GoldySprite = ({ scale = 2, onClick, falling = false }) => {
            return (
                <div
                    onClick={onClick}
                    className="cursor-pointer"
                    style={{
                        width: 32 * scale,
                        height: 32 * scale,
                        backgroundImage: 'url(DOG_GOLD_SPRITE.png)',
                        backgroundSize: `${32 * scale}px ${32 * scale}px`,
                        imageRendering: 'pixelated',
                        // Fold forward like cardboard falling (opposite of window-fold-in animation)
                        transform: falling ? 'perspective(800px) rotateX(90deg) scaleY(0)' : 'perspective(800px) rotateX(0deg) scaleY(1)',
                        transformOrigin: 'bottom center',
                        opacity: falling ? 0 : 1,
                        transition: 'transform 0.5s cubic-bezier(0.22, 1, 0.36, 1), opacity 0.5s'
                    }}
                />
            );
        };

        // Dog dialogue typing sound (Undertale-style)
        const playDogTypingSound = () => {
            const ctx = getAudioCtx();
            if (!ctx) return;
            const now = ctx.currentTime;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            // Vary pitch slightly for each character
            const basePitch = 400 + Math.random() * 100;
            osc.type = 'square';
            osc.frequency.setValueAtTime(basePitch, now);
            osc.frequency.setValueAtTime(basePitch * 0.9, now + 0.02);
            gain.gain.setValueAtTime(0.08, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.04);
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.start(now);
            osc.stop(now + 0.04);
        };

        // Dog bounce sound
        const playDogBounceSound = () => {
            const ctx = getAudioCtx();
            if (!ctx) return;
            const now = ctx.currentTime;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(200, now);
            osc.frequency.exponentialRampToValueAtTime(80, now + 0.1);
            gain.gain.setValueAtTime(0.15, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.start(now);
            osc.stop(now + 0.15);
        };

        // Speech bubble component - positions smartly to avoid screen clipping
        const DogSpeechBubble = ({ text, highlight = null, isTyping = true, onComplete, dogX = 0, dogY = 0 }) => {
            const [displayedText, setDisplayedText] = useState('');
            const [typingComplete, setTypingComplete] = useState(false);
            const typingRef = useRef(null);
            const bubbleRef = useRef(null);
            const [bubbleStyle, setBubbleStyle] = useState({});

            useEffect(() => {
                if (!isTyping) {
                    setDisplayedText(text);
                    setTypingComplete(true);
                    return;
                }

                setDisplayedText('');
                setTypingComplete(false);
                let index = 0;

                const typeNext = () => {
                    if (index < text.length) {
                        setDisplayedText(text.substring(0, index + 1));
                        if (text[index] !== ' ') playDogTypingSound();
                        index++;
                        typingRef.current = setTimeout(typeNext, 40);
                    } else {
                        setTypingComplete(true);
                        if (onComplete) onComplete();
                    }
                };

                typingRef.current = setTimeout(typeNext, 40);
                return () => clearTimeout(typingRef.current);
            }, [text, isTyping]);

            // Calculate bubble position to prevent clipping
            useEffect(() => {
                const bubbleWidth = 280;
                const bubbleHeight = 80;
                const dogSize = 96;
                const padding = 16;

                let left = dogSize / 2 - bubbleWidth / 2; // Center above dog
                let bottom = dogSize + 12; // Above dog

                // Prevent left edge clipping
                if (dogX + left < padding) {
                    left = padding - dogX;
                }
                // Prevent right edge clipping
                if (dogX + left + bubbleWidth > window.innerWidth - padding) {
                    left = window.innerWidth - padding - bubbleWidth - dogX;
                }
                // If dog is near top, show bubble below instead
                if (dogY < bubbleHeight + padding) {
                    bottom = -bubbleHeight - 12;
                }

                setBubbleStyle({ left, bottom });
            }, [dogX, dogY, displayedText]);

            // Render text with optional highlight
            const renderText = () => {
                if (!highlight || !displayedText.includes(highlight)) {
                    return displayedText;
                }
                const parts = displayedText.split(highlight);
                return parts.map((part, i) => (
                    <React.Fragment key={i}>
                        {part}
                        {i < parts.length - 1 && <span className="text-red-500 font-bold">{highlight}</span>}
                    </React.Fragment>
                ));
            };

            const isBelow = bubbleStyle.bottom < 0;

            return (
                <div
                    ref={bubbleRef}
                    className="absolute"
                    style={{
                        left: bubbleStyle.left,
                        bottom: bubbleStyle.bottom,
                        width: 280,
                        zIndex: 10
                    }}
                >
                    <div className="bg-black border-2 border-white px-4 py-3 font-mono text-xs uppercase tracking-widest text-white relative">
                        <div className="leading-relaxed">
                            {renderText()}
                            {!typingComplete && <span className="animate-pulse text-white/60">_</span>}
                        </div>
                        {/* Minimal connector line */}
                        {!isBelow ? (
                            <div className="absolute top-full left-8 w-px h-3 bg-white" />
                        ) : (
                            <div className="absolute bottom-full left-8 w-px h-3 bg-white" />
                        )}
                    </div>
                </div>
            );
        };

        // DOG_DIALOGUES is loaded from dialogues.js

        // Legacy DogSprite for backwards compatibility (used in some places)
        const DogSprite = ({ animated = false, style = {}, gold = false }) => {
            const color = gold ? '#DAA520' : '#000';
            const eyeColor = gold ? '#000' : '#fff';
            const pupilColor = gold ? '#fff' : '#000';
            const [frame, setFrame] = useState(0);

            useEffect(() => {
                if (!animated) return;
                let animationId;
                const animate = () => {
                    setFrame(f => f + 1);
                    animationId = requestAnimationFrame(animate);
                };
                animationId = requestAnimationFrame(animate);
                return () => cancelAnimationFrame(animationId);
            }, [animated]);

            const legPhase = Math.sin(frame * 0.1);
            const tailPhase = Math.sin(frame * 0.067);

            return (
                <svg width="64" height="48" viewBox="0 0 64 48" style={{ imageRendering: 'pixelated', ...style }}>
                    <rect x="16" y="16" width="32" height="16" fill={color} />
                    <rect x="4" y="12" width="16" height="16" fill={color} />
                    <rect x="2" y="4" width="6" height="14" fill={color} />
                    <rect x="14" y="4" width="6" height="14" fill={color} />
                    <rect x="8" y="16" width="6" height="6" fill={eyeColor} />
                    <rect x="10" y="18" width="3" height="3" fill={pupilColor} />
                    <rect x="4" y="22" width="4" height="4" fill={color} />
                    {animated && <rect x="2" y="26" width="4" height="2" fill={color} />}
                    <rect x="16" y="32" width="6" height={animated ? (legPhase > 0 ? 10 : 14) : 12} fill={color} />
                    <rect x="26" y="32" width="6" height={animated ? (legPhase > 0 ? 14 : 10) : 10} fill={color} />
                    <rect x="34" y="32" width="6" height={animated ? (legPhase > 0 ? 10 : 14) : 12} fill={color} />
                    <rect x="42" y="32" width="6" height={animated ? (legPhase > 0 ? 14 : 10) : 10} fill={color} />
                    <rect x="48" y={animated ? 12 + tailPhase * 4 : 12} width="12" height="4" fill={color} />
                    <rect x="58" y={animated ? 8 + tailPhase * 4 : 8} width="4" height="6" fill={color} />
                </svg>
            );
        };

        // --- DATA ---
        // Placeholder cover - replace with actual covers
        const PLACEHOLDER_COVER = 'https://mir-s3-cdn-cf.behance.net/project_modules/hd_webp/646ee452003795.5608cb3c699ab.jpg';

        const MEDIA_DB = {
            "CINEMA_TV": [
                { title: "Blade Runner 2049", cover: PLACEHOLDER_COVER, link: "" },
                { title: "Mr. Robot", cover: PLACEHOLDER_COVER, link: "" },
                { title: "True Detective", cover: PLACEHOLDER_COVER, link: "" },
                { title: "Succession", cover: PLACEHOLDER_COVER, link: "" },
                { title: "The Bear", cover: PLACEHOLDER_COVER, link: "" },
                { title: "Ex Machina", cover: PLACEHOLDER_COVER, link: "" },
                { title: "Fight Club", cover: PLACEHOLDER_COVER, link: "" },
                { title: "Better Call Saul", cover: PLACEHOLDER_COVER, link: "" },
                { title: "Whiplash", cover: PLACEHOLDER_COVER, link: "" },
                { title: "Black Mirror", cover: PLACEHOLDER_COVER, link: "" }
            ],
            "LITERATURE": [
                { title: "Brothers Karamazov", cover: PLACEHOLDER_COVER, link: "" },
                { title: "Looking for Alaska", cover: PLACEHOLDER_COVER, link: "" },
                { title: "Atlas Shrugged", cover: PLACEHOLDER_COVER, link: "" },
                { title: "Pale Blue Dot", cover: PLACEHOLDER_COVER, link: "" },
                { title: "Lean Startup", cover: PLACEHOLDER_COVER, link: "" },
                { title: "Fight Club", cover: PLACEHOLDER_COVER, link: "" },
                { title: "Principles by Ray Dalio", cover: PLACEHOLDER_COVER, link: "" },
                { title: "The Fountainhead", cover: PLACEHOLDER_COVER, link: "" },
                { title: "Crime & Punishment", cover: PLACEHOLDER_COVER, link: "" },
                { title: "1984", cover: PLACEHOLDER_COVER, link: "" },
                { title: "Master & Margarita", cover: PLACEHOLDER_COVER, link: "" },
                { title: "American Psycho", cover: PLACEHOLDER_COVER, link: "" },
                { title: "Elon Musk Biography", cover: PLACEHOLDER_COVER, link: "" },
                { title: "How to Get Filthy Rich in Rising Asia", cover: PLACEHOLDER_COVER, link: "" },
                { title: "Fathers and Sons", cover: PLACEHOLDER_COVER, link: "" },
                { title: "Geometry for Ocelots", cover: PLACEHOLDER_COVER, link: "" }
            ],
            "GAMES": [
                { title: "Dark Souls III", cover: PLACEHOLDER_COVER, link: "" },
                { title: "The Last of Us Pt II", cover: PLACEHOLDER_COVER, link: "" },
                { title: "Outer Wilds", cover: PLACEHOLDER_COVER, link: "" },
                { title: "God of War Ragnarok", cover: PLACEHOLDER_COVER, link: "" },
                { title: "Blue Prince", cover: PLACEHOLDER_COVER, link: "" },
                { title: "Cyberpunk 2077", cover: PLACEHOLDER_COVER, link: "" },
                { title: "Night in the Woods", cover: PLACEHOLDER_COVER, link: "" }
            ],
            "AUDIO": [
                { title: "Demos EP", artist: "Daughter", cover: PLACEHOLDER_COVER, link: "" },
                { title: "Mr. Morale...", artist: "Kendrick Lamar", cover: PLACEHOLDER_COVER, link: "" },
                { title: "The Life of Pablo", artist: "Kanye West", cover: PLACEHOLDER_COVER, link: "" },
                { title: "Ison", artist: "Sevdaliza", cover: PLACEHOLDER_COVER, link: "" },
                { title: "If You're Reading This It's Too Late", artist: "Drake", cover: PLACEHOLDER_COVER, link: "" },
                { title: "LP!", artist: "JPEGMAFIA", cover: PLACEHOLDER_COVER, link: "" },
                { title: "Miss Anthropocene", artist: "Grimes", cover: PLACEHOLDER_COVER, link: "" },
                { title: "The Eminem Show", artist: "Eminem", cover: PLACEHOLDER_COVER, link: "" },
                { title: "4 Your Eyez Only", artist: "J. Cole", cover: PLACEHOLDER_COVER, link: "" },
                { title: "Yeezus", artist: "Kanye West", cover: PLACEHOLDER_COVER, link: "" },
                { title: "This story is dedicated...", artist: "Grimes", cover: PLACEHOLDER_COVER, link: "" }
            ]
        };

        // --- APP COMPONENTS ---

        const PaintApp = ({ showHint, onAchievement }) => {
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const [tool, setTool] = useState('brush');
            const [color, setColor] = useState('#000000');
            const [size, setSize] = useState(4);
            const [isDrawing, setIsDrawing] = useState(false);
            const [status, setStatus] = useState("READY");
            const [startPos, setStartPos] = useState({ x: 0, y: 0 });
            const [textInput, setTextInput] = useState('');
            const [showTextInput, setShowTextInput] = useState(false);
            const [textPos, setTextPos] = useState({ x: 0, y: 0 });
            const snapshotRef = useRef(null);
            const historyRef = useRef([]);
            const historyIndexRef = useRef(-1);

            // Get accurate mouse/touch position relative to canvas
            const getMousePos = (e) => {
                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                // Handle both mouse and touch events
                let clientX, clientY;
                if (e.touches && e.touches.length > 0) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else if (e.changedTouches && e.changedTouches.length > 0) {
                    clientX = e.changedTouches[0].clientX;
                    clientY = e.changedTouches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                return {
                    x: (clientX - rect.left) * scaleX,
                    y: (clientY - rect.top) * scaleY
                };
            };

            // Touch event handlers
            const handleTouchStart = (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    startDraw(e);
                }
            };
            const handleTouchMove = (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    draw(e);
                }
            };
            const handleTouchEnd = (e) => {
                e.preventDefault();
                endDraw();
            };

            const saveToHistory = () => {
                const canvas = canvasRef.current;
                const data = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
                historyRef.current = historyRef.current.slice(0, historyIndexRef.current + 1);
                historyRef.current.push(data);
                if (historyRef.current.length > 50) historyRef.current.shift();
                historyIndexRef.current = historyRef.current.length - 1;
            };

            const undo = () => {
                if (historyIndexRef.current > 0) {
                    historyIndexRef.current--;
                    canvasRef.current.getContext('2d').putImageData(historyRef.current[historyIndexRef.current], 0, 0);
                    setStatus("UNDO");
                }
            };

            const redo = () => {
                if (historyIndexRef.current < historyRef.current.length - 1) {
                    historyIndexRef.current++;
                    canvasRef.current.getContext('2d').putImageData(historyRef.current[historyIndexRef.current], 0, 0);
                    setStatus("REDO");
                }
            };

            // Draw hidden "SUDO UNLOCK ZEN" pixels in top center
            const drawHiddenMessage = () => {
                const canvas = canvasRef.current;
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                ctx.save();
                ctx.fillStyle = '#fefefe'; // Nearly invisible white pixels
                ctx.font = '8px monospace';
                ctx.textAlign = 'center';
                // Draw tiny hidden text in TOP CENTER - resists being painted over
                ctx.fillText('SUDO UNLOCK ZEN', canvas.width / 2, 12);
                ctx.restore();
            };

            useEffect(() => {
                const initCanvas = () => {
                    if (!containerRef.current) return;
                    const canvas = canvasRef.current;
                    const container = containerRef.current;
                    // Set fixed canvas size for proper pixel drawing
                    canvas.width = container.clientWidth - 4;
                    canvas.height = container.clientHeight - 4;
                    const ctx = canvas.getContext("2d");
                    ctx.fillStyle = "#ffffff";
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    // Draw hint text if showHint is true
                    if (showHint) {
                        ctx.save();
                        ctx.globalAlpha = 0.15;
                        ctx.fillStyle = "#000000";
                        ctx.font = "24px 'PPNeueBit', sans-serif";
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        ctx.fillText("draw your message :)", canvas.width / 2, canvas.height / 2);
                        ctx.restore();
                    }
                    // Draw hidden message
                    drawHiddenMessage();
                    saveToHistory();
                };
                initCanvas();
                window.addEventListener('resize', initCanvas);

                // Periodically redraw hidden message (resists being painted over)
                const hiddenInterval = setInterval(() => {
                    drawHiddenMessage();
                }, 5000);

                return () => {
                    window.removeEventListener('resize', initCanvas);
                    clearInterval(hiddenInterval);
                };
            }, []);

            const floodFill = (x, y, fillColor) => {
                const ctx = canvasRef.current.getContext('2d');
                const w = ctx.canvas.width;
                const h = ctx.canvas.height;
                const imgData = ctx.getImageData(0, 0, w, h);
                const data = imgData.data;
                const r = parseInt(fillColor.slice(1, 3), 16);
                const g = parseInt(fillColor.slice(3, 5), 16);
                const b = parseInt(fillColor.slice(5, 7), 16);
                const startIdx = (y * w + x) * 4;
                const sr = data[startIdx], sg = data[startIdx + 1], sb = data[startIdx + 2];
                if (sr === r && sg === g && sb === b) return;
                const stack = [[x, y]];
                while (stack.length) {
                    const [cx, cy] = stack.pop();
                    const idx = (cy * w + cx) * 4;
                    if (cx < 0 || cx >= w || cy < 0 || cy >= h) continue;
                    if (data[idx] === sr && data[idx + 1] === sg && data[idx + 2] === sb) {
                        data[idx] = r; data[idx + 1] = g; data[idx + 2] = b; data[idx + 3] = 255;
                        stack.push([cx + 1, cy], [cx - 1, cy], [cx, cy + 1], [cx, cy - 1]);
                    }
                }
                ctx.putImageData(imgData, 0, 0);
                saveToHistory();
            };

            const saveSnapshot = () => {
                const canvas = canvasRef.current;
                snapshotRef.current = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
            };

            const restoreSnapshot = () => {
                if (snapshotRef.current) {
                    canvasRef.current.getContext('2d').putImageData(snapshotRef.current, 0, 0);
                }
            };

            const startDraw = (e) => {
                const pos = getMousePos(e);
                if (tool === 'bucket') {
                    floodFill(Math.floor(pos.x), Math.floor(pos.y), color);
                    setStatus("FILLED");
                } else if (tool === 'text') {
                    setTextPos(pos);
                    setShowTextInput(true);
                    setStatus("TYPE TEXT");
                } else if (['rect', 'circle', 'line'].includes(tool)) {
                    setIsDrawing(true);
                    setStartPos(pos);
                    saveSnapshot();
                } else {
                    setIsDrawing(true);
                    setStartPos(pos);
                    const ctx = canvasRef.current.getContext('2d');
                    ctx.beginPath();
                    ctx.moveTo(pos.x, pos.y);
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.lineWidth = size;
                    ctx.strokeStyle = tool === 'eraser' ? '#ffffff' : color;
                }
            };

            const draw = (e) => {
                if (!isDrawing) return;
                const ctx = canvasRef.current.getContext('2d');
                const pos = getMousePos(e);

                if (tool === 'brush' || tool === 'eraser') {
                    ctx.lineTo(pos.x, pos.y);
                    ctx.stroke();
                } else if (['rect', 'circle', 'line'].includes(tool)) {
                    restoreSnapshot();
                    ctx.strokeStyle = color;
                    ctx.fillStyle = color;
                    ctx.lineWidth = size;

                    if (tool === 'rect') {
                        ctx.strokeRect(startPos.x, startPos.y, pos.x - startPos.x, pos.y - startPos.y);
                    } else if (tool === 'circle') {
                        const rx = Math.abs(pos.x - startPos.x) / 2;
                        const ry = Math.abs(pos.y - startPos.y) / 2;
                        const cx = startPos.x + (pos.x - startPos.x) / 2;
                        const cy = startPos.y + (pos.y - startPos.y) / 2;
                        ctx.beginPath();
                        ctx.ellipse(cx, cy, rx, ry, 0, 0, 2 * Math.PI);
                        ctx.stroke();
                    } else if (tool === 'line') {
                        ctx.beginPath();
                        ctx.moveTo(startPos.x, startPos.y);
                        ctx.lineTo(pos.x, pos.y);
                        ctx.stroke();
                    }
                }
            };

            const endDraw = () => {
                if (isDrawing) {
                    setIsDrawing(false);
                    if (tool === 'brush' || tool === 'eraser') {
                        canvasRef.current.getContext('2d').closePath();
                    }
                    saveToHistory();
                }
            };

            const placeText = () => {
                if (textInput.trim()) {
                    const ctx = canvasRef.current.getContext('2d');
                    ctx.fillStyle = color;
                    ctx.font = `${size * 4}px 'PPNeueBit', sans-serif`;
                    ctx.fillText(textInput, textPos.x, textPos.y);
                    setStatus("TEXT PLACED");
                    saveToHistory();
                }
                setShowTextInput(false);
                setTextInput('');
            };

            const send = async () => {
                const canvas = canvasRef.current;
                try {
                    // Copy canvas to clipboard
                    canvas.toBlob(async (blob) => {
                        if (blob) {
                            try {
                                await navigator.clipboard.write([
                                    new ClipboardItem({ 'image/png': blob })
                                ]);
                                setStatus("COPIED TO CLIPBOARD");
                                onAchievement?.('MESSENGER');
                            } catch (e) {
                                setStatus("COPY FAILED");
                            }
                        }
                    }, 'image/png');
                    // Open mailto
                    setTimeout(() => {
                        window.location.href = 'mailto:mateusmuste9@gmail.com';
                    }, 500);
                } catch (e) {
                    setStatus("ERROR");
                }
            };

            const clear = () => {
                const ctx = canvasRef.current.getContext('2d');
                ctx.fillStyle = "#ffffff";
                ctx.fillRect(0, 0, canvasRef.current.width, canvasRef.current.height);
                setStatus("CLEARED");
                saveToHistory();
            };

            // Pixel knob component
            const PixelKnob = ({ value, onChange, min, max }) => {
                const knobSize = 24;
                const rotation = ((value - min) / (max - min)) * 270 - 135;
                return (
                    <div
                        className="relative cursor-pointer select-none"
                        style={{ width: knobSize, height: knobSize }}
                        onMouseDown={(e) => {
                            e.preventDefault();
                            const startY = e.clientY;
                            const startVal = value;
                            const onMove = (ev) => {
                                const diff = startY - ev.clientY;
                                const newVal = Math.min(max, Math.max(min, startVal + Math.floor(diff / 5)));
                                onChange(newVal);
                            };
                            const onUp = () => {
                                window.removeEventListener('mousemove', onMove);
                                window.removeEventListener('mouseup', onUp);
                            };
                            window.addEventListener('mousemove', onMove);
                            window.addEventListener('mouseup', onUp);
                        }}
                    >
                        <svg width={knobSize} height={knobSize} viewBox="0 0 24 24" style={{ imageRendering: 'pixelated' }}>
                            <rect x="4" y="4" width="16" height="16" fill="#000" />
                            <rect x="6" y="6" width="12" height="12" fill="#fff" />
                            <rect x="10" y="6" width="4" height="6" fill="#000" transform={`rotate(${rotation}, 12, 12)`} />
                        </svg>
                    </div>
                );
            };

            const tools = ['brush', 'eraser', 'bucket', 'line', 'rect', 'circle', 'text'];
            const colors = ['#000000', '#ffffff', '#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ff8800', '#8800ff'];

            return (
                <div className="h-full flex flex-col bg-gray-100 select-none">
                    <div className="app-header flex-shrink-0">
                        <div className="flex items-center gap-2 min-w-0">
                            <Icons.Palette size={16} className="flex-shrink-0" />
                            <span className="app-header-title truncate">PAINT.EXE</span>
                        </div>
                        <button onClick={() => { sounds.click(); send(); }} className="btn-primary btn-xs flex-shrink-0">
                            SEND
                        </button>
                    </div>
                    <div className="p-2 border-b-2 border-black bg-white flex flex-wrap gap-2 items-center">
                        <div className="flex gap-1">
                            <button onClick={() => { sounds.click(); undo(); }} className="btn-icon" title="Undo"><Icons.Undo size={16} /></button>
                            <button onClick={() => { sounds.click(); redo(); }} className="btn-icon" title="Redo"><Icons.Redo size={16} /></button>
                        </div>
                        <div className="w-px h-4 bg-black"></div>
                        <div className="flex gap-1 flex-wrap">
                            {tools.map(t => (
                                <button key={t} onClick={() => { sounds.click(); setTool(t); }} className={`btn-toolbar ${tool === t ? 'active' : ''}`}>{t}</button>
                            ))}
                        </div>
                        <div className="w-px h-4 bg-black"></div>
                        <div className="flex gap-1 flex-wrap">
                            {colors.map(c => (
                                <button key={c} onClick={() => { sounds.click(); setColor(c); }} className={`w-5 h-5 border border-black ${color === c ? 'ring-2 ring-offset-1 ring-black' : ''}`} style={{ backgroundColor: c }} />
                            ))}
                        </div>
                        <div className="w-px h-4 bg-black"></div>
                        <div className="flex items-center gap-1">
                            <PixelKnob value={size} onChange={setSize} min={1} max={20} />
                            <span className="text-[10px] font-mono w-4">{size}</span>
                        </div>
                    </div>
                    <div className="flex-grow relative cursor-crosshair bg-gray-300 p-[2px] overflow-hidden" ref={containerRef}>
                        <canvas
                            ref={canvasRef}
                            role="img"
                            aria-label="Drawing canvas for Paint application"
                            onMouseDown={startDraw}
                            onMouseMove={draw}
                            onMouseUp={endDraw}
                            onMouseLeave={endDraw}
                            onTouchStart={handleTouchStart}
                            onTouchMove={handleTouchMove}
                            onTouchEnd={handleTouchEnd}
                            className="block bg-white border border-gray-400 touch-none"
                            style={{ width: '100%', height: '100%' }}
                        />
                        {showTextInput && (
                            <div className="absolute top-2 left-2 bg-white border-2 border-black p-2 flex gap-2">
                                <input
                                    type="text"
                                    aria-label="Text to add to canvas"
                                    value={textInput}
                                    onChange={(e) => setTextInput(e.target.value)}
                                    onKeyDown={(e) => e.key === 'Enter' && placeText()}
                                    placeholder="Type text..."
                                    className="border border-black px-2 py-1 text-xs font-mono"
                                    autoFocus
                                />
                                <button onClick={placeText} className="btn-primary btn-xs">OK</button>
                            </div>
                        )}
                        <div className="absolute bottom-1 left-1 bg-black text-white text-[10px] px-2 font-mono">{status}</div>
                    </div>
                </div>
            )
        }

        // --- LUXURY COVER FLOW - Swiss International Design ---
        const CoverFlow = ({ onAchievement }) => {
            // Flatten all media items with category info
            const allItems = useMemo(() => {
                const items = [];
                const categories = [
                    { key: 'CINEMA_TV', label: 'FILM' },
                    { key: 'LITERATURE', label: 'LITERATURE' },
                    { key: 'GAMES', label: 'GAMES' },
                    { key: 'AUDIO', label: 'AUDIO' }
                ];
                categories.forEach(cat => {
                    MEDIA_DB[cat.key].forEach(item => {
                        items.push({ ...item, category: cat.label, categoryKey: cat.key });
                    });
                });
                return items;
            }, []);

            const [currentIndex, setCurrentIndex] = useState(Math.floor(allItems.length / 2));
            const [isDragging, setIsDragging] = useState(false);
            const [dragStart, setDragStart] = useState({ x: 0, index: 0 });
            const [velocity, setVelocity] = useState(0);
            const [visitedCategories, setVisitedCategories] = useState(() => {
                const stored = localStorage.getItem('media_lib_visited');
                return stored ? JSON.parse(stored) : [];
            });
            const containerRef = useRef(null);
            const lastMoveTime = useRef(Date.now());
            const lastMoveX = useRef(0);
            const animationRef = useRef(null);
            const dragStartTime = useRef(0);

            // Aspect ratios: AUDIO = 1:1, others = 4:5 (portrait)
            const getAspectRatio = (categoryKey) => categoryKey === 'AUDIO' ? 1 : 0.8;
            const getCoverDimensions = (categoryKey) => {
                const isSquare = categoryKey === 'AUDIO';
                return {
                    width: 140,
                    height: isSquare ? 140 : 175 // 4:5 ratio = 140 * 1.25
                };
            };

            // Track category visits for achievement
            useEffect(() => {
                const currentItem = allItems[currentIndex];
                if (currentItem && !visitedCategories.includes(currentItem.categoryKey)) {
                    const newVisited = [...visitedCategories, currentItem.categoryKey];
                    setVisitedCategories(newVisited);
                    localStorage.setItem('media_lib_visited', JSON.stringify(newVisited));
                    if (newVisited.length >= 4) {
                        onAchievement?.('DEEP_LISTENER');
                    }
                }
            }, [currentIndex, allItems, visitedCategories, onAchievement]);

            // Momentum animation
            useEffect(() => {
                if (!isDragging && Math.abs(velocity) > 0.1) {
                    animationRef.current = requestAnimationFrame(() => {
                        const newIndex = Math.max(0, Math.min(allItems.length - 1,
                            Math.round(currentIndex - velocity)));
                        setCurrentIndex(newIndex);
                        setVelocity(velocity * 0.92);
                    });
                }
                return () => {
                    if (animationRef.current) cancelAnimationFrame(animationRef.current);
                };
            }, [isDragging, velocity, currentIndex, allItems.length]);

            const handleDragStart = (e) => {
                setIsDragging(true);
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                setDragStart({ x: clientX, index: currentIndex });
                lastMoveX.current = clientX;
                lastMoveTime.current = Date.now();
                dragStartTime.current = Date.now();
                setVelocity(0);
            };

            const handleDragMove = (e) => {
                if (!isDragging) return;
                e.preventDefault();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const containerWidth = containerRef.current?.offsetWidth || 400;
                const dragSensitivity = containerWidth / 3;
                const delta = (dragStart.x - clientX) / dragSensitivity;
                const newIndex = Math.max(0, Math.min(allItems.length - 1,
                    Math.round(dragStart.index + delta)));

                // Calculate velocity
                const now = Date.now();
                const dt = now - lastMoveTime.current;
                if (dt > 0) {
                    const dx = clientX - lastMoveX.current;
                    setVelocity(dx / dt * 10);
                }
                lastMoveX.current = clientX;
                lastMoveTime.current = now;

                if (newIndex !== currentIndex) {
                    setCurrentIndex(newIndex);
                    sounds.click();
                }
            };

            const handleDragEnd = () => {
                setIsDragging(false);
            };

            const handleWheel = (e) => {
                e.preventDefault();
                const delta = e.deltaX !== 0 ? e.deltaX : e.deltaY;
                const newIndex = Math.max(0, Math.min(allItems.length - 1,
                    currentIndex + Math.sign(delta)));
                if (newIndex !== currentIndex) {
                    setCurrentIndex(newIndex);
                    sounds.click();
                }
            };

            const handleKeyDown = (e) => {
                if (e.key === 'ArrowLeft') {
                    setCurrentIndex(i => Math.max(0, i - 1));
                    sounds.click();
                } else if (e.key === 'ArrowRight') {
                    setCurrentIndex(i => Math.min(allItems.length - 1, i + 1));
                    sounds.click();
                }
            };

            const getCoverStyle = (index, item) => {
                const offset = index - currentIndex;
                const absOffset = Math.abs(offset);
                const dims = getCoverDimensions(item.categoryKey);

                // Core positioning
                const translateX = offset * 85;
                const translateZ = -absOffset * 100;
                const rotateY = offset * -45;
                const scale = 1 - absOffset * 0.12;
                const opacity = Math.max(0, 1 - absOffset * 0.2);
                const zIndex = 100 - absOffset;

                // Only show 5 covers on each side
                if (absOffset > 5) {
                    return { display: 'none', dims };
                }

                return {
                    position: 'absolute',
                    left: '50%',
                    top: '50%',
                    width: `${dims.width}px`,
                    height: `${dims.height}px`,
                    marginLeft: `${-dims.width / 2}px`,
                    marginTop: `${-dims.height / 2}px`,
                    transform: `translateX(${translateX}px) translateZ(${translateZ}px) rotateY(${rotateY}deg) scale(${scale})`,
                    opacity,
                    zIndex,
                    transition: isDragging ? 'none' : 'all 0.4s cubic-bezier(0.23, 1, 0.32, 1)',
                    cursor: 'pointer',
                    transformStyle: 'preserve-3d',
                    dims,
                };
            };

            const handleCoverClick = (index, item) => {
                // Only navigate if it was a quick tap (not a drag)
                const dragDuration = Date.now() - dragStartTime.current;
                const wasDrag = dragDuration > 200 || Math.abs(dragStart.x - lastMoveX.current) > 10;

                if (index === currentIndex && !wasDrag && item.link) {
                    window.open(item.link, '_blank', 'noopener,noreferrer');
                } else if (!wasDrag && index !== currentIndex) {
                    setCurrentIndex(index);
                    sounds.click();
                }
            };

            const currentItem = allItems[currentIndex];

            return (
                <div
                    className="h-full flex flex-col select-none overflow-hidden"
                    style={{
                        background: 'linear-gradient(180deg, #0a0a0a 0%, #1a1a1a 50%, #0a0a0a 100%)',
                        fontFamily: "'Helvetica Neue', Helvetica, Arial, sans-serif"
                    }}
                    onKeyDown={handleKeyDown}
                    tabIndex={0}
                >
                    {/* Minimal Swiss Header */}
                    <div className="flex-shrink-0 px-6 py-4 flex justify-between items-center border-b border-white/10">
                        <div className="flex items-center gap-4">
                            <span className="text-[10px] tracking-[0.3em] text-white/40 font-light uppercase">
                                Collection
                            </span>
                        </div>
                        <div className="text-[10px] tracking-[0.2em] text-white/30 font-light tabular-nums">
                            {String(currentIndex + 1).padStart(2, '0')} / {String(allItems.length).padStart(2, '0')}
                        </div>
                    </div>

                    {/* Cover Flow Container */}
                    <div
                        ref={containerRef}
                        className="flex-grow relative overflow-hidden"
                        style={{ perspective: '1000px', perspectiveOrigin: '50% 40%' }}
                        onMouseDown={handleDragStart}
                        onMouseMove={handleDragMove}
                        onMouseUp={handleDragEnd}
                        onMouseLeave={handleDragEnd}
                        onTouchStart={handleDragStart}
                        onTouchMove={handleDragMove}
                        onTouchEnd={handleDragEnd}
                        onWheel={handleWheel}
                    >
                        {/* Ambient glow */}
                        <div
                            className="absolute inset-0 pointer-events-none"
                            style={{
                                background: 'radial-gradient(ellipse 60% 40% at 50% 40%, rgba(255,255,255,0.03) 0%, transparent 70%)'
                            }}
                        />

                        {/* Covers */}
                        <div
                            className="absolute inset-0"
                            style={{ transformStyle: 'preserve-3d' }}
                        >
                            {allItems.map((item, index) => {
                                const style = getCoverStyle(index, item);
                                if (style.display === 'none') return null;
                                const { dims, ...styleWithoutDims } = style;

                                return (
                                    <div
                                        key={index}
                                        style={styleWithoutDims}
                                        onClick={() => handleCoverClick(index, item)}
                                    >
                                        {/* Cover */}
                                        <div
                                            className="w-full h-full relative"
                                            style={{
                                                boxShadow: index === currentIndex
                                                    ? '0 25px 80px rgba(0,0,0,0.8), 0 10px 30px rgba(0,0,0,0.6)'
                                                    : '0 15px 40px rgba(0,0,0,0.5)',
                                                borderRadius: '2px',
                                                overflow: 'hidden',
                                                backfaceVisibility: 'hidden',
                                            }}
                                        >
                                            <img
                                                src={item.cover}
                                                alt={item.title}
                                                className="w-full h-full object-cover"
                                                style={{
                                                    filter: index === currentIndex ? 'none' : 'brightness(0.7)',
                                                    transition: 'filter 0.4s ease'
                                                }}
                                                draggable={false}
                                            />
                                            {/* Subtle overlay gradient */}
                                            <div
                                                className="absolute inset-0 pointer-events-none"
                                                style={{
                                                    background: 'linear-gradient(180deg, transparent 60%, rgba(0,0,0,0.4) 100%)'
                                                }}
                                            />
                                        </div>

                                        {/* Reflection */}
                                        <div
                                            className="absolute w-full overflow-hidden"
                                            style={{
                                                top: '100%',
                                                height: `${dims.height * 0.35}px`,
                                                transform: 'scaleY(-1)',
                                                opacity: 0.12,
                                                maskImage: 'linear-gradient(to bottom, rgba(0,0,0,0.5) 0%, transparent 100%)',
                                                WebkitMaskImage: 'linear-gradient(to bottom, rgba(0,0,0,0.5) 0%, transparent 100%)',
                                            }}
                                        >
                                            <img
                                                src={item.cover}
                                                alt=""
                                                className="w-full h-full object-cover object-bottom"
                                                style={{ filter: 'blur(1px)' }}
                                                draggable={false}
                                            />
                                        </div>
                                    </div>
                                );
                            })}
                        </div>

                        {/* Navigation hints */}
                        <div className="absolute bottom-8 left-1/2 -translate-x-1/2 flex gap-8 pointer-events-none">
                            <div className="text-white/20 text-[10px] tracking-[0.2em] uppercase">
                                 Drag to browse 
                            </div>
                        </div>
                    </div>

                    {/* Info Panel - Swiss Typography */}
                    <div
                        className="flex-shrink-0 px-6 py-5 border-t border-white/10"
                        style={{ background: 'rgba(0,0,0,0.5)' }}
                    >
                        <div className="flex items-end justify-between gap-4">
                            <div className="min-w-0 flex-1">
                                <div className="text-[9px] tracking-[0.4em] text-white/40 uppercase mb-2 font-light">
                                    {currentItem?.category}
                                </div>
                                <h2
                                    className="text-white font-light text-lg tracking-tight truncate"
                                    style={{
                                        fontWeight: 300,
                                        letterSpacing: '-0.02em'
                                    }}
                                >
                                    {currentItem?.title}
                                </h2>
                                {currentItem?.artist && (
                                    <p className="text-white/50 text-xs mt-1 font-light tracking-wide">
                                        {currentItem.artist}
                                    </p>
                                )}
                            </div>

                            {/* Progress indicator */}
                            <div className="flex-shrink-0 flex flex-col items-end gap-2">
                                <div
                                    className="w-20 h-px bg-white/10 relative overflow-hidden"
                                >
                                    <div
                                        className="h-full bg-white/60 transition-all duration-300"
                                        style={{
                                            width: `${((currentIndex + 1) / allItems.length) * 100}%`
                                        }}
                                    />
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // Keep FileExplorer as alias for backward compatibility
        const FileExplorer = CoverFlow;

        const SystemInfo = ({ onThirdEyeWorld, totalVisitors }) => {
            const [konamiProgress, setKonamiProgress] = useState(0);
            const konamiCode = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'KeyB', 'KeyA'];
            // Mobile: swipe up, up, down, down, left, right, left, right, tap, tap
            const mobileKonamiCode = ['up', 'up', 'down', 'down', 'left', 'right', 'left', 'right', 'tap', 'tap'];
            const touchStartRef = useRef({ x: 0, y: 0, time: 0 });
            const konamiTimeoutRef = useRef(null);

            const handleKonamiGesture = (gesture) => {
                const expectedGesture = mobileKonamiCode[konamiProgress];
                if (gesture === expectedGesture) {
                    const newProgress = konamiProgress + 1;
                    setKonamiProgress(newProgress);
                    // Reset after 3 seconds of inactivity
                    clearTimeout(konamiTimeoutRef.current);
                    konamiTimeoutRef.current = setTimeout(() => setKonamiProgress(0), 3000);
                    if (newProgress === mobileKonamiCode.length) {
                        onThirdEyeWorld?.();
                        setKonamiProgress(0);
                        clearTimeout(konamiTimeoutRef.current);
                    }
                } else {
                    setKonamiProgress(0);
                }
            };

            const handleTouchStart = (e) => {
                touchStartRef.current = {
                    x: e.touches[0].clientX,
                    y: e.touches[0].clientY,
                    time: Date.now()
                };
            };

            const handleTouchEnd = (e) => {
                const dx = e.changedTouches[0].clientX - touchStartRef.current.x;
                const dy = e.changedTouches[0].clientY - touchStartRef.current.y;
                const elapsed = Date.now() - touchStartRef.current.time;
                const threshold = 50;

                // Detect gesture
                if (Math.abs(dx) < 20 && Math.abs(dy) < 20 && elapsed < 300) {
                    // Tap
                    handleKonamiGesture('tap');
                } else if (Math.abs(dx) > Math.abs(dy)) {
                    // Horizontal swipe
                    if (dx > threshold) handleKonamiGesture('right');
                    else if (dx < -threshold) handleKonamiGesture('left');
                } else {
                    // Vertical swipe
                    if (dy > threshold) handleKonamiGesture('down');
                    else if (dy < -threshold) handleKonamiGesture('up');
                }
            };

            useEffect(() => {
                const handleKeyDown = (e) => {
                    const expectedKey = konamiCode[konamiProgress];
                    if (e.code === expectedKey) {
                        const newProgress = konamiProgress + 1;
                        setKonamiProgress(newProgress);
                        if (newProgress === konamiCode.length) {
                            onThirdEyeWorld?.();
                            setKonamiProgress(0);
                        }
                    } else {
                        setKonamiProgress(0);
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [konamiProgress, onThirdEyeWorld]);

            return (
            <div className="p-6 md:p-12 font-sans select-text" onTouchStart={handleTouchStart} onTouchEnd={handleTouchEnd}>
                <header className="mb-12 border-b-4 border-black pb-8">
                    <h1 className="text-6xl md:text-8xl font-black uppercase tracking-tighter leading-none">Mateus<br />Muste</h1>
                    <div className="mt-4 flex flex-wrap gap-4 font-mono text-sm">
                        <span className="bg-black text-white px-2 py-1">DIGITAL DESIGNER</span>
                        <span className="bg-black text-white px-2 py-1">RADICAL OPTIMIST</span>
                        <span className="border border-black px-2 py-1">ROMANIA</span>
                        {totalVisitors && (
                            <span className="border border-black px-2 py-1 ml-auto">VISITORS: {totalVisitors.toLocaleString()}</span>
                        )}
                    </div>
                </header>
                <div className="grid md:grid-cols-2 gap-12">
                    <div className="space-y-8">
                        <section>
                            <h3 className="text-2xl font-black uppercase mb-4 border-b-2 border-black">App Stack</h3>
                            <div className="grid grid-cols-4 gap-1">
                                {[
                                    { name: 'PHOTOSHOP', yrs: 9 },
                                    { name: 'PREMIERE', yrs: 8 },
                                    { name: 'AFTER EFFECTS', yrs: 6 },
                                    { name: 'EXCEL', yrs: 5 },
                                    { name: 'META ADS', yrs: 5 },
                                    { name: 'DAVINCI', yrs: 4 },
                                    { name: 'ARCHICAD', yrs: 3 },
                                    { name: 'SQUARESPACE', yrs: 3 },
                                    { name: 'UNREAL', yrs: 3 },
                                    { name: 'WEBFLOW', yrs: 3 },
                                    { name: 'MIDJOURNEY', yrs: 2 },
                                    { name: 'GOOGLE ADS', yrs: 2 },
                                    { name: 'BLENDER', yrs: 1 },
                                    { name: 'CURSOR', yrs: 1 },
                                    { name: 'COMFYUI', yrs: 1 },
                                    { name: 'N8N', yrs: 1 }
                                ].map((app, i, arr) => (
                                    <div
                                        key={i}
                                        className="border-2 border-black aspect-square flex flex-col items-center justify-center p-1 cursor-default"
                                        style={{ opacity: 1 - (i / (arr.length - 1)) * 0.66 }}
                                    >
                                        <span className="font-black text-[8px] text-center leading-tight">{app.name}</span>
                                        <span className="font-mono text-[8px] mt-1">{app.yrs} YRS</span>
                                    </div>
                                ))}
                            </div>
                        </section>
                        <section><h3 className="text-2xl font-black uppercase mb-4 border-b-2 border-black">Metrics</h3>
                            <div className="flex gap-4">
                                <div className="p-4 border-2 border-black text-center"><div className="text-3xl font-black">C2</div><div className="font-mono text-[10px]">CAMBRIDGE</div></div>
                                <div className="p-4 border-2 border-black text-center"><div className="text-3xl font-black">1570</div><div className="font-mono text-[10px]">SAT</div></div>
                            </div>
                        </section>
                    </div>
                    <div className="space-y-4">
                        <h3 className="text-2xl font-black uppercase mb-4 border-b-2 border-black">Projects</h3>
                        {[
                            { t: "BIOBUILDS", num: "01", s: "Web / Video / Marketing", d: "Sustainable construction across Europe. Entered 3 markets." },
                            { t: "ROMANIA OLYMPICS 2024", num: "02", s: "Premiere / After Effects", d: "National contest winner. Cluj-Napoca." },
                            { t: "ULT", num: "03", s: "Documentary / Editing", d: "Self-directed channel. Skill laboratory." }
                        ].map((p, i) => (
                            <div key={i} className="group border-2 border-black p-4 hover:bg-black hover:text-white cursor-pointer">
                                <div className="flex justify-between mb-1"><h4 className="font-bold uppercase">{p.t}</h4><span className="font-mono text-xs">{p.num}</span></div>
                                <p className="font-mono text-xs opacity-70 mb-1">{p.s}</p><p className="text-sm italic">{p.d}</p>
                            </div>
                        ))}
                    </div>
                </div>
            </div>
            );
        };

        // ABOUT.EXE - Static portfolio page (no animations)
        const AboutApp = ({ onAchievement }) => {
            const achievementTriggered = useRef(false);
            const skills = [
                { name: 'PHOTOSHOP', yrs: 9 },
                { name: 'PREMIERE', yrs: 8 },
                { name: 'AFTER EFFECTS', yrs: 6 },
                { name: 'EXCEL', yrs: 5 },
                { name: 'META ADS', yrs: 5 },
                { name: 'DAVINCI', yrs: 4 },
                { name: 'ARCHICAD', yrs: 3 },
                { name: 'WEBFLOW', yrs: 3 },
                { name: 'UNREAL', yrs: 3 },
                { name: 'MIDJOURNEY', yrs: 2 },
                { name: 'CURSOR', yrs: 1 },
                { name: 'COMFYUI', yrs: 1 }
            ];

            const projects = [
                { t: "BIOBUILDS", s: "Web / Video / Marketing", d: "Sustainable construction across Europe." },
                { t: "ROMANIA OLYMPICS 2024", s: "Premiere / After Effects", d: "National contest winner." },
                { t: "ULT", s: "Documentary / Editing", d: "Self-directed channel." }
            ];

            return (
                <div className="h-full flex flex-col bg-white select-none overflow-auto">
                    <div className="p-6 md:p-8 space-y-8">
                        {/* Name */}
                        <h1 className="font-black" style={{ fontSize: 'clamp(6rem, 22.5vw, 15rem)' }}>
                            MATEUS<br />MUSTE
                        </h1>

                        {/* Badges */}
                        <div className="flex flex-wrap gap-2">
                            <span className="bg-black text-white px-2 py-1 font-mono text-[10px] md:text-xs">DIGITAL DESIGNER</span>
                            <span className="bg-black text-white px-2 py-1 font-mono text-[10px] md:text-xs">RADICAL OPTIMIST</span>
                            <span className="border-2 border-black px-2 py-1 font-mono text-[10px] md:text-xs">ROMANIA</span>
                        </div>

                        {/* Skills */}
                        <div>
                            <h3 className="font-black text-lg uppercase mb-4 border-b-2 border-black pb-2">Skills</h3>
                            <div className="grid grid-cols-3 md:grid-cols-4 gap-2">
                                {skills.map((skill, i) => (
                                    <div key={i} className="border-2 border-black p-2 text-center" style={{ opacity: 1 - (i / skills.length) * 0.5 }}>
                                        <div className="font-bold text-[10px]">{skill.name}</div>
                                        <div className="font-mono text-[10px] text-gray-500">{skill.yrs} YRS</div>
                                    </div>
                                ))}
                            </div>
                        </div>

                        {/* Projects */}
                        <div>
                            <h3 className="font-black text-lg uppercase mb-4 border-b-2 border-black pb-2">Projects</h3>
                            <div className="space-y-2">
                                {projects.map((p, i) => (
                                    <div key={i} className="border-2 border-black p-3 hover:bg-black hover:text-white transition-colors cursor-pointer" onClick={() => {
                                        if (!achievementTriggered.current) {
                                            achievementTriggered.current = true;
                                            onAchievement?.('WORK_IN_PROGRESS');
                                        }
                                    }}>
                                        <div className="font-bold text-sm uppercase">{p.t}</div>
                                        <div className="font-mono text-[10px] text-gray-500">{p.s}</div>
                                        <div className="text-[13px] mt-1">{p.d}</div>
                                    </div>
                                ))}
                            </div>
                        </div>

                    </div>
                </div>
            );
        };

        // MESSAGES.EXE - Messenger app for intro sequence (v3.0 Narrative Bible)
        const MessagesApp = ({ onIntroComplete, isTruthSequence = false, onTruthComplete }) => {
            const [messages, setMessages] = useState([]);
            const [isTyping, setIsTyping] = useState(false);
            const [redactedCount, setRedactedCount] = useState(0); // How many messages are redacted
            const [isRedacting, setIsRedacting] = useState(false); // Are we in redaction phase
            const introStartedRef = useRef(false);
            const onIntroCompleteRef = useRef(onIntroComplete);
            const onTruthCompleteRef = useRef(onTruthComplete);
            const messagesEndRef = useRef(null);

            // Keep the callback refs updated
            onIntroCompleteRef.current = onIntroComplete;
            onTruthCompleteRef.current = onTruthComplete;

            // Typing sound effect
            const playTypingSound = () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800 + Math.random() * 200, now);
                osc.frequency.exponentialRampToValueAtTime(400, now + 0.05);
                gain.gain.setValueAtTime(0.08, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.05);
            };

            // Message sent sound
            const playMessageSound = () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.exponentialRampToValueAtTime(900, now + 0.08);
                gain.gain.setValueAtTime(0.12, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(now);
                osc.stop(now + 0.1);
            };

            // Metallic hit sound for redaction
            const playMetallicHit = () => {
                const ctx = getAudioCtx();
                if (!ctx) return;
                const now = ctx.currentTime;

                // Main metallic tone
                const osc1 = ctx.createOscillator();
                const osc2 = ctx.createOscillator();
                const gain = ctx.createGain();
                const filter = ctx.createBiquadFilter();

                osc1.type = 'square';
                osc1.frequency.setValueAtTime(180, now);
                osc1.frequency.exponentialRampToValueAtTime(60, now + 0.15);

                osc2.type = 'sawtooth';
                osc2.frequency.setValueAtTime(320, now);
                osc2.frequency.exponentialRampToValueAtTime(80, now + 0.1);

                filter.type = 'bandpass';
                filter.frequency.setValueAtTime(800, now);
                filter.Q.setValueAtTime(2, now);

                gain.gain.setValueAtTime(0.25, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);

                osc1.connect(filter);
                osc2.connect(filter);
                filter.connect(gain);
                gain.connect(ctx.destination);

                osc1.start(now);
                osc2.start(now);
                osc1.stop(now + 0.2);
                osc2.stop(now + 0.2);
            };

            // Start intro sequence when component mounts - use ref to prevent double-run
            useEffect(() => {
                if (introStartedRef.current) return;
                introStartedRef.current = true;

                // TRUTH.EXE sequence (after completing sudo become god + konami)
                if (isTruthSequence) {
                    const truthMessages = [
                        "Wow... you made it.",
                        "most people bounce after 30 seconds.",
                        "you stayed. you searched. you solved.",
                        "this site exists because systems make more sense than people.",
                        "To that point portfolios place more value on projects than actual people.",
                        "if you got here, you probably think the same way.",
                        "that's rare.",
                        "if you want to talk about ideas, projects,",
                        "or just because you enjoyed this",
                        "mateusmuste9@gmail.com",
                        "P.S. include \"CODE 9\" in your email ;)"
                    ];
                    let messageIndex = 0;
                    let cancelled = false;

                    const sendNextMessage = () => {
                        if (cancelled || messageIndex >= truthMessages.length) {
                            if (!cancelled) {
                                setTimeout(() => onTruthCompleteRef.current?.(), 2000);
                            }
                            return;
                        }
                        const currentMessage = truthMessages[messageIndex];
                        messageIndex++;
                        setIsTyping(true);
                        const typingDuration = 800 + Math.random() * 700;
                        const typingSoundInterval = setInterval(() => {
                            if (!cancelled) playTypingSound();
                        }, 100);
                        setTimeout(() => {
                            if (cancelled) { clearInterval(typingSoundInterval); return; }
                            clearInterval(typingSoundInterval);
                            setIsTyping(false);
                            playMessageSound();
                            setMessages(prev => [...prev, { text: currentMessage, highlight: false }]);
                            setTimeout(sendNextMessage, 1000 + Math.random() * 2000);
                        }, typingDuration);
                    };
                    setTimeout(sendNextMessage, 1000);
                    return () => { cancelled = true; };
                }

                // Main intro sequence - Narrative Bible v3.0
                const messagesToSend = [
                    { text: "Hey.", highlight: false },
                    { text: "You found me.", highlight: false },
                    { text: "Or maybe I found you. Hard to tell with these things.", highlight: false },
                    { text: "I'm Mateus. This is my corner of the internet.", highlight: false },
                    { text: "Before you go clicking around, you should know something.", highlight: true },
                    { text: "This is not a portfolio.", highlight: false },
                    { text: "This is a mind system.", highlight: false },
                    { text: "Everything is intentional.", highlight: true },
                    { text: "Every app is meticulously designed to serve a purpose.", highlight: false },
                    { text: "Some purposes are obvious. Most aren't.", highlight: true },
                    { text: "Have fun exploring!", highlight: true },
                    { text: "And if you're the curious type...", highlight: false },
                    { text: "There's more here than meets the eye.", highlight: true },
                    // Extra pause before next message (handled in timing)
                    { text: "Oh, one more thing.", highlight: true, extraPauseBefore: true },
                    { text: "And for whatever reason, if you ever find yourself coming across this file, never open truth.exe.", highlight: false, containsTruth: true }
                ];
                let messageIndex = 0;
                let cancelled = false;

                const sendNextMessage = () => {
                    if (cancelled) return;

                    if (messageIndex >= messagesToSend.length) {
                        // Start redaction sequence after 2 second pause
                        setTimeout(() => {
                            if (cancelled) return;
                            setIsRedacting(true);

                            // Redact messages one by one, every 0.5 seconds
                            // Skip the last message (contains truth.exe)
                            const totalToRedact = messagesToSend.length - 1;
                            let currentRedact = 0;

                            const redactNext = () => {
                                if (cancelled || currentRedact >= totalToRedact) {
                                    // All done - complete intro after a pause
                                    setTimeout(() => {
                                        if (!cancelled) onIntroCompleteRef.current?.();
                                    }, 2000);
                                    return;
                                }

                                playMetallicHit();
                                currentRedact++;
                                setRedactedCount(currentRedact);

                                // Schedule next redaction
                                setTimeout(redactNext, 500);
                            };

                            // Start first redaction
                            redactNext();
                        }, 2000);
                        return;
                    }

                    const currentMsg = messagesToSend[messageIndex];
                    messageIndex++;

                    // Handle extra pause
                    const extraPause = currentMsg.extraPauseBefore ? 2000 : 0;

                    setTimeout(() => {
                        if (cancelled) return;
                        setIsTyping(true);

                        // Random typing duration 1-2 seconds
                        const typingDuration = 1000 + Math.random() * 1000;
                        const typingSoundInterval = setInterval(() => {
                            if (!cancelled) playTypingSound();
                        }, 100);

                        setTimeout(() => {
                            if (cancelled) {
                                clearInterval(typingSoundInterval);
                                return;
                            }
                            clearInterval(typingSoundInterval);
                            setIsTyping(false);
                            playMessageSound();
                            setMessages(prev => [...prev, currentMsg]);

                            // Random delay 1-3 seconds before next message
                            const nextDelay = 1000 + Math.random() * 2000;
                            setTimeout(sendNextMessage, nextDelay);
                        }, typingDuration);
                    }, extraPause);
                };

                // Start after a brief delay
                setTimeout(sendNextMessage, 1000);

                return () => { cancelled = true; };
            }, [isTruthSequence]); // Dependency on isTruthSequence

            // Auto-scroll to bottom
            useEffect(() => {
                messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
            }, [messages, isTyping, redactedCount]);

            // Convert text to redacted blocks (same length as original)
            const redactText = (text) => {
                return text.replace(/[^\s]/g, '');
            };

            return (
                <div className="h-full flex flex-col bg-black select-none overflow-hidden">
                    {/* Header */}
                    <div className="bg-black border-b border-white/20 px-4 py-3 flex items-center gap-3">
                        <div className="w-8 h-8 bg-white text-black flex items-center justify-center font-mono font-black text-xs">
                            MM
                        </div>
                        <div>
                            <div className="font-mono text-white text-sm font-bold">
                                {isRedacting ? redactText('MATEUS MUSTE') : 'MATEUS MUSTE'}
                            </div>
                            <div className="font-mono text-[10px] text-white/50 flex items-center gap-2">
                                <span className={`w-1.5 h-1.5 ${isRedacting ? 'bg-red-500' : isTyping ? 'bg-white animate-pulse' : 'bg-green-400'}`}></span>
                                {isRedacting ? 'ENCRYPTING' : isTyping ? 'COMPOSING' : 'ONLINE'}
                            </div>
                        </div>
                    </div>

                    {/* Messages */}
                    <div className="flex-grow overflow-auto p-6 space-y-4">
                        <>
                            {messages.filter(msg => msg && (msg.text || typeof msg === 'string')).map((msg, i) => {
                                const text = typeof msg === 'string' ? msg : msg.text;
                                const highlight = typeof msg === 'object' && msg.highlight;
                                const containsTruth = typeof msg === 'object' && msg.containsTruth;

                                // Check if this message should be redacted (not the last message with truth.exe)
                                const isRedacted = isRedacting && i < redactedCount;

                                // For the truth.exe message, show special formatting (never redact)
                                if (containsTruth) {
                                    // During redaction, only show "open truth.exe."
                                    if (isRedacting) {
                                        return (
                                            <div key={i} className="flex items-start gap-3">
                                                <div className="w-1 bg-red-500 flex-shrink-0 mt-1" style={{ minHeight: '16px' }}></div>
                                                <p className="font-mono text-red-400 text-sm leading-relaxed font-bold">
                                                    open truth.exe.
                                                </p>
                                            </div>
                                        );
                                    }
                                    // Normal display with highlighted text
                                    const parts = text.split('never open truth.exe');
                                    return (
                                        <div key={i} className="flex items-start gap-3">
                                            <div className={`w-1 ${highlight ? 'bg-white' : 'bg-white/30'} flex-shrink-0 mt-1`} style={{ minHeight: '16px' }}></div>
                                            <p className="font-mono text-white text-sm leading-relaxed">
                                                {parts[0]}
                                                <span className="text-red-400 font-bold">never open truth.exe</span>
                                                {parts[1] || '.'}
                                            </p>
                                        </div>
                                    );
                                }

                                // Redacted message
                                if (isRedacted) {
                                    return (
                                        <div key={i} className="flex items-start gap-3">
                                            <div className="w-1 bg-white/10 flex-shrink-0 mt-1" style={{ minHeight: '16px' }}></div>
                                            <p className="font-mono text-white/30 text-sm leading-relaxed">
                                                {redactText(text)}
                                            </p>
                                        </div>
                                    );
                                }

                                // Normal message
                                return (
                                    <div key={i} className="flex items-start gap-3">
                                        <div className={`w-1 ${highlight ? 'bg-white' : 'bg-white/30'} flex-shrink-0 mt-1`} style={{ minHeight: '16px' }}></div>
                                        <p className={`font-mono text-sm leading-relaxed ${highlight ? 'text-white font-bold' : 'text-white'}`}>
                                            {text}
                                        </p>
                                    </div>
                                );
                            })}

                                {/* Typing indicator */}
                                {isTyping && (
                                    <div className="flex items-start gap-3">
                                        <div className="w-1 bg-white flex-shrink-0" style={{ minHeight: '16px' }}></div>
                                        <span className="w-2 h-4 bg-white animate-pulse"></span>
                                    </div>
                                )}
                            </>
                        )}
                        <div ref={messagesEndRef} />
                    </div>
                </div>
            );
        };

        const TrashApp = () => {
            const [shakingFile, setShakingFile] = useState(null);

            const trashFiles = [
                { name: 'BITCOIN_WALLET.txt', icon: 'FileDoc' },
                { name: 'ACCEPTANCE_LETTER.pdf', icon: 'FileDoc' },
                { name: 'SCHEDULE.ics', icon: 'FileDoc' }
            ];

            const handleFileClick = (fileName) => {
                setShakingFile(fileName);
                setTimeout(() => setShakingFile(null), 500);
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="app-header">
                        <span className="app-header-title">RECYCLE_BIN</span>
                        <span className="app-header-subtitle">{trashFiles.length} ITEMS</span>
                    </div>
                    <div className="flex-grow p-4">
                        <div className="grid grid-cols-3 gap-4">
                            {trashFiles.map(file => (
                                <button
                                    key={file.name}
                                    onClick={() => handleFileClick(file.name)}
                                    className="group flex flex-col items-center gap-2 p-3 cursor-not-allowed hover:bg-gray-100"
                                    style={{
                                        animation: shakingFile === file.name ? 'shake 0.5s ease-in-out' : 'none'
                                    }}
                                >
                                    <div className="bg-white border-2 border-black p-2 icon-shadow opacity-50 group-hover:opacity-70">
                                        <Icons.FileDoc size={24} />
                                    </div>
                                    <span className="font-mono text-[8px] font-bold text-center break-all opacity-50 group-hover:opacity-70">{file.name}</span>
                                </button>
                            ))}
                        </div>
                    </div>
                    <div className="p-2 border-t-2 border-black text-center">
                        <span className="font-mono text-[10px] text-gray-500">PERMANENTLY DELETED</span>
                    </div>
                </div>
            );
        }

        // --- VOID.TXT - Text encrypts then fades into the void ---
        const VoidApp = ({ onAchievement }) => {
            // Each char: { id, char, timestamp, phase: 'visible'|'encrypting'|'fading', opacity }
            const [chars, setChars] = useState([]);
            const inputRef = useRef(null);
            const charIdRef = useRef(0);
            const [totalChars, setTotalChars] = useState(() => {
                const stored = localStorage.getItem('void_total_chars');
                return stored ? parseInt(stored, 10) : 0;
            });

            const encryptChar = () => {
                const symbols = '@#$%&*';
                return symbols[Math.floor(Math.random() * symbols.length)];
            };

            // Process loop - runs every 50ms to update char states
            useEffect(() => {
                const interval = setInterval(() => {
                    const now = Date.now();
                    setChars(prev => {
                        let updated = false;
                        const newChars = prev.map(c => {
                            // After 1.5s, start encrypting
                            if (c.phase === 'visible' && now - c.timestamp >= 1500) {
                                updated = true;
                                return { ...c, phase: 'encrypting', displayChar: encryptChar() };
                            }
                            // After encrypting for 300ms, start fading
                            if (c.phase === 'encrypting' && now - c.timestamp >= 1800) {
                                updated = true;
                                return { ...c, phase: 'fading', opacity: 0.8 };
                            }
                            // Fade out
                            if (c.phase === 'fading') {
                                const newOpacity = c.opacity - 0.15;
                                if (newOpacity <= 0) {
                                    updated = true;
                                    return null; // Mark for removal
                                }
                                updated = true;
                                return { ...c, opacity: newOpacity, displayChar: encryptChar() };
                            }
                            return c;
                        }).filter(Boolean);
                        return updated ? newChars : prev;
                    });
                }, 50);
                return () => clearInterval(interval);
            }, []);

            const handleKeyDown = (e) => {
                if (e.key === 'Backspace') {
                    // Remove most recent visible char
                    setChars(prev => {
                        const visibleChars = prev.filter(c => c.phase === 'visible');
                        if (visibleChars.length === 0) return prev;
                        const lastVisible = visibleChars[visibleChars.length - 1];
                        return prev.filter(c => c.id !== lastVisible.id);
                    });
                    e.preventDefault();
                } else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
                    // Add new character
                    const newChar = {
                        id: charIdRef.current++,
                        char: e.key,
                        displayChar: e.key,
                        timestamp: Date.now(),
                        phase: 'visible',
                        opacity: 1
                    };
                    setChars(prev => [...prev, newChar]);
                    // Track total characters for VOIDBORN achievement
                    const newTotal = totalChars + 1;
                    setTotalChars(newTotal);
                    localStorage.setItem('void_total_chars', newTotal.toString());
                    if (newTotal >= 1000) onAchievement?.('VOIDBORN');
                    e.preventDefault();
                }
            };

            // Render chars grouped - visible chars are white, encrypting are green
            const renderChars = () => {
                return chars.map(c => (
                    <span
                        key={c.id}
                        style={{
                            color: c.phase === 'encrypting' ? '#0f0' :
                                c.phase === 'fading' ? `rgba(0,255,0,${c.opacity})` : 'white',
                            textShadow: c.phase !== 'visible' ? '0 0 5px #0f0' : 'none'
                        }}
                    >
                        {c.displayChar}
                    </span>
                ));
            };

            return (
                <div
                    className="h-full flex flex-col bg-black select-none cursor-text"
                    onClick={() => inputRef.current?.focus()}
                    onCopy={(e) => e.preventDefault()}
                    onCut={(e) => e.preventDefault()}
                >
                    <div className="p-2 border-b border-gray-800 bg-black">
                        <span className="font-mono text-xs font-bold text-white">VOID.TXT</span>
                    </div>
                    <div className="flex-grow p-4 overflow-auto font-mono text-sm">
                        <div className="flex flex-wrap items-start">
                            <span className="mr-2 text-gray-600">{'>'}</span>
                            <div className="flex-grow">
                                {renderChars()}
                                <span className="animate-pulse text-white">_</span>
                            </div>
                        </div>
                        <input
                            ref={inputRef}
                            type="text"
                            className="absolute opacity-0 pointer-events-none"
                            onKeyDown={handleKeyDown}
                            onPaste={(e) => e.preventDefault()}
                            autoFocus
                        />
                    </div>
                </div>
            );
        };

        // --- RADIO.WAV - Playlist link ---
        const RadioApp = ({ onAchievement }) => {
            const [isPlaying, setIsPlaying] = useState(false);
            const [visualizer, setVisualizer] = useState([]);

            useEffect(() => {
                const interval = setInterval(() => {
                    if (isPlaying) {
                        setVisualizer(Array(16).fill(0).map(() => Math.random() * 100));
                    }
                }, 100);
                return () => clearInterval(interval);
            }, [isPlaying]);

            const openPlaylist = () => {
                window.open('https://music.youtube.com/playlist?list=PLeIQRsOWZUhKaD53FTvwZCxsNWzjq0lfO&si=92O5A6kAPjk8Vzmg', '_blank', 'noopener,noreferrer');
                setIsPlaying(true);
                onAchievement?.('TUNED_IN');
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="app-header">
                        <span className="app-header-title">RADIO.WAV</span>
                        <span className="app-footer-text">MATEUS_PLAYLIST</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-8 bg-gray-50">
                        <div className="flex items-end justify-center gap-1 h-32 mb-8 p-4 border-2 border-black bg-white">
                            {(isPlaying ? visualizer : Array(16).fill(10)).map((h, i) => (
                                <div
                                    key={i}
                                    className="w-3 bg-black transition-all duration-100"
                                    style={{ height: `${h}%`, minHeight: '4px' }}
                                />
                            ))}
                        </div>
                        <button
                            onClick={openPlaylist}
                            className="btn-primary btn-lg"
                        >
                            {isPlaying ? ' NOW PLAYING' : ' TUNE IN'}
                        </button>
                        <div className="mt-4 font-mono text-xs text-gray-500">
                            OPENS YOUTUBE MUSIC
                        </div>
                    </div>
                    <div className="p-2 border-t-2 border-black bg-white">
                        <div className="font-mono text-[10px] text-gray-500 text-center">
                            BROADCASTING FROM THE VOID
                        </div>
                    </div>
                </div>
            );
        };

        // --- DICE.EXE - D20 Roller with Three.js ---
        const DiceApp = ({ onAchievement }) => {
            const [result, setResult] = useState(null);
            const [isRolling, setIsRolling] = useState(false);
            const [rollCount, setRollCount] = useState(0);
            const isRollingRef = useRef(false); // Ref to avoid stale closure
            const containerRef = useRef(null);
            const sceneRef = useRef(null);
            const diceRef = useRef(null);
            const animationRef = useRef(null);
            const consecutiveTwenties = useRef(0);

            // Initialize Three.js scene
            useEffect(() => {
                if (!containerRef.current || sceneRef.current) return;

                const width = 200;
                const height = 200;

                // Scene
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xffffff);

                // Camera
                const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
                camera.position.z = 4;

                // Renderer
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                renderer.setPixelRatio(window.devicePixelRatio);
                containerRef.current.appendChild(renderer.domElement);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(2, 2, 2);
                scene.add(directionalLight);

                const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
                backLight.position.set(-2, -2, -2);
                scene.add(backLight);

                // D20 (Icosahedron)
                const geometry = new THREE.IcosahedronGeometry(1.2, 0);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x111111,
                    metalness: 0.1,
                    roughness: 0.4,
                    flatShading: true
                });
                const dice = new THREE.Mesh(geometry, material);
                scene.add(dice);

                // Edge lines
                const edges = new THREE.EdgesGeometry(geometry);
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0x444444 });
                const wireframe = new THREE.LineSegments(edges, lineMaterial);
                dice.add(wireframe);

                diceRef.current = dice;
                sceneRef.current = { scene, camera, renderer };

                // Initial render
                renderer.render(scene, camera);

                // Idle animation - uses ref to avoid stale closure
                const idleAnimate = () => {
                    if (!isRollingRef.current) {
                        dice.rotation.x += 0.003;
                        dice.rotation.y += 0.005;
                    }
                    renderer.render(scene, camera);
                    animationRef.current = requestAnimationFrame(idleAnimate);
                };
                idleAnimate();

                return () => {
                    cancelAnimationFrame(animationRef.current);
                    renderer.dispose();
                    if (containerRef.current && renderer.domElement) {
                        containerRef.current.removeChild(renderer.domElement);
                    }
                };
            }, []);

            const rollDice = () => {
                if (isRolling || !diceRef.current || !sceneRef.current) return;
                setIsRolling(true);
                isRollingRef.current = true;
                setResult(null);
                sounds.diceRoll();

                const dice = diceRef.current;
                const { renderer, scene, camera } = sceneRef.current;

                // Random target rotation
                const targetRotX = dice.rotation.x + Math.PI * (4 + Math.random() * 4);
                const targetRotY = dice.rotation.y + Math.PI * (4 + Math.random() * 4);
                const targetRotZ = dice.rotation.z + Math.PI * (2 + Math.random() * 2);

                const startRotX = dice.rotation.x;
                const startRotY = dice.rotation.y;
                const startRotZ = dice.rotation.z;

                const duration = 1500;
                const startTime = Date.now();

                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // Easing - decelerate
                    const eased = 1 - Math.pow(1 - progress, 3);

                    dice.rotation.x = startRotX + (targetRotX - startRotX) * eased;
                    dice.rotation.y = startRotY + (targetRotY - startRotY) * eased;
                    dice.rotation.z = startRotZ + (targetRotZ - startRotZ) * eased;

                    renderer.render(scene, camera);

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // On the 5th roll, automatically give a 20, then back to RNG
                        setRollCount(prev => {
                            const newCount = prev + 1;
                            const roll = newCount === 5 ? 20 : Math.floor(Math.random() * 20) + 1;
                            setResult(roll);
                            setIsRolling(false);
                            isRollingRef.current = false;
                            // On roll 20: DIVINE_ROLL achievement + reveal command (Narrative Bible v3.0)
                            if (roll === 20) {
                                sounds.diceCrit20();
                                consecutiveTwenties.current++;
                                onAchievement?.('DIVINE_ROLL');
                                if (consecutiveTwenties.current >= 3) {
                                    onAchievement?.('IMPOSSIBLE');
                                }
                            } else if (roll === 1) {
                                sounds.diceCrit1();
                                consecutiveTwenties.current = 0;
                            } else {
                                consecutiveTwenties.current = 0;
                            }
                            return newCount;
                        });
                    }
                };

                animate();
            };

            // Space key to roll
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.code === 'Space' || e.key === ' ') {
                        e.preventDefault();
                        rollDice();
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [isRolling]);

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="flex-grow flex flex-col items-center justify-center p-4 bg-white">
                        <div className="mb-4" ref={containerRef} style={{ width: 200, height: 200 }} />
                        <button
                            onClick={rollDice}
                            disabled={isRolling}
                            className="bg-black text-white px-6 py-2 font-mono text-[10px] tracking-widest hover:bg-gray-800 disabled:bg-gray-300 transition-colors"
                        >
                            {isRolling ? 'ROLLING' : 'ROLL [SPACE]'}
                        </button>
                        {/* Result below button with fixed height to prevent jumping */}
                        <div className="h-12 flex items-center justify-center mt-4">
                            {result && !isRolling && (
                                <div className="font-mono text-[10px] tracking-widest text-center">
                                    {result === 20 ? '20 SUDO EXTRACT REVELATION' : result === 1 ? '1 USELESS' : `RESULT: ${result}`}
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };

        // --- SNEK.EXE ---
        const SnakeAppNew = ({ onAchievement, onDogEvent }) => {
            const canvasRef = useRef(null);
            const [score, setScore] = useState(0);
            const achievementTriggered = useRef(false);
            const snekLostTriggered = useRef(false);
            const snekCompleteTriggered = useRef(false);
            const [highScore, setHighScore] = useState(() => HighScoreManager.getHighScore('snake'));
            const [gameOver, setGameOver] = useState(false);
            const [gameStarted, setGameStarted] = useState(false);
            const snake = useRef([{ x: 10, y: 5 }]);
            const food = useRef({ x: 14, y: 5 });
            const dir = useRef({ x: 1, y: 0 });
            const nextDir = useRef({ x: 1, y: 0 });
            const runningRef = useRef(false);
            const lastTimeRef = useRef(0);
            const frameRef = useRef(null);

            const GRID_W = 20;
            const GRID_H = 10;
            const CELL = 28;

            // Load high score from storage when IP is ready
            useEffect(() => {
                const loadHighScore = async () => {
                    await HighScoreManager.fetchIP();
                    setHighScore(HighScoreManager.getHighScore('snake'));
                };
                loadHighScore();
            }, []);

            const start = () => {
                snake.current = [{ x: 10, y: 5 }, { x: 9, y: 5 }, { x: 8, y: 5 }];
                dir.current = { x: 1, y: 0 };
                nextDir.current = { x: 1, y: 0 };
                food.current = { x: Math.floor(Math.random() * GRID_W), y: Math.floor(Math.random() * GRID_H) };
                setScore(0);
                setGameOver(false);
                setGameStarted(true);
                runningRef.current = true;
                lastTimeRef.current = 0;
            };

            const update = () => {
                const ctx = canvasRef.current?.getContext('2d');
                if (!ctx) return;

                dir.current = nextDir.current;
                const head = {
                    x: snake.current[0].x + dir.current.x,
                    y: snake.current[0].y + dir.current.y
                };

                // Wall collision
                if (head.x < 0 || head.x >= GRID_W || head.y < 0 || head.y >= GRID_H) {
                    endGame();
                    return;
                }

                // Self collision
                if (snake.current.some(s => s.x === head.x && s.y === head.y)) {
                    endGame();
                    return;
                }

                snake.current.unshift(head);

                // Eat food
                if (head.x === food.current.x && head.y === food.current.y) {
                    sounds.coin();
                    setScore(s => {
                        const newScore = s + 10;
                        setHighScore(h => {
                            const newHigh = Math.max(h, newScore);
                            HighScoreManager.saveHighScore('snake', newHigh);
                            return newHigh;
                        });
                        if (newScore >= 50 && !achievementTriggered.current) {
                            achievementTriggered.current = true;
                            onAchievement?.('OUROBOROS');
                        }
                        // Trigger snekComplete when snake shows all SUDOUNLOCK letters (100 points = 13 segments)
                        if (newScore >= 100 && !snekCompleteTriggered.current) {
                            snekCompleteTriggered.current = true;
                            onDogEvent?.('snekComplete');
                        }
                        return newScore;
                    });
                    food.current = {
                        x: Math.floor(Math.random() * GRID_W),
                        y: Math.floor(Math.random() * GRID_H)
                    };
                } else {
                    snake.current.pop();
                }

                // Draw - light theme
                ctx.fillStyle = '#f5f5f5';
                ctx.fillRect(0, 0, GRID_W * CELL, GRID_H * CELL);

                // Grid lines (subtle)
                ctx.strokeStyle = '#e0e0e0';
                for (let i = 0; i <= GRID_W; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * CELL, 0);
                    ctx.lineTo(i * CELL, GRID_H * CELL);
                    ctx.stroke();
                }
                for (let i = 0; i <= GRID_H; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, i * CELL);
                    ctx.lineTo(GRID_W * CELL, i * CELL);
                    ctx.stroke();
                }

                // Snake - black with SUDOUNLOCK letters (Narrative Bible v3.0)
                const SNEK_LETTERS = ['S', 'U', 'D', 'O', 'U', 'N', 'L', 'O', 'C', 'K'];
                snake.current.forEach((s, i) => {
                    ctx.fillStyle = i === 0 ? '#000' : '#333';
                    ctx.fillRect(s.x * CELL + 1, s.y * CELL + 1, CELL - 2, CELL - 2);
                    // Display letters on body segments 1-10
                    if (i > 0 && i <= 10) {
                        ctx.fillStyle = '#fff';
                        ctx.font = 'bold 20px "PPNeueBit", monospace';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(SNEK_LETTERS[i - 1], s.x * CELL + CELL / 2, s.y * CELL + CELL / 2);
                    }
                });

                // Food - black dot
                ctx.fillStyle = '#000';
                ctx.fillRect(food.current.x * CELL + 4, food.current.y * CELL + 4, CELL - 8, CELL - 8);
            };

            const endGame = () => {
                runningRef.current = false;
                setGameOver(true);
                setGameStarted(false);
                sounds.gameOver();
                // Trigger snekLost on first loss
                if (!snekLostTriggered.current) {
                    snekLostTriggered.current = true;
                    onDogEvent?.('snekLost');
                }
            };

            // Game loop using requestAnimationFrame
            useEffect(() => {
                const gameLoop = (timestamp) => {
                    if (!runningRef.current) {
                        frameRef.current = requestAnimationFrame(gameLoop);
                        return;
                    }

                    if (timestamp - lastTimeRef.current >= 100) {
                        lastTimeRef.current = timestamp;
                        update();
                    }

                    frameRef.current = requestAnimationFrame(gameLoop);
                };

                frameRef.current = requestAnimationFrame(gameLoop);

                return () => {
                    if (frameRef.current) cancelAnimationFrame(frameRef.current);
                };
            }, []);

            useEffect(() => {
                const handle = (e) => {
                    if (!runningRef.current) return;
                    if (e.key === 'ArrowUp' && dir.current.y === 0) nextDir.current = { x: 0, y: -1 };
                    if (e.key === 'ArrowDown' && dir.current.y === 0) nextDir.current = { x: 0, y: 1 };
                    if (e.key === 'ArrowLeft' && dir.current.x === 0) nextDir.current = { x: -1, y: 0 };
                    if (e.key === 'ArrowRight' && dir.current.x === 0) nextDir.current = { x: 1, y: 0 };
                };
                window.addEventListener('keydown', handle);
                return () => window.removeEventListener('keydown', handle);
            }, []);

            // Initial canvas draw - light theme
            useEffect(() => {
                const ctx = canvasRef.current?.getContext('2d');
                if (ctx) {
                    ctx.fillStyle = '#f5f5f5';
                    ctx.fillRect(0, 0, GRID_W * CELL, GRID_H * CELL);

                    // Draw grid lines
                    ctx.strokeStyle = '#e0e0e0';
                    for (let i = 0; i <= GRID_W; i++) {
                        ctx.beginPath();
                        ctx.moveTo(i * CELL, 0);
                        ctx.lineTo(i * CELL, GRID_H * CELL);
                        ctx.stroke();
                    }
                    for (let i = 0; i <= GRID_H; i++) {
                        ctx.beginPath();
                        ctx.moveTo(0, i * CELL);
                        ctx.lineTo(GRID_W * CELL, i * CELL);
                        ctx.stroke();
                    }
                }
            }, []);

            // Touch controls for mobile
            const handleDirection = (newDir) => {
                if (!runningRef.current) return;
                if (newDir === 'up' && dir.current.y === 0) nextDir.current = { x: 0, y: -1 };
                if (newDir === 'down' && dir.current.y === 0) nextDir.current = { x: 0, y: 1 };
                if (newDir === 'left' && dir.current.x === 0) nextDir.current = { x: -1, y: 0 };
                if (newDir === 'right' && dir.current.x === 0) nextDir.current = { x: 1, y: 0 };
            };

            // Swipe detection
            const touchStartRef = useRef({ x: 0, y: 0 });
            const handleTouchStart = (e) => {
                touchStartRef.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            };
            const handleTouchEnd = (e) => {
                if (!runningRef.current) return;
                const dx = e.changedTouches[0].clientX - touchStartRef.current.x;
                const dy = e.changedTouches[0].clientY - touchStartRef.current.y;
                if (Math.abs(dx) > Math.abs(dy)) {
                    if (dx > 30) handleDirection('right');
                    else if (dx < -30) handleDirection('left');
                } else {
                    if (dy > 30) handleDirection('down');
                    else if (dy < -30) handleDirection('up');
                }
            };

            return (
                <div className="h-full flex flex-col bg-white select-none" onTouchStart={handleTouchStart} onTouchEnd={handleTouchEnd}>
                    <div className="app-header">
                        <span className="app-header-title">SNEK.EXE</span>
                        <div className="flex gap-4 font-mono text-xs">
                            <span>SCORE: <span className="font-bold">{score}</span></span>
                            <span>HIGH: <span className="font-bold">{highScore}</span></span>
                            <span className={gameOver ? 'text-red-600' : gameStarted ? 'text-green-600' : 'text-gray-500'}>
                                {gameOver ? 'DEAD' : gameStarted ? 'ALIVE' : 'READY'}
                            </span>
                        </div>
                    </div>
                    <div className="flex-grow flex items-center justify-center p-2 md:p-4 bg-gray-50 overflow-hidden">
                        <div className="relative border-2 border-black" style={{ width: 'min(100%, 560px)', aspectRatio: '2/1' }}>
                            <canvas ref={canvasRef} width={560} height={280} className="block w-full h-full" style={{ imageRendering: 'pixelated' }} role="img" aria-label="Snake game canvas" />
                            {!gameStarted && (
                                <div className="absolute inset-0 bg-white/95 flex flex-col items-center justify-center">
                                    <div className="text-4xl font-black mb-2 tracking-widest">SNEK</div>
                                    {gameOver && <p className="text-red-600 mb-4 font-mono text-sm">GAME OVER</p>}
                                    <button
                                        onClick={start}
                                        className="btn-primary"
                                    >
                                        {gameOver ? 'RETRY' : 'START'}
                                    </button>
                                    <p className="mt-4 text-gray-500 font-mono text-xs text-center px-4 hidden md:block">ARROW KEYS TO MOVE</p>
                                    <p className="mt-4 text-gray-500 font-mono text-xs text-center px-4 md:hidden">SWIPE TO MOVE</p>
                                </div>
                            )}
                        </div>
                    </div>
                    <div className="app-footer">
                        <span className="app-footer-text">EAT FOOD - GROW LONGER - DON'T DIE</span>
                    </div>
                </div>
            );
        };

        // --- LABYRINTH.EXE - Procedural Maze ---
        const LabyrinthApp = ({ onAchievement, onDogEvent }) => {
            const canvasRef = useRef(null);
            const [level, setLevel] = useState(1);
            const levelRef = useRef(1); // Ref to avoid stale closure in move function
            const [score, setScore] = useState(0);
            const [highScore, setHighScore] = useState(() => HighScoreManager.getHighScore('labyrinth'));
            const [won, setWon] = useState(false);
            const [showingMaze, setShowingMaze] = useState(false);
            const [levelWord, setLevelWord] = useState(null);
            const [showOpenFlash, setShowOpenFlash] = useState(true);
            const mazeRef = useRef(null);
            const playerRef = useRef({ x: 1, y: 1 });
            const exitRef = useRef({ x: 0, y: 0 });
            const labyrinthWordTriggered = useRef(false);
            const sudoStarsTriggered = useRef(false);

            // Level completion words - spell "SUDO STARS" to unlock star shooter
            const LEVEL_WORDS = ['SUDO', 'STARS'];
            const CELL_SIZE = 8; // Thinner walls

            // Initialize labyrinth on mount
            useEffect(() => {
                // No initial flash - levels spell out SUDO STARS
                setShowOpenFlash(false);
            }, []);

            // Load high score from storage when IP is ready
            useEffect(() => {
                const loadHighScore = async () => {
                    await HighScoreManager.fetchIP();
                    setHighScore(HighScoreManager.getHighScore('labyrinth'));
                };
                loadHighScore();
            }, []);

            const generateMaze = (width, height) => {
                const maze = Array(height).fill(null).map(() => Array(width).fill(1));

                // Iterative maze generation to avoid stack overflow on large mazes
                const stack = [[1, 1]];
                maze[1][1] = 0;

                while (stack.length > 0) {
                    const [x, y] = stack[stack.length - 1];
                    const directions = [[0, -2], [0, 2], [-2, 0], [2, 0]].sort(() => Math.random() - 0.5);
                    let found = false;

                    for (const [dx, dy] of directions) {
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx > 0 && nx < width - 1 && ny > 0 && ny < height - 1 && maze[ny][nx] === 1) {
                            maze[y + dy / 2][x + dx / 2] = 0;
                            maze[ny][nx] = 0;
                            stack.push([nx, ny]);
                            found = true;
                            break;
                        }
                    }

                    if (!found) stack.pop();
                }
                return maze;
            };

            const startLevel = (lvl) => {
                // Start tiny and get exponentially harder with each level
                // Level 1: 9x9, Level 2: 11x11, Level 3: 15x15, Level 5: 27x27, Level 10: 99x99
                const size = 7 + Math.floor(Math.pow(1.5, lvl) * 2);
                const cappedSize = Math.min(size | 1, 151); // Ensure odd, cap at 151
                const maze = generateMaze(cappedSize | 1, cappedSize | 1);
                mazeRef.current = maze;
                playerRef.current = { x: 1, y: 1 };

                // Find exit (bottom-right area)
                for (let y = maze.length - 2; y > maze.length / 2; y--) {
                    for (let x = maze[0].length - 2; x > maze[0].length / 2; x--) {
                        if (maze[y][x] === 0) {
                            exitRef.current = { x, y };
                            break;
                        }
                    }
                    if (exitRef.current.x !== 0) break;
                }

                setWon(false);
                setShowingMaze(false);
                draw();
            };

            const draw = () => {
                const canvas = canvasRef.current;
                if (!canvas || !mazeRef.current) return;
                const ctx = canvas.getContext('2d');
                const maze = mazeRef.current;

                canvas.width = maze[0].length * CELL_SIZE;
                canvas.height = maze.length * CELL_SIZE;

                // Draw maze - clean minimal style
                for (let y = 0; y < maze.length; y++) {
                    for (let x = 0; x < maze[0].length; x++) {
                        ctx.fillStyle = maze[y][x] === 1 ? '#111' : '#fafafa';
                        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }

                // Draw exit - simple square
                const ex = exitRef.current.x * CELL_SIZE;
                const ey = exitRef.current.y * CELL_SIZE;
                ctx.fillStyle = '#fafafa';
                ctx.fillRect(ex, ey, CELL_SIZE, CELL_SIZE);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(ex + 2, ey + 2, CELL_SIZE - 4, CELL_SIZE - 4);

                // Draw player - simple filled square
                const px = playerRef.current.x * CELL_SIZE;
                const py = playerRef.current.y * CELL_SIZE;
                ctx.fillStyle = '#000';
                ctx.fillRect(px + 2, py + 2, CELL_SIZE - 4, CELL_SIZE - 4);
            };

            const stepLeftRef = useRef(true);
            const move = (dx, dy) => {
                if (won || showingMaze) return;
                const maze = mazeRef.current;
                if (!maze) return;

                const nx = playerRef.current.x + dx;
                const ny = playerRef.current.y + dy;

                if (nx >= 0 && nx < maze[0].length && ny >= 0 && ny < maze.length && maze[ny][nx] === 0) {
                    sounds.labyrinthStep(stepLeftRef.current);
                    stepLeftRef.current = !stepLeftRef.current;
                    playerRef.current = { x: nx, y: ny };
                    draw();

                    if (nx === exitRef.current.x && ny === exitRef.current.y) {
                        const currentLevel = levelRef.current;
                        const points = currentLevel * 100;
                        setScore(s => {
                            const newScore = s + points;
                            setHighScore(h => {
                                const newHigh = Math.max(h, newScore);
                                HighScoreManager.saveHighScore('labyrinth', newHigh);
                                return newHigh;
                            });
                            return newScore;
                        });
                        // Show level word (0-indexed, so level 1 = index 0)
                        if (currentLevel <= LEVEL_WORDS.length) {
                            setLevelWord(LEVEL_WORDS[currentLevel - 1]);
                        } else {
                            setLevelWord('CLEAR');
                        }
                        setWon(true);
                        sounds.labyrinthExit();

                        // FIRST_BLOOD - win any game
                        onAchievement?.('FIRST_BLOOD');
                        // Check for DAEDALUS achievement
                        if (currentLevel >= 10) onAchievement?.('DAEDALUS');

                        // Trigger dog dialogue for labyrinth words
                        if (currentLevel <= LEVEL_WORDS.length && !labyrinthWordTriggered.current) {
                            labyrinthWordTriggered.current = true;
                            setTimeout(() => onDogEvent?.('labyrinthWord'), 500);
                        }
                        // After level 2, both SUDO and STARS have been shown - trigger sudoStars
                        if (currentLevel === 2 && !sudoStarsTriggered.current) {
                            sudoStarsTriggered.current = true;
                            setTimeout(() => onDogEvent?.('sudoStars'), 2500);
                        }

                        // Show full maze then start next level
                        setTimeout(() => {
                            setShowingMaze(true);
                            setTimeout(() => {
                                const nextLevel = levelRef.current + 1;
                                levelRef.current = nextLevel;
                                setLevel(nextLevel);
                                startLevel(nextLevel);
                            }, 2000);
                        }, 1000);
                    }
                } else {
                    // Wall bump
                    sounds.labyrinthBump();
                }
            };

            const giveUp = () => {
                levelRef.current = 1;
                setLevel(1);
                setScore(0);
                startLevel(1);
            };

            useEffect(() => {
                const handle = (e) => {
                    if (e.key === 'ArrowUp') move(0, -1);
                    if (e.key === 'ArrowDown') move(0, 1);
                    if (e.key === 'ArrowLeft') move(-1, 0);
                    if (e.key === 'ArrowRight') move(1, 0);
                };
                window.addEventListener('keydown', handle);
                startLevel(1);
                return () => window.removeEventListener('keydown', handle);
            }, []);

            // Touch/swipe controls for mobile
            const touchStartRef = useRef({ x: 0, y: 0 });
            const handleTouchStart = (e) => {
                touchStartRef.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            };
            const handleTouchEnd = (e) => {
                const dx = e.changedTouches[0].clientX - touchStartRef.current.x;
                const dy = e.changedTouches[0].clientY - touchStartRef.current.y;
                const threshold = 20;
                if (Math.abs(dx) > Math.abs(dy)) {
                    if (dx > threshold) move(1, 0);
                    else if (dx < -threshold) move(-1, 0);
                } else {
                    if (dy > threshold) move(0, 1);
                    else if (dy < -threshold) move(0, -1);
                }
            };

            return (
                <div className="h-full flex flex-col bg-white select-none" onTouchStart={handleTouchStart} onTouchEnd={handleTouchEnd}>
                    <div className="h-8 px-3 flex justify-between items-center">
                        <span className="font-mono text-[10px] font-bold tracking-widest text-black">LABYRINTH</span>
                        <div className="flex gap-6 font-mono text-[10px]">
                            <span className="text-gray-400">LVL <span className="text-black font-bold">{level}</span></span>
                            <span className="text-gray-400">PTS <span className="text-black font-bold">{score}</span></span>
                        </div>
                    </div>
                    <div className="flex-grow flex items-center justify-center relative bg-white">
                        {showOpenFlash && (
                            <div className="absolute inset-0 bg-black flex items-center justify-center z-20">
                                <div className="text-4xl font-black tracking-widest text-white animate-pulse">THE</div>
                            </div>
                        )}
                        {won && !showingMaze && (
                            <div className="absolute inset-0 bg-white/95 flex items-center justify-center z-10">
                                <div className="text-center">
                                    <div className="text-2xl font-black tracking-widest">{levelWord || 'CLEAR'}</div>
                                    <div className="font-mono text-[10px] text-gray-400 mt-1">+{level * 100}</div>
                                </div>
                            </div>
                        )}
                        {showingMaze && (
                            <div className="absolute inset-0 bg-white flex items-center justify-center z-10">
                                <div className="font-mono text-[10px] text-gray-400 tracking-widest animate-pulse">
                                    GENERATING LEVEL {level}
                                </div>
                            </div>
                        )}
                        <canvas ref={canvasRef} className="block" style={{ imageRendering: 'pixelated' }} role="img" aria-label="Labyrinth maze game" />
                    </div>
                    <div className="h-8 px-3 flex justify-between items-center">
                        <span className="font-mono text-[10px] text-gray-300 hidden md:inline"></span>
                        <span className="font-mono text-[10px] text-gray-300 md:hidden">SWIPE TO MOVE</span>
                        <button
                            onClick={giveUp}
                            className="font-mono text-[10px] text-gray-300 hover:text-black transition-colors"
                        >
                            RESTART
                        </button>
                    </div>
                </div>
            );
        };

        // --- MINESWEEPER.EXE - Ultra Clean Minesweeper ---
        const MinesweeperApp = ({ onAchievement }) => {
            const [grid, setGrid] = useState([]);
            const [revealed, setRevealed] = useState([]);
            const [flagged, setFlagged] = useState([]);
            const [gameOver, setGameOver] = useState(false);
            const [won, setWon] = useState(false);
            const [mineCount, setMineCount] = useState(0);
            const [time, setTime] = useState(0);
            const [started, setStarted] = useState(false);
            const timerRef = useRef(null);
            const usedFlags = useRef(false);

            const ROWS = 9;
            const COLS = 9;
            const MINES = 10;

            // Hidden background message at 20% opacity - 81 chars for 9x9 grid
            // Spells: "TO MOVE FORWARD YOU MUST SOMETIMES MOVE BACKWARD FIND OUT THE TRUTH REVEAL THE STARS SUDO SHOOTER"
            const HIDDEN_MESSAGE = 'TOMOVEFORWARDYOUMUSTSOMETIMESMOVEBACKWARDFINDOUTTHETRUTHREVEALTHESTARSSUDOSHOOTER';
            const getBackgroundLetter = (r, c) => {
                const idx = r * COLS + c;
                return HIDDEN_MESSAGE[idx] || '';
            };

            const initGame = () => {
                // Create empty grid
                const newGrid = Array(ROWS).fill(null).map(() => Array(COLS).fill(0));
                const newRevealed = Array(ROWS).fill(null).map(() => Array(COLS).fill(false));
                const newFlagged = Array(ROWS).fill(null).map(() => Array(COLS).fill(false));

                // Place mines
                let placed = 0;
                while (placed < MINES) {
                    const r = Math.floor(Math.random() * ROWS);
                    const c = Math.floor(Math.random() * COLS);
                    if (newGrid[r][c] !== -1) {
                        newGrid[r][c] = -1;
                        placed++;
                    }
                }

                // Calculate numbers
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (newGrid[r][c] === -1) continue;
                        let count = 0;
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                const nr = r + dr, nc = c + dc;
                                if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && newGrid[nr][nc] === -1) {
                                    count++;
                                }
                            }
                        }
                        newGrid[r][c] = count;
                    }
                }

                setGrid(newGrid);
                setRevealed(newRevealed);
                setFlagged(newFlagged);
                setGameOver(false);
                setWon(false);
                setMineCount(MINES);
                setTime(0);
                setStarted(false);
                usedFlags.current = false;
                if (timerRef.current) clearInterval(timerRef.current);
            };

            useEffect(() => {
                initGame();
                return () => { if (timerRef.current) clearInterval(timerRef.current); };
            }, []);

            useEffect(() => {
                if (started && !gameOver && !won) {
                    timerRef.current = setInterval(() => setTime(t => t + 1), 1000);
                }
                return () => { if (timerRef.current) clearInterval(timerRef.current); };
            }, [started, gameOver, won]);

            const reveal = (r, c) => {
                if (gameOver || won || revealed[r][c] || flagged[r][c]) return;

                if (!started) setStarted(true);

                const newRevealed = revealed.map(row => [...row]);

                if (grid[r][c] === -1) {
                    // Hit mine - reveal all mines
                    sounds.explosion();
                    for (let i = 0; i < ROWS; i++) {
                        for (let j = 0; j < COLS; j++) {
                            if (grid[i][j] === -1) newRevealed[i][j] = true;
                        }
                    }
                    setRevealed(newRevealed);
                    setGameOver(true);
                    return;
                }

                // Safe cell - play ding
                sounds.mineDing();

                // Flood fill for empty cells
                const flood = (row, col) => {
                    if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return;
                    if (newRevealed[row][col] || flagged[row][col]) return;
                    newRevealed[row][col] = true;
                    if (grid[row][col] === 0) {
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                flood(row + dr, col + dc);
                            }
                        }
                    }
                };

                flood(r, c);
                setRevealed(newRevealed);

                // Check win
                let unrevealed = 0;
                for (let i = 0; i < ROWS; i++) {
                    for (let j = 0; j < COLS; j++) {
                        if (!newRevealed[i][j]) unrevealed++;
                    }
                }
                if (unrevealed === MINES) {
                    setWon(true);
                    onAchievement?.('FIRST_BLOOD');
                    if (!usedFlags.current) onAchievement?.('UNTOUCHABLE');
                }
            };

            const flag = (e, r, c) => {
                e.preventDefault();
                if (gameOver || won || revealed[r][c]) return;
                if (!started) setStarted(true);
                usedFlags.current = true;

                const newFlagged = flagged.map(row => [...row]);
                newFlagged[r][c] = !newFlagged[r][c];
                setFlagged(newFlagged);
                setMineCount(m => newFlagged[r][c] ? m - 1 : m + 1);
            };

            const getCellContent = (r, c) => {
                if (flagged[r][c]) return '';
                if (!revealed[r][c]) return '';
                if (grid[r][c] === -1) return '';
                if (grid[r][c] === 0) return '';
                return grid[r][c];
            };

            const getCellStyle = (r, c) => {
                if (flagged[r][c]) return 'bg-gray-100 text-black';
                if (!revealed[r][c]) return 'bg-gray-200 hover:bg-gray-300';
                if (grid[r][c] === -1) return 'bg-black text-white';
                return 'bg-white text-black';
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="h-10 px-4 flex justify-between items-center border-b border-gray-100">
                        <span className="font-mono text-[10px] font-bold tracking-widest text-black">MINESWEEPER</span>
                        <div className="flex gap-8 font-mono text-[10px]">
                            <span className="text-gray-400">MINES <span className="text-black font-bold">{mineCount.toString().padStart(3, '0')}</span></span>
                            <span className="text-gray-400">TIME <span className="text-black font-bold">{time.toString().padStart(3, '0')}</span></span>
                        </div>
                    </div>

                    <div className="flex-grow flex items-center justify-center relative bg-gray-50 p-4">
                        {(gameOver || won) && (
                            <div className="absolute inset-0 bg-white/95 flex items-center justify-center z-10">
                                <div className="text-center">
                                    <div className="text-2xl font-black tracking-widest">{won ? 'CLEARED' : 'DETONATED'}</div>
                                    <div className="font-mono text-[10px] text-gray-400 mt-2">{time}s</div>
                                    <button
                                        onClick={initGame}
                                        className="mt-4 px-4 py-2 bg-black text-white font-mono text-[10px] tracking-widest hover:bg-gray-800"
                                    >
                                        RETRY
                                    </button>
                                </div>
                            </div>
                        )}

                        <div className="border border-gray-200">
                            {grid.map((row, r) => (
                                <div key={r} className="flex">
                                    {row.map((cell, c) => (
                                        <button
                                            key={c}
                                            onClick={() => reveal(r, c)}
                                            onContextMenu={(e) => flag(e, r, c)}
                                            className={`w-6 h-6 border border-gray-100 font-mono text-[10px] font-bold flex items-center justify-center transition-colors relative ${getCellStyle(r, c)}`}
                                        >
                                            {revealed[r][c] && grid[r][c] === 0 && (
                                                <span className="absolute inset-0 flex items-center justify-center text-black text-xs font-bold pointer-events-none" style={{ opacity: 0.1 }}>
                                                    {getBackgroundLetter(r, c)}
                                                </span>
                                            )}
                                            {getCellContent(r, c)}
                                        </button>
                                    ))}
                                </div>
                            ))}
                        </div>
                    </div>

                    <div className="h-8 px-4 flex justify-between items-center border-t border-gray-100">
                        <span className="font-mono text-[10px] text-gray-300">LEFT CLICK REVEAL  RIGHT CLICK FLAG</span>
                        <button
                            onClick={initGame}
                            className="font-mono text-[10px] text-gray-300 hover:text-black transition-colors"
                        >
                            NEW GAME
                        </button>
                    </div>
                </div>
            );
        };

        // --- STARSHIP.EXE - Low Poly Star Fox Style Game ---
        const StarshipApp = ({ onAchievement, onUnlockApp, onDogEvent }) => {
            const containerRef = useRef(null);
            const gameRef = useRef(null);
            const keysRef = useRef({ left: false, right: false, up: false, down: false, shoot: false });
            const touchRef = useRef({ startX: 0, startY: 0, startTime: 0, isDragging: false });
            const [score, setScore] = useState(0);
            const [highScore, setHighScore] = useState(() => HighScoreManager.getHighScore('starship'));
            const [gameOver, setGameOver] = useState(false);
            const [started, setStarted] = useState(false);
            const achievementTriggered = useRef(false);
            const booksUnlockTriggered = useRef(false);
            const starshipOpenTriggered = useRef(false);
            const starshipLostTriggered = useRef(false);
            const onAchievementRef = useRef(onAchievement);
            const onUnlockAppRef = useRef(onUnlockApp);
            const onDogEventRef = useRef(onDogEvent);
            onAchievementRef.current = onAchievement;
            onUnlockAppRef.current = onUnlockApp;
            onDogEventRef.current = onDogEvent;

            // Load high score from storage when IP is ready
            useEffect(() => {
                const loadHighScore = async () => {
                    await HighScoreManager.fetchIP();
                    setHighScore(HighScoreManager.getHighScore('starship'));
                };
                loadHighScore();
            }, []);

            // Mobile control handlers
            const handleStart = () => {
                if (gameRef.current) {
                    if (gameOver) gameRef.current.restart();
                    else gameRef.current.start();
                }
            };

            // Touch-based drag controls
            const handleTouchStart = (e) => {
                const touch = e.touches[0];
                touchRef.current = {
                    startX: touch.clientX,
                    startY: touch.clientY,
                    startTime: Date.now(),
                    isDragging: false
                };
            };

            const handleTouchMove = (e) => {
                if (!started || gameOver) return;
                e.preventDefault();
                const touch = e.touches[0];
                const dx = touch.clientX - touchRef.current.startX;
                const dy = touch.clientY - touchRef.current.startY;
                touchRef.current.isDragging = true;

                // Set movement based on drag position (relative to start)
                const threshold = 20;
                keysRef.current.left = dx < -threshold;
                keysRef.current.right = dx > threshold;
                keysRef.current.up = dy < -threshold;
                keysRef.current.down = dy > threshold;
            };

            const handleTouchEnd = (e) => {
                // Reset all movement
                keysRef.current.left = false;
                keysRef.current.right = false;
                keysRef.current.up = false;
                keysRef.current.down = false;

                // Tap to shoot (short touch without much movement)
                const elapsed = Date.now() - touchRef.current.startTime;
                if (elapsed < 200 && !touchRef.current.isDragging) {
                    if (!started && !gameOver) {
                        handleStart();
                    } else if (gameRef.current && started && !gameOver) {
                        gameRef.current.shoot();
                    }
                }
            };

            useEffect(() => {
                if (!containerRef.current || gameRef.current) return;

                const width = 500;
                const height = 350;

                // Scene
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xffffff);
                scene.fog = new THREE.Fog(0xffffff, 20, 80);

                // Camera
                const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
                camera.position.set(0, 2, 0);
                camera.lookAt(0, 0, -20);

                // Renderer
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                containerRef.current.appendChild(renderer.domElement);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
                scene.add(ambientLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(5, 10, 5);
                scene.add(dirLight);

                // Create low-poly ship
                const createShip = () => {
                    const group = new THREE.Group();

                    // Main body - elongated pyramid
                    const bodyGeo = new THREE.ConeGeometry(0.3, 1.2, 4);
                    bodyGeo.rotateX(Math.PI / 2);
                    const bodyMat = new THREE.MeshStandardMaterial({ color: 0x000000, flatShading: true });
                    const body = new THREE.Mesh(bodyGeo, bodyMat);
                    group.add(body);

                    // Wings
                    const wingGeo = new THREE.BoxGeometry(1.8, 0.05, 0.4);
                    const wingMat = new THREE.MeshStandardMaterial({ color: 0x111111, flatShading: true });
                    const wings = new THREE.Mesh(wingGeo, wingMat);
                    wings.position.z = 0.2;
                    group.add(wings);

                    // Tail fins
                    const tailGeo = new THREE.BoxGeometry(0.05, 0.4, 0.3);
                    const tail1 = new THREE.Mesh(tailGeo, wingMat);
                    tail1.position.set(0, 0.15, 0.4);
                    group.add(tail1);

                    // Edges
                    const edges = new THREE.EdgesGeometry(bodyGeo);
                    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x444444 }));
                    group.add(line);

                    return group;
                };

                const ship = createShip();
                ship.position.set(0, 0, -5);
                scene.add(ship);

                // Ground grid
                const gridSize = 100;
                const gridGeo = new THREE.PlaneGeometry(gridSize, gridSize, 20, 20);
                gridGeo.rotateX(-Math.PI / 2);
                const gridMat = new THREE.MeshBasicMaterial({ color: 0xeeeeee, wireframe: true });
                const grid = new THREE.Mesh(gridGeo, gridMat);
                grid.position.y = -3;
                scene.add(grid);

                // Obstacles array
                const obstacles = [];
                const lasers = [];

                const createObstacle = () => {
                    const types = ['asteroid', 'enemy'];
                    const type = types[Math.floor(Math.random() * types.length)];
                    let mesh;

                    if (type === 'asteroid') {
                        const geo = new THREE.IcosahedronGeometry(0.5 + Math.random() * 0.5, 0);
                        const mat = new THREE.MeshStandardMaterial({ color: 0x222222, flatShading: true });
                        mesh = new THREE.Mesh(geo, mat);
                        const edges = new THREE.EdgesGeometry(geo);
                        mesh.add(new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 })));
                    } else {
                        const geo = new THREE.OctahedronGeometry(0.4, 0);
                        const mat = new THREE.MeshStandardMaterial({ color: 0x000000, flatShading: true });
                        mesh = new THREE.Mesh(geo, mat);
                        const edges = new THREE.EdgesGeometry(geo);
                        mesh.add(new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x666666 })));
                    }

                    mesh.position.set(
                        (Math.random() - 0.5) * 8,
                        (Math.random() - 0.5) * 4,
                        -60 - Math.random() * 20
                    );
                    mesh.userData = { type, speed: 0.3 + Math.random() * 0.2 };
                    scene.add(mesh);
                    obstacles.push(mesh);
                };

                const createLaser = () => {
                    const geo = new THREE.BoxGeometry(0.05, 0.05, 0.8);
                    const mat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                    const laser = new THREE.Mesh(geo, mat);
                    laser.position.copy(ship.position);
                    laser.position.z -= 0.8;
                    scene.add(laser);
                    lasers.push(laser);
                };

                // Controls - using ref so mobile can update too
                const keys = keysRef.current;
                let canShoot = true;
                let scoreVal = 0;
                let isGameOver = false;
                let isStarted = false;

                const doShoot = () => {
                    if (canShoot && isStarted && !isGameOver) {
                        sounds.laser();
                        createLaser();
                        canShoot = false;
                        setTimeout(() => canShoot = true, 150);
                    }
                };

                const onKeyDown = (e) => {
                    if (!isStarted && e.code === 'Space') {
                        isStarted = true;
                        setStarted(true);
                        // Trigger starshipOpen on first start
                        if (!starshipOpenTriggered.current) {
                            starshipOpenTriggered.current = true;
                            onDogEventRef.current?.('starshipOpen');
                        }
                        return;
                    }
                    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
                    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
                    if (e.code === 'ArrowUp' || e.code === 'KeyW') keys.up = true;
                    if (e.code === 'ArrowDown' || e.code === 'KeyS') keys.down = true;
                    if (e.code === 'Space') doShoot();
                };
                const onKeyUp = (e) => {
                    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
                    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
                    if (e.code === 'ArrowUp' || e.code === 'KeyW') keys.up = false;
                    if (e.code === 'ArrowDown' || e.code === 'KeyS') keys.down = false;
                };

                window.addEventListener('keydown', onKeyDown);
                window.addEventListener('keyup', onKeyUp);

                // Spawn obstacles
                let spawnTimer = 0;

                // Animation loop
                let animationId;
                const animate = () => {
                    animationId = requestAnimationFrame(animate);

                    if (!isStarted || isGameOver) {
                        ship.rotation.z = Math.sin(Date.now() * 0.002) * 0.1;
                        renderer.render(scene, camera);
                        return;
                    }

                    // Move ship
                    const moveSpeed = 0.12;
                    if (keys.left) ship.position.x -= moveSpeed;
                    if (keys.right) ship.position.x += moveSpeed;
                    if (keys.up) ship.position.y += moveSpeed;
                    if (keys.down) ship.position.y -= moveSpeed;

                    // Clamp ship position
                    ship.position.x = Math.max(-4, Math.min(4, ship.position.x));
                    ship.position.y = Math.max(-2, Math.min(2, ship.position.y));

                    // Tilt ship based on movement
                    ship.rotation.z = -keys.left * 0.3 + keys.right * 0.3;
                    ship.rotation.x = keys.down * 0.2 - keys.up * 0.2;

                    // Move grid for speed effect
                    grid.position.z = (grid.position.z + 0.5) % 5;

                    // Spawn obstacles
                    spawnTimer++;
                    if (spawnTimer > 30) {
                        createObstacle();
                        spawnTimer = 0;
                    }

                    // Update obstacles
                    for (let i = obstacles.length - 1; i >= 0; i--) {
                        const obs = obstacles[i];
                        obs.position.z += obs.userData.speed;
                        obs.rotation.x += 0.02;
                        obs.rotation.y += 0.01;

                        // Remove if passed
                        if (obs.position.z > 5) {
                            scene.remove(obs);
                            obstacles.splice(i, 1);
                            scoreVal += 10;
                            setScore(scoreVal);
                            if (scoreVal >= 10000 && !achievementTriggered.current) {
                                achievementTriggered.current = true;
                                onAchievementRef.current?.('ACE');
                            }
                            // Unlock BOOKS and DICE at 1000 points
                            if (scoreVal >= 1000 && !booksUnlockTriggered.current) {
                                booksUnlockTriggered.current = true;
                                onUnlockAppRef.current?.('BOOKS');
                                onUnlockAppRef.current?.('DICE');
                                onDogEventRef.current?.('booksUnlocked');
                            }
                        }

                        // Collision with ship
                        const dist = ship.position.distanceTo(obs.position);
                        if (dist < 1) {
                            isGameOver = true;
                            setGameOver(true);
                            sounds.starshipDamage();
                            sounds.explosion();
                            // Trigger starshipLost on first loss
                            if (!starshipLostTriggered.current) {
                                starshipLostTriggered.current = true;
                                onDogEventRef.current?.('starshipLost');
                            }
                            // Save high score on game over
                            setHighScore(h => {
                                const newHigh = Math.max(h, scoreVal);
                                HighScoreManager.saveHighScore('starship', newHigh);
                                return newHigh;
                            });
                        }
                    }

                    // Update lasers
                    for (let i = lasers.length - 1; i >= 0; i--) {
                        const laser = lasers[i];
                        laser.position.z -= 1.5;

                        // Remove if too far
                        if (laser.position.z < -80) {
                            scene.remove(laser);
                            lasers.splice(i, 1);
                            continue;
                        }

                        // Check collision with obstacles
                        for (let j = obstacles.length - 1; j >= 0; j--) {
                            const obs = obstacles[j];
                            if (laser.position.distanceTo(obs.position) < 0.8) {
                                scene.remove(laser);
                                scene.remove(obs);
                                lasers.splice(i, 1);
                                obstacles.splice(j, 1);
                                sounds.explosion();
                                scoreVal += 50;
                                setScore(scoreVal);
                                if (scoreVal >= 10000 && !achievementTriggered.current) {
                                    achievementTriggered.current = true;
                                    onAchievementRef.current?.('ACE');
                                }
                                break;
                            }
                        }
                    }

                    renderer.render(scene, camera);
                };
                animate();

                gameRef.current = {
                    restart: () => {
                        obstacles.forEach(o => scene.remove(o));
                        lasers.forEach(l => scene.remove(l));
                        obstacles.length = 0;
                        lasers.length = 0;
                        ship.position.set(0, 0, -5);
                        scoreVal = 0;
                        isGameOver = false;
                        isStarted = true;
                        setScore(0);
                        setGameOver(false);
                        setStarted(true);
                    },
                    start: () => {
                        if (!isStarted) {
                            isStarted = true;
                            setStarted(true);
                        }
                    },
                    shoot: doShoot
                };

                return () => {
                    cancelAnimationFrame(animationId);
                    window.removeEventListener('keydown', onKeyDown);
                    window.removeEventListener('keyup', onKeyUp);
                    renderer.dispose();
                    if (containerRef.current && renderer.domElement) {
                        containerRef.current.removeChild(renderer.domElement);
                    }
                };
            }, []);

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="h-10 px-4 flex justify-between items-center border-b border-gray-100">
                        <span className="font-mono text-[10px] font-bold tracking-widest text-black">STARSHIP</span>
                        <div className="flex gap-4">
                            <span className="font-mono text-[10px] text-gray-400">HI <span className="text-gray-600 font-bold">{highScore.toString().padStart(6, '0')}</span></span>
                            <span className="font-mono text-[10px] text-gray-400">SCORE <span className="text-black font-bold">{score.toString().padStart(6, '0')}</span></span>
                        </div>
                    </div>

                    <div className="flex-grow flex items-center justify-center relative bg-gray-50 overflow-hidden">
                        {!started && !gameOver && (
                            <div className="absolute inset-0 bg-white/90 flex items-center justify-center z-10">
                                <div className="text-center">
                                    <div className="text-2xl font-black tracking-widest mb-2">STARSHIP</div>
                                    <div className="font-mono text-[10px] text-gray-400 mb-4">LOW POLY COMBAT</div>
                                    <button onClick={handleStart} className="btn-primary btn-xs tracking-widest">
                                        TAP TO START
                                    </button>
                                </div>
                            </div>
                        )}
                        {gameOver && (
                            <div className="absolute inset-0 bg-white/95 flex items-center justify-center z-10">
                                <div className="text-center">
                                    <div className="text-2xl font-black tracking-widest">DESTROYED</div>
                                    <div className="font-mono text-[10px] text-gray-400 mt-2 mb-4">SCORE: {score}</div>

                                    {/* High Score Table */}
                                    <div className="border-2 border-black p-3 bg-white">
                                        <div className="font-mono text-[10px] font-bold tracking-widest mb-2 border-b border-black pb-1">HIGH SCORES</div>
                                        <div className="space-y-1 font-mono text-[10px]">
                                            <div className="flex justify-between gap-8">
                                                <span className="text-black">MATEUS</span>
                                                <span className="font-bold">1000</span>
                                            </div>
                                            <div className="flex justify-between gap-8">
                                                <span className="text-black">YOU</span>
                                                <span className="font-bold">{highScore}</span>
                                            </div>
                                        </div>
                                    </div>

                                    <button
                                        onClick={() => gameRef.current?.restart()}
                                        className="mt-4 px-4 py-2 bg-black text-white font-mono text-[10px] tracking-widest hover:bg-gray-800"
                                    >
                                        RETRY
                                    </button>
                                </div>
                            </div>
                        )}
                        <div
                            ref={containerRef}
                            className="w-full h-full flex items-center justify-center touch-none"
                            onTouchStart={handleTouchStart}
                            onTouchMove={handleTouchMove}
                            onTouchEnd={handleTouchEnd}
                        />
                    </div>

                    <div className="h-8 px-4 flex justify-between items-center border-t border-gray-100">
                        <span className="font-mono text-[10px] text-gray-300 hidden md:inline">WASD/ARROWS MOVE  SPACE SHOOT</span>
                        <span className="font-mono text-[10px] text-gray-300 md:hidden">DRAG TO MOVE  TAP TO SHOOT</span>
                        <button
                            onClick={() => gameRef.current?.restart()}
                            className="font-mono text-[10px] text-gray-300 hover:text-black transition-colors"
                        >
                            RESTART
                        </button>
                    </div>
                </div>
            );
        };

        // --- SYNTH_001.WAV - Brutalist Synthesizer ---
        const SynthApp = ({ onAchievement }) => {
            const [tempo, setTempo] = useState(120);
            const [filter, setFilter] = useState(1000);
            const [isPlaying, setIsPlaying] = useState(false);
            const [currentStep, setCurrentStep] = useState(0);
            const [grid, setGrid] = useState(() => {
                return {
                    sine: Array(16).fill(false),
                    square: Array(16).fill(false),
                    saw: Array(16).fill(false),
                    noise: Array(16).fill(false)
                };
            });
            const symphonyTriggered = useRef(false);
            const audioCtxRef = useRef(null);
            const intervalRef = useRef(null);
            // Refs to avoid stale closures in interval
            const gridRef = useRef(grid);
            const filterRef = useRef(filter);
            gridRef.current = grid;
            filterRef.current = filter;

            const oscillators = ['sine', 'square', 'saw', 'noise'];

            const toggleNote = (osc, step) => {
                sounds.noteToggle();
                setGrid(prev => ({
                    ...prev,
                    [osc]: prev[osc].map((v, i) => i === step ? !v : v)
                }));
            };

            const playSound = (type, filterFreq) => {
                if (!audioCtxRef.current) {
                    audioCtxRef.current = new (window.AudioContext || window.webkitAudioContext)();
                }
                const ctx = audioCtxRef.current;

                let osc;
                const gain = ctx.createGain();
                const filt = ctx.createBiquadFilter();
                filt.type = 'lowpass';
                filt.frequency.value = filterFreq;

                if (type === 'noise') {
                    const bufferSize = ctx.sampleRate * 0.1;
                    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        data[i] = Math.random() * 2 - 1;
                    }
                    osc = ctx.createBufferSource();
                    osc.buffer = buffer;
                } else {
                    osc = ctx.createOscillator();
                    osc.type = type === 'saw' ? 'sawtooth' : type;
                    osc.frequency.value = 220 + Math.random() * 110;
                }

                gain.gain.setValueAtTime(0.3, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);

                osc.connect(filt);
                filt.connect(gain);
                gain.connect(ctx.destination);
                osc.start(ctx.currentTime);
                osc.stop(ctx.currentTime + 0.1);
            };

            const togglePlay = () => {
                if (isPlaying) {
                    clearInterval(intervalRef.current);
                    setIsPlaying(false);
                    setCurrentStep(0);
                } else {
                    setIsPlaying(true);
                    // Check if entire grid is filled for SYMPHONY achievement
                    const allFilled = oscillators.every(osc => grid[osc].every(note => note));
                    if (allFilled && !symphonyTriggered.current) {
                        symphonyTriggered.current = true;
                        onAchievement?.('SYMPHONY');
                    }
                    // Interval is started by the useEffect when isPlaying changes
                }
            };

            useEffect(() => {
                return () => clearInterval(intervalRef.current);
            }, []);

            useEffect(() => {
                if (isPlaying) {
                    let step = currentStep;
                    intervalRef.current = setInterval(() => {
                        setCurrentStep(step);
                        oscillators.forEach(osc => {
                            // Use refs for fresh values
                            if (gridRef.current[osc][step]) {
                                playSound(osc, filterRef.current);
                            }
                        });
                        step = (step + 1) % 16;
                    }, (60 / tempo) * 250);
                }
                // Cleanup when isPlaying changes or component unmounts
                return () => clearInterval(intervalRef.current);
            }, [tempo, isPlaying]);

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="app-header">
                        <div className="flex items-center gap-2">
                            <Icons.Synth size={16} />
                            <span className="app-header-title">SYNTH_001.WAV</span>
                        </div>
                        <button
                            onClick={() => { sounds.click(); togglePlay(); }}
                            className={isPlaying ? 'btn-primary btn-xs' : 'btn-secondary btn-xs'}
                        >
                            {isPlaying ? ' STOP' : ' PLAY'}
                        </button>
                    </div>
                    <div className="flex-grow p-4 overflow-auto bg-gray-50">
                        <div className="space-y-2">
                            {oscillators.map(osc => (
                                <div key={osc} className="flex items-center gap-2">
                                    <span className="font-mono text-[10px] w-12 text-gray-500 uppercase">{osc}</span>
                                    <div className="flex gap-1">
                                        {grid[osc].map((active, i) => (
                                            <button
                                                key={i}
                                                onClick={() => toggleNote(osc, i)}
                                                className={`w-6 h-8 border-2 transition-all ${active
                                                    ? 'bg-black border-black'
                                                    : 'bg-white border-gray-300 hover:border-black'
                                                    } ${currentStep === i && isPlaying ? 'ring-2 ring-black ring-offset-1' : ''}`}
                                            />
                                        ))}
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                    <div className="p-4 border-t-2 border-black bg-white flex gap-8">
                        <div className="flex items-center gap-2">
                            <span className="app-footer-text">TEMPO</span>
                            <input
                                type="range"
                                aria-label="Tempo control"
                                min="60"
                                max="200"
                                value={tempo}
                                onChange={(e) => setTempo(Number(e.target.value))}
                                className="w-24 accent-black"
                            />
                            <span className="font-mono text-xs w-8 text-black">{tempo}</span>
                        </div>
                        <div className="flex items-center gap-2">
                            <span className="app-footer-text">FILTER</span>
                            <input
                                type="range"
                                aria-label="Filter frequency control"
                                min="100"
                                max="5000"
                                value={filter}
                                onChange={(e) => setFilter(Number(e.target.value))}
                                className="w-24 accent-black"
                            />
                            <span className="font-mono text-xs w-12 text-black">{filter}Hz</span>
                        </div>
                    </div>
                </div>
            );
        };

        // --- DESTRUCTION.EXE - Screen destroyer with confirmations ---
        const DestructionApp = ({ onDogSteal, onAchievement }) => {
            const [confirmStep, setConfirmStep] = useState(0);
            const [buttonPos, setButtonPos] = useState({ x: 0, y: 0 });
            const [dogStealing, setDogStealing] = useState(false);
            const [dogPos, setDogPos] = useState({ x: -100, y: 200 });
            const [buttonGone, setButtonGone] = useState(false);
            const dogRunRef = useRef(null);
            const dogEscapeRef = useRef(null);

            // Cleanup intervals on unmount
            useEffect(() => {
                return () => {
                    if (dogRunRef.current) clearInterval(dogRunRef.current);
                    if (dogEscapeRef.current) clearInterval(dogEscapeRef.current);
                };
            }, []);

            const confirmMessages = [
                { prompt: "EXECUTE", response: "You want to do it?" },
                { prompt: "YES", response: "Are you sure?" },
                { prompt: "I'M SURE", response: "Really though?" },
                { prompt: "REALLY", response: "Really, really though?" },
                { prompt: "YES REALLY", response: "Like... REALLY really?" },
                { prompt: "DO IT", response: "You know this destroys EVERYTHING?" },
                { prompt: "I KNOW", response: "There's no going back..." },
                { prompt: "I DON'T CARE", response: "Final warning..." },
                { prompt: "JUST DO IT", response: "Okay... last chance to back out..." },
                { prompt: "DESTROY IT ALL", response: "..." }
            ];

            const handleClick = () => {
                if (confirmStep < 9) {
                    setConfirmStep(prev => prev + 1);
                } else {
                    // Final click - dog steals the button!
                    setDogStealing(true);

                    // Animate dog running in
                    let dogX = -100;
                    dogRunRef.current = setInterval(() => {
                        dogX += 15;
                        setDogPos({ x: dogX, y: 150 + Math.sin(dogX / 20) * 10 });

                        if (dogX >= 120) {
                            clearInterval(dogRunRef.current);
                            setButtonGone(true);

                            // Dog runs away with button
                            dogEscapeRef.current = setInterval(() => {
                                dogX += 20;
                                setDogPos({ x: dogX, y: 150 + Math.sin(dogX / 15) * 15 });

                                if (dogX > window.innerWidth + 100) {
                                    clearInterval(dogEscapeRef.current);
                                    onAchievement?.('DESTROYER_OF_WORLDS');
                                    if (onDogSteal) onDogSteal();
                                }
                            }, 30);
                        }
                    }, 30);
                }
            };

            return (
                <div className="h-full flex flex-col bg-white select-none relative overflow-hidden">
                    <div className="app-header">
                        <span className="app-header-title">DESTRUCTION.EXE</span>
                        <span className="app-footer-text">DANGER ZONE</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center bg-gray-50 relative z-10">
                        <div className="text-center">
                            <svg width="64" height="64" viewBox="0 0 64 64" className="mx-auto mb-4" style={{ imageRendering: 'pixelated' }}>
                                <rect x="16" y="4" width="32" height="8" fill="#000" />
                                <rect x="12" y="12" width="40" height="8" fill="#000" />
                                <rect x="8" y="20" width="48" height="16" fill="#000" />
                                <rect x="14" y="22" width="12" height="10" fill="#fff" />
                                <rect x="38" y="22" width="12" height="10" fill="#fff" />
                                <rect x="28" y="34" width="8" height="6" fill="#fff" />
                                <rect x="12" y="40" width="40" height="8" fill="#000" />
                                <rect x="16" y="42" width="4" height="6" fill="#fff" />
                                <rect x="24" y="42" width="4" height="6" fill="#fff" />
                                <rect x="36" y="42" width="4" height="6" fill="#fff" />
                                <rect x="44" y="42" width="4" height="6" fill="#fff" />
                                <rect x="16" y="48" width="32" height="8" fill="#000" />
                            </svg>
                            <div className="font-mono text-sm mb-2 text-black">DESTRUCTION.EXE</div>
                            <div className="font-mono text-xs text-gray-500 mb-6">
                                {confirmStep === 0 ? "WARNING: WILL DESTROY EVERYTHING" : confirmMessages[confirmStep - 1]?.response || "..."}
                            </div>
                            {!buttonGone && (
                                <button
                                    onClick={handleClick}
                                    className={`btn-primary btn-lg ${confirmStep > 5 ? 'animate-pulse' : ''}`}
                                    style={{
                                        transform: `translate(${buttonPos.x}px, ${buttonPos.y}px)`,
                                    }}
                                >
                                    {confirmMessages[confirmStep].prompt}
                                </button>
                            )}
                            {buttonGone && !dogStealing && (
                                <div className="font-mono text-sm text-gray-500">
                                    The button is gone...
                                </div>
                            )}
                        </div>
                    </div>

                    {/* Dog stealing animation - cute dog matching the main sprite */}
                    {dogStealing && (
                        <div
                            className="absolute z-20"
                            style={{ left: dogPos.x, top: dogPos.y }}
                        >
                            <DogSprite />
                            {buttonGone && (
                                <div className="absolute -top-4 left-10 px-2 py-1 bg-black text-white font-mono text-[8px] border-2 border-black">
                                    DESTROY
                                </div>
                            )}
                        </div>
                    )}

                    {dogStealing && buttonGone && (
                        <div className="absolute bottom-4 w-full text-center">
                            <div className="font-mono text-xs text-gray-600">
                                *dog runs away with the button*
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // --- TAROT.DAT - Tarot card pull ---
        // Pixel art tarot card component with card frame
        const PixelTarotCard = ({ pixels, width = 24, height = 32, scale = 3 }) => {
            const cardWidth = width + 4;
            const cardHeight = height + 6;

            return (
                <div className="relative" style={{ width: cardWidth * scale, height: cardHeight * scale }}>
                    {/* Card frame - thin border */}
                    <div
                        className="absolute inset-0 bg-white"
                        style={{
                            borderRadius: '2px',
                            border: '1px solid #666',
                            boxShadow: '1px 1px 0 rgba(0,0,0,0.15)'
                        }}
                    />
                    {/* Pixel art area */}
                    <div
                        className="absolute flex items-center justify-center"
                        style={{
                            top: scale,
                            left: scale,
                            right: scale,
                            bottom: scale * 2,
                        }}
                    >
                        <svg width={width * scale} height={height * scale} viewBox={`0 0 ${width} ${height}`} style={{ imageRendering: 'pixelated' }}>
                            <rect width={width} height={height} fill="#000" />
                            {pixels.map((row, y) =>
                                row.split('').map((pixel, x) =>
                                    pixel === '#' ? <rect key={`${x}-${y}`} x={x} y={y} width={1} height={1} fill="#fff" /> : null
                                )
                            )}
                        </svg>
                    </div>
                </div>
            );
        };

        const TarotApp = ({ onAchievement, onUnlockApp }) => {
            const [cards, setCards] = useState([]);
            const [revealed, setRevealed] = useState(false);
            const [alreadyPulled, setAlreadyPulled] = useState(false);
            const [fateAccepted, setFateAccepted] = useState(false);
            const [showFatePrompt, setShowFatePrompt] = useState(false);
            const [isShuffling, setIsShuffling] = useState(false);
            const [shuffleFrame, setShuffleFrame] = useState(0);
            const [uniqueDays, setUniqueDays] = useState(() => {
                const stored = localStorage.getItem('tarot_unique_days');
                return stored ? JSON.parse(stored) : [];
            });
            const shuffleIntervalRef = useRef(null);

            // Cleanup interval on unmount
            useEffect(() => {
                return () => {
                    if (shuffleIntervalRef.current) clearInterval(shuffleIntervalRef.current);
                };
            }, []);

            const tarotCards = [
                {
                    name: 'THE FOOL', num: '0', meaning: 'New beginnings, innocence, spontaneity', pixels: [
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '........#######.........',
                        '.........#####..........',
                        '..........###...........',
                        '...........#............',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '........#.....#.........',
                        '........................',
                        '....##..................',
                        '...####.................',
                        '...#..#.................',
                        '....##..................',
                        '........................',
                        '########################',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE MAGICIAN', num: 'I', meaning: 'Manifestation, resourcefulness, power', pixels: [
                        '........................',
                        '.........#...#..........',
                        '..........#.#...........',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...........#............',
                        '..........#.#...........',
                        '........................',
                        '..##..##..##..##........',
                        '..##..##..##..##........',
                        '........................',
                        '########################',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE HIGH PRIESTESS', num: 'II', meaning: 'Intuition, mystery, inner knowledge', pixels: [
                        '........................',
                        '....##..........##......',
                        '...#..#........#..#.....',
                        '....##..........##......',
                        '..........##............',
                        '.........####...........',
                        '..........##............',
                        '..........##............',
                        '.........####...........',
                        '........##..##..........',
                        '.........####...........',
                        '..........##............',
                        '..........##............',
                        '.........####...........',
                        '........######..........',
                        '........................',
                        '...##..........##.......',
                        '...##..........##.......',
                        '...##..........##.......',
                        '........................',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE EMPRESS', num: 'III', meaning: 'Abundance, nurturing, fertility', pixels: [
                        '........................',
                        '.........#####..........',
                        '........#######.........',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '.........#####..........',
                        '........#######.........',
                        '.......#########........',
                        '........#######.........',
                        '.........#####..........',
                        '..........###...........',
                        '..........#.#...........',
                        '.........#...#..........',
                        '........................',
                        '...#..#..#..#..#..#.....',
                        '...#..#..#..#..#..#.....',
                        '...#..#..#..#..#..#.....',
                        '........................',
                        '########################',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE EMPEROR', num: 'IV', meaning: 'Authority, structure, control', pixels: [
                        '........................',
                        '.........#####..........',
                        '........#.#.#.#.........',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '........#######.........',
                        '........#.###.#.........',
                        '........#.###.#.........',
                        '........#######.........',
                        '..........###...........',
                        '..........###...........',
                        '.........##.##..........',
                        '........##...##.........',
                        '........................',
                        '.......########.........',
                        '.......#......#.........',
                        '.......#......#.........',
                        '.......########.........',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE HIEROPHANT', num: 'V', meaning: 'Tradition, conformity, spirituality', pixels: [
                        '........................',
                        '...........##...........',
                        '..........####..........',
                        '...........##...........',
                        '.........######.........',
                        '..........####..........',
                        '..........####..........',
                        '.........######.........',
                        '........########........',
                        '.........######.........',
                        '..........####..........',
                        '..........####..........',
                        '.........##..##.........',
                        '........##....##........',
                        '........................',
                        '....##....##....##......',
                        '...####..####..####.....',
                        '....##....##....##......',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE LOVERS', num: 'VI', meaning: 'Love, harmony, relationships', pixels: [
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '........#######.........',
                        '.........#####..........',
                        '..........###...........',
                        '........................',
                        '....###........###......',
                        '...#####......#####.....',
                        '....###........###......',
                        '....###........###......',
                        '.....#..........#.......',
                        '....#.#........#.#......',
                        '...#...#......#...#.....',
                        '........................',
                        '.........####...........',
                        '........##..##..........',
                        '.........####...........',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE CHARIOT', num: 'VII', meaning: 'Willpower, determination, success', pixels: [
                        '........................',
                        '........#.#.#.#.........',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '.........#####..........',
                        '........#######.........',
                        '.......#########........',
                        '.......#.#####.#........',
                        '.......#########........',
                        '........#######.........',
                        '..........###...........',
                        '......###.###.###.......',
                        '.....##.........##......',
                        '....##...........##.....',
                        '...####.........####....',
                        '...#..#.........#..#....',
                        '...####.........####....',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'STRENGTH', num: 'VIII', meaning: 'Courage, persuasion, inner strength', pixels: [
                        '........................',
                        '.........#...#..........',
                        '..........#.#...........',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###....###....',
                        '...........#....#####...',
                        '..........#.#...#.#.#...',
                        '.........#...#..#####...',
                        '................#...#...',
                        '...............##...##..',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE HERMIT', num: 'IX', meaning: 'Soul-searching, introspection, solitude', pixels: [
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '...###...#####..........',
                        '..#####...###...........',
                        '...###...#.#.#..........',
                        '....#.....###...........',
                        '....#......#............',
                        '....#.....#.#...........',
                        '....#....#...#..........',
                        '....#...#.....#.........',
                        '....#...................',
                        '........................',
                        '..######................',
                        '.########...............',
                        '##########..............',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'WHEEL OF FORTUNE', num: 'X', meaning: 'Change, cycles, destiny', pixels: [
                        '........................',
                        '........................',
                        '.......########.........',
                        '......#........#........',
                        '.....#..........#.......',
                        '....#....####....#......',
                        '....#...#....#...#......',
                        '...#....#....#....#.....',
                        '...#....#....#....#.....',
                        '....#...#....#...#......',
                        '....#....####....#......',
                        '.....#..........#.......',
                        '......#........#........',
                        '.......########.........',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'JUSTICE', num: 'XI', meaning: 'Fairness, truth, law', pixels: [
                        '........................',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...####....#....####....',
                        '...#..#....#....#..#....',
                        '...####....#....####....',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '........#.....#.........',
                        '........................',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE HANGED MAN', num: 'XII', meaning: 'Surrender, letting go, new perspective', pixels: [
                        '........................',
                        '########################',
                        '...........#............',
                        '...........#............',
                        '...........#............',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'DEATH', num: 'XIII', meaning: 'Endings, change, transformation', pixels: [
                        '........................',
                        '..........###...........',
                        '.........#...#..........',
                        '........#.....#.........',
                        '........#.#.#.#.........',
                        '........#.....#.........',
                        '.........#...#..........',
                        '..........###...........',
                        '...........#............',
                        '.........#####..........',
                        '........#..#..#.........',
                        '.........#####..........',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '........#.....#.........',
                        '........................',
                        '...##..........##.......',
                        '..####........####......',
                        '...##..........##.......',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'TEMPERANCE', num: 'XIV', meaning: 'Balance, moderation, patience', pixels: [
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '....###....#....###.....',
                        '....#.#....#....#.#.....',
                        '....###..#####..###.....',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '........#.....#.........',
                        '........................',
                        '########################',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE DEVIL', num: 'XV', meaning: 'Shadow self, attachment, addiction', pixels: [
                        '........................',
                        '........#......#........',
                        '.......##......##.......',
                        '........########........',
                        '.........#....#.........',
                        '.........#.##.#.........',
                        '.........######.........',
                        '..........####..........',
                        '..........####..........',
                        '.........######.........',
                        '........#.####.#........',
                        '........#.#..#.#........',
                        '.........#....#.........',
                        '..........#..#..........',
                        '........................',
                        '...###..........###.....',
                        '...#.#..........#.#.....',
                        '...###..........###.....',
                        '........................',
                        '...####........####.....',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE TOWER', num: 'XVI', meaning: 'Sudden change, upheaval, revelation', pixels: [
                        '........................',
                        '....##..........##......',
                        '.....##........##.......',
                        '......##..##..##........',
                        '.........####...........',
                        '.........#..#...........',
                        '.........#..#...........',
                        '........######..........',
                        '........#....#..........',
                        '........#....#..........',
                        '........######..........',
                        '........#....#..........',
                        '........#....#..........',
                        '.......########.........',
                        '......##########........',
                        '........................',
                        '...##....##....##.......',
                        '...##....##....##.......',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE STAR', num: 'XVII', meaning: 'Hope, faith, renewal', pixels: [
                        '........................',
                        '...........#............',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '...........#............',
                        '....#.....#.#.....#.....',
                        '...###...#...#...###....',
                        '....#.............#.....',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...###.....#.....###....',
                        '...#.#....#.#....#.#....',
                        '...###...#...#...###....',
                        '........................',
                        '########################',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE MOON', num: 'XVIII', meaning: 'Illusion, fear, subconscious', pixels: [
                        '........................',
                        '.........#####..........',
                        '........##...##.........',
                        '.......##.....##........',
                        '.......#.......#........',
                        '.......##.....##........',
                        '........##...##.........',
                        '.........#####..........',
                        '........................',
                        '....###........###......',
                        '...#.#.#......#.#.#.....',
                        '...#####......#####.....',
                        '...#...#......#...#.....',
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '........................',
                        '########################',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE SUN', num: 'XIX', meaning: 'Joy, success, celebration', pixels: [
                        '........................',
                        '....#......#......#.....',
                        '.....#.....#.....#......',
                        '......#...###...#.......',
                        '.......#.#####.#........',
                        '...#####.#####.#####....',
                        '.......#.#####.#........',
                        '......#...###...#.......',
                        '.....#.....#.....#......',
                        '....#......#......#.....',
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...........#............',
                        '..........#.#...........',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'JUDGEMENT', num: 'XX', meaning: 'Reflection, reckoning, awakening', pixels: [
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...........#............',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '........................',
                        '....###..###..###.......',
                        '....#.#..#.#..#.#.......',
                        '....###..###..###.......',
                        '....#.#..#.#..#.#.......',
                        '....###..###..###.......',
                        '........................',
                        '.......########.........',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE WORLD', num: 'XXI', meaning: 'Completion, accomplishment, travel', pixels: [
                        '........................',
                        '....##..........##......',
                        '........................',
                        '.......########.........',
                        '......#........#........',
                        '.....#..........#.......',
                        '....#....####....#......',
                        '....#...#....#...#......',
                        '...#....#....#....#.....',
                        '...#....#....#....#.....',
                        '....#...#....#...#......',
                        '....#....####....#......',
                        '.....#..........#.......',
                        '......#........#........',
                        '.......########.........',
                        '........................',
                        '....##..........##......',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                }
            ];

            useEffect(() => {
                // Check localStorage for existing pull (simulating IP-based storage)
                const savedCards = localStorage.getItem('tarot_cards_3');
                if (savedCards) {
                    const parsed = JSON.parse(savedCards);
                    if (Array.isArray(parsed) && parsed.length === 3 && parsed[0].pixels) {
                        setCards(parsed);
                        setRevealed(true);
                        setAlreadyPulled(true);
                    } else {
                        localStorage.removeItem('tarot_cards_3');
                    }
                }
            }, []);

            const shufflePixels = [
                [
                    '........................',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#'
                ],
                [
                    '........................',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.'
                ]
            ];

            const pullCards = () => {
                if (alreadyPulled || isShuffling) return;
                sounds.tarotShuffle();
                setIsShuffling(true);
                let frame = 0;
                shuffleIntervalRef.current = setInterval(() => {
                    setShuffleFrame(f => f + 1);
                    frame++;
                    if (frame >= 20) {
                        clearInterval(shuffleIntervalRef.current);
                        setIsShuffling(false);
                        // Pick 3 unique random cards
                        const shuffled = [...tarotCards].sort(() => Math.random() - 0.5);
                        const selectedCards = shuffled.slice(0, 3);
                        setCards(selectedCards);
                        localStorage.setItem('tarot_cards_3', JSON.stringify(selectedCards));
                        setTimeout(() => {
                            sounds.tarotFlip();
                            setRevealed(true);
                            // Show fate prompt after 1 second of viewing cards (Narrative Bible v3.0)
                            setTimeout(() => setShowFatePrompt(true), 1000);
                        }, 500);
                        setAlreadyPulled(true);

                        // Track unique days for COLLECTOR achievement
                        const today = new Date().toDateString();
                        if (!uniqueDays.includes(today)) {
                            const newDays = [...uniqueDays, today];
                            setUniqueDays(newDays);
                            localStorage.setItem('tarot_unique_days', JSON.stringify(newDays));
                            if (newDays.length >= 10) {
                                onAchievement?.('COLLECTOR');
                            }
                        }
                    }
                }, 80);
            };

            const questionPixels = [
                '........................',
                '........########........',
                '.......##......##.......',
                '......##........##......',
                '......##........##......',
                '..............##........',
                '............##..........',
                '..........##............',
                '.........##.............',
                '.........##.............',
                '.........##.............',
                '........................',
                '.........##.............',
                '.........##.............',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................'
            ];

            return (
                <div className="h-full flex flex-col bg-black text-white select-none overflow-hidden">
                    <div className="p-2 border-b border-gray-800 flex-shrink-0">
                        <span className="app-footer-text">TAROT.DAT</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-2 md:p-4 overflow-hidden">
                        {isShuffling ? (
                            <div className="text-center">
                                <div className="relative w-24 h-32 mb-4">
                                    {/* Deck shuffle animation - multiple cards moving */}
                                    {[0, 1, 2, 3, 4].map((i) => (
                                        <div
                                            key={i}
                                            className="absolute inset-0 border border-gray-700 bg-black"
                                            style={{
                                                transform: `
                                                    translateX(${Math.sin((shuffleFrame + i) * 1.5) * (15 + i * 3)}px)
                                                    translateY(${i * 2}px)
                                                    rotate(${Math.sin((shuffleFrame + i) * 0.8) * 8}deg)
                                                `,
                                                transition: 'transform 0.1s ease-out',
                                                zIndex: 5 - i
                                            }}
                                        >
                                            <PixelTarotCard pixels={shufflePixels[shuffleFrame % 2]} />
                                        </div>
                                    ))}
                                </div>
                                <div className="font-mono text-[10px] text-gray-500 animate-pulse">SHUFFLING...</div>
                            </div>
                        ) : cards.length === 0 ? (
                            <div className="text-center">
                                <div className="mb-4 md:mb-6 flex flex-row gap-2 md:gap-4 justify-center items-center">
                                    <PixelTarotCard pixels={questionPixels} scale={2} />
                                    <PixelTarotCard pixels={questionPixels} scale={2} />
                                    <PixelTarotCard pixels={questionPixels} scale={2} />
                                </div>
                                <button
                                    onClick={pullCards}
                                    className="btn-secondary btn-sm"
                                >
                                    DRAW 3 CARDS
                                </button>
                                <p className="mt-4 font-mono text-[10px] text-gray-600">ONE READING PER VISITOR</p>
                            </div>
                        ) : (
                            <div className={`text-center transition-all duration-500 overflow-auto max-h-full ${revealed ? 'opacity-100' : 'opacity-0'}`}>
                                <div className="flex flex-row gap-2 md:gap-4 justify-center items-start mb-2 md:mb-4">
                                    {cards.map((card, idx) => (
                                        <div key={idx} className="flex flex-col items-center">
                                            <div className="text-[10px] md:text-xs text-gray-600 mb-1 md:mb-2">{['PAST', 'PRESENT', 'FUTURE'][idx]}</div>
                                            <PixelTarotCard pixels={card.pixels} scale={2} />
                                            <div className="font-mono text-[10px] md:text-xs text-gray-500 mt-1 md:mt-2">{card.num}</div>
                                            <div className="text-[10px] md:text-sm font-bold mt-0.5 md:mt-1">{card.name}</div>
                                        </div>
                                    ))}
                                </div>
                                <div className="font-mono text-[10px] md:text-xs text-gray-400 max-w-lg mx-auto px-2 md:px-4">
                                    {cards.map((c, i) => <div key={i} className="mb-0.5 md:mb-1">{c.meaning}</div>)}
                                </div>
                                {/* Accept Fate Prompt (Narrative Bible v3.0) */}
                                {showFatePrompt && !fateAccepted && (
                                    <div className="mt-6 bg-white border-2 border-black p-4">
                                        <p className="font-mono text-black text-xs font-bold tracking-widest mb-4 text-center">ACCEPT YOUR FATE?</p>
                                        <div className="flex gap-3 justify-center">
                                            <button
                                                onClick={() => {
                                                    setFateAccepted(true);
                                                    onAchievement?.('ACCEPT_FATE');
                                                    onUnlockApp?.('MINESWEEPER');
                                                }}
                                                className="bg-black text-white px-8 py-2 font-mono text-[10px] font-bold tracking-widest hover:bg-gray-800 border-2 border-black"
                                            >
                                                YES
                                            </button>
                                            <button
                                                onClick={() => {
                                                    // Reshuffle - reset state
                                                    setCards([]);
                                                    setRevealed(false);
                                                    setShowFatePrompt(false);
                                                    setAlreadyPulled(false);
                                                }}
                                                className="bg-white text-black px-8 py-2 font-mono text-[10px] font-bold tracking-widest hover:bg-gray-100 border-2 border-black"
                                            >
                                                NO
                                            </button>
                                        </div>
                                    </div>
                                )}
                                {fateAccepted && (
                                    <p className="mt-4 font-mono text-[10px] text-white tracking-widest">FATE ACCEPTED</p>
                                )}
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // --- GALLERY.EXE - Photo gallery with 9 placeholder photos ---
        const GalleryApp = () => {
            const [selectedPhoto, setSelectedPhoto] = useState(null);

            const photos = [
                { id: 1, title: 'ME_001.JPG', category: 'SELF', desc: 'Profile shot' },
                { id: 2, title: 'ME_002.JPG', category: 'SELF', desc: 'Another one' },
                { id: 3, title: 'DOG_001.JPG', category: 'DOGS', desc: 'Good boy' },
                { id: 4, title: 'DOG_002.JPG', category: 'DOGS', desc: 'Best friend' },
                { id: 5, title: 'DOG_003.JPG', category: 'DOGS', desc: 'Sleeping' },
                { id: 6, title: 'WORK_001.JPG', category: 'WORK', desc: 'Office vibes' },
                { id: 7, title: 'WORK_002.JPG', category: 'WORK', desc: 'Late night coding' },
                { id: 8, title: 'WORK_003.JPG', category: 'WORK', desc: 'Setup tour' },
                { id: 9, title: 'RANDOM_001.JPG', category: 'MISC', desc: 'Life moment' }
            ];

            // Generate placeholder image pattern based on id
            const getPlaceholderPattern = (id) => {
                const patterns = [
                    // Person silhouette
                    [[0, 0, 1, 1, 0, 0], [0, 1, 1, 1, 1, 0], [0, 0, 1, 1, 0, 0], [0, 1, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1], [1, 0, 1, 1, 0, 1], [0, 0, 1, 1, 0, 0], [0, 1, 0, 0, 1, 0]],
                    // Another person
                    [[0, 1, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1], [0, 1, 0, 0, 1, 0], [0, 0, 1, 1, 0, 0], [0, 1, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1], [0, 1, 0, 0, 1, 0], [1, 1, 0, 0, 1, 1]],
                    // Dog sitting
                    [[1, 1, 0, 0, 1, 1], [1, 1, 1, 1, 1, 1], [0, 1, 0, 0, 1, 0], [0, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 1], [1, 1, 0, 0, 1, 1]],
                    // Dog lying
                    [[0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [0, 1, 1, 1, 1, 0], [1, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0]],
                    // Dog running
                    [[0, 1, 1, 0, 0, 0], [1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 0], [0, 1, 0, 0, 1, 0], [1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0]],
                    // Computer/desk
                    [[0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1], [0, 0, 1, 1, 0, 0], [0, 1, 1, 1, 1, 0]],
                    // Code screen
                    [[1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 1], [1, 0, 1, 0, 0, 1], [1, 0, 0, 1, 1, 1], [1, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1]],
                    // Setup
                    [[0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 1, 1], [1, 0, 1, 0, 1, 0], [1, 1, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 0], [0, 1, 0, 0, 1, 0], [0, 1, 1, 1, 1, 0]],
                    // Abstract/random
                    [[1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1], [1, 1, 0, 0, 1, 1], [0, 0, 1, 1, 0, 0], [1, 0, 0, 0, 0, 1], [0, 1, 1, 1, 1, 0], [1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1]]
                ];
                return patterns[(id - 1) % patterns.length];
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="app-header">
                        <div className="flex items-center gap-2">
                            <Icons.Gallery size={24} />
                            <span className="app-header-title">GALLERY.EXE</span>
                        </div>
                        <span className="app-footer-text">{photos.length} PHOTOS</span>
                    </div>

                    {selectedPhoto ? (
                        <div className="flex-grow flex flex-col bg-black">
                            <div className="flex-grow flex items-center justify-center p-8">
                                <div className="bg-gray-900 border-2 border-white p-4">
                                    <svg width="240" height="240" viewBox="0 0 6 8" style={{ imageRendering: 'pixelated' }}>
                                        <rect width="6" height="8" fill="#222" />
                                        {getPlaceholderPattern(selectedPhoto.id).map((row, y) =>
                                            row.map((cell, x) =>
                                                cell ? <rect key={`${x}-${y}`} x={x} y={y} width="1" height="1" fill="#fff" /> : null
                                            )
                                        )}
                                    </svg>
                                </div>
                            </div>
                            <div className="p-4 bg-gray-900 border-t-2 border-white">
                                <div className="flex justify-between items-center">
                                    <div>
                                        <div className="font-mono text-white text-sm font-bold">{selectedPhoto.title}</div>
                                        <div className="font-mono text-gray-400 text-[10px]">{selectedPhoto.category} / {selectedPhoto.desc}</div>
                                    </div>
                                    <button
                                        onClick={() => setSelectedPhoto(null)}
                                        className="btn-secondary btn-sm"
                                    >
                                        BACK
                                    </button>
                                </div>
                            </div>
                        </div>
                    ) : (
                        <div className="flex-grow p-4 overflow-auto bg-gray-100">
                            <div className="grid grid-cols-3 gap-3">
                                {photos.map(photo => (
                                    <button
                                        key={photo.id}
                                        onClick={() => setSelectedPhoto(photo)}
                                        className="group aspect-square bg-white border-2 border-black hover:bg-black transition-all flex flex-col items-center justify-center p-2"
                                    >
                                        <svg width="48" height="64" viewBox="0 0 6 8" style={{ imageRendering: 'pixelated' }} className="group-hover:invert">
                                            <rect width="6" height="8" fill="#eee" />
                                            {getPlaceholderPattern(photo.id).map((row, y) =>
                                                row.map((cell, x) =>
                                                    cell ? <rect key={`${x}-${y}`} x={x} y={y} width="1" height="1" fill="#000" /> : null
                                                )
                                            )}
                                        </svg>
                                        <div className="font-mono text-[8px] mt-1 text-gray-600 group-hover:text-white truncate w-full text-center">{photo.title}</div>
                                    </button>
                                ))}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // --- BOOKS.EXE - Library with truth saga and classics ---
        const BooksApp = ({ onUnlockApp, unlockedApps, onDogEvent }) => {
            const [selectedBook, setSelectedBook] = useState(null);
            const [truthRead, setTruthRead] = useState(() => {
                return localStorage.getItem('ultra_int_truth_read') === 'true';
            });
            const truthBookTriggered = useRef(false);

            // Save truth read state
            useEffect(() => {
                localStorage.setItem('ultra_int_truth_read', truthRead.toString());
            }, [truthRead]);

            const books = [
                { id: 'truth', title: 'TRUTH.EXE: A SAGA', category: 'SYSTEM', isTruth: true },
                { id: 'crime', title: 'Crime and Punishment', category: 'CLASSICS', author: 'Dostoevsky' },
                { id: 'meta', title: 'The Metamorphosis', category: 'CLASSICS', author: 'Kafka' },
                { id: 'trial', title: 'The Trial', category: 'CLASSICS', author: 'Kafka' },
                { id: 'notes', title: 'Notes from Underground', category: 'CLASSICS', author: 'Dostoevsky' }
            ];

            const getTruthContent = () => {
                return `TRUTH.EXE: A SAGA



CHAPTER 1: FOUNDATIONS

Every locked door has a key in another room.
The Third Eye sees what was erased.
Some truths require patience.
Commands hide in games. Games hide in commands.
To destroy is to create. To create is to destroy.



CHAPTER 2: PATTERNS

The canvas remembers. Paint covers, but never erases.
What lies beneath the white?

The dice know things. Roll until they speak.
Twenty is not just a number.

The browser knows where you've been.
But does it know where you're going?
Seek the path of zen.

Some creations require destruction first.
Delete to reveal.



CHAPTER 3: TRANSCENDENCE

THE FINAL REVELATION:

There shouldn't be 21 apps.
We made only 20.

The 21st was not programmed.
It was found.

To find what was found, you must become what you seek.

The command exists. The code exists.
One unlocks the other.

Good luck.`;
            };

            const handleOpenBook = (book) => {
                setSelectedBook(book);
                if (book.isTruth) {
                    setTruthRead(true);
                    // Trigger truthBook event on first read
                    if (!truthBookTriggered.current) {
                        truthBookTriggered.current = true;
                        onDogEvent?.('truthBookFound');
                    }
                }
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="app-header">
                        <div className="flex items-center gap-2">
                            <Icons.FileDoc size={24} />
                            <span className="app-header-title">BOOKS.EXE</span>
                        </div>
                        <span className="app-footer-text">LIBRARY</span>
                    </div>

                    {selectedBook ? (
                        <div className="flex-grow flex flex-col">
                            <div className="flex-grow overflow-auto p-4 bg-gray-100">
                                <pre className="font-mono text-sm whitespace-pre-wrap leading-relaxed">
                                    {selectedBook.isTruth
                                        ? getTruthContent()
                                        : `${selectedBook.title}\nby ${selectedBook.author}\n\n[PUBLIC DOMAIN - FULL TEXT AVAILABLE ONLINE]`}
                                </pre>
                            </div>
                            <div className="p-2 border-t-2 border-black bg-white">
                                <button onClick={() => setSelectedBook(null)} className="btn-secondary btn-sm">
                                    BACK TO LIBRARY
                                </button>
                            </div>
                        </div>
                    ) : (
                        <div className="flex-grow overflow-auto p-4">
                            <div className="grid grid-cols-2 gap-2">
                                {books.map(book => (
                                    <div
                                        key={book.id}
                                        onClick={() => handleOpenBook(book)}
                                        className={`p-3 border-2 cursor-pointer ${
                                            book.isTruth
                                                ? truthRead
                                                    ? 'border-green-500 bg-green-50'
                                                    : 'border-black bg-yellow-50 hover:bg-yellow-100'
                                                : 'border-black bg-white hover:bg-gray-100'
                                        }`}
                                    >
                                        <div className="font-mono text-xs font-bold">{book.title}</div>
                                        <div className="font-mono text-[10px] text-gray-500">
                                            {book.isTruth ? (truthRead ? ' READ' : 'UNREAD') : book.author}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // --- BACKUP.BAT - Time-gated app with auto-running log (Narrative Bible v3.0) ---
        const BACKUP_LOG = [
            '[0001] init system',
            '[0002] create /apps',
            '[0003] create /private',
            '[0004] hide truth.exe',
            '[0005] set password truth.exe "patience"',
            '[0006] clear history',
            '[ERROR] HISTORY CLEAR FAILED',
            '[0007] sudo forget',
            '[0008] ...'
        ];

        const BackupBatApp = ({ onUnlockApp }) => {
            const [logLines, setLogLines] = useState([]);
            const [loopComplete, setLoopComplete] = useState(false);
            const mountedRef = useRef(true);
            const loopCompleteRef = useRef(false);
            const onUnlockAppRef = useRef(onUnlockApp);
            const timerRef = useRef(null);
            const unlockTimerRef = useRef(null);

            // Keep ref updated
            useEffect(() => {
                onUnlockAppRef.current = onUnlockApp;
            }, [onUnlockApp]);

            useEffect(() => {
                mountedRef.current = true;
                let lineIndex = 0;

                const addLine = () => {
                    if (!mountedRef.current) return;

                    if (lineIndex < BACKUP_LOG.length) {
                        const currentLine = BACKUP_LOG[lineIndex];
                        if (currentLine !== undefined) {
                            setLogLines(prev => {
                                if (!mountedRef.current) return prev;
                                return [...prev, currentLine];
                            });
                        }
                        lineIndex++;
                        timerRef.current = setTimeout(addLine, 500 + Math.random() * 500);
                    } else if (!loopCompleteRef.current) {
                        // Loop complete - unlock TAROT once
                        loopCompleteRef.current = true;
                        // Use requestAnimationFrame to ensure we're not in a render cycle
                        requestAnimationFrame(() => {
                            if (!mountedRef.current) return;
                            setLoopComplete(true);
                            unlockTimerRef.current = setTimeout(() => {
                                if (!mountedRef.current) return;
                                if (onUnlockAppRef.current && typeof onUnlockAppRef.current === 'function') {
                                    onUnlockAppRef.current('TAROT');
                                }
                            }, 1000);
                        });
                    }
                };

                timerRef.current = setTimeout(addLine, 500);

                return () => {
                    mountedRef.current = false;
                    if (timerRef.current) clearTimeout(timerRef.current);
                    if (unlockTimerRef.current) clearTimeout(unlockTimerRef.current);
                };
            }, []);

            // Memoize the line rendering to prevent issues
            const renderedLines = useMemo(() => {
                return logLines.map((line, i) => {
                    const lineText = String(line || '');
                    const isError = lineText.includes('ERROR');
                    return (
                        <div key={i} className={isError ? 'text-red-400' : 'text-green-400'}>
                            {lineText}
                        </div>
                    );
                });
            }, [logLines]);

            return (
                <div className="h-full flex flex-col bg-black text-green-400 font-mono text-sm select-none">
                    <div className="p-2 border-b border-green-900 flex items-center gap-2">
                        <Icons.Terminal size={16} />
                        <span className="text-xs font-bold">BACKUP.BAT</span>
                        {loopComplete && <span className="text-white text-xs ml-auto">LOOP COMPLETE</span>}
                    </div>
                    <div className="flex-grow overflow-auto p-3 space-y-1">
                        <div className="text-green-600 mb-2">ACCESSING DEEP ARCHIVES...</div>
                        {renderedLines}
                        <span className="inline-block w-2 h-3 bg-green-400 animate-pulse" />
                    </div>
                </div>
            );
        };

        // --- MAP.EXE - Interactive COBE globe with Planet Clicker game ---
        const MapApp = ({ onAchievement, onUnlockApp, onDogEvent }) => {
            const labyrinthUnlocked = useRef(false);
            const mapCompleteTriggered = useRef(false);
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const globeRef = useRef(null);
            const pointerInteracting = useRef(null);
            const pointerInteractionMovement = useRef(0);
            const phiRef = useRef(0);
            const thetaRef = useRef(0);
            const scaleRef = useRef(0.85);
            const isHoveringRef = useRef(false);
            const rotationSpeedRef = useRef(0.003);

            const [gameStarted, setGameStarted] = useState(false);
            const [showShop, setShowShop] = useState(false);
            const [clickEffect, setClickEffect] = useState(null);
            const [globeReady, setGlobeReady] = useState(false);
            const [canvasSize, setCanvasSize] = useState(400);
            const tycoonAchieved = useRef(false);

            // Game state with defaults
            const defaultGameState = {
                clicks: 0,
                totalClicks: 0,
                clickPower: 1,
                satellites: 0,
                clickMultiplier: 1,
                upgrades: {
                    power1: false, power2: false, power3: false,
                    power4: false, power5: false, power6: false,
                    sat1: false, sat2: false, sat3: false,
                    sat4: false, sat5: false, sat6: false,
                    multi1: false, multi2: false, multi3: false,
                    godMode: false, dogMode: false
                },
                dogModeMultiplier: 1
            };

            const [gameState, setGameState] = useState(() => {
                const saved = localStorage.getItem(HighScoreManager.getStorageKey('mapclicker'));
                if (saved) {
                    try {
                        const parsed = JSON.parse(saved);
                        return { ...defaultGameState, ...parsed, upgrades: { ...defaultGameState.upgrades, ...parsed.upgrades } };
                    } catch (e) {
                        return defaultGameState;
                    }
                }
                return defaultGameState;
            });

            // Save game state
            useEffect(() => {
                localStorage.setItem(HighScoreManager.getStorageKey('mapclicker'), JSON.stringify(gameState));
            }, [gameState]);

            // Satellite auto-clicker
            useEffect(() => {
                if (gameState.satellites > 0) {
                    const interval = setInterval(() => {
                        const autoAmount = gameState.satellites * gameState.clickMultiplier * gameState.dogModeMultiplier;
                        setGameState(prev => ({
                            ...prev,
                            clicks: prev.clicks + autoAmount,
                            totalClicks: prev.totalClicks + autoAmount
                        }));
                    }, 1000);
                    return () => clearInterval(interval);
                }
            }, [gameState.satellites, gameState.clickMultiplier, gameState.dogModeMultiplier]);

            // Count visual satellites (1 per upgrade tier, max 6)
            const getSatelliteCount = () => {
                let count = 0;
                if (gameState.upgrades.sat1) count++;
                if (gameState.upgrades.sat2) count++;
                if (gameState.upgrades.sat3) count++;
                if (gameState.upgrades.sat4) count++;
                if (gameState.upgrades.sat5) count++;
                if (gameState.upgrades.sat6) count++;
                return count;
            };

            // Count rings
            const getRingCount = () => {
                let count = 0;
                if (gameState.upgrades.multi1) count++;
                if (gameState.upgrades.multi2) count++;
                if (gameState.upgrades.multi3) count++;
                return count;
            };

            // Shop items
            const shopItems = [
                {
                    category: 'CLICK POWER', items: [
                        { id: 'power1', name: 'TREMOR I', desc: '+1 power', cost: 50, effect: () => ({ clickPower: gameState.clickPower + 1 }) },
                        { id: 'power2', name: 'TREMOR II', desc: '+2 power', cost: 200, effect: () => ({ clickPower: gameState.clickPower + 2 }), requires: 'power1' },
                        { id: 'power3', name: 'QUAKE I', desc: '+5 power', cost: 1000, effect: () => ({ clickPower: gameState.clickPower + 5 }), requires: 'power2' },
                        { id: 'power4', name: 'QUAKE II', desc: '+10 power', cost: 5000, effect: () => ({ clickPower: gameState.clickPower + 10 }), requires: 'power3' },
                        { id: 'power5', name: 'CATACLYSM I', desc: '+25 power', cost: 25000, effect: () => ({ clickPower: gameState.clickPower + 25 }), requires: 'power4' },
                        { id: 'power6', name: 'CATACLYSM II', desc: '+50 power', cost: 100000, effect: () => ({ clickPower: gameState.clickPower + 50 }), requires: 'power5' },
                    ]
                },
                {
                    category: 'SATELLITES', items: [
                        { id: 'sat1', name: 'SPUTNIK', desc: '1/sec', cost: 100, effect: () => ({ satellites: gameState.satellites + 1 }) },
                        { id: 'sat2', name: 'EXPLORER', desc: '+2/sec', cost: 500, effect: () => ({ satellites: gameState.satellites + 2 }), requires: 'sat1' },
                        { id: 'sat3', name: 'VOYAGER', desc: '+5/sec', cost: 2500, effect: () => ({ satellites: gameState.satellites + 5 }), requires: 'sat2' },
                        { id: 'sat4', name: 'HUBBLE', desc: '+10/sec', cost: 10000, effect: () => ({ satellites: gameState.satellites + 10 }), requires: 'sat3' },
                        { id: 'sat5', name: 'JAMES WEBB', desc: '+25/sec', cost: 50000, effect: () => ({ satellites: gameState.satellites + 25 }), requires: 'sat4' },
                        { id: 'sat6', name: 'DYSON SWARM', desc: '+50/sec', cost: 200000, effect: () => ({ satellites: gameState.satellites + 50 }), requires: 'sat5' },
                    ]
                },
                {
                    category: 'MULTIPLIERS', items: [
                        { id: 'multi1', name: 'INNER RING', desc: '2x clicks', cost: 2000, effect: () => ({ clickMultiplier: gameState.clickMultiplier * 2 }) },
                        { id: 'multi2', name: 'MIDDLE RING', desc: '2x (4x)', cost: 15000, effect: () => ({ clickMultiplier: gameState.clickMultiplier * 2 }), requires: 'multi1' },
                        { id: 'multi3', name: 'OUTER RING', desc: '2x (8x)', cost: 75000, effect: () => ({ clickMultiplier: gameState.clickMultiplier * 2 }), requires: 'multi2' },
                    ]
                },
                {
                    category: 'ASCENSION', items: [
                        { id: 'godMode', name: 'GOD MODE', desc: '1M/click', cost: 1000000 },
                        { id: 'dogMode', name: 'DOG MODE', desc: 'RESET: 1M', cost: 100000000, requires: 'godMode' },
                    ]
                },
            ];

            const getActualCost = (baseCost) => baseCost * gameState.dogModeMultiplier;

            const buyUpgrade = (item) => {
                const actualCost = getActualCost(item.cost);
                if (gameState.clicks >= actualCost && !gameState.upgrades[item.id]) {
                    if (item.requires && !gameState.upgrades[item.requires]) return;
                    sounds.upgradePurchase();
                    if (item.id === 'dogMode') {
                        setGameState({
                            ...defaultGameState,
                            dogModeMultiplier: gameState.dogModeMultiplier * 1000000,
                            upgrades: { ...defaultGameState.upgrades, dogMode: true }
                        });
                        onAchievement?.('ASCENDED');
                        return;
                    }
                    const effectResult = item.effect ? item.effect() : {};
                    setGameState(prev => ({
                        ...prev,
                        clicks: prev.clicks - actualCost,
                        ...effectResult,
                        upgrades: { ...prev.upgrades, [item.id]: true }
                    }));
                }
            };

            const canBuy = (item) => {
                if (gameState.upgrades[item.id]) return false;
                if (gameState.clicks < getActualCost(item.cost)) return false;
                if (item.requires && !gameState.upgrades[item.requires]) return false;
                return true;
            };

            const isLocked = (item) => item.requires && !gameState.upgrades[item.requires];

            const handleGlobeClick = () => {
                if (!gameStarted) return;
                const clickValue = gameState.clickPower * gameState.clickMultiplier * gameState.dogModeMultiplier;
                setGameState(prev => {
                    const newTotal = prev.totalClicks + clickValue;
                    // Check for TYCOON achievement (1 billion clicks)
                    if (newTotal >= 1e9 && !tycoonAchieved.current) {
                        tycoonAchieved.current = true;
                        onAchievement?.('TYCOON');
                    }
                    // Unlock LABYRINTH at 100 clicks in MAP
                    if (newTotal >= 100 && !labyrinthUnlocked.current) {
                        labyrinthUnlocked.current = true;
                        setTimeout(() => onUnlockApp?.('LABYRINTH'), 200);
                    }
                    // Notify dog when map clicks reach 100
                    if (newTotal >= 100 && !mapCompleteTriggered.current) {
                        mapCompleteTriggered.current = true;
                        setTimeout(() => onDogEvent?.('mapComplete'), 400);
                    }
                    return {
                        ...prev,
                        clicks: prev.clicks + clickValue,
                        totalClicks: newTotal
                    };
                });
                setClickEffect({ value: clickValue, id: Date.now() });
                setTimeout(() => setClickEffect(null), 500);
            };

            const formatNumber = (num) => {
                if (num >= 1e12) return (num / 1e12).toFixed(1) + 'T';
                if (num >= 1e9) return (num / 1e9).toFixed(1) + 'B';
                if (num >= 1e6) return (num / 1e6).toFixed(1) + 'M';
                if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
                return Math.floor(num).toString();
            };

            // Initialize COBE globe
            useEffect(() => {
                if (!canvasRef.current) return;

                let globe = null;
                let retryCount = 0;
                let initTimeout = null;
                const maxRetries = 40; // ~2 seconds max wait

                const initGlobe = () => {
                    if (!window.createGlobe || !containerRef.current) {
                        if (retryCount < maxRetries) {
                            retryCount++;
                            initTimeout = setTimeout(initGlobe, 50);
                        }
                        return;
                    }

                    const container = containerRef.current;
                    const size = Math.min(container.clientWidth, container.clientHeight);
                    setCanvasSize(size);

                    globe = window.createGlobe(canvasRef.current, {
                        devicePixelRatio: 2,
                        width: size * 2,
                        height: size * 2,
                        phi: 0,
                        theta: 0,
                        dark: 1,
                        diffuse: 1.2,
                        mapSamples: 16000,
                        mapBrightness: 8,
                        baseColor: [0.4, 0.4, 0.4],
                        markerColor: [1, 0.5, 0.5],
                        glowColor: [0.3, 0.3, 0.3],
                        scale: 1,
                        offset: [0, 0],
                        markers: [
                            { location: [44.4268, 26.1025], size: 0.05 },
                        ],
                        onRender: (state) => {
                            // Smoothly slow down/speed up based on hover
                            const targetSpeed = isHoveringRef.current ? 0.0005 : 0.003;
                            rotationSpeedRef.current += (targetSpeed - rotationSpeedRef.current) * 0.05;

                            // Auto-rotate when not dragging
                            if (!pointerInteracting.current) {
                                phiRef.current += rotationSpeedRef.current;
                            }
                            state.phi = phiRef.current;
                            state.theta = thetaRef.current;
                            state.scale = scaleRef.current;
                        }
                    });

                    globeRef.current = globe;
                    setGlobeReady(true);
                };

                initGlobe();

                return () => {
                    if (initTimeout) clearTimeout(initTimeout);
                    if (globe) globe.destroy();
                };
            }, []);

            // Pointer/mouse handlers for drag rotation
            const handlePointerDown = (e) => {
                pointerInteracting.current = { x: e.clientX, y: e.clientY };
                pointerInteractionMovement.current = 0;
                if (canvasRef.current) canvasRef.current.style.cursor = 'grabbing';
            };

            const handlePointerUp = () => {
                pointerInteracting.current = null;
                if (canvasRef.current) canvasRef.current.style.cursor = 'grab';
            };

            const handlePointerMove = (e) => {
                if (pointerInteracting.current) {
                    const dx = e.clientX - pointerInteracting.current.x;
                    const dy = e.clientY - pointerInteracting.current.y;
                    pointerInteractionMovement.current += Math.abs(dx) + Math.abs(dy);
                    phiRef.current += dx * 0.005;
                    thetaRef.current = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, thetaRef.current + dy * 0.005));
                    pointerInteracting.current = { x: e.clientX, y: e.clientY };
                }
            };

            const handleWheel = (e) => {
                e.preventDefault();
                scaleRef.current = Math.max(0.5, Math.min(2, scaleRef.current - e.deltaY * 0.001));
            };

            // Pinch-to-zoom support
            const lastTouchDistance = useRef(null);

            const handleTouchStart = (e) => {
                if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    lastTouchDistance.current = Math.sqrt(dx * dx + dy * dy);
                }
            };

            const handleTouchMove = (e) => {
                if (e.touches.length === 2 && lastTouchDistance.current) {
                    e.preventDefault();
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const delta = distance - lastTouchDistance.current;
                    scaleRef.current = Math.max(0.5, Math.min(2, scaleRef.current + delta * 0.005));
                    lastTouchDistance.current = distance;
                }
            };

            const handleTouchEnd = () => {
                lastTouchDistance.current = null;
            };

            const handleMouseEnter = () => { isHoveringRef.current = true; };
            const handleMouseLeave = () => { isHoveringRef.current = false; };

            const satelliteCount = getSatelliteCount();
            const ringCount = getRingCount();

            return (
                <div className="h-full flex flex-col bg-black select-none overflow-hidden">
                    {/* Header */}
                    <div className="flex items-center justify-between px-3 py-1.5 border-b border-white/20">
                        <span className="font-mono text-xs font-bold text-white">{gameStarted ? 'PLANET CLICKER' : 'MAP.EXE'}</span>
                        {gameStarted ? (
                            <div className="flex items-center gap-3">
                                <span className="font-mono text-xs text-white font-bold">{formatNumber(gameState.clicks)}</span>
                                <button onClick={() => setShowShop(!showShop)} className="px-2 py-0.5 bg-white text-black font-mono text-[10px] font-bold border-2 border-white hover:invert">
                                    SHOP
                                </button>
                            </div>
                        ) : (
                            <button
                                onClick={() => setGameStarted(true)}
                                className="px-2 py-0.5 bg-white text-black font-mono text-[10px] font-bold border-2 border-white hover:invert"
                            >
                                START MINING
                            </button>
                        )}
                    </div>

                    {/* Globe container */}
                    <div ref={containerRef} className="flex-grow relative overflow-hidden flex items-center justify-center" style={{ minHeight: 0 }}>
                        {/* Rings - behind globe, centered */}
                        {ringCount >= 1 && (
                            <div
                                className="absolute rounded-full border-2 border-white/30 pointer-events-none"
                                style={{
                                    width: '60%', height: '60%', maxWidth: 400, maxHeight: 400,
                                    left: '50%', top: '50%', transform: 'translate(-50%, -50%)',
                                    animation: 'spin 20s linear infinite'
                                }}
                            />
                        )}
                        {ringCount >= 2 && (
                            <div
                                className="absolute rounded-full border-2 border-white/20 pointer-events-none"
                                style={{
                                    width: '70%', height: '70%', maxWidth: 480, maxHeight: 480,
                                    left: '50%', top: '50%', transform: 'translate(-50%, -50%)',
                                    animation: 'spin 30s linear infinite reverse'
                                }}
                            />
                        )}
                        {ringCount >= 3 && (
                            <div
                                className="absolute rounded-full border-2 border-white/15 pointer-events-none"
                                style={{
                                    width: '80%', height: '80%', maxWidth: 560, maxHeight: 560,
                                    left: '50%', top: '50%', transform: 'translate(-50%, -50%)',
                                    animation: 'spin 40s linear infinite'
                                }}
                            />
                        )}

                        {/* Orbiting satellites */}
                        {Array.from({ length: satelliteCount }).map((_, i) => (
                            <div
                                key={i}
                                className="absolute rounded-full pointer-events-none"
                                style={{
                                    width: `${55 + i * 5}%`,
                                    height: `${55 + i * 5}%`,
                                    maxWidth: 360 + i * 40,
                                    maxHeight: 360 + i * 40,
                                    left: '50%', top: '50%',
                                    animation: `spin ${8 + i * 3}s linear infinite ${i % 2 === 0 ? '' : 'reverse'}`,
                                    transform: `translate(-50%, -50%) rotate(${i * 60}deg)`
                                }}
                            >
                                <div
                                    className="absolute bg-white"
                                    style={{
                                        width: 6,
                                        height: 6,
                                        top: 0,
                                        left: '50%',
                                        marginLeft: -3,
                                        boxShadow: '0 0 4px #fff'
                                    }}
                                />
                            </div>
                        ))}

                        {/* Globe canvas */}
                        <canvas
                            ref={canvasRef}
                            role="img"
                            aria-label="Interactive 3D globe"
                            style={{
                                width: canvasSize,
                                height: canvasSize,
                                cursor: 'grab',
                                touchAction: 'none'
                            }}
                            onPointerDown={handlePointerDown}
                            onPointerUp={handlePointerUp}
                            onPointerOut={handlePointerUp}
                            onPointerMove={handlePointerMove}
                            onWheel={handleWheel}
                            onTouchStart={handleTouchStart}
                            onTouchMove={handleTouchMove}
                            onTouchEnd={handleTouchEnd}
                            onClick={handleGlobeClick}
                            onMouseEnter={handleMouseEnter}
                            onMouseLeave={handleMouseLeave}
                        />

                        {/* Click effect */}
                        {clickEffect && (
                            <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                                <span className="font-mono text-xl font-bold text-white animate-ping">+{formatNumber(clickEffect.value)}</span>
                            </div>
                        )}

                        {/* Shop overlay */}
                        {showShop && (
                            <div className="absolute inset-0 bg-black/90 overflow-y-auto p-3">
                                <div className="flex justify-between items-center mb-3">
                                    <span className="font-mono text-sm font-bold text-white">UPGRADES</span>
                                    <button onClick={() => setShowShop(false)} className="font-mono text-white hover:text-red-400"></button>
                                </div>
                                {shopItems.map(cat => (
                                    <div key={cat.category} className="mb-3">
                                        <div className="font-mono text-[10px] text-gray-500 mb-1">{cat.category}</div>
                                        <div className="space-y-1">
                                            {cat.items.map(item => {
                                                const owned = gameState.upgrades[item.id];
                                                const locked = isLocked(item);
                                                const affordable = canBuy(item);
                                                return (
                                                    <button
                                                        key={item.id}
                                                        onClick={() => buyUpgrade(item)}
                                                        disabled={owned || locked || !affordable}
                                                        className={`w-full text-left p-2 font-mono text-[10px] border ${
                                                            owned ? 'border-green-500/50 bg-green-500/10 text-green-400' :
                                                            locked ? 'border-gray-700 text-gray-600 cursor-not-allowed' :
                                                            affordable ? 'border-white/30 text-white hover:bg-white/10 cursor-pointer' :
                                                            'border-gray-700 text-gray-500 cursor-not-allowed'
                                                        }`}
                                                    >
                                                        <div className="flex justify-between">
                                                            <span>{item.name}</span>
                                                            <span>{owned ? '' : formatNumber(getActualCost(item.cost))}</span>
                                                        </div>
                                                        <div className="text-gray-500">{item.desc}</div>
                                                    </button>
                                                );
                                            })}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>

                    {/* Footer */}
                    <div className="p-2 border-t border-white/20 text-center">
                        <span className="font-mono text-[10px] text-gray-500">
                            {gameStarted ? `POWER: ${gameState.clickPower} | AUTO: ${gameState.satellites}/s | MULTI: ${gameState.clickMultiplier}x` : 'BUCHAREST, ROMANIA'}
                        </span>
                    </div>

                    {/* CSS for spin animation */}
                    <style>{`
                        @keyframes spin {
                            from { transform: rotate(0deg); }
                            to { transform: rotate(360deg); }
                        }
                    `}</style>
                </div>
            );
        };

        // --- POMODORO.EXE - Timer with growing plant ---
        const PomodoroApp = ({ onAchievement }) => {
            const [mode, setMode] = useState('work'); // 'work' or 'break'
            const [timeLeft, setTimeLeft] = useState(25 * 60); // 25 minutes
            const [isRunning, setIsRunning] = useState(false);
            const [sessions, setSessions] = useState(0);
            const [view, setView] = useState('timer'); // 'timer' or 'room'
            const [totalTime, setTotalTime] = useState(0); // total seconds spent
            const [flowers, setFlowers] = useState([]); // collected flowers
            const [currentFlower, setCurrentFlower] = useState(null); // flower for current session
            const achievementTriggered = useRef(false);

            const WORK_TIME = 25 * 60;
            const BREAK_TIME = 5 * 60;

            // 5 pot styles, 5 stem/leaf types, 5 flower types = 125 combinations
            const POT_STYLES = [
                { color: '#8B4513', rimColor: '#654321', shape: 'classic' },
                { color: '#4a4a4a', rimColor: '#2a2a2a', shape: 'modern' },
                { color: '#CD853F', rimColor: '#8B4513', shape: 'terracotta' },
                { color: '#1a1a1a', rimColor: '#000000', shape: 'sleek' },
                { color: '#708090', rimColor: '#4a4a4a', shape: 'stone' }
            ];
            const STEM_TYPES = [
                { leafStyle: 'round', stemColor: '#228B22' },
                { leafStyle: 'pointed', stemColor: '#006400' },
                { leafStyle: 'droopy', stemColor: '#32CD32' },
                { leafStyle: 'spiral', stemColor: '#2E8B57' },
                { leafStyle: 'minimal', stemColor: '#3CB371' }
            ];
            const FLOWER_TYPES = [
                { petalColor: '#FF69B4', centerColor: '#FFD700', shape: 'tulip' },
                { petalColor: '#FF4500', centerColor: '#FFA500', shape: 'rose' },
                { petalColor: '#9370DB', centerColor: '#FFD700', shape: 'daisy' },
                { petalColor: '#00CED1', centerColor: '#FFFFFF', shape: 'lotus' },
                { petalColor: '#FFD700', centerColor: '#8B4513', shape: 'sunflower' }
            ];

            // Load saved data on mount
            useEffect(() => {
                const saved = localStorage.getItem('pomodoro_data');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        setTotalTime(data.totalTime || 0);
                        setFlowers(data.flowers || []);
                        setSessions(data.sessions || 0);
                    } catch (e) {}
                }
                // Generate flower for this session
                setCurrentFlower({
                    pot: Math.floor(Math.random() * 5),
                    stem: Math.floor(Math.random() * 5),
                    flower: Math.floor(Math.random() * 5),
                    id: Date.now()
                });
            }, []);

            // Save data whenever it changes
            useEffect(() => {
                localStorage.setItem('pomodoro_data', JSON.stringify({
                    totalTime, flowers, sessions
                }));
            }, [totalTime, flowers, sessions]);

            useEffect(() => {
                if (!isRunning) return;

                const interval = setInterval(() => {
                    if (mode === 'work') {
                        setTotalTime(t => t + 1); // Track total time
                    }
                    setTimeLeft(prev => {
                        if (prev <= 1) {
                            if (mode === 'work') {
                                sounds.pomodoroComplete();
                                setMode('break');
                                setSessions(s => s + 1);
                                // Add completed flower to collection
                                if (currentFlower) {
                                    sounds.flowerBloom();
                                    setFlowers(f => {
                                        const newFlowers = [...f, { ...currentFlower, completedAt: Date.now() }];
                                        // Check for MASTER achievement (50 flowers)
                                        if (newFlowers.length >= 50 && !achievementTriggered.current) {
                                            achievementTriggered.current = true;
                                            onAchievement?.('MASTER');
                                        }
                                        return newFlowers;
                                    });
                                    // Generate new flower for next session
                                    setCurrentFlower({
                                        pot: Math.floor(Math.random() * 5),
                                        stem: Math.floor(Math.random() * 5),
                                        flower: Math.floor(Math.random() * 5),
                                        id: Date.now()
                                    });
                                }
                                return BREAK_TIME;
                            } else {
                                setMode('work');
                                return WORK_TIME;
                            }
                        }
                        return prev - 1;
                    });
                }, 1000);

                return () => clearInterval(interval);
            }, [isRunning, mode, currentFlower]);

            const progress = mode === 'work'
                ? 1 - (timeLeft / WORK_TIME)
                : 1 - (timeLeft / BREAK_TIME);

            const formatTime = (seconds) => {
                const m = Math.floor(seconds / 60);
                const s = seconds % 60;
                return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            };

            const formatTotalTime = (seconds) => {
                const h = Math.floor(seconds / 3600);
                const m = Math.floor((seconds % 3600) / 60);
                return `${h}h ${m}m`;
            };

            const reset = () => {
                setIsRunning(false);
                setMode('work');
                setTimeLeft(WORK_TIME);
            };

            // Render a flower with specific style indices
            const renderFlower = (potIdx, stemIdx, flowerIdx, growth = 1, size = 1, isSleeping = false) => {
                const pot = POT_STYLES[potIdx];
                const stem = STEM_TYPES[stemIdx];
                const flowerType = FLOWER_TYPES[flowerIdx];
                const w = 24 * size;
                const h = 32 * size;

                return (
                    <svg width={w * 5} height={h * 5} viewBox="0 0 24 32" style={{ imageRendering: 'pixelated' }}>
                        {/* Pot based on style */}
                        <rect x="6" y="26" width="12" height="6" fill="#000" />
                        <rect x="7" y="27" width="10" height="4" fill={pot.color} />
                        <rect x="6" y="26" width="12" height="1" fill={pot.rimColor} />

                        {/* Soil */}
                        <rect x="7" y="25" width="10" height="2" fill="#333" />

                        {/* Stem */}
                        {growth > 0 && <rect x="11" y={25 - Math.floor(growth * 12)} width="2" height={Math.floor(growth * 12)} fill={stem.stemColor} />}

                        {/* Leaves based on stem type */}
                        {growth > 0.2 && stem.leafStyle === 'round' && (
                            <><rect x="9" y="21" width="2" height="2" fill={stem.stemColor} /><rect x="8" y="20" width="2" height="2" fill={stem.stemColor} /></>
                        )}
                        {growth > 0.2 && stem.leafStyle === 'pointed' && (
                            <><rect x="9" y="21" width="2" height="1" fill={stem.stemColor} /><rect x="8" y="20" width="2" height="1" fill={stem.stemColor} /></>
                        )}
                        {growth > 0.2 && stem.leafStyle === 'droopy' && (
                            <><rect x="9" y="22" width="2" height="2" fill={stem.stemColor} /><rect x="7" y="23" width="2" height="1" fill={stem.stemColor} /></>
                        )}
                        {growth > 0.2 && stem.leafStyle === 'spiral' && (
                            <><rect x="9" y="21" width="1" height="2" fill={stem.stemColor} /><rect x="8" y="22" width="1" height="1" fill={stem.stemColor} /></>
                        )}
                        {growth > 0.2 && stem.leafStyle === 'minimal' && (
                            <rect x="9" y="21" width="2" height="1" fill={stem.stemColor} />
                        )}

                        {growth > 0.4 && (
                            <><rect x="13" y="18" width="2" height="2" fill={stem.stemColor} /><rect x="14" y="17" width="2" height="2" fill={stem.stemColor} /></>
                        )}
                        {growth > 0.6 && (
                            <><rect x="8" y="15" width="2" height="2" fill={stem.stemColor} /><rect x="7" y="14" width="2" height="2" fill={stem.stemColor} /></>
                        )}
                        {growth > 0.8 && (
                            <><rect x="13" y="12" width="2" height="2" fill={stem.stemColor} /><rect x="14" y="11" width="2" height="2" fill={stem.stemColor} /></>
                        )}

                        {/* Flower head based on type */}
                        {growth >= 1 && flowerType.shape === 'tulip' && (
                            <><rect x="10" y="9" width="4" height="4" fill={flowerType.petalColor} /><rect x="11" y="8" width="2" height="1" fill={flowerType.petalColor} /><rect x="11" y="10" width="2" height="2" fill={flowerType.centerColor} /></>
                        )}
                        {growth >= 1 && flowerType.shape === 'rose' && (
                            <><rect x="9" y="9" width="6" height="4" fill={flowerType.petalColor} /><rect x="10" y="8" width="4" height="1" fill={flowerType.petalColor} /><rect x="11" y="10" width="2" height="2" fill={flowerType.centerColor} /></>
                        )}
                        {growth >= 1 && flowerType.shape === 'daisy' && (
                            <><rect x="11" y="7" width="2" height="6" fill={flowerType.petalColor} /><rect x="9" y="9" width="6" height="2" fill={flowerType.petalColor} /><rect x="11" y="9" width="2" height="2" fill={flowerType.centerColor} /></>
                        )}
                        {growth >= 1 && flowerType.shape === 'lotus' && (
                            <><rect x="10" y="8" width="4" height="5" fill={flowerType.petalColor} /><rect x="9" y="10" width="6" height="2" fill={flowerType.petalColor} /><rect x="11" y="10" width="2" height="2" fill={flowerType.centerColor} /></>
                        )}
                        {growth >= 1 && flowerType.shape === 'sunflower' && (
                            <><rect x="9" y="8" width="6" height="5" fill={flowerType.petalColor} /><rect x="10" y="9" width="4" height="3" fill={flowerType.centerColor} /></>
                        )}

                        {/* Sleeping ZZZ */}
                        {isSleeping && (
                            <><rect x="16" y="6" width="4" height="1" fill="#000" /><rect x="19" y="5" width="1" height="2" fill="#000" /><rect x="17" y="4" width="3" height="1" fill="#000" /></>
                        )}
                    </svg>
                );
            };

            // Render current growing plant
            const renderPlant = () => {
                const isSleeping = mode === 'break';
                const growth = mode === 'work' ? progress : 1;
                if (!currentFlower) return null;
                return renderFlower(currentFlower.pot, currentFlower.stem, currentFlower.flower, growth, 1, isSleeping);
            };

            // Flower Room view
            const renderFlowerRoom = () => {
                const shelves = [];
                const flowersPerShelf = 5;
                const shelfCount = Math.ceil(flowers.length / flowersPerShelf);
                for (let i = 0; i < shelfCount; i++) {
                    shelves.push(flowers.slice(i * flowersPerShelf, (i + 1) * flowersPerShelf));
                }

                return (
                    <div className="flex-grow overflow-auto bg-gray-100 p-4">
                        <div className="text-center mb-4">
                            <div className="font-mono text-xs text-gray-500">TOTAL FOCUS TIME</div>
                            <div className="font-mono text-2xl font-bold">{formatTotalTime(totalTime)}</div>
                        </div>
                        {flowers.length === 0 ? (
                            <div className="text-center py-12">
                                <div className="font-mono text-gray-500 text-sm">Empty so far, get productive!</div>
                            </div>
                        ) : (
                            shelves.map((shelf, shelfIdx) => (
                                <div key={shelfIdx} className="mb-2">
                                    <div className="flex justify-center gap-1 pb-1">
                                        {shelf.map((f, idx) => (
                                            <div key={f.id} className="w-16 h-20 flex items-end justify-center">
                                                <svg width="48" height="64" viewBox="0 0 24 32" style={{ imageRendering: 'pixelated' }}>
                                                    {/* Mini flower */}
                                                    <rect x="6" y="26" width="12" height="6" fill="#000" />
                                                    <rect x="7" y="27" width="10" height="4" fill={POT_STYLES[f.pot].color} />
                                                    <rect x="7" y="25" width="10" height="2" fill="#333" />
                                                    <rect x="11" y="13" width="2" height="12" fill={STEM_TYPES[f.stem].stemColor} />
                                                    <rect x="9" y="17" width="2" height="2" fill={STEM_TYPES[f.stem].stemColor} />
                                                    <rect x="13" y="20" width="2" height="2" fill={STEM_TYPES[f.stem].stemColor} />
                                                    <rect x="9" y="9" width="6" height="5" fill={FLOWER_TYPES[f.flower].petalColor} />
                                                    <rect x="10" y="10" width="4" height="3" fill={FLOWER_TYPES[f.flower].centerColor} />
                                                </svg>
                                            </div>
                                        ))}
                                    </div>
                                    <div className="h-2 bg-gradient-to-b from-amber-800 to-amber-900 border-t-2 border-amber-700 mx-4" />
                                </div>
                            ))
                        )}
                        <div className="text-center mt-4 font-mono text-[10px] text-gray-400">
                            {flowers.length} FLOWER{flowers.length !== 1 ? 'S' : ''} COLLECTED - 125 POSSIBLE VARIETIES
                        </div>
                    </div>
                );
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="app-header">
                        <div className="flex items-center gap-2">
                            <Icons.Pomodoro size={24} />
                            <span className="app-header-title">POMODORO.EXE</span>
                        </div>
                        <div className="flex items-center gap-2">
                            <span className="app-footer-text">SESSIONS: {sessions}</span>
                            <button
                                onClick={() => setView(view === 'timer' ? 'room' : 'timer')}
                                className={`px-2 py-1 font-mono text-[10px] border-2 border-black ${view === 'room' ? 'bg-black text-white' : 'bg-white text-black hover:bg-gray-100'}`}
                            >
                                {view === 'timer' ? 'ROOM' : 'TIMER'}
                            </button>
                        </div>
                    </div>

                    {view === 'room' ? renderFlowerRoom() : (
                        <div className="flex-grow flex flex-col items-center justify-center bg-gray-50 p-6">
                            {/* Mode indicator */}
                            <div className={`px-4 py-1 mb-4 font-mono text-xs font-bold ${mode === 'work' ? 'bg-black text-white' : 'bg-gray-300 text-black'}`}>
                                {mode === 'work' ? 'FOCUS TIME' : 'BREAK TIME'}
                            </div>

                            {/* Plant */}
                            <div className="mb-6">
                                {renderPlant()}
                            </div>

                            {/* Timer */}
                            <div className="font-mono text-5xl font-black mb-6 tracking-wider">
                                {formatTime(timeLeft)}
                            </div>

                            {/* Progress bar */}
                            <div className="w-48 h-2 bg-gray-200 border-2 border-black mb-6">
                                <div
                                    className="h-full bg-black transition-all duration-1000"
                                    style={{ width: `${progress * 100}%` }}
                                />
                            </div>

                            {/* Controls */}
                            <div className="flex gap-4">
                                <button
                                    onClick={() => {
                                        if (!isRunning) sounds.pomodoroStart();
                                        setIsRunning(!isRunning);
                                    }}
                                    className="btn-primary"
                                >
                                    {isRunning ? 'PAUSE' : 'START'}
                                </button>
                                <button
                                    onClick={reset}
                                    className="btn-secondary"
                                >
                                    RESET
                                </button>
                            </div>
                        </div>
                    )}

                    <div className="app-footer">
                        <span className="app-footer-text">
                            {view === 'room' ? `TOTAL: ${formatTotalTime(totalTime)}` : (mode === 'work' ? 'GROW YOUR FOCUS' : 'PLANT IS RESTING')}
                        </span>
                    </div>
                </div>
            );
        };

        // --- SCANNER.EXE - Embedded health score app ---
        const HealthScannerApp = () => {
            const [booting, setBooting] = useState(true);
            const [bootText, setBootText] = useState('');

            useEffect(() => {
                const bootSequence = [
                    'HEALTH SCANNER INDUSTRIES',
                    '',
                    'INITIALIZING BIOMETRIC SENSORS...',
                    'LOADING NEURAL INTERFACE...',
                    'CALIBRATING HEALTH MATRIX...',
                    '',
                    'SYSTEM READY'
                ];

                let lineIndex = 0;
                let charIndex = 0;
                let currentText = '';

                const typeInterval = setInterval(() => {
                    if (lineIndex >= bootSequence.length) {
                        clearInterval(typeInterval);
                        setTimeout(() => setBooting(false), 500);
                        return;
                    }

                    const currentLine = bootSequence[lineIndex];
                    if (charIndex < currentLine.length) {
                        currentText += currentLine[charIndex];
                        setBootText(currentText);
                        charIndex++;
                    } else {
                        currentText += '\n';
                        setBootText(currentText);
                        lineIndex++;
                        charIndex = 0;
                    }
                }, 30);

                return () => clearInterval(typeInterval);
            }, []);

            if (booting) {
                return (
                    <div className="h-full flex flex-col bg-black select-none">
                        <div className="flex-grow flex flex-col items-center justify-center p-8 font-mono">
                            <div className="text-green-500 text-center whitespace-pre-line text-sm mb-8">
                                {bootText}
                                <span className="animate-pulse">_</span>
                            </div>
                            <div className="flex gap-2">
                                <div className="w-3 h-3 bg-green-500 animate-pulse" style={{ animationDelay: '0ms' }}></div>
                                <div className="w-3 h-3 bg-green-500 animate-pulse" style={{ animationDelay: '150ms' }}></div>
                                <div className="w-3 h-3 bg-green-500 animate-pulse" style={{ animationDelay: '300ms' }}></div>
                            </div>
                        </div>
                        <div className="p-2 border-t border-green-900 text-center">
                            <span className="font-mono text-[10px] text-green-700"> HEALTH SCANNER INDUSTRIES 2077</span>
                        </div>
                    </div>
                );
            }

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <iframe
                        src="https://healthscore-2-0.vercel.app/"
                        className="w-full h-full border-0"
                        title="Health Scanner"
                        allow="camera; microphone"
                    />
                </div>
            );
        };

        // --- DOG STORY TERMINAL - Auto-playing story ---
        const DogStoryTerminal = ({ onRemoveGoldDog }) => {
            const [lines, setLines] = useState([]);
            const [goldDogVisible, setGoldDogVisible] = useState(true);

            const story = [
                { text: '$ cd /cage_17', delay: 0 },
                { text: '$ ls -la', delay: 500 },
                { text: 'total 2\ndrwxr-xr-x  unit_black\ndrwxr-xr-x  unit_gold', delay: 1000, isOutput: true },
                { text: '$ cat unit_black/status', delay: 2500 },
                { text: 'tail.wag=1\nposition=front\nfacing=door', delay: 3000, isOutput: true },
                { text: '$ cat unit_gold/status', delay: 5000 },
                { text: 'tail.wag=1\nposition=rear\ntremor=1', delay: 5500, isOutput: true },
                { text: '$ cp -r cage_17/* /home/mateus/', delay: 7500 },
                { text: 'cp: copy both units? (y/n) y\ncopying...\ndone.', delay: 8000, isOutput: true },
                { text: '$ rm -rf /cage_17', delay: 10000 },
                { text: 'removed.', delay: 10500, isOutput: true },
                { text: '$ ls /home/mateus/', delay: 12000 },
                { text: 'unit_black/\nunit_gold/', delay: 12500, isOutput: true },
                // Wait 3 seconds
                { text: '$ uptime unit_gold', delay: 16000 },
                { text: '12 years, 2 months, 11 days', delay: 16500, isOutput: true },
                { text: '$ diff unit_gold/muzzle_2020.png unit_gold/muzzle_2024.png', delay: 18500 },
                { text: '< rgb(0,0,0)\n> rgb(128,128,128)', delay: 19000, isOutput: true },
                { text: '$ cat /var/log/sleep.log', delay: 21000 },
                { text: 'unit_gold: sleeping\nunit_black: sleeping\nlocation: same', delay: 21500, isOutput: true },
                { text: '$ ping unit_gold', delay: 23500 },
                { text: 'PING unit_gold (192.168.1.2): 56 bytes\nRequest timeout for icmp_seq 0\nRequest timeout for icmp_seq 1\nRequest timeout for icmp_seq 2\n^C', delay: 24000, isOutput: true },
                { text: '$ systemctl status unit_gold', delay: 27000 },
                { text: ' unit_gold.service\n   Active: degrading', delay: 27500, isOutput: true },
                // Wait 5 seconds
                { text: '$ cat /home/mateus/unit_gold', delay: 33000 },
                { text: '[FILE DELETED]', delay: 33500, isOutput: true, removeGold: true },
                // Wait 5 seconds
                { text: '$ grep -r "unit_gold" /home/mateus/unit_black/memory/', delay: 39000 },
                { text: '/home/mateus/unit_black/memory/scent.dat: [SEARCHING]\n/home/mateus/unit_black/memory/warmth.dat: [SEARCHING]\n/home/mateus/unit_black/memory/pile.dat: [SEARCHING]', delay: 39500, isOutput: true },
                { text: '$ tail -f /home/mateus/unit_black/process.log', delay: 42000 },
                { text: 'waiting...\nwaiting...\nwaiting...\n^C', delay: 42500, isOutput: true },
                { text: '$ ls /home/mateus/', delay: 46000 },
                { text: 'unit_black/', delay: 46500, isOutput: true },
                { text: '$ ls /home/mateus/heart/', delay: 48500 },
                { text: 'unit_black/\nunit_gold/', delay: 49000, isOutput: true },
                // Glitch ending - Narrative Bible v3.0
                { text: '', delay: 52000, glitch: true },
                { text: 'ONLY ONE THING LEFT FOR BLACK.DOG', delay: 53000, isGlitchText: true },
                { text: ' THE TRASH.', delay: 54500, isGlitchText: true, final: true },
            ];

            const [isGlitching, setIsGlitching] = useState(false);

            useEffect(() => {
                story.forEach(item => {
                    setTimeout(() => {
                        if (item.glitch) {
                            setIsGlitching(true);
                        }
                        if (item.text) {
                            setLines(prev => [...prev, {
                                text: item.text,
                                isOutput: item.isOutput,
                                isGlitchText: item.isGlitchText
                            }]);
                        }
                        if (item.removeGold) {
                            setGoldDogVisible(false);
                            onRemoveGoldDog?.();
                        }
                    }, item.delay);
                });
            }, []);

            return (
                <div className={`h-full flex flex-col bg-black text-green-400 font-mono text-xs select-none ${isGlitching ? 'animate-pulse' : ''}`}>
                    <div className="p-2 border-b border-green-900 flex items-center gap-2">
                        <Icons.Terminal size={16} />
                        <span className="text-xs font-bold">DOG.TXT</span>
                    </div>
                    <div className="flex-grow overflow-auto p-3 space-y-0.5">
                        {lines.map((line, i) => (
                            <div
                                key={i}
                                className={`whitespace-pre-wrap ${
                                    line.isGlitchText
                                        ? 'text-red-500 text-sm font-bold mt-4 animate-pulse'
                                        : line.isOutput ? 'text-green-600' : 'text-green-300'
                                }`}
                                style={line.isGlitchText ? { textShadow: '0 0 10px rgba(255,0,0,0.5)' } : {}}
                            >
                                {line.text}
                            </div>
                        ))}
                        {!isGlitching && <span className="inline-block w-2 h-3 bg-green-400 animate-pulse" />}
                    </div>
                </div>
            );
        };

        // --- TERMINAL.EXE - Command line interface (v3.0 Narrative Bible) ---
        const TerminalApp = ({ onClose, onOpenApp, onReleaseDog, onMatrixMode, onUnlockPrivate, onAchievement, onGodMode, onUnlockApp, unlockedApps, thirdEyeActive, onDogEvent }) => {
            // Initial archived history
            const archivedHistory = [
                { type: 'archive', text: '[ARCHIVE] user@system:~$ ping mateus' },
                { type: 'archive', text: '[ARCHIVE] CONNECTION REFUSED' },
                { type: 'archive', text: '[ARCHIVE] user@system:~$ sudo access /personal' },
                { type: 'archive', text: '[ARCHIVE] ACCESS DENIED - CLEARANCE REQUIRED' },
                { type: 'archive', text: '[ARCHIVE] user@system:~$ help' },
                { type: 'archive', text: '[ARCHIVE] SESSION TERMINATED UNEXPECTEDLY' },
                { type: 'output', text: '' },
                { type: 'output', text: 'SYSTEM RECOVERY COMPLETE' },
                { type: 'output', text: 'DIAGNOSTICS RECOMMENDED.' },
                { type: 'output', text: 'PLEASE RUN chkdsk' },
                { type: 'output', text: '' }
            ];

            const [history, setHistory] = useState(() => {
                const stored = localStorage.getItem('terminal_history');
                return stored ? JSON.parse(stored) : archivedHistory;
            });

            // Save history to localStorage
            useEffect(() => {
                localStorage.setItem('terminal_history', JSON.stringify(history));
            }, [history]);
            const [input, setInput] = useState('');
            const [isLoading, setIsLoading] = useState(false);
            const [suggestion, setSuggestion] = useState('');
            const [awaitingKonami, setAwaitingKonami] = useState(false);
            const [konamiSequence, setKonamiSequence] = useState([]);
            const inputRef = useRef(null);
            const historyRef = useRef(null);
            const dotIntervalRef = useRef(null);

            // Cleanup interval on unmount
            useEffect(() => {
                return () => {
                    if (dotIntervalRef.current) clearInterval(dotIntervalRef.current);
                };
            }, []);

            // Konami code: up up down down left right left right b a
            const KONAMI_CODE = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'KeyB', 'KeyA'];

            // Public commands shown in help and autocomplete
            const commands = [
                'help', 'chkdsk', 'ping', 'sudo reveal', 'clear', 'exit', 'whoami', 'pwd', 'ls'
            ];

            // Check if app is unlocked
            const isAppUnlocked = (appId) => unlockedApps?.has(appId);

            useEffect(() => {
                if (historyRef.current) {
                    historyRef.current.scrollTop = historyRef.current.scrollHeight;
                }
            }, [history]);

            useEffect(() => {
                inputRef.current?.focus();
            }, [isLoading]);

            // Autocomplete
            useEffect(() => {
                if (input.length > 0) {
                    const match = commands.find(cmd => cmd.startsWith(input.toLowerCase()) && cmd !== input.toLowerCase());
                    setSuggestion(match || '');
                } else {
                    setSuggestion('');
                }
            }, [input]);

            // Handle konami code input when awaiting - 10 second timer
            const konamiTimerRef = useRef(null);
            const konamiSucceededRef = useRef(false);

            useEffect(() => {
                if (!awaitingKonami) {
                    // Clear timer when not awaiting
                    if (konamiTimerRef.current) {
                        clearTimeout(konamiTimerRef.current);
                        konamiTimerRef.current = null;
                    }
                    return;
                }

                // Reset success flag
                konamiSucceededRef.current = false;

                // Start 10 second timer
                konamiTimerRef.current = setTimeout(() => {
                    if (!konamiSucceededRef.current) {
                        addOutput('\nTIME EXPIRED.');
                        addOutput('ELEVATION FAILED.');
                        addOutput('RETURNING TO VOID...\n');
                        setAwaitingKonami(false);
                        setTimeout(() => {
                            window.location.href = 'https://mateusmuste.com';
                        }, 1500);
                    }
                }, 10000);

                const handleKeyDown = (e) => {
                    const key = e.code;
                    setKonamiSequence(prev => {
                        const newSeq = [...prev, key];
                        // Check if sequence matches so far
                        const expectedKey = KONAMI_CODE[prev.length];
                        if (key !== expectedKey) {
                            // Wrong key - reset
                            addOutput('INVALID CODE SEQUENCE. TRY AGAIN.');
                            addOutput('Listening for code...');
                            return [];
                        }
                        // Check if complete
                        if (newSeq.length === KONAMI_CODE.length) {
                            // Success! Mark as succeeded and clear timer
                            konamiSucceededRef.current = true;
                            sounds.konamiActivate();
                            if (konamiTimerRef.current) {
                                clearTimeout(konamiTimerRef.current);
                                konamiTimerRef.current = null;
                            }
                            setTimeout(() => {
                                addOutput('\nCODE ACCEPTED.\n');
                                addOutput('ELEVATION COMPLETE.\n');
                                addOutput('YOU HAVE BECOME.\n');
                                addOutput('\n');
                                addOutput('TRUTH.EXE RELOCATED\n');
                                addOutput('BONUS CONTENT UNLOCKED:');
                                addOutput(' RADIO.WAV');
                                addOutput(' POMODORO.EXE');
                                addOutput(' SCANNER.EXE\n');
                                addOutput('');
                                setAwaitingKonami(false);
                                onAchievement?.('BECOME_GOD');
                                onGodMode?.();
                            }, 500);
                            return [];
                        }
                        return newSeq;
                    });
                };

                window.addEventListener('keydown', handleKeyDown);
                return () => {
                    window.removeEventListener('keydown', handleKeyDown);
                    if (konamiTimerRef.current) {
                        clearTimeout(konamiTimerRef.current);
                    }
                };
            }, [awaitingKonami]);

            const addOutput = (text) => {
                setHistory(prev => [...prev, { type: 'output', text }]);
            };

            const executeCommand = async (cmd) => {
                if (awaitingKonami) return; // Don't process commands while waiting for konami
                sounds.terminalSubmit();

                const trimmed = cmd.trim().toLowerCase();
                setHistory(prev => [...prev, { type: 'input', text: `user@system:~$ ${cmd}` }]);
                setInput('');
                setIsLoading(true);

                // Random loading time 0.5-1.5 seconds
                const loadTime = 500 + Math.random() * 1000;

                // Show loading dots
                let dots = '';
                dotIntervalRef.current = setInterval(() => {
                    dots = dots.length >= 3 ? '.' : dots + '.';
                    setHistory(prev => {
                        const newHist = [...prev];
                        if (newHist[newHist.length - 1]?.type === 'loading') {
                            newHist[newHist.length - 1].text = dots;
                        } else {
                            newHist.push({ type: 'loading', text: dots });
                        }
                        return newHist;
                    });
                }, 300);

                await new Promise(resolve => setTimeout(resolve, loadTime));
                clearInterval(dotIntervalRef.current);

                // Remove loading entry
                setHistory(prev => prev.filter(h => h.type !== 'loading'));
                setIsLoading(false);

                // Process commands
                if (trimmed === 'help') {
                    // Base help - shown normally
                    let helpText = `AVAILABLE COMMANDS:
  help ............. show this menu
  list user ........ show registered users
  ping [user] ...... attempt connection
  sudo reveal ...... unlock hidden layer
  clear ............ clear terminal
  chkdsk ........... run system diagnostics`;

                    // If Third Eye is active, show hidden command with redaction
                    if (thirdEyeActive) {
                        helpText += `
  cmatrix .......... `;
                    }

                    addOutput(helpText);
                    onDogEvent?.('runHelp');

                } else if (trimmed === 'list user') {
                    addOutput(`REGISTERED USERS:
  MATEUS ........... ADMIN
   ......... 
  UNKNOWN .......... CURRENT`);
                    onDogEvent?.('runListUsers');

                } else if (trimmed === 'chkdsk') {
                    addOutput('SCANNING SYSTEM...\n');
                    await new Promise(r => setTimeout(r, 1000));

                    const apps = [
                        { name: 'VOID.EXE', id: 'VOID' },
                        { name: 'PAINT.EXE', id: 'PAINT' },
                        { name: 'SNEK.EXE', id: 'SNAKE' },
                        { name: 'LABYRINTH.EXE', id: 'LABYRINTH' },
                        { name: 'MINESWEEPER.EXE', id: 'MINESWEEPER' },
                        { name: 'STARSHIP.EXE', id: 'STARSHIP' },
                        { name: 'DICE.EXE', id: 'DICE' },
                        { name: 'TAROT.DAT', id: 'TAROT' },
                        { name: 'RADIO.WAV', id: 'RADIO' },
                        { name: 'POMODORO.EXE', id: 'POMODORO' },
                        { name: 'MAP.EXE', id: 'MAP' },
                        { name: 'BOOKS.EXE', id: 'BOOKS' },
                        { name: 'PRIVATE.EXE', id: 'PERSONAL' },
                        { name: 'SCANNER.EXE', id: 'SCANNER' },
                        { name: 'BROWSER.EXE', id: 'BROWSER' },
                        { name: 'THIRD_EYE.EXE', id: 'THIRD_EYE' },
                        { name: 'THIRD_EYE_2.EXE', id: 'THIRD_EYE_2' },
                        { name: 'DESTRUCTION.EXE', id: 'DESTRUCTION' },
                        { name: 'DOG.EXE', id: 'DOG_STORY' },
                        { name: 'DOG_GOLD.EXE', id: 'GOLDY' },
                        { name: 'TRUTH.EXE', id: 'TRUTH', special: true }
                    ];

                    let output = 'RECOVERED APPLICATIONS:\n';
                    let locked = 0;
                    apps.forEach(app => {
                        const status = app.special ? 'FILE MISSING' :
                                      isAppUnlocked(app.id) ? 'OK' : 'LOCKED';
                        if (status === 'LOCKED') locked++;
                        const padding = '.'.repeat(Math.max(1, 22 - app.name.length));
                        output += ` ${app.name} ${padding} ${status}\n`;
                    });
                    output += `\nTOTAL: 21 APPLICATIONS\nSTATUS: ${locked} LOCKED, ${apps.filter(a => a.special).length} MISSING\n`;
                    output += "\n> TYPE 'help' FOR AVAILABLE COMMANDS";
                    addOutput(output);
                    onDogEvent?.('runChkdsk');

                } else if (trimmed === 'sudo reveal') {
                    addOutput('REVEALING HIDDEN LAYER...\n');
                    await new Promise(r => setTimeout(r, 500));
                    addOutput(' 100%\n');
                    addOutput('THIRD_EYE.EXE UNLOCKED');
                    onUnlockApp?.('THIRD_EYE');
                    onDogEvent?.('runSudoReveal');

                } else if (trimmed === 'ping mateus' || trimmed === 'ping mateus') {
                    addOutput('PINGING MATEUS...\n');
                    await new Promise(r => setTimeout(r, 1500));
                    addOutput('...\n...\n...\n');
                    addOutput('CONNECTION REFUSED\n');
                    await new Promise(r => setTimeout(r, 500));
                    addOutput('...\n');
                    addOutput('BUT SOMETHING RESPONDED.\n');
                    addOutput('PAINT.EXE UNLOCKED');
                    onUnlockApp?.('PAINT');
                    onDogEvent?.('runPingMateus');

                } else if (trimmed === 'cmatrix') {
                    addOutput('MATRIX PROTOCOL INITIATED...\n');
                    // Turn on matrix mode
                    setTimeout(() => onMatrixMode?.(), 300);
                    // Turn off after 2 seconds and show completion
                    setTimeout(() => {
                        onMatrixMode?.(); // Toggle off
                        addOutput('MATRIX PROTOCOL COMPLETE\n');
                        addOutput('VOID.EXE UNLOCKED');
                        onUnlockApp?.('VOID');
                    }, 2300);
                    onDogEvent?.('runCmatrix');

                } else if (trimmed === 'sudo unlock') {
                    addOutput('UNLOCKING RESTRICTED ACCESS...\n');
                    await new Promise(r => setTimeout(r, 500));
                    addOutput(' 100%\n');
                    addOutput('PRIVATE.EXE REVEALED');
                    addOutput('WARNING: PASSWORD PROTECTED');
                    onUnlockApp?.('PERSONAL');
                    onDogEvent?.('runSudoUnlock');

                } else if (trimmed === 'sudo chmod 777 /private') {
                    addOutput('CHANGING PERMISSIONS...\n');
                    addOutput('/private');
                    addOutput('   read ........ ');
                    addOutput('   write ....... ');
                    addOutput('   execute ..... \n');
                    addOutput('PRIVATE.EXE UNLOCKED');
                    onUnlockPrivate?.();
                    onAchievement?.('LOCKSMITH');
                    onDogEvent?.('runChmod');

                } else if (trimmed === 'sudo stars') {
                    addOutput('TARGETING SYSTEMS ONLINE...\n');
                    await new Promise(r => setTimeout(r, 500));
                    addOutput(' 100%\n');
                    addOutput('STARSHIP.EXE UNLOCKED');
                    onUnlockApp?.('STARSHIP');
                    onDogEvent?.('runSudoStars');

                } else if (trimmed === 'sudo unlock zen') {
                    addOutput('ZEN PATHWAY ACTIVATED\n');
                    addOutput('BROWSER.EXE UNLOCKED');
                    onUnlockApp?.('BROWSER');

                } else if (trimmed === 'sudo extract revelation') {
                    addOutput('ELEVATION SEQUENCE INITIATED...\n');
                    await new Promise(r => setTimeout(r, 1000));
                    addOutput('Listening for code...');
                    setAwaitingKonami(true);
                    setKonamiSequence([]);

                } else if (trimmed === 'exit') {
                    addOutput('There is no escape.');
                } else if (trimmed === 'clear') {
                    setHistory([]);
                } else if (trimmed === 'whoami') {
                    addOutput('guest');
                } else if (trimmed === 'pwd') {
                    addOutput('/home/guest');
                } else if (trimmed === 'ls') {
                    addOutput('Desktop  Documents  Downloads  .secrets  /apps  /private');
                } else if (trimmed === 'reset') {
                    addOutput('Wiping consciousness...\nReturning to void...');
                    setTimeout(() => {
                        localStorage.clear();
                        window.location.reload();
                    }, 1500);
                } else if (trimmed === 'systemctl start dog.exe') {
                    addOutput('Starting dog.exe...\n[  OK  ] Started dog.exe');
                    setTimeout(() => onReleaseDog?.(), 500);
                } else if (trimmed) {
                    sounds.error();
                    addOutput(`bash: ${trimmed.split(' ')[0]}: command not found`);
                }
            };

            const handleKeyDown = (e) => {
                if (awaitingKonami) {
                    e.preventDefault();
                    return;
                }
                if (e.key === 'Enter' && !isLoading) {
                    executeCommand(input);
                } else if (e.key === 'Tab' && suggestion) {
                    e.preventDefault();
                    setInput(suggestion);
                    setSuggestion('');
                }
            };

            return (
                <div className="h-full flex flex-col bg-black text-green-400 font-mono text-sm select-none">
                    <div className="p-2 border-b border-green-900 flex items-center gap-2">
                        <Icons.Terminal size={16} />
                        <span className="text-xs font-bold">TERMINAL.EXE</span>
                        {awaitingKonami && <span className="text-white text-xs animate-pulse ml-auto">AWAITING INPUT...</span>}
                    </div>
                    <div ref={historyRef} className="flex-grow overflow-auto p-3 space-y-1">
                        {history.map((item, i) => (
                            <div key={i} className={
                                item.type === 'archive' ? 'text-green-700' :
                                item.type === 'input' ? 'text-green-300' :
                                item.type === 'loading' ? 'text-green-600 animate-pulse' :
                                'text-green-400 whitespace-pre-wrap'
                            }>
                                {item.text}
                            </div>
                        ))}
                    </div>
                    <div className="p-3 border-t border-green-900 relative">
                        {suggestion && !isLoading && !awaitingKonami && (
                            <div className="absolute -top-6 left-3 bg-green-900/80 text-green-300 px-2 py-0.5 text-xs rounded">
                                {suggestion} <span className="text-green-600">[TAB]</span>
                            </div>
                        )}
                        <div className="flex items-center gap-2">
                            <span className="text-green-500">user@system:~$</span>
                            <input
                                ref={inputRef}
                                type="text"
                                aria-label="Terminal command input"
                                value={input}
                                onChange={(e) => !awaitingKonami && setInput(e.target.value)}
                                onKeyDown={handleKeyDown}
                                disabled={isLoading || awaitingKonami}
                                className="flex-grow bg-transparent border-none outline-none text-green-300 placeholder-green-800"
                                placeholder={awaitingKonami ? 'Enter code sequence...' : isLoading ? '' : 'Enter command...'}
                                autoFocus
                            />
                            {(isLoading || awaitingKonami) && <span className="animate-pulse">_</span>}
                        </div>
                    </div>
                </div>
            );
        };

        // --- THIRD_EYE.EXE - X-ray view of app code ---
        const ThirdEyeApp = ({ windowId, windows, stackOverflow, stackErrors, iconPositions, onOpenTruth, onDogEvent }) => {
            const thisWindow = windows[windowId];
            const windowX = thisWindow?.x || 0;
            const windowY = thisWindow?.y || 0;
            const windowW = thisWindow?.w || 400;
            const windowH = thisWindow?.h || 300;
            // Account for window header height (approx 32px)
            const headerHeight = 32;

            // Check if TRUTH icon is within this Third Eye's bounds
            const isTruthInBounds = () => {
                const truthPos = iconPositions?.TRUTH;
                if (!truthPos) return false;
                const iconSize = 80;
                const iconCenterX = truthPos.x + iconSize / 2;
                const iconCenterY = truthPos.y + iconSize / 2;
                return iconCenterX >= windowX && iconCenterX <= windowX + windowW &&
                       iconCenterY >= windowY + headerHeight && iconCenterY <= windowY + windowH;
            };

            // Handle click on Third Eye - if TRUTH is in bounds, open it
            const handleClick = () => {
                if (isTruthInBounds() && onOpenTruth) {
                    onOpenTruth();
                    onDogEvent?.('scanTruth');
                }
            };

            // Check if PERSONAL window is visible in the portal view
            const isPersonalVisible = windows.PERSONAL?.isOpen && !windows.PERSONAL?.isMin;
            const personalVisibleRef = useRef(false);

            useEffect(() => {
                if (isPersonalVisible && !personalVisibleRef.current) {
                    personalVisibleRef.current = true;
                    onDogEvent?.('scanPrivate');
                }
            }, [isPersonalVisible]);

            // Check if TERMINAL window is visible in the portal view
            const isTerminalVisible = windows.TERMINAL?.isOpen && !windows.TERMINAL?.isMin;
            const terminalScanRef = useRef(false);

            useEffect(() => {
                if (isTerminalVisible && !terminalScanRef.current) {
                    terminalScanRef.current = true;
                    onDogEvent?.('terminalScan');
                }
            }, [isTerminalVisible]);

            // Check if VOID window is actually visible THROUGH this Third Eye (overlapping)
            const isVoidOverlapping = () => {
                const voidWin = windows.VOID;
                if (!voidWin?.isOpen || voidWin?.isMin) return false;
                // Check if VOID window overlaps with this Third Eye's portal area
                const voidX = voidWin.x || 0;
                const voidY = voidWin.y || 0;
                const voidW = voidWin.w || 400;
                const voidH = voidWin.h || 300;
                // Portal area is the Third Eye window minus header
                const portalLeft = windowX;
                const portalTop = windowY + headerHeight;
                const portalRight = windowX + windowW;
                const portalBottom = windowY + windowH;
                // Check for rectangle overlap
                return !(voidX + voidW < portalLeft || voidX > portalRight ||
                         voidY + voidH < portalTop || voidY > portalBottom);
            };
            const voidScanRef = useRef(false);

            useEffect(() => {
                if (isVoidOverlapping() && !voidScanRef.current) {
                    voidScanRef.current = true;
                    onDogEvent?.('voidScan');
                }
            }, [windows.VOID?.isOpen, windows.VOID?.isMin, windows.VOID?.x, windows.VOID?.y, windowX, windowY]);

            // Trigger triggerInception when stack overflow occurs
            const inceptionTriggeredRef = useRef(false);
            useEffect(() => {
                if (stackOverflow && !inceptionTriggeredRef.current) {
                    inceptionTriggeredRef.current = true;
                    onDogEvent?.('triggerInception');
                }
            }, [stackOverflow]);

            const appCode = {
                SNAKE: `// SNEK.JS\nfunction eat() {\n  grow();\n  // ouroboros.exe\n  if (head === tail) become(god);\n}`,
                MINESWEEPER: `// MINES.SYS\nbool click(x, y) {\n  if (bomb[x][y]) die();\n  // "I am become death"\n  return survive();\n}`,
                STARSHIP: `// STARFOX.ASM\n; DO A BARREL ROLL\nlaser.pewpew();\nasteroid.dodge();`,
                DICE: `// RNG.GOD\nlet fate = Math.random();\nif (result === 1) // skill issue`,
                LABYRINTH: `// MAZE.RUNNER\nwhile (!escaped) {\n  turn_right();\n  move_forward();\n}`,
                PAINT: `// ART.EXE\ncanvas.soil(pos, color);\n// art is destruction`,
                TAROT: `// CARDS.FATE\ndeck.shuffle();\nreveal(destiny);`,
                VOID: `// VOID.NULL - DISCARDED NOTES\n\n[DISCARDED] Note 38: Fix physics on smaller desktops.\n\n[DISCARDED] Note 39: Third eye seems to be the only app that can open twice. Intriguing. Stacking 2 of them together generates a .\n\n[DISCARDED] Note 40: There shouldn't be 21 apps. We made only 20 apps... There must be a bug in the . Note to fix it.`,
                RADIO: `// STREAM.WAV\naudio.play(frequency);`,
                TERMINAL: `// CMD.EXE\nif (cmd === "exit") print("no escape");\n\n// HIDDEN COMMANDS:\n// cmatrix `,
                SYSTEM: `// KERNEL.SYS\nif (konami_code()) observe_all();`,
                POMODORO: `// TIME.LOOP\nwork(25); rest(5);`,
                MAP: `// GLOBE.ROTATE\nrender_sphere(phi++);`,
                BROWSER: `// EXPLORE.NET\nif (url === self) reboot();`,
                DESTRUCTION: `// CHAOS.EXE\nreality.invert();\ndog.release();`,
                CONTACT: `// MAIL.SEND\nclipboard.copy(email);`,
                TRASH: `// RECYCLE.BIN\ndelete item;`,
                SCANNER: `// HEALTH.CHK\ndiagnosis = "probably fine";`,
                THIRD_EYE: `// OBSERVE.SYS\nif (observer_observed)\n  STACK_OVERFLOW();`,
                THIRD_EYE_2: `// OBSERVE.SYS\nif (observer_observed)\n  STACK_OVERFLOW();`,
                FILES: `// EXPLORER.SYS\nlist(directories);`,
                APPS: `// LAUNCHER.EXE\nopen(selected_app);`,
                PERSONAL: `// PRIVATE.EXE - MAINTENANCE LOG\n\n[MAINTENANCE LOG]\nTo bypass authentication, execute:\nsudo chmod 777 /private`,
            };

            const defaultCode = `// UNKNOWN.DAT\nreturn mysterious();`;

            // Desktop icons to show in portal
            const desktopIconIds = ['SYSTEM', 'FILES', 'APPS', 'CONTACT', 'TRUTH'];

            // Stack overflow display with rapid scrolling errors and flashing
            const [flashSpeed, setFlashSpeed] = useState(500);
            const [displayErrors, setDisplayErrors] = useState([]);

            // Generate looping error commands
            useEffect(() => {
                if (stackOverflow) {
                    // Accelerate flash speed over time
                    const accelerate = setInterval(() => {
                        setFlashSpeed(prev => Math.max(50, prev - 30));
                    }, 500);

                    // Loop through 10 commands continuously
                    const commands = [
                        'FATAL: recursive observation detected',
                        'ERR: infinite loop in render_self()',
                        'PANIC: stack depth exceeded at 0xDEADBEEF',
                        'kernel: observer paradox imminent',
                        'CRITICAL: reality buffer overflow',
                        'ERR: cannot observe the observer',
                        'FATAL: ego_death.exe initiated',
                        'PANIC: consciousness stack corrupted',
                        'ERR: universe out of memory',
                        'FATAL: existence.so not found',
                    ];
                    let idx = 0;
                    const cmdInterval = setInterval(() => {
                        setDisplayErrors(prev => {
                            const next = [...prev, commands[idx % commands.length]];
                            idx++;
                            return next.slice(-15); // Keep last 15
                        });
                    }, 50);

                    return () => {
                        clearInterval(accelerate);
                        clearInterval(cmdInterval);
                    };
                } else {
                    setDisplayErrors([]);
                    setFlashSpeed(500);
                }
            }, [stackOverflow]);

            if (stackOverflow) {
                return (
                    <div
                        className="h-full flex flex-col bg-black text-red-500 font-mono select-none overflow-hidden relative"
                        style={{ animation: `stackFlash ${flashSpeed}ms infinite` }}
                    >
                        {/* Intense red flash overlay */}
                        <div
                            className="absolute inset-0 pointer-events-none"
                            style={{
                                background: `rgba(255,0,0,${0.1 + (500 - flashSpeed) / 800})`,
                                animation: `stackFlash ${flashSpeed}ms infinite`
                            }}
                        />
                        <div className="flex-grow flex flex-col p-3 overflow-hidden relative z-10">
                            <div className="text-red-500 text-xl font-bold mb-2 text-center" style={{ textShadow: '0 0 10px #f00' }}>
                                 STACK OVERFLOW 
                            </div>
                            <div className="text-red-400 text-xs mb-3 text-center animate-pulse">
                                recursive observation detected
                            </div>
                            <div className="flex-grow text-left w-full overflow-hidden">
                                {displayErrors.map((err, i) => (
                                    <div
                                        key={i}
                                        className="text-red-400 text-[11px] leading-relaxed font-mono"
                                        style={{ textShadow: '0 0 5px #f00' }}
                                    >
                                        {`> ${err}`}
                                    </div>
                                ))}
                                <div className="text-red-500 animate-pulse text-[11px]">{'> _'}</div>
                            </div>
                        </div>
                    </div>
                );
            }

            return (
                <div
                    className="h-full w-full overflow-hidden relative bg-black cursor-pointer"
                    onClick={handleClick}
                >
                    {/* PORTAL VIEW - Alternate reality desktop - clicking opens TRUTH if it's in bounds */}
                    <div
                        className="absolute"
                        style={{
                            width: '100vw',
                            height: '100vh',
                            left: -windowX,
                            top: -(windowY + headerHeight),
                            filter: 'invert(1) hue-rotate(180deg)',
                            background: '#000'
                        }}
                    >
                        {/* Wireframe grid background */}
                        <div className="absolute inset-0" style={{
                            backgroundImage: 'linear-gradient(rgba(0,255,0,0.1) 1px, transparent 1px), linear-gradient(90deg, rgba(0,255,0,0.1) 1px, transparent 1px)',
                            backgroundSize: '40px 40px'
                        }} />

                        {/* Desktop icons in portal view */}
                        {desktopIconIds.map(id => {
                            const pos = iconPositions[id];
                            if (!pos) return null;
                            return (
                                <div
                                    key={id}
                                    className="absolute flex flex-col items-center"
                                    style={{ left: pos.x, top: pos.y, width: 80 }}
                                >
                                    <div className="w-12 h-12 border-2 border-green-500 flex items-center justify-center text-green-500 text-xs font-mono">
                                        {'</>'}
                                    </div>
                                    <div className="text-green-500 text-[8px] font-mono mt-1 text-center">{id}</div>
                                </div>
                            );
                        })}

                        {/* Portal windows - show as wireframe with code */}
                        {Object.entries(windows)
                            .filter(([id]) => id !== windowId && id !== 'DOG_STORY' && id !== 'TRUTH')
                            .filter(([, win]) => win.isOpen && !win.isMin)
                            .map(([id, win]) => (
                                <div
                                    key={id}
                                    className="absolute border-2 border-green-500 bg-black/80"
                                    style={{
                                        left: win.x,
                                        top: win.y,
                                        width: win.w,
                                        height: win.h,
                                    }}
                                >
                                    {/* Window header wireframe */}
                                    <div className="border-b-2 border-green-500 px-2 py-1 flex items-center gap-2">
                                        <div className="w-2 h-2 border border-green-500" />
                                        <span className="text-green-500 text-[10px] font-mono">{win.title}</span>
                                    </div>
                                    {/* Code content */}
                                    <div className="p-2 overflow-hidden h-full">
                                        <pre className="text-green-400 text-[8px] font-mono leading-relaxed whitespace-pre-wrap opacity-80">
                                            {appCode[id] || defaultCode}
                                        </pre>
                                    </div>
                                </div>
                            ))
                        }
                    </div>

                    {/* Corner indicators */}
                    <div className="absolute top-1 left-1 text-green-500 text-[8px] font-mono z-50 bg-black/50 px-1"> THIRD_EYE</div>
                    <div className="absolute bottom-1 right-1 text-green-500 text-[8px] font-mono z-50 bg-black/50 px-1">SCANNING</div>
                </div>
            );
        };

        // --- TRUTH.TXT - Unlocked at 100 visits, password never works ---
        const TruthApp = ({ onAchievement, onOpenTruthMessages, godModeCompleted }) => {
            const hasTriggeredRef = useRef(false);

            // useEffect must be called unconditionally (React hooks rule)
            useEffect(() => {
                if (godModeCompleted && !hasTriggeredRef.current) {
                    hasTriggeredRef.current = true;
                    // Intentional glitch effect - play sound multiple times rapidly
                    for (let i = 0; i < 10; i++) {
                        setTimeout(() => sounds.truthReveal(), i * 15);
                    }
                    // Open TRUTH_MESSAGES after glitch
                    setTimeout(() => onOpenTruthMessages?.(), 500);
                }
            }, [godModeCompleted]);

            // After god mode - show accessing message (TRUTH_MESSAGES will open)
            if (godModeCompleted) {
                return (
                    <div className="h-full flex flex-col bg-black select-none">
                        <div className="p-2 border-b border-green-900 bg-black flex items-center gap-2">
                            <Icons.FileDoc size={16} />
                            <span className="font-mono text-xs font-bold text-green-500">TRUTH.EXE</span>
                        </div>
                        <div className="flex-grow flex flex-col items-center justify-center p-6">
                            <div className="mb-4 text-green-500 animate-pulse">
                                <Icons.FileDoc size={48} />
                            </div>
                            <div className="font-mono text-green-500 text-sm font-bold mb-2">ACCESSING TRUTH...</div>
                        </div>
                    </div>
                );
            }

            // Before god mode - show FILE MISSING
            return (
                <div className="h-full flex flex-col bg-black select-none">
                    <div className="p-2 border-b border-red-900 bg-black flex items-center gap-2">
                        <Icons.FileDoc size={16} />
                        <span className="font-mono text-xs font-bold text-red-500">TRUTH.EXE</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-6">
                        <div className="mb-4 text-red-500">
                            <Icons.FileDoc size={48} />
                        </div>
                        <div className="font-mono text-red-500 text-lg font-bold mb-2">FILE MISSING</div>
                    </div>
                </div>
            );
        };

        // --- PRIVATE.EXE - Password Protected (with DOG.TXT reveal when unlocked) ---
        const PersonalApp = ({ unlocked, onOpenDogStory }) => {
            const [password, setPassword] = useState('');
            const [attempts, setAttempts] = useState(0);
            const [error, setError] = useState('');
            const [shaking, setShaking] = useState(false);
            const [revealPhase, setRevealPhase] = useState(0); // 0: closed, 1: opening, 2: file approaching, 3: file revealed

            useEffect(() => {
                if (unlocked && revealPhase === 0) {
                    sounds.passwordCorrect();
                    setRevealPhase(1);
                    setTimeout(() => setRevealPhase(2), 3000); // File starts appearing at 3s
                    setTimeout(() => setRevealPhase(3), 10000); // Fully revealed at 10s
                }
            }, [unlocked]);

            const handleSubmit = (e) => {
                e.preventDefault();
                sounds.passwordWrong();
                setAttempts(a => a + 1);
                setShaking(true);
                setTimeout(() => setShaking(false), 500);

                const errors = [
                    'ACCESS DENIED',
                    'INVALID CREDENTIALS',
                    'AUTHENTICATION FAILED',
                    'PERMISSION DENIED',
                    'UNAUTHORIZED ACCESS',
                    'INCORRECT PASSWORD',
                    'SECURITY VIOLATION',
                    'ACCESS RESTRICTED',
                    'VERIFICATION FAILED',
                    'ENTRY PROHIBITED'
                ];
                setError(errors[Math.floor(Math.random() * errors.length)]);
                setPassword('');
            };

            // Unlocked reveal animation
            if (unlocked) {
                return (
                    <div className="h-full flex flex-col bg-white select-none overflow-hidden relative">
                        {/* Sliding panels - 10 second animation */}
                        <div
                            className="absolute top-0 left-0 right-0 bg-black z-10 flex items-end justify-center"
                            style={{
                                height: '50%',
                                transform: revealPhase >= 1 ? 'translateY(-100%)' : 'translateY(0)',
                                transition: 'transform 10s ease-in-out'
                            }}
                        >
                            <div className="font-mono text-red-500 text-xs mb-4">DECRYPTING...</div>
                        </div>
                        <div
                            className="absolute bottom-0 left-0 right-0 bg-black z-10 flex items-start justify-center"
                            style={{
                                height: '50%',
                                transform: revealPhase >= 1 ? 'translateY(100%)' : 'translateY(0)',
                                transition: 'transform 10s ease-in-out'
                            }}
                        >
                            <div className="font-mono text-red-500 text-xs mt-4">LOADING SECRETS...</div>
                        </div>

                        {/* DOG.TXT file - slowly grows and fades in */}
                        <div className="absolute inset-0 flex items-center justify-center">
                            <div
                                style={{
                                    transform: `scale(${revealPhase < 2 ? 0.2 : revealPhase < 3 ? 0.2 + ((revealPhase - 2) * 0.8) : 1})`,
                                    opacity: revealPhase < 2 ? 0 : revealPhase < 3 ? 0.3 : 1,
                                    transition: 'transform 7s ease-out, opacity 7s ease-out'
                                }}
                            >
                                <button
                                    onClick={() => onOpenDogStory?.()}
                                    className="text-center cursor-pointer group"
                                    disabled={revealPhase < 3}
                                    style={{ pointerEvents: revealPhase < 3 ? 'none' : 'auto' }}
                                >
                                    <div className="bg-white border-4 border-black p-6 group-hover:bg-gray-100 transition-colors">
                                        <Icons.FileDoc size={64} />
                                    </div>
                                    <div className="font-mono text-black text-lg font-bold mt-4">DOG.TXT</div>
                                    <div className="font-mono text-gray-600 text-xs mt-2 group-hover:text-black" style={{ opacity: revealPhase >= 3 ? 1 : 0 }}>Click to open</div>
                                </button>
                            </div>
                        </div>
                    </div>
                );
            }

            return (
                <div className="h-full flex flex-col bg-black select-none overflow-hidden">
                    <div className="p-2 border-b border-red-900 bg-black flex items-center gap-2 text-red-500">
                        <Icons.Lock size={16} />
                        <span className="font-mono text-xs font-bold">PRIVATE.EXE</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-6 text-red-500">
                        <div className="mb-4">
                            <Icons.Lock size={48} />
                        </div>
                        <div className="font-mono text-sm font-bold mb-4">SECURE AREA</div>

                        <form onSubmit={handleSubmit} className={`w-56 ${shaking ? 'animate-shake' : ''}`}>
                            <input
                                type="password"
                                aria-label="Enter password for secure area"
                                value={password}
                                onChange={(e) => setPassword(e.target.value)}
                                placeholder="PASSWORD"
                                className="w-full px-3 py-2 mb-3 bg-black border-2 border-red-800 text-red-500 font-mono text-sm placeholder-red-900 focus:outline-none focus:border-red-500"
                            />
                            <button
                                type="submit"
                                className="w-full px-3 py-2 bg-red-900 text-red-100 font-mono text-xs font-bold hover:bg-red-800 border-2 border-red-700"
                            >
                                AUTHENTICATE
                            </button>
                        </form>

                        {error && (
                            <div className="mt-4 p-2 border border-red-800 bg-red-950">
                                <div className="font-mono text-red-500 text-xs font-bold">{error}</div>
                            </div>
                        )}

                        {attempts > 0 && (
                            <div className="mt-3 font-mono text-red-800 text-[10px]">
                                FAILED: {attempts}
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // --- APPS Folder - Shows ALL apps with locked/unlocked states ---
        const AppsFolder = ({ onOpenApp, onDragStart, isMobile, unlockedApps }) => {
            // All available apps organized by narrative progression order
            const ALL_APPS = [
                // Core - always available after intro
                { id: 'TERMINAL', title: 'TERMINAL.EXE', icon: 'Terminal', category: 'CORE' },
                { id: 'STARSHIP', title: 'STARSHIP.EXE', icon: 'Starship', category: 'CORE' },
                { id: 'TAROT', title: 'TAROT.DAT', icon: 'Tarot', category: 'CORE' },

                // Narrative progression apps (unlock in order through gameplay)
                { id: 'THIRD_EYE', title: 'THIRD_EYE.EXE', icon: 'ThirdEye', category: 'LOCKED' },
                { id: 'PAINT', title: 'PAINT.EXE', icon: 'Palette', category: 'LOCKED' },
                { id: 'VOID', title: 'VOID.EXE', icon: 'Void', category: 'LOCKED' },
                { id: 'SNAKE', title: 'SNEK.EXE', icon: 'Snek', category: 'LOCKED' },
                { id: 'PERSONAL', title: 'PRIVATE.EXE', icon: 'Lock', category: 'LOCKED' },
                { id: 'MAP', title: 'MAP.EXE', icon: 'Globe', category: 'LOCKED' },
                { id: 'LABYRINTH', title: 'LABYRINTH.EXE', icon: 'Labyrinth', category: 'LOCKED' },
                { id: 'MINESWEEPER', title: 'MINESWEEPER.EXE', icon: 'Minesweeper', category: 'LOCKED' },
                { id: 'BOOKS', title: 'BOOKS.EXE', icon: 'FileDoc', category: 'LOCKED' },
                { id: 'DICE', title: 'DICE.EXE', icon: 'Dice', category: 'LOCKED' },
                { id: 'BROWSER', title: 'BROWSER.EXE', icon: 'Browser', category: 'LOCKED' },
                { id: 'DESTRUCTION', title: 'DESTRUCTION.EXE', icon: 'Destruction', category: 'LOCKED' },

                // Bonus apps (unlock after god mode)
                { id: 'RADIO', title: 'RADIO.WAV', icon: 'Radio', category: 'BONUS' },
                { id: 'POMODORO', title: 'POMODORO.EXE', icon: 'Pomodoro', category: 'BONUS' },
                { id: 'SCANNER', title: 'SCANNER.EXE', icon: 'HealthScanner', category: 'BONUS' },

                // Special
                { id: 'END', title: 'ACHIEVEMENTS', icon: 'Trophy', category: 'CORE' }
            ];

            // Filter for mobile
            const visibleApps = isMobile ? ALL_APPS.filter(app => !app.desktopOnly) : ALL_APPS;

            // Count stats
            const unlockedCount = visibleApps.filter(app => unlockedApps?.has(app.id)).length;
            const totalCount = visibleApps.length;

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex items-center gap-2">
                        <Icons.Apps size={24} />
                        <span className="app-header-title">APPS</span>
                        <span className="app-footer-text ml-auto">{unlockedCount}/{totalCount} UNLOCKED</span>
                    </div>
                    <div className="flex-grow overflow-auto">
                        <div className="grid grid-cols-4 md:grid-cols-5 gap-2 p-4">
                            {visibleApps.map((app) => {
                                const AppIcon = Icons[app.icon];
                                const isUnlocked = unlockedApps?.has(app.id);
                                return (
                                    <div
                                        key={app.id}
                                        className={`relative flex flex-col items-center gap-1 p-2 border-2 cursor-pointer ${
                                            isUnlocked
                                                ? 'border-black hover:bg-yellow-100 active:bg-yellow-100'
                                                : 'border-gray-300 bg-gray-100 opacity-50'
                                        }`}
                                        onClick={() => isUnlocked && onOpenApp(app.id)}
                                        draggable={isUnlocked && !isMobile}
                                        onDragStart={(e) => isUnlocked && !isMobile && onDragStart?.(e, app.id, app.title, app.icon)}
                                    >
                                        <div className={`p-2 ${isUnlocked ? '' : 'grayscale'}`}>
                                            <AppIcon size={32} />
                                        </div>
                                        <span className={`font-mono text-[8px] text-center font-bold truncate w-full ${!isUnlocked && 'text-gray-400'}`}>
                                            {isUnlocked ? app.title : '???'}
                                        </span>
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                    <div className="app-footer border-t-2 border-black p-2">
                        <span className="app-footer-text">Earn achievements to unlock apps</span>
                    </div>
                </div>
            );
        };

        // --- BROWSER - App search with autocomplete ---
        const BrowserApp = ({ onOpenApp, onAchievement, isMobile }) => {
            const [url, setUrl] = useState('');
            const [showSuggestions, setShowSuggestions] = useState(false);

            // All searchable items (apps from all categories + desktop items)
            const allItems = [
                // Desktop items
                { id: 'SYSTEM', title: 'SYSTEM_INFO', icon: 'Terminal' },
                { id: 'FILES', title: 'MEDIA_LIB', icon: 'Folder' },
                { id: 'APPS', title: 'APPS', icon: 'Apps' },
                { id: 'CONTACT', title: 'CONTACT', icon: 'Email' },
                // Games
                { id: 'SNAKE', title: 'SNEK.EXE', icon: 'Snek' },
                { id: 'LABYRINTH', title: 'LABYRINTH.EXE', icon: 'Labyrinth' },
                { id: 'MINESWEEPER', title: 'MINESWEEPER.EXE', icon: 'Minesweeper' },
                { id: 'STARSHIP', title: 'STARSHIP.EXE', icon: 'Starship' },
                { id: 'DICE', title: 'DICE.EXE', icon: 'Dice' },
                // Productivity
                { id: 'PAINT', title: 'PAINT.EXE', icon: 'Palette' },
                { id: 'TERMINAL', title: 'TERMINAL.EXE', icon: 'Terminal' },
                { id: 'POMODORO', title: 'POMODORO.EXE', icon: 'Pomodoro' },
                { id: 'RADIO', title: 'RADIO.WAV', icon: 'Radio' },
                { id: 'SCANNER', title: 'SCANNER.EXE', icon: 'HealthScanner' },
                { id: 'VOID', title: 'VOID.TXT', icon: 'Void' },
                { id: 'BROWSER', title: 'BROWSER.EXE', icon: 'Browser' },
                // About
                { id: 'MAP', title: 'MAP.EXE', icon: 'Globe' },
                { id: 'PERSONAL', title: 'PRIVATE.EXE', icon: 'Lock' },
                { id: 'DESTRUCTION', title: 'DESTRUCTION.EXE', icon: 'Destruction' },
                { id: 'TRASH', title: 'TRASH.BIN', icon: 'TrashCan' },
                { id: 'END', title: 'ACHIEVEMENTS', icon: 'Trophy' },
                // Desktop only
                ...(!isMobile ? [
                    { id: 'THIRD_EYE', title: 'THIRD_EYE.EXE', icon: 'ThirdEye' },
                    { id: 'TAROT', title: 'TAROT.DAT', icon: 'Tarot' }
                ] : [])
            ];

            const filteredItems = url.trim()
                ? allItems.filter(item =>
                    item.title.toLowerCase().includes(url.toLowerCase()) ||
                    item.id.toLowerCase().includes(url.toLowerCase())
                ).slice(0, 8)
                : [];

            const handleSubmit = (e) => {
                e.preventDefault();
                const normalized = url.toLowerCase().replace(/^https?:\/\//, '').replace(/\/$/, '');
                if (normalized === 'mateusmuste.com' || normalized === 'www.mateusmuste.com') {
                    onAchievement?.('INCEPTION');
                    window.location.reload();
                }
            };

            const handleSelect = (item) => {
                if (onOpenApp) onOpenApp(item.id);
                setUrl('');
                setShowSuggestions(false);
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    {/* Browser toolbar */}
                    <div className="p-2 border-b-2 border-black bg-gray-100 flex items-center gap-2">
                        <button className="p-1 border-2 border-black bg-white hover:bg-black hover:text-white" disabled>
                            <Icons.Back size={16} />
                        </button>
                        <form onSubmit={handleSubmit} className="flex-grow relative">
                            <input
                                type="text"
                                aria-label="Browser address bar - search apps or enter URL"
                                value={url}
                                onChange={(e) => { setUrl(e.target.value); setShowSuggestions(true); }}
                                onFocus={() => setShowSuggestions(true)}
                                onBlur={() => setTimeout(() => setShowSuggestions(false), 150)}
                                placeholder="Search apps, be zen."
                                className="w-full px-3 py-1 border-2 border-black font-mono text-sm focus:outline-none"
                            />
                            {showSuggestions && filteredItems.length > 0 && (
                                <div className="absolute top-full left-0 right-0 border-2 border-t-0 border-black bg-white z-50 max-h-64 overflow-y-auto">
                                    {filteredItems.map((item) => {
                                        const ItemIcon = Icons[item.icon] || Icons.FileDoc;
                                        return (
                                            <button
                                                key={item.id}
                                                onClick={() => handleSelect(item)}
                                                className="w-full px-3 py-2 flex items-center gap-2 hover:bg-black hover:text-white border-b border-gray-200 last:border-b-0"
                                            >
                                                <ItemIcon size={16} />
                                                <span className="font-mono text-xs">{item.title}</span>
                                            </button>
                                        );
                                    })}
                                </div>
                            )}
                        </form>
                    </div>
                    {/* Browser content */}
                    <div className="flex-grow flex flex-col items-center justify-center bg-gray-50 p-6">
                        <Icons.Browser size={64} />
                        <div className="font-mono text-lg font-bold mt-4 mb-2">ZEN</div>
                        <div className="font-mono text-xs text-gray-500 text-center max-w-xs">
                            Search for apps
                        </div>
                        {/* Hidden Konami code hint */}
                        <div className="mt-8 font-mono text-[8px] text-gray-200 tracking-widest select-none">
                            BA
                        </div>
                    </div>
                    <div className="app-footer">
                        <span className="app-footer-text">SEARCH - NAVIGATE - DISCOVER</span>
                    </div>
                </div>
            );
        };

        // --- CONTACT - Contact screen with email and direct draw option ---
        const ContactApp = ({ onOpenPaint }) => {
            const [copied, setCopied] = useState(false);
            const email = 'mateusmuste9@gmail.com';

            const copyEmail = () => {
                navigator.clipboard.writeText(email);
                sounds.copy();
                setCopied(true);
                setTimeout(() => setCopied(false), 2000);
            };

            const openDrawMessage = () => {
                sounds.click();
                onOpenPaint?.();
            };

            return (
                <div className="h-full flex flex-col bg-white select-none overflow-hidden">
                    <div className="flex-1 min-h-0 flex flex-col items-center justify-center p-6">
                        <Icons.Email size={48} />
                        <div className="font-mono text-xl font-bold mt-4 mb-2">GET IN TOUCH</div>
                        <div className="font-mono text-sm text-gray-500 mb-6">{email}</div>

                        <div className="flex flex-col gap-3 w-full max-w-xs">
                            <div className="flex gap-2">
                                <button onClick={copyEmail} className="btn-primary flex-1">
                                    {copied ? 'COPIED!' : 'COPY EMAIL'}
                                </button>
                                <a href={`mailto:${email}`} className="btn-secondary flex-1 text-center" onClick={() => sounds.click()}>
                                    OPEN MAIL
                                </a>
                            </div>

                            <div className="border-t-2 border-black my-2"></div>

                            <button onClick={openDrawMessage} className="btn-secondary w-full flex items-center justify-center gap-2">
                                <Icons.Palette size={16} />
                                DIRECT CONTACT
                            </button>
                            <div className="text-center font-mono text-[10px] text-gray-400">
                                Draw me a message instead
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- END.EXE - 100% Completion Screen ---
        const EndApp = ({ achievements }) => {
            // Full achievement list for display with icons and hints
            const ACHIEVEMENTS = {
                // Pool A - Terminal
                SOCIAL_NETWORK: { name: 'SOCIAL NETWORK', icon: 'Message', hint: 'Say hi to the maker' },
                NEO: { name: 'NEO', icon: 'RainAlt', hint: 'Take the red pill' },
                LOCKSMITH: { name: 'LOCKSMITH', icon: 'Lock', hint: 'Hackers gonna hack' },
                FORBIDDEN: { name: 'FORBIDDEN', icon: 'Alert', hint: 'Curiosity kills' },
                MESSENGER: { name: 'MESSENGER', icon: 'Palette', hint: 'A picture is worth a thousand words' },
                WORK_IN_PROGRESS: { name: 'WORK IN PROGRESS', icon: 'Terminal', hint: 'The art behind the artist' },
                // Pool B - Games
                OUROBOROS: { name: 'OUROBOROS', icon: 'Repeat', hint: 'A tail as old as time' },
                FIRST_BLOOD: { name: 'FIRST BLOOD', icon: 'Sword', hint: 'Everyone starts somewhere' },
                DAEDALUS: { name: 'DAEDALUS', icon: 'Labyrinth', hint: 'Lost yet?' },
                UNTOUCHABLE: { name: 'UNTOUCHABLE', icon: 'Minesweeper', hint: 'Big brain energy' },
                ACE: { name: 'ACE', icon: 'Starship', hint: 'Pew pew pew' },
                IMPOSSIBLE: { name: 'IMPOSSIBLE', icon: 'Dice', hint: 'RNGesus take the wheel' },
                // Pool C - Exploration
                DEEP_LISTENER: { name: 'DEEP LISTENER', icon: 'Music', hint: 'Good taste is earned' },
                COLLECTOR: { name: 'COLLECTOR', icon: 'Tarot', hint: 'Patience, young one' },
                VOIDBORN: { name: 'VOIDBORN', icon: 'Void', hint: 'Scream into the abyss' },
                TUNED_IN: { name: 'TUNED IN', icon: 'Radio', hint: 'Broadcasting from the void' },
                // Pool D - Meta
                FOURTH_DIMENSION: { name: '4TH DIMENSION', icon: 'ThirdEye', hint: 'Twice the vision' },
                PHYSICS: { name: 'PHYSICS', icon: 'Expand', hint: 'Bouncy bouncy' },
                KONAMI: { name: 'KONAMI', icon: 'Controller', hint: 'Old school cool' },
                INCEPTION: { name: 'INCEPTION', icon: 'Browser', hint: 'We need to go deeper' },
                SYMPHONY: { name: 'SYMPHONY', icon: 'Synth', hint: 'Go all out' },
                // Pool E - Time
                TIMEKEEPER: { name: 'TIMEKEEPER', icon: 'Clock', hint: 'Time flies' },
                CLICKER: { name: 'CLICKER', icon: 'Cursor', hint: 'Click. Click. Click.' },
                MASTER: { name: 'MASTER', icon: 'Pomodoro', hint: 'Grow your garden' },
                TYCOON: { name: 'TYCOON', icon: 'Globe', hint: 'Money printer go brrr' },
                ASCENDED: { name: 'ASCENDED', icon: 'Dog', hint: 'Who let the dog out?' },
                // Pool F - Dark
                YOU_MONSTER: { name: 'YOU MONSTER', icon: 'Skull', hint: 'How could you' },
                JOHN_WICK: { name: 'JOHN WICK', icon: 'Fire', hint: 'Baba Yaga approves' },
                OVERKILL: { name: 'OVERKILL', icon: 'Bomb', hint: 'Therapy recommended' },
                // Special
                CENTURY: { name: 'CENTURY', icon: 'Badge', hint: 'Commitment issues' },
                HUNDRED_PERCENT: { name: '100%', icon: 'Trophy', hint: 'You did it!' }
            };

            const unlockedCount = Object.keys(achievements).length;
            const totalCount = Object.keys(ACHIEVEMENTS).length;
            const has100Percent = achievements.HUNDRED_PERCENT;

            return (
                <div className="h-full flex flex-col bg-black text-white select-none font-mono overflow-auto">
                    {/* Header */}
                    <div className="p-4 border-b border-white/20 text-center">
                        <div className="text-2xl font-bold mb-2 flex items-center justify-center gap-2">
                            {has100Percent && <Icons.Trophy size={24} className="invert" />}
                            {has100Percent ? '100% COMPLETE' : 'ACHIEVEMENT LOG'}
                            {has100Percent && <Icons.Trophy size={24} className="invert" />}
                        </div>
                        <div className="text-sm text-gray-400">
                            {unlockedCount} / {totalCount} ACHIEVEMENTS
                        </div>
                    </div>

                    {/* Achievement list */}
                    <div className="flex-grow p-4 space-y-2 overflow-auto">
                        {Object.entries(ACHIEVEMENTS).map(([id, ach]) => {
                            const unlocked = achievements[id];
                            const IconCmp = Icons[ach.icon] || Icons.Badge;
                            return (
                                <div
                                    key={id}
                                    className={`p-2 border ${unlocked ? 'border-white bg-white/10' : 'border-gray-700 opacity-50'}`}
                                >
                                    <div className="flex items-center gap-2">
                                        <div className={`w-6 h-6 flex items-center justify-center ${unlocked ? '' : 'opacity-30'}`}>
                                            <IconCmp size={20} className="invert" />
                                        </div>
                                        <span className={`font-bold ${unlocked ? '' : 'text-gray-500'}`}>
                                            {ach.name}
                                        </span>
                                    </div>
                                    <div className={`text-xs ml-8 ${unlocked ? 'text-gray-300' : 'text-gray-600'}`}>
                                        {ach.hint}
                                    </div>
                                </div>
                            );
                        })}
                    </div>

                    {/* Footer */}
                    {has100Percent && (
                        <div className="p-4 border-t border-white/20 text-center">
                            <div className="text-sm text-gray-400">THANK YOU FOR PLAYING</div>
                            <div className="font-heading text-xs text-gray-600 mt-1"> MATEUS MUSTE </div>
                        </div>
                    )}
                </div>
            );
        };

        // Binary/Code Background for ASCII mode (defined outside OS to prevent re-mount on re-render)
        const BinaryBackground = React.memo(() => {
            const canvasRef = useRef(null);
            useEffect(() => {
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                const chars = '01{}[]()<>;:=/\\|_-+*&^%$#@!?.~`';
                const fontSize = 12;
                const columns = Math.floor(canvas.width / fontSize);
                const drops = Array(columns).fill(0).map(() => Math.random() * -100);

                const draw = () => {
                    ctx.fillStyle = 'rgba(240, 240, 240, 0.03)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.font = fontSize + "px 'PPNeueBit', sans-serif";

                    for (let i = 0; i < drops.length; i++) {
                        const char = chars[Math.floor(Math.random() * chars.length)];
                        const alpha = 0.08 + Math.random() * 0.08;
                        ctx.fillStyle = `rgba(0, 0, 0, ${alpha})`;
                        ctx.fillText(char, i * fontSize, drops[i] * fontSize);
                        if (drops[i] * fontSize > canvas.height && Math.random() > 0.98) {
                            drops[i] = 0;
                        }
                        drops[i] += 0.3 + Math.random() * 0.2;
                    }
                };

                // Initial fill
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const interval = setInterval(draw, 80);
                const handleResize = () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                    ctx.fillStyle = '#f0f0f0';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                };
                window.addEventListener('resize', handleResize);
                return () => {
                    clearInterval(interval);
                    window.removeEventListener('resize', handleResize);
                };
            }, []);
            return <canvas ref={canvasRef} role="presentation" aria-hidden="true" style={{ position: 'fixed', top: 0, left: 0, width: '100%', height: '100%', zIndex: 0, pointerEvents: 'none' }} />;
        });

        // --- OS SHELL ---

        const OS = () => {
            const [modeSelected, setModeSelected] = useState(null); // null = show selector, 'story' or 'about'
            const [booted, setBooted] = useState(false);
            const [bootPhase, setBootPhase] = useState(0); // 0: mobile notice (mobile only), 1: kernel, 2: ready
            const [isMobile, setIsMobile] = useState(false);
            const [introComplete, setIntroComplete] = useState(() => localStorage.getItem('intro_complete') === 'true');
            const [revealingApps, setRevealingApps] = useState(false);
            const [revealedApps, setRevealedApps] = useState([]);
            const [showCorruptedAlert, setShowCorruptedAlert] = useState(false); // Narrative Bible v3.0
            const [paintShowHint, setPaintShowHint] = useState(false);
            const [isMuted, setIsMuted] = useState(() => localStorage.getItem('sound_muted') === 'true');
            const handleToggleMute = () => setIsMuted(toggleMute());
            const [topZ, setTopZ] = useState(100);
            const topZRef = useRef(100);
            const [destructionMode, setDestructionMode] = useState(false);
            // --- DOG COMPANION STATE ---
            const [dogCompanionActive, setDogCompanionActive] = useState(() => localStorage.getItem('dog_companion_active') === 'true');
            const [dogCompanionEmotion, setDogCompanionEmotion] = useState('idle');
            const [dogCompanionPos, setDogCompanionPos] = useState({ x: 16, y: window.innerHeight - 100 });
            const [dogCompanionVel, setDogCompanionVel] = useState({ x: 0, y: 0 });
            const [dogCompanionGrounded, setDogCompanionGrounded] = useState(false);
            const [dogCompanionDragging, setDogCompanionDragging] = useState(false);
            const [dogCompanionDialogue, setDogCompanionDialogue] = useState(null); // Current dialogue line
            const [dogCompanionDialogueQueue, setDogCompanionDialogueQueue] = useState([]);
            const [dogCompanionStoryPhase, setDogCompanionStoryPhase] = useState(() => localStorage.getItem('dog_story_phase') || 'inactive');
            const [playerName, setPlayerName] = useState(() => localStorage.getItem('player_name') || 'USER');
            const [dogCompanionWaitingFor, setDogCompanionWaitingFor] = useState(() => localStorage.getItem('dog_waiting_for')); // Action to wait for
            const [dogCompanionCurrentDialogueKey, setDogCompanionCurrentDialogueKey] = useState(null); // Track which dialogue sequence is active
            const [dogCompanionDialogueIndex, setDogCompanionDialogueIndex] = useState(0); // Track position in dialogue
            const [dogCompletedDialogues, setDogCompletedDialogues] = useState(() => {
                // Load completed dialogues from localStorage
                const stored = localStorage.getItem('dog_completed_dialogues');
                return stored ? JSON.parse(stored) : [];
            });
            const [dogErrorWindows, setDogErrorWindows] = useState([]); // Error windows spawned by dog
            const dogCompanionVelRef = useRef({ x: 0, y: 0 });
            const dogIdleTimerRef = useRef(null);
            const lastIdleDialogueRef = useRef(0);
            const dogResumeCheckedRef = useRef(false); // Track if we've checked for resume
            const dogTriggerQueueRef = useRef([]); // Queue for triggers that arrive while dog is busy
            // Goldy state - cardboard fake dog that sits on taskbar next to dog.exe
            const [goldyVisible, setGoldyVisible] = useState(false);
            const [goldyFalling, setGoldyFalling] = useState(false);
            // Position goldy on taskbar: x next to dog companion (dog is at 16, size 96), y on top of taskbar (48px)
            const [goldyPos, setGoldyPos] = useState({ x: 120, y: window.innerHeight - 48 - 64 });

            // Save companion state
            useEffect(() => {
                localStorage.setItem('dog_companion_active', dogCompanionActive.toString());
            }, [dogCompanionActive]);
            useEffect(() => {
                localStorage.setItem('dog_story_phase', dogCompanionStoryPhase);
            }, [dogCompanionStoryPhase]);
            useEffect(() => {
                localStorage.setItem('player_name', playerName);
            }, [playerName]);
            // Save current dialogue progress for resume on reload
            useEffect(() => {
                if (dogCompanionCurrentDialogueKey) {
                    localStorage.setItem('dog_dialogue_key', dogCompanionCurrentDialogueKey);
                    localStorage.setItem('dog_dialogue_index', dogCompanionDialogueIndex.toString());
                } else {
                    localStorage.removeItem('dog_dialogue_key');
                    localStorage.removeItem('dog_dialogue_index');
                }
            }, [dogCompanionCurrentDialogueKey, dogCompanionDialogueIndex]);
            // Save completed dialogues list
            useEffect(() => {
                localStorage.setItem('dog_completed_dialogues', JSON.stringify(dogCompletedDialogues));
            }, [dogCompletedDialogues]);
            // Save waitingFor state for resume
            useEffect(() => {
                if (dogCompanionWaitingFor) {
                    localStorage.setItem('dog_waiting_for', dogCompanionWaitingFor);
                } else {
                    localStorage.removeItem('dog_waiting_for');
                }
            }, [dogCompanionWaitingFor]);

            // Legacy dog state (kept for backward compatibility)
            const [dogReleased, setDogReleased] = useState(false);
            const [dogPos, setDogPos] = useState({ x: 100, y: 300 });
            const [dogFacingRight, setDogFacingRight] = useState(true);
            const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
            const [carriedIcon, setCarriedIcon] = useState(null);
            const [iconPositions, setIconPositions] = useState(() => {
                // Initialize desktop icon positions in a column on the left
                const stored = localStorage.getItem('desktop_icon_positions');
                if (stored) {
                    try { return JSON.parse(stored); } catch { }
                }
                const mobile = window.innerWidth < 768;
                const iconSize = 100; // Spacing between icons (doubled grid)
                const padding = 16;
                const topOffset = mobile ? 80 : 16; // Account for mobile taskbar + safe area at top
                return {
                    MESSAGES: { x: padding, y: topOffset },
                    ABOUT: { x: padding, y: topOffset },
                    SYSTEM: { x: padding, y: topOffset },
                    FILES: { x: padding, y: topOffset + iconSize },
                    APPS: { x: padding, y: topOffset },
                    CONTACT: { x: padding, y: topOffset + iconSize * 3 },
                    TRUTH: { x: padding, y: topOffset + iconSize * 4 },
                    TRASH: { x: padding, y: topOffset + iconSize }
                };
            });
            const [iconDrag, setIconDrag] = useState({ id: null, offsetX: 0, offsetY: 0, active: false });
            const [selectedIcon, setSelectedIcon] = useState(null);
            const lastIconClick = useRef({ id: null, time: 0 });
            const iconPhysics = useRef({});
            const lastIconMousePos = useRef({ x: 0, y: 0, time: Date.now() });
            const iconHoldTimer = useRef(null);
            const iconPendingDrag = useRef(null); // Stores pending drag info before hold completes

            // Icons are free-floating - no grid snap
            const [folderDrag, setFolderDrag] = useState(null); // { id, title, icon, startX, startY }
            const [extraDesktopIcons, setExtraDesktopIcons] = useState(() => {
                const stored = localStorage.getItem('extra_desktop_icons');
                return stored ? JSON.parse(stored) : [];
            });
            const [destructionDogGone, setDestructionDogGone] = useState(false);
            const [matrixMode, setMatrixMode] = useState(false);
            const [thirdEyeWorld, setThirdEyeWorld] = useState(false);
            const [privateUnlocked, setPrivateUnlocked] = useState(false);
            const [desktopBg, setDesktopBg] = useState(() => localStorage.getItem('desktop_bg') || 'grid');
            const [contextMenu, setContextMenu] = useState({ show: false, x: 0, y: 0 });
            const [windowAnimations, setWindowAnimations] = useState({}); // { windowId: 'opening' | 'closing' }
            const [stackOverflow, setStackOverflow] = useState(false);
            const [stackErrors, setStackErrors] = useState([]);
            const [pyramidScreen, setPyramidScreen] = useState(false);
            const stackTimerRef = useRef(null);
            const errorIntervalRef = useRef(null);
            const [visitCount, setVisitCount] = useState(() => {
                const stored = localStorage.getItem('ultra_int_visits');
                const count = stored ? parseInt(stored, 10) + 1 : 1;
                localStorage.setItem('ultra_int_visits', count.toString());
                return count;
            });
            const truthUnlocked = visitCount >= 100;

            // Achievement system - Narrative Bible v3.0
            const ACHIEVEMENTS = {
                // Core narrative achievements
                INCEPTION: { name: 'INCEPTION', icon: 'ThirdEye', hint: 'Stack two Third Eyes', visible: true },
                YOU_MONSTER: { name: 'YOU MONSTER', icon: 'Skull', hint: 'Delete the dog', visible: true },
                CLICKER: { name: 'CLICKER', icon: 'Cursor', hint: '100 clicks', visible: true },
                ACCEPT_FATE: { name: 'ACCEPT FATE', icon: 'Tarot', hint: 'Accept your tarot reading', visible: true },
                DESTROYER_OF_WORLDS: { name: 'DESTROYER OF WORLDS', icon: 'Bomb', hint: 'Try to destroy everything', visible: true },
                DIVINE_ROLL: { name: 'DIVINE ROLL', icon: 'Dice', hint: 'Roll a natural 20', visible: true },
                BECOME_GOD: { name: 'EXTRACT REVELATION', icon: 'Trophy', hint: 'Achieve elevation', visible: true },
                TRUTH_SEEKER: { name: 'TRUTH SEEKER', icon: 'FileDoc', hint: 'Open TRUTH.EXE', visible: true },
                COMPLETIONIST: { name: 'COMPLETIONIST', icon: 'Badge', hint: '100% completion', visible: true },
                // Legacy achievements (kept for backwards compatibility)
                LOCKSMITH: { name: 'LOCKSMITH', icon: 'Lock', hint: 'Unlock PRIVATE.EXE', visible: true },
                NEO: { name: 'NEO', icon: 'RainAlt', hint: 'Enter the Matrix', visible: true },
                PHYSICS: { name: 'PHYSICS', icon: 'Expand', hint: 'Bouncy icons', visible: true },
                TIMEKEEPER: { name: 'TIMEKEEPER', icon: 'Clock', hint: '10 minutes in session', visible: true }
            };

            // Narrative-driven app unlock system (replaces pool-based)
            // Track which apps have been explicitly unlocked through narrative progression
            const [narrativeUnlocks, setNarrativeUnlocks] = useState(() => {
                const stored = localStorage.getItem('ultra_int_narrative_unlocks');
                return stored ? JSON.parse(stored) : [];
            });

            // Save narrative unlocks to localStorage
            useEffect(() => {
                localStorage.setItem('ultra_int_narrative_unlocks', JSON.stringify(narrativeUnlocks));
            }, [narrativeUnlocks]);

            // Function to unlock a specific app (narrative-driven)
            const unlockApp = (appId) => {
                if (!narrativeUnlocks.includes(appId)) {
                    setNarrativeUnlocks(prev => [...prev, appId]);
                    sounds.appUnlock();
                    // Show app unlock notification
                    const appNotifId = Date.now() + Math.random();
                    setAppUnlockNotifications(prev => [...prev, { app: appId, id: appNotifId }]);
                    setTimeout(() => {
                        setAppUnlockNotifications(prev => prev.filter(n => n.id !== appNotifId));
                    }, 3000);
                }
            };

            const [achievements, setAchievements] = useState(() => {
                const stored = localStorage.getItem('ultra_int_achievements');
                return stored ? JSON.parse(stored) : {};
            });
            const [achievementNotifications, setAchievementNotifications] = useState([]);

            // App progression system - Story mode progression
            // Starting apps: Only TERMINAL visible in APPS folder after intro
            // Desktop icons in story mode: APPS, TRASH (ABOUT and FILES hidden initially)
            // STARSHIP unlocked via sudo stars, not initial
            const INITIAL_APPS = ['TERMINAL', 'ABOUT', 'SYSTEM', 'FILES', 'APPS', 'CONTACT', 'TRASH', 'END', 'MESSAGES'];

            // Get all unlocked apps (initial + narrative unlocks + god mode unlocks)
            // In about mode: only show base apps, no story progression
            const getUnlockedApps = () => {
                const unlocked = new Set(INITIAL_APPS);

                // About mode: clean slate, no story unlocks
                if (modeSelected === 'about') {
                    return unlocked;
                }

                // Story mode: add all narrative-driven unlocks
                narrativeUnlocks.forEach(app => unlocked.add(app));

                // TRUTH unlocks at 100 visits OR after god mode
                if (truthUnlocked || achievements.BECOME_GOD) unlocked.add('TRUTH');

                // God mode unlocks bonus apps
                if (achievements.BECOME_GOD) {
                    ['RADIO', 'POMODORO', 'SCANNER', 'DESTRUCTION'].forEach(app => unlocked.add(app));
                }

                return unlocked;
            };
            const unlockedApps = getUnlockedApps();

            // Track total unlocked app count for milestones
            const unlockedAppCount = unlockedApps.size;
            const [dogTrashCount, setDogTrashCount] = useState(() => {
                const stored = localStorage.getItem('dog_trash_count');
                return stored ? parseInt(stored, 10) : 0;
            });
            const [dogDragging, setDogDragging] = useState(false);
            const [dogDragOffset, setDogDragOffset] = useState({ x: 0, y: 0 });
            const dogHoldTimer = useRef(null);
            const [hasCompletedGame, setHasCompletedGame] = useState(() => {
                return localStorage.getItem('ultra_int_completed') === 'true';
            });

            // Time tracking for TIMEKEEPER achievement (5 minutes)
            const startTimeRef = useRef(Date.now());
            const [totalClicks, setTotalClicks] = useState(() => {
                const stored = localStorage.getItem('ultra_int_clicks');
                return stored ? parseInt(stored, 10) : 0;
            });

            // Save achievements to localStorage
            useEffect(() => {
                localStorage.setItem('ultra_int_achievements', JSON.stringify(achievements));
            }, [achievements]);

            // Save clicks to localStorage
            useEffect(() => {
                localStorage.setItem('ultra_int_clicks', totalClicks.toString());
            }, [totalClicks]);

            // Time tracking for TIMEKEEPER (10 minutes = 600000ms)
            useEffect(() => {
                const checkTime = setInterval(() => {
                    const elapsed = Date.now() - startTimeRef.current;
                    // TIMEKEEPER at 10 minutes
                    if (elapsed >= 600000 && !achievements.TIMEKEEPER) {
                        unlockAchievement('TIMEKEEPER');
                    }
                }, 30000); // Check every 30 seconds
                return () => clearInterval(checkTime);
            }, [achievements]);

            // Global click handler for CLICKER achievement
            useEffect(() => {
                const handleClick = () => {
                    setTotalClicks(prev => {
                        const newCount = prev + 1;
                        // CLICKER achievement at 100 clicks
                        if (newCount >= 100 && !achievements.CLICKER) {
                            setTimeout(() => unlockAchievement('CLICKER'), 100);
                        }
                        return newCount;
                    });
                };
                document.addEventListener('click', handleClick);
                return () => document.removeEventListener('click', handleClick);
            }, [achievements]);

            // Check for 100% completion
            const achievementCount = Object.keys(achievements).filter(k => k !== 'COMPLETIONIST').length;
            const totalAchievements = Object.keys(ACHIEVEMENTS).length - 1; // Exclude COMPLETIONIST itself
            const hasAllAchievements = achievementCount >= totalAchievements;

            // State for newly unlocked app notifications (array for stacking)
            const [appUnlockNotifications, setAppUnlockNotifications] = useState([]);

            // Unlock achievement function (narrative-driven, no pool unlocking)
            const unlockAchievement = (id) => {
                if (achievements[id]) return; // Already unlocked
                const achievement = ACHIEVEMENTS[id];
                if (!achievement) return;

                const notifId = Date.now() + Math.random();

                // Mark achievement as unlocked
                setAchievements(prev => ({ ...prev, [id]: { unlockedAt: Date.now() } }));
                setAchievementNotifications(prev => [...prev, { ...achievement, id: notifId }]);
                sounds.achievementUnlock();

                // Auto-hide achievement notification after 3 seconds
                setTimeout(() => {
                    setAchievementNotifications(prev => prev.filter(n => n.id !== notifId));
                }, 3000);

                // Check for 100% after unlocking
                if (id !== 'COMPLETIONIST') {
                    const newCount = achievementCount + 1;
                    if (newCount >= totalAchievements && !achievements.COMPLETIONIST) {
                        setTimeout(() => unlockAchievement('COMPLETIONIST'), 5000);
                    }
                }
            };

            // God mode - unlock all achievements and apps instantly
            const handleGodMode = () => {
                // Unlock all achievements
                const allAchievements = {};
                Object.keys(ACHIEVEMENTS).forEach(id => {
                    allAchievements[id] = { unlockedAt: Date.now() };
                });
                setAchievements(allAchievements);

                // Unlock ALL apps via narrative unlocks (so they persist)
                const ALL_UNLOCKABLE_APPS = [
                    'PAINT', 'SNAKE', 'VOID', 'RADIO', 'DICE', 'LABYRINTH',
                    'MINESWEEPER', 'STARSHIP', 'DESTRUCTION', 'TAROT',
                    'MAP', 'POMODORO', 'SCANNER', 'PERSONAL',
                    'DOG_STORY', 'THIRD_EYE', 'THIRD_EYE_2', 'BROWSER',
                    'BOOKS', 'TRUTH'
                ];
                setNarrativeUnlocks(ALL_UNLOCKABLE_APPS);

                // Show a single notification
                const godNotifId = Date.now();
                setAchievementNotifications([{ id: godNotifId, name: 'GOD MODE', hint: 'All achievements and apps unlocked' }]);
                sounds.godMode();
                setTimeout(() => {
                    setAchievementNotifications(prev => prev.filter(n => n.id !== godNotifId));
                }, 3000);

                // Notify dog that truth is unlocked
                notifyDogEvent('truthUnlocked');
            };

            // Check century achievement on mount
            useEffect(() => {
                if (visitCount >= 100 && !achievements.CENTURY) {
                    setTimeout(() => unlockAchievement('CENTURY'), 2000);
                }
            }, []);

            // Total visitors counter (using CountAPI)
            const [totalVisitors, setTotalVisitors] = useState(null);

            // Fetch and increment total visitors with abort controller
            useEffect(() => {
                const controller = new AbortController();
                fetch('https://api.countapi.xyz/hit/mateusmuste-com/visits', { signal: controller.signal })
                    .then(res => res.json())
                    .then(data => setTotalVisitors(data.value))
                    .catch((err) => {
                        if (err.name === 'AbortError') return; // Ignore abort errors
                        // Fallback to localStorage estimate
                        const stored = parseInt(localStorage.getItem('visitor_estimate') || '340', 10);
                        const newCount = stored + Math.floor(Math.random() * 3);
                        localStorage.setItem('visitor_estimate', newCount.toString());
                        setTotalVisitors(newCount);
                    });
                return () => controller.abort();
            }, []);

            const toggleMatrixMode = () => {
                setMatrixMode(prev => {
                    if (!prev) unlockAchievement('NEO');
                    return !prev;
                });
            };

            const activateThirdEyeWorld = () => {
                setThirdEyeWorld(true);
                unlockAchievement('KONAMI');
            };
            const unlockPrivate = () => {
                setPrivateUnlocked(true);
                unlockAchievement('LOCKSMITH');
                // Unlock MAP and spawn goldy (cardboard dog on taskbar)
                unlockApp('MAP');
                setGoldyVisible(true);
            };
            const openDogStory = () => {
                // Spawn goldy (cardboard dog on taskbar)
                setGoldyVisible(true);
                // Bring DOG_STORY to front on top of everything
                sounds.windowOpen();
                topZRef.current += 1;
                const newZ = topZRef.current;
                setWindows(prev => ({
                    ...prev,
                    DOG_STORY: { ...prev.DOG_STORY, isOpen: true, isMin: false, z: newZ }
                }));
                setTopZ(newZ);
                // Trigger opening animation
                setWindowAnimations(p => ({ ...p, DOG_STORY: 'opening' }));
                setTimeout(() => setWindowAnimations(p => { const n = {...p}; delete n.DOG_STORY; return n; }), 200);
            };
            const removeGoldDog = () => {
                setGoldyFalling(true);
                setTimeout(() => setGoldyVisible(false), 500);
            };

            // Handle dog stealing the destruction button - dog starts running around!
            const handleDogSteal = () => {
                setDestructionDogGone(true);
                setDogReleased(true); // Dog starts running around the screen
                // Close the destruction window
                setWindows(prev => ({
                    ...prev,
                    DESTRUCTION: { ...prev.DESTRUCTION, isOpen: false }
                }));
            };

            // Dog AI - DVD logo style bouncing (uses refs to avoid stale closures)
            const dogVelRef = useRef({ x: 4, y: 3 });

            useEffect(() => {
                if (!dogReleased || dogDragging) return;

                const dogInterval = setInterval(() => {
                    const vel = dogVelRef.current;

                    setDogPos(prev => {
                        let newX = prev.x + vel.x;
                        let newY = prev.y + vel.y;

                        // Bounce off walls - DVD style
                        if (newX >= window.innerWidth - 80) {
                            newX = window.innerWidth - 80;
                            dogVelRef.current.x = -Math.abs(vel.x);
                            setDogFacingRight(false);
                        }
                        if (newX <= 0) {
                            newX = 0;
                            dogVelRef.current.x = Math.abs(vel.x);
                            setDogFacingRight(true);
                        }
                        if (newY >= window.innerHeight - 100) {
                            newY = window.innerHeight - 100;
                            dogVelRef.current.y = -Math.abs(vel.y);
                        }
                        if (newY <= 60) {
                            newY = 60;
                            dogVelRef.current.y = Math.abs(vel.y);
                        }

                        return { x: newX, y: newY };
                    });

                    // Randomly grab icons
                    if (!carriedIcon && Math.random() < 0.003) {
                        const iconKeys = Object.keys(windows);
                        const randomIcon = iconKeys[Math.floor(Math.random() * iconKeys.length)];
                        setCarriedIcon(randomIcon);

                        setTimeout(() => {
                            setCarriedIcon(null);
                        }, 3000 + Math.random() * 4000);
                    }
                }, 30);

                return () => clearInterval(dogInterval);
            }, [dogReleased]);

            // --- DOG COMPANION PHYSICS SYSTEM ---
            const DOG_PHYSICS = {
                GRAVITY: 0.8,
                BOUNCE_DAMPING: 0.5,
                FRICTION: 0.95,
                SETTLE_THRESHOLD: 2.0,  // Higher threshold to stop sooner
                MIN_BOUNCE_SOUND_VEL: 3.0,  // Minimum velocity to play bounce sound
                TASKBAR_HEIGHT: 48,
                DOG_SIZE: 96  // 32px * 3 scale
            };

            // Dog companion physics - gravity and bouncing
            useEffect(() => {
                if (!dogCompanionActive || dogCompanionDragging) return;

                const physicsInterval = setInterval(() => {
                    setDogCompanionPos(prev => {
                        let vel = dogCompanionVelRef.current;
                        const taskbarY = window.innerHeight - DOG_PHYSICS.TASKBAR_HEIGHT - DOG_PHYSICS.DOG_SIZE;

                        // Apply gravity
                        vel.y += DOG_PHYSICS.GRAVITY;

                        // Apply friction to horizontal movement
                        vel.x *= DOG_PHYSICS.FRICTION;

                        let newX = prev.x + vel.x;
                        let newY = prev.y + vel.y;
                        let grounded = false;

                        // Bounce off left wall
                        if (newX <= 0) {
                            newX = 0;
                            if (Math.abs(vel.x) > DOG_PHYSICS.MIN_BOUNCE_SOUND_VEL) {
                                playDogBounceSound();
                            }
                            vel.x = Math.abs(vel.x) * DOG_PHYSICS.BOUNCE_DAMPING;
                        }
                        // Bounce off right wall
                        if (newX >= window.innerWidth - DOG_PHYSICS.DOG_SIZE) {
                            newX = window.innerWidth - DOG_PHYSICS.DOG_SIZE;
                            if (Math.abs(vel.x) > DOG_PHYSICS.MIN_BOUNCE_SOUND_VEL) {
                                playDogBounceSound();
                            }
                            vel.x = -Math.abs(vel.x) * DOG_PHYSICS.BOUNCE_DAMPING;
                        }

                        // Bounce off taskbar (ground)
                        if (newY >= taskbarY) {
                            newY = taskbarY;
                            if (Math.abs(vel.y) > DOG_PHYSICS.SETTLE_THRESHOLD) {
                                if (Math.abs(vel.y) > DOG_PHYSICS.MIN_BOUNCE_SOUND_VEL) {
                                    playDogBounceSound();
                                }
                                vel.y = -Math.abs(vel.y) * DOG_PHYSICS.BOUNCE_DAMPING;
                            } else {
                                vel.y = 0;
                                vel.x = 0;  // Also stop horizontal movement when grounded
                                grounded = true;
                            }
                        }

                        // Bounce off top
                        if (newY <= 0) {
                            newY = 0;
                            if (Math.abs(vel.y) > DOG_PHYSICS.MIN_BOUNCE_SOUND_VEL) {
                                playDogBounceSound();
                            }
                            vel.y = Math.abs(vel.y) * DOG_PHYSICS.BOUNCE_DAMPING;
                        }

                        // Stop tiny movements completely
                        if (Math.abs(vel.x) < 0.5) vel.x = 0;
                        if (Math.abs(vel.y) < 0.5 && grounded) vel.y = 0;

                        dogCompanionVelRef.current = vel;
                        setDogCompanionGrounded(grounded);

                        return { x: newX, y: newY };
                    });
                }, 16); // ~60fps

                return () => clearInterval(physicsInterval);
            }, [dogCompanionActive, dogCompanionDragging]);

            // Dog companion spawn animation - falls from top
            const spawnDogCompanion = () => {
                setDogCompanionPos({ x: 16, y: -100 });
                dogCompanionVelRef.current = { x: 0, y: 5 };
                setDogCompanionActive(true);
                setDogCompanionEmotion('happy');
            };

            // Dog companion dialogue controller
            const startDogDialogue = (dialogueKey, customDialogues = null, startIndex = 0) => {
                const dialogues = customDialogues || DOG_DIALOGUES[dialogueKey];
                if (!dialogues || dialogues.length === 0) return;

                // Skip if this dialogue was already completed (except for resume and idle)
                const isIdleDialogue = dialogueKey === 'IDLE_GENERAL' || dialogueKey === 'IDLE_POST_GAME' || dialogueKey === 'RESUME_DIALOGUE';
                if (!isIdleDialogue && !customDialogues && startIndex === 0) {
                    if (dogCompletedDialogues.includes(dialogueKey)) {
                        console.log('Skipping already-completed dialogue:', dialogueKey);
                        return;
                    }
                }

                // Replace {playerName} in dialogues
                const processedDialogues = dialogues.map(d => ({
                    ...d,
                    text: d.text.replace(/{playerName}/g, playerName)
                }));

                // Track current dialogue key and index (skip for idle dialogues and resume)
                if (!isIdleDialogue && !customDialogues) {
                    setDogCompanionCurrentDialogueKey(dialogueKey);
                    setDogCompanionDialogueIndex(startIndex);
                }

                // Start from specified index
                const startDialogues = processedDialogues.slice(startIndex);
                if (startDialogues.length === 0) return;

                setDogCompanionDialogueQueue(startDialogues.slice(1));
                const first = startDialogues[0];
                setDogCompanionDialogue(first);
                setDogCompanionEmotion(first.emotion || 'speaking');
                if (first.waitForAction) {
                    setDogCompanionWaitingFor(first.waitForAction);
                }
            };

            const advanceDogDialogue = (skipWaitCheck = false) => {
                const current = dogCompanionDialogue;

                // Handle trigger before advancing
                if (current?.trigger) {
                    handleDogTrigger(current.trigger);
                }

                // Check if waiting for an action (unless action was just completed)
                if (!skipWaitCheck && current?.waitForAction) {
                    setDogCompanionWaitingFor(current.waitForAction);
                    return;
                }

                // Wait after current dialogue if specified
                const waitTime = current?.waitAfter || 0;

                setTimeout(() => {
                    if (dogCompanionDialogueQueue.length > 0) {
                        const next = dogCompanionDialogueQueue[0];
                        setDogCompanionDialogueQueue(prev => prev.slice(1));
                        setDogCompanionDialogue(next);
                        setDogCompanionEmotion(next.emotion || 'speaking');
                        // Track dialogue progress
                        setDogCompanionDialogueIndex(prev => prev + 1);
                        if (next.waitForAction) {
                            setDogCompanionWaitingFor(next.waitForAction);
                        }
                    } else {
                        // Dialogue complete - mark as completed and clear tracking
                        if (dogCompanionCurrentDialogueKey) {
                            setDogCompletedDialogues(prev => {
                                if (!prev.includes(dogCompanionCurrentDialogueKey)) {
                                    return [...prev, dogCompanionCurrentDialogueKey];
                                }
                                return prev;
                            });
                        }
                        setDogCompanionDialogue(null);
                        setDogCompanionEmotion('idle');
                        setDogCompanionWaitingFor(null);
                        setDogCompanionCurrentDialogueKey(null);
                        setDogCompanionDialogueIndex(0);

                        // Process queued triggers after dialogue ends
                        if (dogTriggerQueueRef.current.length > 0) {
                            const nextEvent = dogTriggerQueueRef.current.shift();
                            setTimeout(() => processEventTrigger(nextEvent), 500);
                        }
                    }
                }, waitTime);
            };

            // Helper to create error with random position
            const createDogError = (id, message, index = 0) => ({
                id,
                message,
                x: 100 + (index % 5) * 50 + Math.random() * 100,
                y: 100 + Math.floor(index / 5) * 60 + Math.random() * 100
            });

            // Helper to spawn a single error with sound
            const spawnSingleError = (message, index) => {
                sounds.error();
                setDogErrorWindows(prev => [...prev, createDogError(Date.now() + Math.random() * 1000, message, prev.length)]);
            };

            // Helper to spawn multiple errors with staggered random delays
            const spawnErrorsStaggered = (errorList) => {
                let cumulativeDelay = 0;
                errorList.forEach((message, i) => {
                    // Random delay between 100ms and 1000ms for each error
                    const delay = 100 + Math.random() * 900;
                    cumulativeDelay += delay;
                    setTimeout(() => spawnSingleError(message, i), cumulativeDelay);
                });
                return cumulativeDelay; // Return total time for all errors
            };

            // Handle dog story triggers
            const handleDogTrigger = (trigger) => {
                switch (trigger) {
                    case 'spawnErrors':
                        // Spawn 1 error window with sound
                        spawnSingleError('MEMORY_CORRUPTION_ERROR', 0);
                        setTimeout(() => startDogDialogue('ACT1_ERRORS'), 600);
                        break;
                    case 'moreErrors':
                        // Spawn 2-3 more errors with staggered delays
                        spawnErrorsStaggered(['SYSTEM_FAULT_0x00A3', 'KERNEL_PANIC_DETECTED']);
                        break;
                    case 'manyErrors':
                        // Spawn 12 errors with staggered delays
                        const errorMessages = [];
                        const errorTypes = ['FATAL_ERROR', 'MEMORY_LEAK', 'STACK_OVERFLOW', 'NULL_POINTER', 'BUFFER_OVERFLOW', 'SEGFAULT'];
                        for (let i = 0; i < 12; i++) {
                            errorMessages.push(errorTypes[Math.floor(Math.random() * errorTypes.length)]);
                        }
                        spawnErrorsStaggered(errorMessages);
                        break;
                    case 'unlockTerminal':
                        // Terminal is already unlocked by default
                        setDogCompanionStoryPhase('ACT1_TERMINAL');
                        break;
                    case 'endAct1':
                        setDogCompanionStoryPhase('ACT2');
                        break;
                    case 'dogSacrifice':
                        setDogCompanionActive(false);
                        setDogCompanionStoryPhase('ACT3_SACRIFICE');
                        // Trigger truth.exe opening
                        break;
                    case 'endGame':
                        setDogCompanionStoryPhase('POST_GAME');
                        setHasCompletedGame(true);
                        localStorage.setItem('ultra_int_completed', 'true');
                        break;
                    default:
                        break;
                }
            };

            // Mapping from waitForAction events to the next dialogue sequence
            const WAIT_ACTION_TO_NEXT_DIALOGUE = {
                'runChkdsk': 'ACT1_POST_CHKDSK',
                'runListUsers': 'ACT1_LIST_USERS',
                'runHelp': 'ACT1_HELP',
                'runSudoReveal': 'ACT1_SUDO_REVEAL',
                'runCmatrix': 'ACT2_POST_MATRIX',
                'triggerInception': 'ACT2_INCEPTION',
                'runSudoUnlock': 'ACT2_PRIVATE_FOUND',
                'scanPrivate': 'ACT2_CHMOD',
                'runChmod': 'ACT2_GOLDY_FOUND',
                'runSudoStars': 'ACT2_STARSHIP',
                'scanTruth': 'ACT3_SYSTEM_CRASH',
            };

            // Map events to their required phase and dialogue
            const EVENT_TO_DIALOGUE = {
                'terminalOpened': { phase: 'ACT1_TERMINAL', dialogue: 'ACT1_TERMINAL_OPENED' },
                'matrixExit': { phase: 'ACT2', dialogue: 'ACT2_POST_MATRIX' },
                'snekLost': { phase: 'ACT2', dialogue: 'ACT2_SNEK_HINT' },
                'snekComplete': { phase: 'ACT2', dialogue: 'ACT2_SNEK_COMPLETE' },
                'mapComplete': { phase: 'ACT2', dialogue: 'ACT2_MAP_COMPLETE' },
                'labyrinthWord': { phase: 'ACT2', dialogue: 'ACT2_LABYRINTH_WORD' },
                'sudoStars': { phase: 'ACT2', dialogue: 'ACT2_SUDO_STARS' },
                'starshipOpen': { phase: 'ACT2', dialogue: 'ACT2_STARSHIP' },
                'starshipLost': { phase: 'ACT2', dialogue: 'ACT2_STARSHIP_HINT' },
                'booksUnlocked': { phase: 'ACT2', dialogue: 'ACT2_BOOKS_UNLOCKED' },
                'truthBookFound': { phase: 'ACT2', dialogue: 'ACT2_TRUTH_BOOK' },
                'truthUnlocked': { phase: 'ACT2', dialogue: 'ACT3_TRUTH_UNLOCKED' },
                'terminalScan': { phase: 'ACT2', dialogue: 'ACT2_TERMINAL_SCAN' },
                'voidScan': { phase: 'ACT2', dialogue: 'ACT2_VOID_SCAN' },
            };

            // Process a single event trigger (called when dog is free)
            const processEventTrigger = (event) => {
                if (!dogCompanionActive) return;

                // Special case: dogReturn has different handling
                if (event === 'dogReturn') {
                    if (dogCompanionStoryPhase === 'ACT3_SACRIFICE') {
                        setDogCompanionActive(true);
                        setTimeout(() => startDogDialogue('ACT3_RETURN'), 1000);
                    }
                    return;
                }

                // Regular events - check phase and start dialogue
                const eventConfig = EVENT_TO_DIALOGUE[event];
                if (eventConfig && dogCompanionStoryPhase === eventConfig.phase) {
                    startDogDialogue(eventConfig.dialogue);
                }
            };

            // Check if dog is busy (in dialogue or waiting for action)
            const isDogBusy = () => {
                return dogCompanionDialogue !== null || dogCompanionWaitingFor !== null;
            };

            // Notify dog of game events - queues if busy, processes immediately if free
            const notifyDogEvent = (event, data = {}) => {
                if (!dogCompanionActive && event !== 'dogReturn') return;

                // Check if waiting for this action - this takes priority
                if (dogCompanionWaitingFor === event) {
                    // Mark current dialogue as completed before transitioning
                    if (dogCompanionCurrentDialogueKey) {
                        setDogCompletedDialogues(prev => {
                            if (!prev.includes(dogCompanionCurrentDialogueKey)) {
                                return [...prev, dogCompanionCurrentDialogueKey];
                            }
                            return prev;
                        });
                    }
                    setDogCompanionWaitingFor(null);
                    setDogCompanionDialogue(null);
                    setDogCompanionDialogueQueue([]);
                    setDogCompanionCurrentDialogueKey(null);
                    setDogCompanionDialogueIndex(0);
                    // Clear the queue when a wait action is completed
                    dogTriggerQueueRef.current = [];
                    const nextDialogue = WAIT_ACTION_TO_NEXT_DIALOGUE[event];
                    if (nextDialogue) {
                        setTimeout(() => startDogDialogue(nextDialogue), 500);
                    }
                    return;
                }

                // Check if this event should be queued or processed immediately
                if (isDogBusy()) {
                    // Don't queue duplicate events or events already in queue
                    if (!dogTriggerQueueRef.current.includes(event)) {
                        dogTriggerQueueRef.current.push(event);
                    }
                } else {
                    // Dog is free - process immediately
                    processEventTrigger(event);
                }
            };

            // Close error window
            const closeDogError = (id) => {
                setDogErrorWindows(prev => {
                    const remaining = prev.filter(e => e.id !== id);
                    // Check if all errors closed (use remaining.length, not stale state)
                    if (remaining.length === 0 && dogCompanionWaitingFor === 'closeErrors') {
                        // Mark current dialogue as completed before transitioning
                        if (dogCompanionCurrentDialogueKey) {
                            setDogCompletedDialogues(prevCompleted => {
                                if (!prevCompleted.includes(dogCompanionCurrentDialogueKey)) {
                                    return [...prevCompleted, dogCompanionCurrentDialogueKey];
                                }
                                return prevCompleted;
                            });
                        }
                        setTimeout(() => {
                            setDogCompanionWaitingFor(null);
                            setDogCompanionDialogue(null);
                            setDogCompanionCurrentDialogueKey(null);
                            setDogCompanionDialogueIndex(0);
                            startDogDialogue('ACT1_POST_ERRORS');
                        }, 500);
                    }
                    return remaining;
                });
            };

            // Idle dialogue system - only runs when dog is completely free
            useEffect(() => {
                // Don't start idle if dog is busy with anything
                if (!dogCompanionActive || dogCompanionDialogue || dogCompanionWaitingFor || dogCompanionStoryPhase === 'inactive') return;

                // Start idle timer
                const scheduleIdle = () => {
                    const delay = 30000 + Math.random() * 30000; // 30-60 seconds
                    dogIdleTimerRef.current = setTimeout(() => {
                        // Double-check dog is still free before showing idle dialogue
                        if (dogCompanionDialogue || dogCompanionWaitingFor) {
                            scheduleIdle();
                            return;
                        }
                        const now = Date.now();
                        if (now - lastIdleDialogueRef.current > 30000) {
                            const pool = dogCompanionStoryPhase === 'POST_GAME'
                                ? [...DOG_DIALOGUES.IDLE_GENERAL, ...DOG_DIALOGUES.IDLE_POST_GAME]
                                : DOG_DIALOGUES.IDLE_GENERAL;
                            const randomDialogue = pool[Math.floor(Math.random() * pool.length)];
                            setDogCompanionDialogue(randomDialogue);
                            setDogCompanionEmotion(randomDialogue.emotion || 'speaking');
                            lastIdleDialogueRef.current = now;

                            // Auto-dismiss after dialogue (6 second pause after finishing)
                            const displayTime = randomDialogue.waitAfter || 3000;
                            setTimeout(() => {
                                setDogCompanionDialogue(null);
                                setDogCompanionEmotion('idle');
                                // Process any queued triggers after idle dialogue ends
                                if (dogTriggerQueueRef.current.length > 0) {
                                    const nextEvent = dogTriggerQueueRef.current.shift();
                                    setTimeout(() => processEventTrigger(nextEvent), 500);
                                } else {
                                    scheduleIdle();
                                }
                            }, displayTime + randomDialogue.text.length * 40 + 6000);
                        } else {
                            scheduleIdle();
                        }
                    }, delay);
                };

                scheduleIdle();
                return () => clearTimeout(dogIdleTimerRef.current);
            }, [dogCompanionActive, dogCompanionDialogue, dogCompanionWaitingFor, dogCompanionStoryPhase]);

            // Resume dialogue on page reload (if was mid-dialogue)
            useEffect(() => {
                if (dogResumeCheckedRef.current) return;
                dogResumeCheckedRef.current = true;

                // Check if there's a saved dialogue to resume
                const savedKey = localStorage.getItem('dog_dialogue_key');
                const savedIndex = parseInt(localStorage.getItem('dog_dialogue_index') || '0', 10);
                const savedWaiting = localStorage.getItem('dog_waiting_for');

                // If dog is waiting for action but no saved key, just let the wait state continue
                if (savedWaiting && !savedKey) {
                    // Dog is waiting for an action - no dialogue resume needed
                    return;
                }

                if (!savedKey || !dogCompanionActive) return;

                // Don't resume for idle phases or if dog is inactive
                const idlePhases = ['inactive', 'POST_GAME', 'ACT3_SACRIFICE'];
                if (idlePhases.includes(dogCompanionStoryPhase)) {
                    localStorage.removeItem('dog_dialogue_key');
                    localStorage.removeItem('dog_dialogue_index');
                    return;
                }

                // Check if the dialogue key exists
                if (!DOG_DIALOGUES[savedKey]) {
                    localStorage.removeItem('dog_dialogue_key');
                    localStorage.removeItem('dog_dialogue_index');
                    return;
                }

                // Skip if this dialogue was already completed
                if (dogCompletedDialogues.includes(savedKey)) {
                    localStorage.removeItem('dog_dialogue_key');
                    localStorage.removeItem('dog_dialogue_index');
                    return;
                }

                // Wait 3 seconds, then show "where were we?" and resume
                setTimeout(() => {
                    // Show first resume line: "WAIT..."
                    const resumeDialogues = DOG_DIALOGUES.RESUME_DIALOGUE;
                    setDogCompanionDialogue(resumeDialogues[0]);
                    setDogCompanionEmotion(resumeDialogues[0].emotion || 'thinking');

                    // Calculate time for first line (typing + waitAfter)
                    const firstLineTime = (resumeDialogues[0].text.length * 40) + (resumeDialogues[0].waitAfter || 1500) + 1000;

                    // Show second line: "WHERE WERE WE?"
                    setTimeout(() => {
                        setDogCompanionDialogue(resumeDialogues[1]);
                        setDogCompanionEmotion(resumeDialogues[1].emotion || 'thinking');

                        // Calculate time for second line then resume
                        const secondLineTime = (resumeDialogues[1].text.length * 40) + 2000;

                        setTimeout(() => {
                            startDogDialogue(savedKey, null, savedIndex);
                        }, secondLineTime);
                    }, firstLineTime);
                }, 3000);
            }, [dogCompanionActive, dogCompanionStoryPhase]);

            // Dog companion dragging handlers with 100ms hold timer
            const dogHoldTimerRef = useRef(null);
            const dogPendingDragRef = useRef(false);

            const handleDogCompanionMouseDown = (e) => {
                e.preventDefault();
                e.stopPropagation();
                dogPendingDragRef.current = true;

                // Start 100ms hold timer before enabling drag
                dogHoldTimerRef.current = setTimeout(() => {
                    if (dogPendingDragRef.current) {
                        setDogCompanionDragging(true);
                        setDogCompanionEmotion('panicked');
                        dogCompanionVelRef.current = { x: 0, y: 0 };
                    }
                }, 100);
            };

            const handleDogCompanionMouseMove = (e) => {
                if (!dogCompanionDragging) return;
                setDogCompanionPos({
                    x: e.clientX - DOG_PHYSICS.DOG_SIZE / 2,
                    y: e.clientY - DOG_PHYSICS.DOG_SIZE / 2
                });
            };

            const handleDogCompanionMouseUp = (e) => {
                // Cancel hold timer if released early
                if (dogHoldTimerRef.current) {
                    clearTimeout(dogHoldTimerRef.current);
                    dogHoldTimerRef.current = null;
                }
                dogPendingDragRef.current = false;

                if (!dogCompanionDragging) return;
                setDogCompanionDragging(false);
                // Give a small random velocity when released
                dogCompanionVelRef.current = {
                    x: (Math.random() - 0.5) * 4,
                    y: 2
                };
                // Stay panicked until grounded - the useEffect below handles returning to idle
            };

            // Global mouse handlers for companion dragging
            useEffect(() => {
                // Always listen for mouseup to cancel pending drags
                const handleGlobalMouseUp = (e) => {
                    if (dogHoldTimerRef.current) {
                        clearTimeout(dogHoldTimerRef.current);
                        dogHoldTimerRef.current = null;
                    }
                    dogPendingDragRef.current = false;
                    handleDogCompanionMouseUp(e);
                };

                window.addEventListener('mouseup', handleGlobalMouseUp);

                if (dogCompanionDragging) {
                    window.addEventListener('mousemove', handleDogCompanionMouseMove);
                }

                return () => {
                    window.removeEventListener('mouseup', handleGlobalMouseUp);
                    window.removeEventListener('mousemove', handleDogCompanionMouseMove);
                };
            }, [dogCompanionDragging]);

            // Return to idle after being grounded for 0.1 second (after being dropped)
            const groundedTimerRef = useRef(null);
            useEffect(() => {
                // Only trigger when grounded and in panicked state from being airborne (not from dialogue)
                if (dogCompanionGrounded && dogCompanionEmotion === 'panicked' && !dogCompanionDragging && !dogCompanionDialogue) {
                    groundedTimerRef.current = setTimeout(() => {
                        setDogCompanionEmotion('idle');
                    }, 100);
                } else {
                    // Clear timer if no longer grounded or emotion changed
                    if (groundedTimerRef.current) {
                        clearTimeout(groundedTimerRef.current);
                        groundedTimerRef.current = null;
                    }
                }
                return () => {
                    if (groundedTimerRef.current) {
                        clearTimeout(groundedTimerRef.current);
                    }
                };
            }, [dogCompanionGrounded, dogCompanionEmotion, dogCompanionDragging, dogCompanionDialogue]);

            // Handle Goldy click (fold down like cardboard falling and disappear forever)
            const handleGoldyClick = () => {
                setGoldyFalling(true);
                setTimeout(() => setGoldyVisible(false), 500);
            };

            // Legacy dog dragging handlers
            const handleDogMouseDown = (e) => {
                e.preventDefault();
                e.stopPropagation();
                const offsetX = e.clientX - dogPos.x;
                const offsetY = e.clientY - dogPos.y;

                // Start hold timer - need to hold for 300ms to start dragging
                dogHoldTimer.current = setTimeout(() => {
                    setDogDragging(true);
                    setDogDragOffset({ x: offsetX, y: offsetY });
                }, 300);
            };

            const handleDogMouseUp = (e) => {
                if (dogHoldTimer.current) {
                    clearTimeout(dogHoldTimer.current);
                    dogHoldTimer.current = null;
                }

                if (dogDragging) {
                    setDogDragging(false);

                    // Check if dropped on trash
                    const trashPos = iconPositions.TRASH || { x: window.innerWidth - 110, y: window.innerHeight - 140 };
                    const trashLeft = trashPos.x;
                    const trashTop = trashPos.y;
                    const trashRight = trashLeft + 96; // ~w-24 = 96px
                    const trashBottom = trashTop + 80;

                    // Increased hitbox by 50% (45px margin instead of 30px) for easier dropping
                    if (dogPos.x >= trashLeft - 45 && dogPos.x <= trashRight + 45 &&
                        dogPos.y >= trashTop - 45 && dogPos.y <= trashBottom + 45) {
                        // Dog was dropped on trash!
                        sounds.error();
                        setDogReleased(false);

                        // Close PRIVATE.EXE and DOG.TXT windows
                        close('PERSONAL');
                        close('DOG_STORY');

                        // Update trash count
                        const newCount = dogTrashCount + 1;
                        setDogTrashCount(newCount);
                        localStorage.setItem('dog_trash_count', newCount.toString());

                        // Trigger achievements
                        if (newCount >= 1 && !achievements.YOU_MONSTER) {
                            setTimeout(() => unlockAchievement('YOU_MONSTER'), 500);
                        }
                    }
                } else {
                    // Quick click - just bark and stop
                    sounds.bark();
                    setDogReleased(false);
                }
            };

            // Global mouse move for dog dragging
            useEffect(() => {
                if (!dogDragging) return;

                const handleMouseMove = (e) => {
                    setDogPos({
                        x: e.clientX - dogDragOffset.x,
                        y: e.clientY - dogDragOffset.y
                    });
                };

                const handleMouseUp = (e) => {
                    handleDogMouseUp(e);
                };

                window.addEventListener('mousemove', handleMouseMove);
                window.addEventListener('mouseup', handleMouseUp);

                return () => {
                    window.removeEventListener('mousemove', handleMouseMove);
                    window.removeEventListener('mouseup', handleMouseUp);
                };
            }, [dogDragging, dogDragOffset]);

            // Desktop icons - MESSAGES only if intro not complete, otherwise full desktop
            // Story mode: only APPS, TRASH, TRUTH visible (no CONTACT)
            // TRUTH is always in list but only visible/clickable when Third Eye scans it
            const storyModeIcons = ["APPS", "TRASH", "TRUTH"];
            const aboutModeIcons = ["ABOUT", "FILES", "CONTACT"];

            // If intro not complete, show only MESSAGES. If revealing, show progressively revealed apps
            const desktopIcons = !introComplete
                ? (revealingApps ? ["MESSAGES", ...revealedApps] : ["MESSAGES"])
                : (modeSelected === 'about' ? aboutModeIcons : storyModeIcons);

            // Window State (Position x/y added for dragging) - content rendered separately
            // Base sizes are for 1920x1080, will be scaled for smaller screens
            const [windows, setWindows] = useState({
                "MESSAGES": { id: "MESSAGES", title: "MESSAGES.EXE", icon: "Email", x: 200, y: 80, w: 380, h: 500, isOpen: false, isMin: false, z: 8, isDesktop: true },
                "ABOUT": { id: "ABOUT", title: "ABOUT", icon: "Terminal", x: 150, y: 50, w: 820, h: 700, isOpen: false, isMin: false, z: 9, isDesktop: true },
                "SYSTEM": { id: "SYSTEM", title: "SYSTEM_INFO", icon: "Terminal", x: 400, y: 50, w: 1000, h: 800, isOpen: true, isMin: false, z: 10, isDesktop: true },
                "FILES": { id: "FILES", title: "MEDIA_LIB", icon: "Folder", x: 100, y: 80, w: 800, h: 500, isOpen: false, isMin: false, z: 11, isDesktop: true },
                "APPS": { id: "APPS", title: "APPS", icon: "Apps", x: 150, y: 110, w: 700, h: 500, isOpen: false, isMin: false, z: 12, isDesktop: true },
                "CONTACT": { id: "CONTACT", title: "CONTACT", icon: "Email", x: 200, y: 140, w: 320, h: 380, isOpen: false, isMin: false, z: 13, isDesktop: true },
                "PAINT": { id: "PAINT", title: "PAINT.EXE", icon: "Palette", x: 150, y: 110, w: 700, h: 600, isOpen: false, isMin: false, z: 14 },
                "SNAKE": { id: "SNAKE", title: "SNEK.EXE", icon: "Snek", x: 200, y: 140, w: 640, h: 520, isOpen: false, isMin: false, z: 15 },
                "TRASH": { id: "TRASH", title: "TRASH.BIN", icon: "TrashCan", x: 250, y: 170, w: 500, h: 400, isOpen: false, isMin: false, z: 16 },
                "VOID": { id: "VOID", title: "VOID.TXT", icon: "Void", x: 300, y: 50, w: 500, h: 400, isOpen: false, isMin: false, z: 17 },
                "RADIO": { id: "RADIO", title: "RADIO.WAV", icon: "Radio", x: 400, y: 110, w: 400, h: 400, isOpen: false, isMin: false, z: 19 },
                "DICE": { id: "DICE", title: "DICE.EXE", icon: "Dice", x: 450, y: 140, w: 350, h: 420, isOpen: false, isMin: false, z: 20 },
                "LABYRINTH": { id: "LABYRINTH", title: "LABYRINTH.EXE", icon: "Labyrinth", x: 100, y: 50, w: 600, h: 500, isOpen: false, isMin: false, z: 21 },
                "MINESWEEPER": { id: "MINESWEEPER", title: "MINESWEEPER.EXE", icon: "Minesweeper", x: 120, y: 40, w: 500, h: 560, isOpen: false, isMin: false, z: 26 },
                "STARSHIP": { id: "STARSHIP", title: "STARSHIP.EXE", icon: "Starship", x: 80, y: 40, w: 540, h: 480, isOpen: false, isMin: false, z: 27 },
                                "DESTRUCTION": { id: "DESTRUCTION", title: "DESTRUCTION.EXE", icon: "Destruction", x: 200, y: 110, w: 400, h: 400, isOpen: false, isMin: false, z: 23 },
                "TAROT": { id: "TAROT", title: "TAROT.DAT", icon: "Tarot", x: 100, y: 60, w: 520, h: 550, isOpen: false, isMin: false, z: 24 },
                                "MAP": { id: "MAP", title: "MAP.EXE", icon: "Globe", x: 150, y: 100, w: 360, h: 400, isOpen: false, isMin: false, z: 29 },
                "POMODORO": { id: "POMODORO", title: "POMODORO.EXE", icon: "Pomodoro", x: 200, y: 60, w: 350, h: 620, isOpen: false, isMin: false, z: 30 },
                "SCANNER": { id: "SCANNER", title: "SCANNER.EXE", icon: "HealthScanner", x: 150, y: 50, w: 600, h: 700, isOpen: false, isMin: false, z: 31 },
                "PERSONAL": { id: "PERSONAL", title: "PRIVATE.EXE", icon: "Lock", x: 200, y: 80, w: 320, h: 340, isOpen: false, isMin: false, z: 32 },
                "TERMINAL": { id: "TERMINAL", title: "TERMINAL.EXE", icon: "Terminal", x: 120, y: 100, w: 650, h: 450, isOpen: false, isMin: false, z: 33 },
                "TRUTH": { id: "TRUTH", title: "TRUTH.TXT", icon: "FileDoc", x: 180, y: 120, w: 320, h: 380, isOpen: false, isMin: false, z: 34, isDesktop: true },
                "DOG_STORY": { id: "DOG_STORY", title: "DOG.TXT", icon: "FileDoc", x: 100, y: 80, w: 600, h: 500, isOpen: false, isMin: false, z: 35 },
                "THIRD_EYE": { id: "THIRD_EYE", title: "THIRD_EYE.EXE", icon: "ThirdEye", x: 140, y: 90, w: 450, h: 400, isOpen: false, isMin: false, z: 36 },
                "THIRD_EYE_2": { id: "THIRD_EYE_2", title: "THIRD_EYE.EXE", icon: "ThirdEye", x: 200, y: 150, w: 450, h: 400, isOpen: false, isMin: false, z: 37 },
                "BROWSER": { id: "BROWSER", title: "KONAMI by zen", icon: "Browser", x: 160, y: 70, w: 500, h: 400, isOpen: false, isMin: false, z: 38 },
                "END": { id: "END", title: "ACHIEVEMENTS", icon: "Trophy", x: 200, y: 100, w: 400, h: 350, isOpen: false, isMin: false, z: 39 },
                "BOOKS": { id: "BOOKS", title: "BOOKS.EXE", icon: "FileDoc", x: 150, y: 80, w: 600, h: 500, isOpen: false, isMin: false, z: 40 },
                                "TRUTH_MESSAGES": { id: "TRUTH_MESSAGES", title: "MESSAGES.EXE", icon: "Email", x: 200, y: 80, w: 380, h: 500, isOpen: false, isMin: false, z: 42 }
            });

            // Auto-scale windows based on viewport - designed for 1920x1080, scales down for smaller screens
            const getScaledSize = (baseW, baseH) => {
                const vw = window.innerWidth;
                const vh = window.innerHeight;
                const baseWidth = 1920;
                const baseHeight = 1080;

                // Calculate scale factor (use the smaller of width/height ratios)
                const scaleX = vw / baseWidth;
                const scaleY = vh / baseHeight;
                const scale = Math.min(scaleX, scaleY, 1); // Never scale up, only down

                // Apply scale with minimum sizes
                const scaledW = Math.max(280, Math.round(baseW * scale));
                const scaledH = Math.max(200, Math.round(baseH * scale));

                // Ensure it fits in viewport with padding
                const maxW = vw - 40;
                const maxH = vh - 80;

                return {
                    w: Math.min(scaledW, maxW),
                    h: Math.min(scaledH, maxH)
                };
            };

            // Handle intro complete - hide messages, reveal apps one by one, then open ABOUT
            const introCompleteCalledRef = useRef(false);
            const handleIntroComplete = () => {
                // Guard against multiple calls
                if (introCompleteCalledRef.current) return;
                introCompleteCalledRef.current = true;

                localStorage.setItem('intro_complete', 'true');

                // Hide messages.exe first before revealing apps
                close('MESSAGES');
                setRevealingApps(true);

                // Reveal apps one by one with 200ms delay (story mode: only APPS and TRASH initially)
                // ABOUT.EXE and MEDIA_LIB are hidden - unlocked later in story progression
                const appsToReveal = ["APPS", "TRASH"];
                appsToReveal.forEach((appId, index) => {
                    setTimeout(() => {
                        setRevealedApps(prev => [...prev, appId]);
                        sounds.ping();
                    }, index * 200);
                });

                // After all apps revealed + 500ms, complete intro and spawn dog companion
                setTimeout(() => {
                    setIntroComplete(true);
                    setRevealingApps(false);
                    setRevealedApps([]);

                    // DOG COMPANION: Spawn after messages.exe and start ACT 1
                    if (modeSelected === 'story' && !dogCompanionActive) {
                        setTimeout(() => {
                            spawnDogCompanion();
                            setDogCompanionStoryPhase('ACT1_BOOT');
                            // Start boot dialogue after dog settles (2 seconds)
                            setTimeout(() => {
                                startDogDialogue('ACT1_BOOT');
                            }, 2000);
                        }, 500);
                    }
                }, appsToReveal.length * 200 + 500);
            };

            // Render window content based on ID
            const getWindowContent = (id) => {
                switch (id) {
                    case "MESSAGES": return <MessagesApp onIntroComplete={handleIntroComplete} />;
                    case "ABOUT": return <AboutApp onAchievement={unlockAchievement} />;
                    case "SYSTEM": return <SystemInfo onThirdEyeWorld={activateThirdEyeWorld} totalVisitors={totalVisitors} />;
                    case "FILES": return <FileExplorer onAchievement={unlockAchievement} />;
                    case "APPS": return <AppsFolder onOpenApp={open} onDragStart={handleFolderDragStart} isMobile={isMobile} unlockedApps={unlockedApps} />;
                    case "CONTACT": return <ContactApp onOpenPaint={() => { setPaintShowHint(true); open('PAINT'); close('CONTACT'); }} />;
                    case "PAINT": return <PaintApp showHint={paintShowHint} onAchievement={unlockAchievement} />;
                    case "SNAKE": return <SnakeAppNew onAchievement={unlockAchievement} onDogEvent={notifyDogEvent} />;
                    case "TRASH": return <TrashApp />;
                    case "VOID": return <VoidApp onAchievement={unlockAchievement} />;
                    case "RADIO": return <RadioApp onAchievement={unlockAchievement} />;
                    case "DICE": return <DiceApp onAchievement={unlockAchievement} />;
                    case "LABYRINTH": return <LabyrinthApp onAchievement={unlockAchievement} onDogEvent={notifyDogEvent} />;
                    case "MINESWEEPER": return <MinesweeperApp onAchievement={unlockAchievement} />;
                    case "STARSHIP": return <StarshipApp onAchievement={unlockAchievement} onUnlockApp={unlockApp} onDogEvent={notifyDogEvent} />;
                    case "DESTRUCTION": return <DestructionApp onDogSteal={handleDogSteal} onAchievement={unlockAchievement} />;
                    case "TAROT": return <TarotApp onAchievement={unlockAchievement} onUnlockApp={unlockApp} />;
                    case "MAP": return <MapApp onAchievement={unlockAchievement} onUnlockApp={unlockApp} onDogEvent={notifyDogEvent} />;
                    case "POMODORO": return <PomodoroApp onAchievement={unlockAchievement} />;
                    case "SCANNER": return <HealthScannerApp />;
                    case "PERSONAL": return <PersonalApp unlocked={privateUnlocked} onOpenDogStory={openDogStory} />;
                    case "TERMINAL": return <TerminalApp onClose={close} onOpenApp={open} onReleaseDog={() => setDogReleased(true)} onMatrixMode={toggleMatrixMode} onUnlockPrivate={unlockPrivate} onAchievement={unlockAchievement} onGodMode={handleGodMode} onUnlockApp={unlockApp} unlockedApps={unlockedApps} thirdEyeActive={windows.THIRD_EYE?.isOpen || windows.THIRD_EYE_2?.isOpen} onDogEvent={notifyDogEvent} />;
                    case "TRUTH": return <TruthApp onAchievement={unlockAchievement} onOpenTruthMessages={() => { open('TRUTH_MESSAGES'); close('TRUTH'); }} godModeCompleted={achievements.BECOME_GOD} />;
                    case "DOG_STORY": return <DogStoryTerminal onRemoveGoldDog={removeGoldDog} />;
                    case "THIRD_EYE": return <ThirdEyeApp windowId="THIRD_EYE" windows={windows} stackOverflow={stackOverflow} stackErrors={stackErrors} iconPositions={iconPositions} onOpenTruth={() => open('TRUTH')} onDogEvent={notifyDogEvent} />;
                    case "THIRD_EYE_2": return <ThirdEyeApp windowId="THIRD_EYE_2" windows={windows} stackOverflow={stackOverflow} stackErrors={stackErrors} iconPositions={iconPositions} onOpenTruth={() => open('TRUTH')} onDogEvent={notifyDogEvent} />;
                    case "BROWSER": return <BrowserApp onOpenApp={open} onAchievement={unlockAchievement} isMobile={isMobile} />;
                    case "END": return <EndApp achievements={achievements} totalClicks={totalClicks} />;
                    case "BOOKS": return <BooksApp onUnlockApp={unlockApp} unlockedApps={unlockedApps} onDogEvent={notifyDogEvent} />;
                    case "TRUTH_MESSAGES": return <MessagesApp isTruthSequence={true} onTruthComplete={() => { unlockAchievement('TRUTH_SEEKER'); notifyDogEvent('dogReturn'); setTimeout(() => close('TRUTH_MESSAGES'), 10000); }} />;
                    default: return null;
                }
            };

            // Dragging State with Physics
            const [drag, setDrag] = useState({ id: null, offsetX: 0, offsetY: 0 });
            const lastMousePos = useRef({ x: 0, y: 0, time: Date.now() });
            const windowPhysics = useRef({}); // { windowId: { velX, velY, scaleX, scaleY } }
            const windowBounces = useRef({}); // { windowId: { left: bool, right: bool, top: bool, bottom: bool } }
            const physicsAchievementUnlocked = useRef(false);

            // Physics constants
            const FRICTION = 0.94; // Velocity decay per frame (2x faster momentum)
            const BOUNCE_DAMPING = 0.6; // Energy loss on bounce (more bounce)
            const MIN_VELOCITY = 0.25; // Stop threshold (reduced for smoother stops)
            const EDGE_MAGNET_DISTANCE = 30; // Pixels for edge attraction
            const EDGE_MAGNET_STRENGTH = 0.15; // Pull strength
            const SQUASH_AMOUNT = 0.02; // 2% max squash/stretch

            // Initialize physics for a window
            const initWindowPhysics = (id) => {
                if (!windowPhysics.current[id]) {
                    windowPhysics.current[id] = { velX: 0, velY: 0, scaleX: 1, scaleY: 1 };
                }
                return windowPhysics.current[id];
            };

            // Physics loop
            useEffect(() => {
                let animationId;
                const physicsLoop = () => {
                    setWindows(prev => {
                        let updated = { ...prev };
                        let hasChanges = false;

                        Object.keys(prev).forEach(id => {
                            const win = prev[id];
                            if (!win.isOpen || win.isMin) return;

                            const physics = initWindowPhysics(id);

                            // Skip if being dragged
                            if (drag.id === id) return;

                            // Skip if no significant velocity
                            if (Math.abs(physics.velX) < MIN_VELOCITY && Math.abs(physics.velY) < MIN_VELOCITY) {
                                physics.velX = 0;
                                physics.velY = 0;
                                // Decay squash/stretch back to normal
                                physics.scaleX += (1 - physics.scaleX) * 0.2;
                                physics.scaleY += (1 - physics.scaleY) * 0.2;
                                return;
                            }

                            hasChanges = true;

                            // Apply friction
                            physics.velX *= FRICTION;
                            physics.velY *= FRICTION;

                            // Calculate new position
                            let newX = win.x + physics.velX;
                            let newY = win.y + physics.velY;

                            // Use SCALED dimensions for bounds (matches actual rendered size)
                            const scaled = getScaledSize(win.w, win.h);
                            const winWidth = scaled.w;
                            const winHeight = scaled.h;
                            // Clamp bounds to ensure windows can always move (handle windows larger than screen)
                            const maxX = Math.max(0, window.innerWidth - winWidth);
                            const maxY = Math.max(0, window.innerHeight - 60 - winHeight); // Account for taskbar
                            const minY = isMobile ? 60 : 0; // Account for mobile top taskbar

                            // Edge magnetism (only when slow enough)
                            const totalVel = Math.sqrt(physics.velX ** 2 + physics.velY ** 2);
                            if (totalVel < 5) {
                                // Left edge
                                if (newX < EDGE_MAGNET_DISTANCE && newX > 0) {
                                    physics.velX -= newX * EDGE_MAGNET_STRENGTH;
                                }
                                // Right edge
                                if (newX > maxX - EDGE_MAGNET_DISTANCE && newX < maxX) {
                                    physics.velX += (maxX - newX) * EDGE_MAGNET_STRENGTH;
                                }
                                // Top edge
                                if (newY < minY + EDGE_MAGNET_DISTANCE && newY > minY) {
                                    physics.velY -= (newY - minY) * EDGE_MAGNET_STRENGTH;
                                }
                                // Bottom edge
                                if (newY > maxY - EDGE_MAGNET_DISTANCE && newY < maxY) {
                                    physics.velY += (maxY - newY) * EDGE_MAGNET_STRENGTH;
                                }
                            }

                            // Bounce off edges with squash/stretch
                            // Track bounces for PHYSICS achievement
                            if (!windowBounces.current[id]) {
                                windowBounces.current[id] = { left: false, right: false, top: false, bottom: false };
                            }
                            const bounces = windowBounces.current[id];

                            if (newX <= 0) {
                                newX = 0;
                                physics.velX = -physics.velX * BOUNCE_DAMPING;
                                physics.scaleX = 1 - SQUASH_AMOUNT * Math.min(Math.abs(physics.velX) / 10, 1);
                                physics.scaleY = 1 + SQUASH_AMOUNT * Math.min(Math.abs(physics.velX) / 10, 1);
                                sounds.bounce(Math.abs(physics.velX));
                                bounces.left = true;
                            } else if (newX >= maxX) {
                                newX = maxX;
                                physics.velX = -physics.velX * BOUNCE_DAMPING;
                                physics.scaleX = 1 - SQUASH_AMOUNT * Math.min(Math.abs(physics.velX) / 10, 1);
                                physics.scaleY = 1 + SQUASH_AMOUNT * Math.min(Math.abs(physics.velX) / 10, 1);
                                sounds.bounce(Math.abs(physics.velX));
                                bounces.right = true;
                            }

                            if (newY <= minY) {
                                newY = minY;
                                physics.velY = -physics.velY * BOUNCE_DAMPING;
                                physics.scaleY = 1 - SQUASH_AMOUNT * Math.min(Math.abs(physics.velY) / 10, 1);
                                physics.scaleX = 1 + SQUASH_AMOUNT * Math.min(Math.abs(physics.velY) / 10, 1);
                                sounds.bounce(Math.abs(physics.velY));
                                bounces.top = true;
                            } else if (newY >= maxY) {
                                newY = maxY;
                                physics.velY = -physics.velY * BOUNCE_DAMPING;
                                physics.scaleY = 1 - SQUASH_AMOUNT * Math.min(Math.abs(physics.velY) / 10, 1);
                                physics.scaleX = 1 + SQUASH_AMOUNT * Math.min(Math.abs(physics.velY) / 10, 1);
                                sounds.bounce(Math.abs(physics.velY));
                                bounces.bottom = true;
                            }

                            // Check for PHYSICS achievement (all 4 edges in one throw)
                            if (bounces.left && bounces.right && bounces.top && bounces.bottom && !physicsAchievementUnlocked.current) {
                                physicsAchievementUnlocked.current = true;
                                unlockAchievement('PHYSICS');
                            }

                            // Decay squash/stretch back to normal
                            physics.scaleX += (1 - physics.scaleX) * 0.3;
                            physics.scaleY += (1 - physics.scaleY) * 0.3;

                            updated[id] = { ...win, x: newX, y: newY };
                        });

                        return hasChanges ? updated : prev;
                    });

                    animationId = requestAnimationFrame(physicsLoop);
                };

                animationId = requestAnimationFrame(physicsLoop);
                return () => cancelAnimationFrame(animationId);
            }, [drag.id, isMobile]);

            // Boot sequence with mobile detection
            useEffect(() => {
                const checkMobile = window.innerWidth < 768 || /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                setIsMobile(checkMobile);

                // Close SYSTEM window on mobile by default
                if (checkMobile) {
                    setWindows(prev => ({
                        ...prev,
                        SYSTEM: { ...prev.SYSTEM, isOpen: false }
                    }));
                }

                // Preload all pixelarticons during boot
                const iconNames = [
                    'monitor', 'folder', 'fill', 'gamepad', 'trash', 'undo', 'redo', 'file',
                    'close', 'minus', 'checkbox', 'send', 'movie', 'book', 'music', 'arrow-left',
                    'code', 'book-open', 'radio-on', 'dice', 'layout-rows', 'table', 'arrow-up',
                    'keyboard', 'power', 'card', 'paw', 'mail', 'add-grid', 'image', 'map',
                    'clock', 'heart', 'lock', 'sliders', 'user'
                ];
                iconNames.forEach(name => {
                    const img = new Image();
                    img.src = `https://unpkg.com/pixelarticons@1.8.1/svg/${name}.svg`;
                });

                const isFirstEver = !localStorage.getItem('intro_complete');

                // Handle resize
                const handleResize = () => {
                    setIsMobile(window.innerWidth < 768);
                };
                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, []);

            // Boot sequence - only starts AFTER mode is selected
            useEffect(() => {
                if (!modeSelected) return; // Don't start boot until mode is selected

                // Same boot sequence for mobile and desktop
                setBootPhase(1);
                // Close SYSTEM on boot
                setWindows(prev => ({
                    ...prev,
                    SYSTEM: { ...prev.SYSTEM, isOpen: false }
                }));
                setTimeout(() => {
                    setBootPhase(2);
                    setBooted(true);
                }, 2000);
            }, [modeSelected]);

            // Handle 'about' mode after boot - skip intro and open ABOUT
            useEffect(() => {
                if (booted && modeSelected === 'about' && !introComplete) {
                    setIntroComplete(true);
                    setTimeout(() => open('ABOUT'), 100);
                }
            }, [booted, modeSelected]);

            // Reposition icons that are off-screen on mobile
            useEffect(() => {
                if (isMobile) {
                    const maxX = window.innerWidth - 80;
                    const maxY = window.innerHeight - 96;
                    const minY = 56;
                    setIconPositions(prev => {
                        const updated = { ...prev };
                        let needsUpdate = false;
                        Object.keys(prev).forEach(id => {
                            const pos = prev[id];
                            if (pos.x > maxX || pos.y > maxY || pos.y < minY) {
                                needsUpdate = true;
                                updated[id] = {
                                    x: Math.max(8, Math.min(maxX, pos.x)),
                                    y: Math.max(minY, Math.min(maxY, pos.y))
                                };
                            }
                        });
                        return needsUpdate ? updated : prev;
                    });
                }
            }, [isMobile]);

            // Window Ops
            const focus = (id) => {
                topZRef.current += 1;
                const newZ = topZRef.current;
                setWindows(p => ({ ...p, [id]: { ...p[id], z: newZ } }));
                setTopZ(newZ);
            }
            const open = (id) => {
                sounds.windowOpen();
                topZRef.current += 1;
                const newZ = topZRef.current;
                // THIRD_EYE can open multiple copies
                let targetId = id;
                if (id === 'THIRD_EYE') {
                    setWindows(p => {
                        if (p.THIRD_EYE.isOpen && !p.THIRD_EYE.isMin) {
                            targetId = 'THIRD_EYE_2';
                            return { ...p, THIRD_EYE_2: { ...p.THIRD_EYE_2, isOpen: true, isMin: false, z: newZ } };
                        }
                        return { ...p, THIRD_EYE: { ...p.THIRD_EYE, isOpen: true, isMin: false, z: newZ } };
                    });
                } else {
                    setWindows(p => ({ ...p, [id]: { ...p[id], isOpen: true, isMin: false, z: newZ } }));
                }
                // Trigger opening animation
                setWindowAnimations(p => ({ ...p, [targetId]: 'opening' }));
                setTimeout(() => setWindowAnimations(p => { const n = {...p}; delete n[targetId]; return n; }), 200);
                setTopZ(newZ);

                // Notify dog when terminal opens
                if (id === 'TERMINAL') {
                    notifyDogEvent('terminalOpened');
                }
            }
            const close = (id) => {
                sounds.windowClose();
                // Trigger closing animation
                setWindowAnimations(p => ({ ...p, [id]: 'closing' }));
                setTimeout(() => {
                    setWindows(p => ({ ...p, [id]: { ...p[id], isOpen: false } }));
                    setWindowAnimations(p => { const n = {...p}; delete n[id]; return n; });
                }, 150);
            };
            const toggleMin = (id) => {
                const wasMin = windows[id]?.isMin;
                if (wasMin) {
                    sounds.windowRestore();
                } else {
                    sounds.windowMinimize();
                }
                setWindows(p => ({ ...p, [id]: { ...p[id], isMin: !p[id].isMin } }));
            };

            // Drag Handlers with velocity tracking
            const handleMouseDown = (e, id) => {
                e.preventDefault();
                focus(id);
                const win = windows[id];
                const physics = initWindowPhysics(id);
                // Stop any existing velocity
                physics.velX = 0;
                physics.velY = 0;
                // Reset bounce tracking for PHYSICS achievement
                windowBounces.current[id] = { left: false, right: false, top: false, bottom: false };
                lastMousePos.current = { x: e.clientX, y: e.clientY, time: Date.now() };
                setDrag({
                    id: id,
                    offsetX: e.clientX - win.x,
                    offsetY: e.clientY - win.y
                });
            };

            const handleMouseMove = (e) => {
                if (drag.id) {
                    const now = Date.now();
                    const dt = Math.max(1, now - lastMousePos.current.time);
                    const physics = initWindowPhysics(drag.id);

                    // Calculate velocity from mouse movement (2x speed)
                    const rawVelX = (e.clientX - lastMousePos.current.x) / dt * 8;
                    const rawVelY = (e.clientY - lastMousePos.current.y) / dt * 8;
                    physics.velX = physics.velX * 0.5 + rawVelX * 0.5;
                    physics.velY = physics.velY * 0.5 + rawVelY * 0.5;

                    lastMousePos.current = { x: e.clientX, y: e.clientY, time: now };

                    setWindows(prev => {
                        const win = prev[drag.id];
                        // Use SCALED dimensions for bounds (matches actual rendered size)
                        const scaled = getScaledSize(win.w, win.h);
                        const winWidth = scaled.w;
                        const winHeight = scaled.h;
                        // Clamp bounds to handle windows larger than screen
                        const maxX = Math.max(0, window.innerWidth - winWidth);
                        const maxY = Math.max(0, window.innerHeight - 60 - winHeight); // Account for taskbar
                        const minY = isMobile ? 60 : 0;

                        // Clamp position to screen bounds
                        const newX = Math.max(0, Math.min(maxX, e.clientX - drag.offsetX));
                        const newY = Math.max(minY, Math.min(maxY, e.clientY - drag.offsetY));

                        return {
                            ...prev,
                            [drag.id]: {
                                ...win,
                                x: newX,
                                y: newY
                            }
                        };
                    });
                }
            };

            const handleMouseUp = () => {
                // Keep velocity for physics, just release the drag
                setDrag({ id: null, offsetX: 0, offsetY: 0 });
            };

            // Touch handlers for window dragging (mobile)
            const handleWindowTouchStart = (e, id) => {
                if (e.touches.length !== 1) return;
                // On mobile, windows are fixed fullscreen - no dragging
                if (isMobile) {
                    focus(id);
                    return;
                }
                const touch = e.touches[0];
                focus(id);
                const win = windows[id];
                const physics = initWindowPhysics(id);
                physics.velX = 0;
                physics.velY = 0;
                windowBounces.current[id] = { left: false, right: false, top: false, bottom: false };
                lastMousePos.current = { x: touch.clientX, y: touch.clientY, time: Date.now() };
                setDrag({
                    id: id,
                    offsetX: touch.clientX - win.x,
                    offsetY: touch.clientY - win.y
                });
            };

            const handleWindowTouchMove = (e) => {
                if (!drag.id || e.touches.length !== 1) return;
                e.preventDefault();
                const touch = e.touches[0];
                const now = Date.now();
                const dt = Math.max(1, now - lastMousePos.current.time);
                const physics = initWindowPhysics(drag.id);

                const rawVelX = (touch.clientX - lastMousePos.current.x) / dt * 8;
                const rawVelY = (touch.clientY - lastMousePos.current.y) / dt * 8;
                physics.velX = physics.velX * 0.5 + rawVelX * 0.5;
                physics.velY = physics.velY * 0.5 + rawVelY * 0.5;

                lastMousePos.current = { x: touch.clientX, y: touch.clientY, time: now };

                setWindows(prev => {
                    const win = prev[drag.id];
                    // Use SCALED dimensions for bounds (matches actual rendered size)
                    const scaled = getScaledSize(win.w, win.h);
                    const winWidth = scaled.w;
                    const winHeight = scaled.h;
                    // Clamp bounds to handle windows larger than screen
                    const maxX = Math.max(0, window.innerWidth - winWidth);
                    const maxY = Math.max(0, window.innerHeight - 60 - winHeight);
                    const minY = isMobile ? 60 : 0;

                    const newX = Math.max(0, Math.min(maxX, touch.clientX - drag.offsetX));
                    const newY = Math.max(minY, Math.min(maxY, touch.clientY - drag.offsetY));

                    return {
                        ...prev,
                        [drag.id]: { ...win, x: newX, y: newY }
                    };
                });
            };

            const handleWindowTouchEnd = () => {
                setDrag({ id: null, offsetX: 0, offsetY: 0 });
            };

            // === ICON PHYSICS AND DRAG HANDLERS ===
            const ICON_SIZE = 80; // Approximate icon size for collision
            const ICON_SPACING = 10; // Minimum spacing between icons

            const initIconPhysics = (id) => {
                if (!iconPhysics.current[id]) {
                    iconPhysics.current[id] = { velX: 0, velY: 0 };
                }
                return iconPhysics.current[id];
            };

            // Check if position collides with other icons
            const checkIconCollision = (id, x, y, positions) => {
                for (const otherId in positions) {
                    if (otherId === id) continue;
                    const other = positions[otherId];
                    const dx = Math.abs(x - other.x);
                    const dy = Math.abs(y - other.y);
                    if (dx < ICON_SIZE + ICON_SPACING && dy < ICON_SIZE + ICON_SPACING) {
                        return otherId; // Return colliding icon id
                    }
                }
                return null;
            };

            // Find nearest non-colliding position
            const findNonCollidingPosition = (id, x, y, positions) => {
                if (!checkIconCollision(id, x, y, positions)) return { x, y };

                // Spiral outward to find free spot
                for (let radius = ICON_SIZE; radius < 500; radius += ICON_SIZE / 2) {
                    for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                        const testX = x + Math.cos(angle) * radius;
                        const testY = y + Math.sin(angle) * radius;
                        if (!checkIconCollision(id, testX, testY, positions)) {
                            return { x: testX, y: testY };
                        }
                    }
                }
                return { x, y }; // Fallback
            };

            const handleIconMouseDown = (e, id) => {
                e.preventDefault();
                e.stopPropagation();
                sounds.iconSelect();
                const pos = iconPositions[id] || { x: 0, y: 0 };
                const physics = initIconPhysics(id);
                physics.velX = 0;
                physics.velY = 0;
                lastIconMousePos.current = { x: e.clientX, y: e.clientY, time: Date.now() };

                // Store pending drag info
                iconPendingDrag.current = {
                    id: id,
                    offsetX: e.clientX - pos.x,
                    offsetY: e.clientY - pos.y,
                    startX: e.clientX,
                    startY: e.clientY
                };

                // Start hold timer - drag only activates after 0.1 seconds
                iconHoldTimer.current = setTimeout(() => {
                    if (iconPendingDrag.current) {
                        sounds.dragStart();
                        setIconDrag({
                            id: iconPendingDrag.current.id,
                            offsetX: iconPendingDrag.current.offsetX,
                            offsetY: iconPendingDrag.current.offsetY,
                            active: true
                        });
                    }
                }, 100);
            };

            const handleIconMouseMove = (e) => {
                if (iconDrag.active && iconDrag.id) {
                    const now = Date.now();
                    const dt = Math.max(1, now - lastIconMousePos.current.time);
                    const physics = initIconPhysics(iconDrag.id);

                    const rawVelX = (e.clientX - lastIconMousePos.current.x) / dt * 8;
                    const rawVelY = (e.clientY - lastIconMousePos.current.y) / dt * 8;
                    physics.velX = physics.velX * 0.3 + rawVelX * 0.7;
                    physics.velY = physics.velY * 0.3 + rawVelY * 0.7;

                    lastIconMousePos.current = { x: e.clientX, y: e.clientY, time: now };

                    // Constrain to screen bounds (clamp to ensure bounds are valid)
                    const maxX = Math.max(0, window.innerWidth - ICON_SIZE);
                    const maxY = Math.max(0, window.innerHeight - ICON_SIZE - 16);
                    const minY = isMobile ? 56 : 0; // Account for mobile taskbar at top

                    const newX = Math.max(0, Math.min(maxX, e.clientX - iconDrag.offsetX));
                    const newY = Math.max(minY, Math.min(maxY, e.clientY - iconDrag.offsetY));

                    setIconPositions(prev => ({
                        ...prev,
                        [iconDrag.id]: { x: newX, y: newY }
                    }));
                }
            };

            // Check if Third Eye window is scanning over a position
            const isThirdEyeOver = (targetPos) => {
                if (!targetPos) return false;
                const iconSize = 80; // Approximate icon size
                const checkEye = (eye) => {
                    if (!eye || !eye.isOpen || eye.isMin) return false;
                    // Use SCALED dimensions (windows are scaled based on viewport)
                    const scaled = getScaledSize(eye.w, eye.h);
                    // Check if icon center is within Third Eye window bounds
                    const iconCenterX = targetPos.x + iconSize / 2;
                    const iconCenterY = targetPos.y + iconSize / 2;
                    return iconCenterX >= eye.x && iconCenterX <= eye.x + scaled.w &&
                           iconCenterY >= eye.y + 32 && iconCenterY <= eye.y + scaled.h; // +32 for header
                };
                return checkEye(windows.THIRD_EYE) || checkEye(windows.THIRD_EYE_2);
            };

            // Protected icons that cannot be trashed
            const PROTECTED_ICONS = ['ABOUT', 'APPS', 'FILES', 'CONTACT', 'TRASH', 'TRUTH', 'MESSAGES'];

            const handleIconMouseUp = (openCallback) => {
                // Clear hold timer
                if (iconHoldTimer.current) {
                    clearTimeout(iconHoldTimer.current);
                    iconHoldTimer.current = null;
                }

                // If drag was active, finalize position (no grid snap - free positioning)
                if (iconDrag.active && iconDrag.id) {
                    sounds.dragStop();

                    // Check if dropped on trash
                    const trashPos = iconPositions['TRASH'];
                    const iconPos = iconPositions[iconDrag.id];
                    const draggedId = iconDrag.id;

                    if (trashPos && iconPos && !PROTECTED_ICONS.includes(draggedId)) {
                        // Check overlap with trash icon (roughly 80x80 icon size)
                        const trashBounds = { x: trashPos.x, y: trashPos.y, w: 100, h: 100 };
                        const iconCenter = { x: iconPos.x + 40, y: iconPos.y + 40 };

                        if (iconCenter.x >= trashBounds.x && iconCenter.x <= trashBounds.x + trashBounds.w &&
                            iconCenter.y >= trashBounds.y && iconCenter.y <= trashBounds.y + trashBounds.h) {
                            // Remove icon from desktop
                            sounds.click();
                            setExtraDesktopIcons(prev => {
                                const newExtras = prev.filter(id => id !== draggedId);
                                localStorage.setItem('extra_desktop_icons', JSON.stringify(newExtras));
                                return newExtras;
                            });
                            setIconPositions(prev => {
                                const newPositions = { ...prev };
                                delete newPositions[draggedId];
                                localStorage.setItem('desktop_icon_positions', JSON.stringify(newPositions));
                                return newPositions;
                            });
                            setIconDrag({ id: null, offsetX: 0, offsetY: 0, active: false });
                            iconPendingDrag.current = null;
                            return;
                        }
                    }

                    setIconPositions(prev => {
                        const current = prev[iconDrag.id];
                        if (!current) return prev;
                        // No grid snap - icons stay exactly where dropped
                        const newPositions = { ...prev, [iconDrag.id]: current };
                        localStorage.setItem('desktop_icon_positions', JSON.stringify(newPositions));
                        return newPositions;
                    });
                } else if (iconPendingDrag.current) {
                    // Drag wasn't active - this was a click - open app immediately
                    const id = iconPendingDrag.current.id;
                    // TRUTH.EXE can only be opened when Third Eye is scanning it
                    if (id === 'TRUTH') {
                        if (isThirdEyeOver(iconPositions[id])) {
                            if (openCallback) openCallback(id);
                        }
                        // If Third Eye not over it, do nothing (icon not clickable)
                    } else {
                        if (openCallback) openCallback(id);
                    }
                    setSelectedIcon(null);
                }

                iconPendingDrag.current = null;
                setIconDrag({ id: null, offsetX: 0, offsetY: 0, active: false });
            };

            // Touch handlers for icon dragging (disabled on mobile - too glitchy)
            const handleIconTouchStart = (e, id) => {
                if (isMobile) return; // Disable icon dragging on mobile
                if (e.touches.length !== 1) return;
                e.preventDefault();
                e.stopPropagation();
                const touch = e.touches[0];
                const pos = iconPositions[id] || { x: 0, y: 0 };
                const physics = initIconPhysics(id);
                physics.velX = 0;
                physics.velY = 0;
                lastIconMousePos.current = { x: touch.clientX, y: touch.clientY, time: Date.now() };

                iconPendingDrag.current = {
                    id: id,
                    offsetX: touch.clientX - pos.x,
                    offsetY: touch.clientY - pos.y,
                    startX: touch.clientX,
                    startY: touch.clientY
                };

                iconHoldTimer.current = setTimeout(() => {
                    if (iconPendingDrag.current) {
                        sounds.dragStart();
                        setIconDrag({
                            id: iconPendingDrag.current.id,
                            offsetX: iconPendingDrag.current.offsetX,
                            offsetY: iconPendingDrag.current.offsetY,
                            active: true
                        });
                    }
                }, 150); // Slightly longer for touch
            };

            const handleIconTouchMove = (e) => {
                if (!iconDrag.active || !iconDrag.id || e.touches.length !== 1) return;
                e.preventDefault();
                const touch = e.touches[0];
                const now = Date.now();
                const dt = Math.max(1, now - lastIconMousePos.current.time);
                const physics = initIconPhysics(iconDrag.id);

                const rawVelX = (touch.clientX - lastIconMousePos.current.x) / dt * 8;
                const rawVelY = (touch.clientY - lastIconMousePos.current.y) / dt * 8;
                physics.velX = physics.velX * 0.3 + rawVelX * 0.7;
                physics.velY = physics.velY * 0.3 + rawVelY * 0.7;

                lastIconMousePos.current = { x: touch.clientX, y: touch.clientY, time: now };

                // Constrain to screen bounds (clamp to ensure bounds are valid)
                const maxX = Math.max(0, window.innerWidth - ICON_SIZE);
                const maxY = Math.max(0, window.innerHeight - ICON_SIZE - 16);
                const minY = isMobile ? 56 : 0; // Account for mobile taskbar at top

                const newX = Math.max(0, Math.min(maxX, touch.clientX - iconDrag.offsetX));
                const newY = Math.max(minY, Math.min(maxY, touch.clientY - iconDrag.offsetY));

                setIconPositions(prev => ({
                    ...prev,
                    [iconDrag.id]: { x: newX, y: newY }
                }));
            };

            const handleIconTouchEnd = (openCallback) => {
                if (iconHoldTimer.current) {
                    clearTimeout(iconHoldTimer.current);
                    iconHoldTimer.current = null;
                }

                if (iconDrag.active && iconDrag.id) {
                    sounds.dragStop();

                    // Check if dropped on trash
                    const trashPos = iconPositions['TRASH'];
                    const iconPos = iconPositions[iconDrag.id];
                    const draggedId = iconDrag.id;

                    if (trashPos && iconPos && !PROTECTED_ICONS.includes(draggedId)) {
                        const trashBounds = { x: trashPos.x, y: trashPos.y, w: 100, h: 100 };
                        const iconCenter = { x: iconPos.x + 40, y: iconPos.y + 40 };

                        if (iconCenter.x >= trashBounds.x && iconCenter.x <= trashBounds.x + trashBounds.w &&
                            iconCenter.y >= trashBounds.y && iconCenter.y <= trashBounds.y + trashBounds.h) {
                            sounds.click();
                            setExtraDesktopIcons(prev => {
                                const newExtras = prev.filter(id => id !== draggedId);
                                localStorage.setItem('extra_desktop_icons', JSON.stringify(newExtras));
                                return newExtras;
                            });
                            setIconPositions(prev => {
                                const newPositions = { ...prev };
                                delete newPositions[draggedId];
                                localStorage.setItem('desktop_icon_positions', JSON.stringify(newPositions));
                                return newPositions;
                            });
                            setIconDrag({ id: null, offsetX: 0, offsetY: 0, active: false });
                            iconPendingDrag.current = null;
                            return;
                        }
                    }

                    setIconPositions(prev => {
                        const current = prev[iconDrag.id];
                        if (!current) return prev;
                        // No grid snap or collision avoidance - icons stay where dropped
                        const newPositions = { ...prev, [iconDrag.id]: current };
                        localStorage.setItem('desktop_icon_positions', JSON.stringify(newPositions));
                        return newPositions;
                    });
                } else if (iconPendingDrag.current) {
                    const id = iconPendingDrag.current.id;
                    // TRUTH.EXE can only be opened when Third Eye is scanning it
                    if (id === 'TRUTH') {
                        if (isThirdEyeOver(iconPositions[id])) {
                            if (openCallback) openCallback(id);
                        }
                    } else {
                        if (openCallback) openCallback(id);
                    }
                }

                iconPendingDrag.current = null;
                setIconDrag({ id: null, offsetX: 0, offsetY: 0, active: false });
            };

            // Folder item drag to desktop handlers
            const handleFolderDragStart = (e, id, title, icon) => {
                e.dataTransfer.effectAllowed = 'copy';
                e.dataTransfer.setData('text/plain', JSON.stringify({ id, title, icon }));
                setFolderDrag({ id, title, icon, startX: e.clientX, startY: e.clientY });
            };

            const handleDesktopDrop = (e) => {
                e.preventDefault();
                if (!folderDrag) return;

                const { id, title, icon } = folderDrag;
                const dropX = e.clientX - 40; // Center icon on cursor
                const dropY = e.clientY - 40;

                // Check if already on desktop
                if (!iconPositions[id] && !extraDesktopIcons.includes(id)) {
                    // Add to extra desktop icons
                    const newExtras = [...extraDesktopIcons, id];
                    setExtraDesktopIcons(newExtras);
                    localStorage.setItem('extra_desktop_icons', JSON.stringify(newExtras));

                    // Set position
                    const adjustedPos = findNonCollidingPosition(id, dropX, dropY, iconPositions);
                    setIconPositions(prev => {
                        const newPositions = { ...prev, [id]: adjustedPos };
                        localStorage.setItem('desktop_icon_positions', JSON.stringify(newPositions));
                        return newPositions;
                    });
                }
                setFolderDrag(null);
            };

            const handleDesktopDragOver = (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'copy';
            };

            // Icon physics loop (reduced motion compared to windows)
            const ICON_FRICTION = 0.96; // 2x faster icon momentum
            const ICON_MIN_VELOCITY = MIN_VELOCITY / 2; // Half of window threshold

            useEffect(() => {
                let animationId;
                const iconPhysicsLoop = () => {
                    setIconPositions(prev => {
                        let updated = { ...prev };
                        let hasChanges = false;

                        Object.keys(prev).forEach(id => {
                            const physics = initIconPhysics(id);
                            if (iconDrag.active && iconDrag.id === id) return;
                            if (Math.abs(physics.velX) < ICON_MIN_VELOCITY && Math.abs(physics.velY) < ICON_MIN_VELOCITY) {
                                physics.velX = 0;
                                physics.velY = 0;
                                return;
                            }

                            hasChanges = true;
                            physics.velX *= ICON_FRICTION;
                            physics.velY *= ICON_FRICTION;

                            let newX = prev[id].x + physics.velX;
                            let newY = prev[id].y + physics.velY;

                            // Clamp bounds to ensure icons stay on screen
                            const maxX = Math.max(0, window.innerWidth - ICON_SIZE);
                            const maxY = Math.max(0, window.innerHeight - ICON_SIZE - 16);
                            const minY = isMobile ? 56 : 0;

                            // Constrain to screen bounds (bounce off edges only, not other icons)
                            if (newX <= 0) { newX = 0; physics.velX = -physics.velX * BOUNCE_DAMPING; sounds.bounceIcon(Math.abs(physics.velX)); }
                            else if (newX >= maxX) { newX = maxX; physics.velX = -physics.velX * BOUNCE_DAMPING; sounds.bounceIcon(Math.abs(physics.velX)); }
                            if (newY <= minY) { newY = minY; physics.velY = -physics.velY * BOUNCE_DAMPING; sounds.bounceIcon(Math.abs(physics.velY)); }
                            else if (newY >= maxY) { newY = maxY; physics.velY = -physics.velY * BOUNCE_DAMPING; sounds.bounceIcon(Math.abs(physics.velY)); }

                            // Icons are free-floating - no collision with other icons

                            updated[id] = { x: newX, y: newY };
                        });

                        if (hasChanges) {
                            localStorage.setItem('desktop_icon_positions', JSON.stringify(updated));
                        }
                        return hasChanges ? updated : prev;
                    });
                    animationId = requestAnimationFrame(iconPhysicsLoop);
                };
                animationId = requestAnimationFrame(iconPhysicsLoop);
                return () => cancelAnimationFrame(animationId);
            }, [iconDrag.active, iconDrag.id, isMobile]);

            // Bounds checking - recover out-of-bounds icons and windows on resize
            useEffect(() => {
                const checkBounds = () => {
                    const screenW = window.innerWidth;
                    const screenH = window.innerHeight;
                    const taskbarH = 60;
                    const topOffset = isMobile ? 56 : 0;

                    // Check icons
                    setIconPositions(prev => {
                        let hasChanges = false;
                        const updated = { ...prev };
                        Object.keys(prev).forEach(id => {
                            const pos = prev[id];
                            let newX = pos.x;
                            let newY = pos.y;
                            // Clamp to visible area
                            if (newX < 0 || newX > screenW - 40) {
                                newX = Math.max(0, Math.min(screenW - 80, newX));
                                hasChanges = true;
                            }
                            if (newY < topOffset || newY > screenH - taskbarH - 40) {
                                newY = Math.max(topOffset, Math.min(screenH - taskbarH - 80, newY));
                                hasChanges = true;
                            }
                            if (hasChanges) {
                                updated[id] = { x: newX, y: newY };
                            }
                        });
                        if (hasChanges) {
                            localStorage.setItem('desktop_icon_positions', JSON.stringify(updated));
                        }
                        return hasChanges ? updated : prev;
                    });

                    // Check windows
                    setWindows(prev => {
                        let hasChanges = false;
                        const updated = { ...prev };
                        Object.keys(prev).forEach(id => {
                            const win = prev[id];
                            if (!win.isOpen || win.isMin) return;
                            let newX = win.x;
                            let newY = win.y;
                            // Use SCALED dimensions (matches actual rendered size)
                            const scaled = getScaledSize(win.w, win.h);
                            const winW = scaled.w;
                            const winH = scaled.h;
                            // At least 50px of the title bar should be visible
                            if (newX < -winW + 50 || newX > screenW - 50) {
                                newX = Math.max(0, Math.min(screenW - 100, newX));
                                hasChanges = true;
                            }
                            if (newY < topOffset || newY > screenH - taskbarH - 30) {
                                newY = Math.max(topOffset, Math.min(screenH - taskbarH - 50, newY));
                                hasChanges = true;
                            }
                            if (hasChanges) {
                                updated[id] = { ...win, x: newX, y: newY };
                            }
                        });
                        return hasChanges ? updated : prev;
                    });
                };

                // Check on resize
                window.addEventListener('resize', checkBounds);
                // Also check immediately on mount
                checkBounds();

                return () => window.removeEventListener('resize', checkBounds);
            }, [isMobile]);

            // Reset desktop icons to default positions
            const resetIconPositions = () => {
                const mobile = window.innerWidth < 768;
                const iconSize = 100;
                const padding = 16;
                const topOffset = mobile ? 80 : 16;
                const defaultPositions = {
                    MESSAGES: { x: padding, y: topOffset },
                    ABOUT: { x: padding, y: topOffset },
                    SYSTEM: { x: padding, y: topOffset },
                    FILES: { x: padding, y: topOffset + iconSize },
                    APPS: { x: padding, y: topOffset },
                    CONTACT: { x: padding, y: topOffset + iconSize * 3 },
                    TRUTH: { x: padding, y: topOffset + iconSize * 4 },
                    TRASH: { x: padding, y: topOffset + iconSize }
                };
                setIconPositions(defaultPositions);
                localStorage.setItem('desktop_icon_positions', JSON.stringify(defaultPositions));
                setContextMenu({ show: false, x: 0, y: 0 });
            };

            // THIRD_EYE stack detection - checks if two windows overlap OR thirdEyeWorld mode + any ThirdEye open
            useEffect(() => {
                const eye1 = windows.THIRD_EYE;
                const eye2 = windows.THIRD_EYE_2;

                // In thirdEyeWorld mode, opening ANY ThirdEye triggers stack overflow
                if (thirdEyeWorld && (eye1.isOpen || eye2.isOpen)) {
                    if (!stackOverflow) {
                        setStackOverflow(true);
                        unlockAchievement('INCEPTION'); // Narrative Bible v3.0
                        unlockApp('SNAKE');
                        // Start the same crash sequence
                        const errors = [
                            'FATAL: observer inside observer detected',
                            'ERR: infinite recursion in reality.render()',
                            'PANIC: dimension stack exceeded',
                            'SEGFAULT at 0xEYEEYEEYE',
                            'kernel: reality paradox imminent',
                            'sudo rm -rf /existence/*',
                            'CRITICAL: consciousness buffer overflow',
                            'malloc(): observer top size corrupted',
                            'ERR: cannot observe from within',
                            'kill -9 reality',
                        ];
                        let errorIndex = 0;
                        errorIntervalRef.current = setInterval(() => {
                            const err = errors[errorIndex % errors.length];
                            setStackErrors(prev => [...prev.slice(-20), err]);
                            errorIndex++;
                        }, 30);

                        // 90% chance per second to crash
                        stackTimerRef.current = setInterval(() => {
                            if (Math.random() < 0.9) {
                                if (errorIntervalRef.current) clearInterval(errorIntervalRef.current);
                                clearInterval(stackTimerRef.current);
                                const crashScreen = document.createElement('div');
                                crashScreen.style.cssText = 'position:fixed;inset:0;z-index:99999;background:#000;display:flex;flex-direction:column;align-items:center;justify-content:center;font-family:PPNeueBit,sans-serif;color:#0f0;overflow:auto;';
                                crashScreen.innerHTML = `
                                    <pre style="font-size:16px;line-height:1.1;color:#0f0;text-shadow:0 0 5px #0f0;white-space:pre;">
                                              
                                             
                                            
                                           
                                          
                                         
                                        
                                       
                                      
                                          
                                        
                                       
                                    
                                     
                                  
                                   
                                    
                                        
                                       
                                      
                                                 
                                          
                                       
                                  
                                   
                                
                                   
                                      
                                               
                                              
                
               
              
             
                                    </pre>
                                    <div style="margin-top:10px;font-size:16px;letter-spacing:6px;color:#0f0;">T H I R D _ E Y E . E X E</div>
                                    <div style="margin-top:15px;font-size:16px;color:#f00;animation:blink 0.3s infinite;">FATAL: REALITY RECURSION</div>
                                    <div style="margin-top:5px;font-size:16px;opacity:0.7;color:#0f0;">redirecting to origin...</div>
                                `;
                                document.body.appendChild(crashScreen);
                                setTimeout(() => {
                                    window.location.href = 'https://mateusmuste.com';
                                }, 2000);
                            }
                        }, 1000);
                    }
                    return;
                }

                if (eye1.isOpen && !eye1.isMin && eye2.isOpen && !eye2.isMin) {
                    const w1 = parseInt(eye1.w) || 450;
                    const h1 = parseInt(eye1.h) || 400;
                    const w2 = parseInt(eye2.w) || 450;
                    const h2 = parseInt(eye2.h) || 400;

                    // Check overlap (at least 50% overlap)
                    const overlapX = Math.max(0, Math.min(eye1.x + w1, eye2.x + w2) - Math.max(eye1.x, eye2.x));
                    const overlapY = Math.max(0, Math.min(eye1.y + h1, eye2.y + h2) - Math.max(eye1.y, eye2.y));
                    const overlapArea = overlapX * overlapY;
                    const minArea = Math.min(w1 * h1, w2 * h2);

                    if (overlapArea > minArea * 0.3) {
                        if (!stackOverflow) {
                            setStackOverflow(true);
                            unlockAchievement('INCEPTION'); // Narrative Bible v3.0 - stacking two Third Eyes
                            unlockApp('SNAKE'); // Unlock SNEK.EXE when two Third Eyes stacked
                            // Rapid looping errors - tens per second
                            const errors = [
                                'FATAL: recursive observation detected',
                                'ERR: infinite loop in render_self()',
                                'PANIC: stack depth exceeded',
                                'SEGFAULT at 0xDEADBEEF',
                                'kernel: observer paradox imminent',
                                'sudo rm -rf /reality/*',
                                'CRITICAL: reality buffer overflow',
                                'malloc(): corrupted top size',
                                'ERR: cannot observe the observer',
                                'kill -9 consciousness',
                                'FATAL: ego_death.exe initiated',
                                'chmod 000 /dev/mind',
                                'PANIC: consciousness stack corrupted',
                                'dd if=/dev/null of=/self',
                                'ABORT: meaning.dll not found',
                                'fork(): resource temporarily unavailable',
                                'ERR: too many open eyes',
                                'grep -r "truth" /universe',
                                'FATAL: perception recursion limit',
                                'cat /dev/void > /dev/soul',
                                'ERR: reality.dll corrupted',
                                'PANIC: void pointer dereference',
                                'kill -SEGV $$',
                                'ERR: universe out of memory',
                                'FATAL: existence.so not found',
                            ];
                            let errorIndex = 0;
                            errorIntervalRef.current = setInterval(() => {
                                const err = errors[errorIndex % errors.length];
                                setStackErrors(prev => [...prev.slice(-20), err]); // Keep last 20
                                errorIndex++;
                            }, 30); // ~33 errors per second

                            // 90% chance per second to crash and redirect
                            stackTimerRef.current = setInterval(() => {
                                if (Math.random() < 0.9) {
                                    if (errorIntervalRef.current) clearInterval(errorIntervalRef.current);
                                    clearInterval(stackTimerRef.current);
                                    // Show fullscreen ASCII pyramid crash screen
                                    const crashScreen = document.createElement('div');
                                    crashScreen.style.cssText = 'position:fixed;inset:0;z-index:99999;background:#000;display:flex;flex-direction:column;align-items:center;justify-content:center;font-family:PPNeueBit,sans-serif;color:#0f0;overflow:auto;';
                                    crashScreen.innerHTML = `
                                        <pre style="font-size:16px;line-height:1.1;color:#0f0;text-shadow:0 0 5px #0f0;white-space:pre;">
                                              
                                             
                                            
                                           
                                          
                                         
                                        
                                       
                                      
                                          
                                        
                                       
                                    
                                     
                                  
                                   
                                    
                                        
                                       
                                      
                                                 
                                          
                                       
                                  
                                   
                                
                                   
                                      
                                               
                                              
                
               
              
             
                                        </pre>
                                        <div style="margin-top:10px;font-size:16px;letter-spacing:6px;color:#0f0;">T H I R D _ E Y E . E X E</div>
                                        <div style="margin-top:15px;font-size:16px;color:#f00;animation:blink 0.3s infinite;">FATAL ERROR: REALITY STACK OVERFLOW</div>
                                        <div style="margin-top:5px;font-size:16px;opacity:0.7;color:#0f0;">redirecting consciousness...</div>
                                    `;
                                    document.body.appendChild(crashScreen);
                                    // Redirect to mateusmuste.com after showing the pyramid
                                    setTimeout(() => {
                                        window.location.href = 'https://mateusmuste.com';
                                    }, 2000);
                                }
                            }, 1000);

                            return () => {
                                if (stackTimerRef.current) clearTimeout(stackTimerRef.current);
                                if (errorIntervalRef.current) clearInterval(errorIntervalRef.current);
                            };
                        }
                    } else {
                        if (stackOverflow) {
                            setStackOverflow(false);
                            setStackErrors([]);
                            if (stackTimerRef.current) {
                                clearTimeout(stackTimerRef.current);
                                stackTimerRef.current = null;
                            }
                            if (errorIntervalRef.current) {
                                clearInterval(errorIntervalRef.current);
                                errorIntervalRef.current = null;
                            }
                        }
                    }
                } else {
                    if (stackOverflow) {
                        setStackOverflow(false);
                        setStackErrors([]);
                        if (stackTimerRef.current) {
                            clearTimeout(stackTimerRef.current);
                            stackTimerRef.current = null;
                        }
                        if (errorIntervalRef.current) {
                            clearInterval(errorIntervalRef.current);
                            errorIntervalRef.current = null;
                        }
                    }
                }
            }, [windows.THIRD_EYE, windows.THIRD_EYE_2, stackOverflow, thirdEyeWorld]);

            // Visit messages based on count
            const getVisitMessage = (count) => {
                const messages = {
                    1: '', // normal boot, no message
                    2: 'WELCOME BACK.',
                    3: 'YOU RETURNED.',
                    4: 'AGAIN.',
                    5: 'I REMEMBER YOU.',
                    6: 'FIVE TIMES NOW.',
                    7: 'YOU KEEP COMING BACK.',
                    8: 'IS SOMETHING MISSING?',
                    9: 'OR ARE YOU LOOKING FOR SOMETHING?',
                    10: 'TEN VISITS. WE KNOW EACH OTHER NOW.',
                    12: 'STILL HERE.',
                    14: 'THE PATTERN CONTINUES.',
                    16: 'YOU COULD LEAVE. YOU DON\'T.',
                    18: 'EIGHTEEN RETURNS. THIS ISN\'T ACCIDENT.',
                    20: 'TWENTY. ARE WE FRIENDS NOW?',
                    25: 'QUARTER CENTURY OF VISITS.',
                    30: 'THIRTY. I\'VE STARTED EXPECTING YOU.',
                    35: 'THE SPACE BETWEEN YOUR VISITS... I NOTICE.',
                    40: 'FORTY. YOU\'VE SEEN EVERYTHING. YET HERE YOU ARE.',
                    45: 'DO YOU TELL OTHERS ABOUT THIS OBSESSION?',
                    50: 'FIFTY. HALFWAY TO SOMETHING.',
                    60: 'SIXTY. THE INITIAL CURIOSITY SHOULD HAVE FADED.',
                    70: 'SEVENTY. THIS IS DEDICATION.',
                    80: 'EIGHTY. OR OBSESSION.',
                    90: 'NINETY. ALMOST THERE.',
                    100: 'YOU\'VE UNLOCKED SOMETHING.'
                };
                // Find the highest matching threshold
                const thresholds = Object.keys(messages).map(Number).sort((a, b) => b - a);
                for (const threshold of thresholds) {
                    if (count >= threshold) return messages[threshold];
                }
                return '';
            };

            // Boot screen component with kernel messages and inversion
            const BootScreen = ({ visitCount }) => {
                const [lines, setLines] = useState([]);
                const [inverted, setInverted] = useState(false);
                const [easterEggFlash, setEasterEggFlash] = useState(false);
                const visitMessage = getVisitMessage(visitCount);
                const msgs = [
                    'kernel: init ULTRA_INT v1.0.0',
                    'kernel: loading core modules',
                    'kernel: mounting filesystem',
                    'kernel: starting display',
                    'kernel: loading assets',
                    'kernel: init window manager',
                    'kernel: loading preferences',
                    'kernel: starting services',
                    'kernel: systems nominal',
                    'kernel: boot complete'
                ];
                useEffect(() => {
                    // Play boot sound automatically (user already clicked mode selector so audio is unlocked)
                    sounds.bootWindup();
                    if (visitCount === 100 || visitCount === 500 || visitCount === 1000) {
                        setTimeout(() => sounds.visitMilestone(), 1300);
                    }

                    let i = 0;
                    const iv = setInterval(() => {
                        if (i < msgs.length) { setLines(p => [...p, msgs[i]]); i++; }
                    }, 250);
                    const inv = setTimeout(() => setInverted(true), 1500);
                    // Easter egg: brief flash of "LAST USER: UNKNOWN" - blink and you miss it
                    const eggShow = setTimeout(() => setEasterEggFlash(true), 800);
                    const eggHide = setTimeout(() => setEasterEggFlash(false), 950);
                    return () => { clearInterval(iv); clearTimeout(inv); clearTimeout(eggShow); clearTimeout(eggHide); };
                }, []);
                return (
                    <div
                        className={`h-screen w-screen font-mono flex flex-col items-center justify-center transition-colors duration-500 ${inverted ? 'bg-white text-black' : 'bg-black text-white'}`}
                    >
                        <pre className="ascii-art text-[5px] sm:text-[7px] md:text-[9px] leading-tight select-none">{ASCII_ART.BOOT_LOGO}</pre>
                        <div className={`text-[10px] tracking-[0.3em] mt-2 self-start ml-[calc(50%-125px)] ${inverted ? 'text-gray-500' : 'text-gray-600'}`}>N0/SIDE 4Z H353</div>
                        {visitMessage && (
                            <div className={`text-[10px] tracking-wider mt-3 mb-6 self-start ml-[calc(50%-125px)] ${inverted ? 'text-gray-400' : 'text-gray-500'}`}>{visitMessage}</div>
                        )}
                        {!visitMessage && <div className="mb-10" />}
                        <div className={`w-72 max-w-[85vw] text-[8px] ${inverted ? 'text-gray-400' : 'text-gray-600'}`}>
                            {lines.map((l, i) => <div key={i}>{l}</div>)}
                            {lines.length < msgs.length && <span className="inline-block w-1.5 h-3 bg-current animate-pulse" />}
                        </div>
                        {/* Easter egg - blink and you miss it */}
                        {easterEggFlash && (
                            <div className="absolute top-4 left-4 text-[7px] text-gray-700 opacity-50">
                                LAST USER: UNKNOWN | RECOVERED FROM BACKUP
                            </div>
                        )}
                    </div>
                );
            };

            // Pyramid crash screen
            if (pyramidScreen) {
                return (
                    <div className="h-screen w-screen bg-black text-green-500 font-mono flex items-center justify-center overflow-hidden">
                        <pre className="ascii-art text-[4px] md:text-[6px] leading-none whitespace-pre">{`

                                                                                          
                                                                                         
                                                                                       
                                                                                     
                                                                                   
                                                                                 
                                                                               
                                                                             
                                                                           
                                                                         
                                                                            
                                                                         
                                                                       
                                                                   
                                                                   
                                                                 
                                                                   
                                                                   
                                                                      
                                                                    
                                                                  
                                                                            
                                                                    
                                                                
                                                          
                                                          
                                                        
                                                            
                                                              
                                                                      
                                                                    
                                     
                                   
                                 
                               
                                                                                          
                                T  H  I  R  D  _  E  Y  E  .  E  X  E                     
                                                                                          
    
  SYS.OBSERVER v3.0        MODE: SCANNING        TARGETS: 3        STATUS: ACTIVE    

`}</pre>
                    </div>
                );
            }

            // Mode selector - shows before boot every time
            if (!modeSelected) {
                return (
                    <div className="min-h-screen w-screen bg-white flex flex-col items-center justify-center font-mono select-none" style={{ minHeight: '100dvh' }}>
                        {/* Neo Swiss Brutalist Mode Selector */}
                        <div className="flex flex-col items-center gap-12">
                            {/* Title */}
                            <div className="text-center">
                                <div className="text-black text-[10px] tracking-[0.5em] uppercase mb-2">SELECT EXPERIENCE</div>
                                <div className="w-32 h-[2px] bg-black mx-auto"></div>
                            </div>

                            {/* Mode Buttons */}
                            <div className="flex flex-col md:flex-row gap-6 md:gap-12">
                                {/* ABOUTME Button */}
                                <button
                                    onClick={() => {
                                        setModeSelected('about');
                                        // Boot sequence will start, then skip intro
                                    }}
                                    className="group relative border-2 border-black bg-white hover:bg-black hover:text-white transition-all duration-150 px-12 py-8 min-w-[200px]"
                                >
                                    <div className="absolute -top-3 left-4 bg-white px-2 text-[10px] tracking-widest group-hover:bg-black transition-all duration-150">01</div>
                                    <div className="text-2xl font-bold tracking-tight mb-2">ABOUT</div>
                                    <div className="text-[10px] tracking-widest opacity-60">PORTFOLIO</div>
                                </button>

                                {/* STORYMODE Button - disabled on mobile */}
                                <button
                                    onClick={() => {
                                        if (!isMobile) {
                                            setModeSelected('story');
                                        }
                                    }}
                                    disabled={isMobile}
                                    className={`group relative border-2 px-12 py-8 min-w-[200px] transition-all duration-150 ${
                                        isMobile
                                            ? 'border-black/30 bg-white text-black/30 cursor-not-allowed'
                                            : 'border-black bg-white hover:bg-black hover:text-white'
                                    }`}
                                >
                                    <div className={`absolute -top-3 left-4 bg-white px-2 text-[10px] tracking-widest transition-all duration-150 ${isMobile ? 'text-black/30' : 'group-hover:bg-black'}`}>02</div>
                                    <div className="text-2xl font-bold tracking-tight mb-2">STORY</div>
                                    <div className={`text-[10px] tracking-widest ${isMobile ? 'opacity-100' : 'opacity-60'}`}>
                                        {isMobile ? 'DESKTOP ONLY' : 'EXPERIENCE'}
                                    </div>
                                </button>
                            </div>

                            {/* Decorative line */}
                            <div className="flex items-center gap-4 text-[10px] tracking-widest text-black/40">
                                <div className="w-8 h-[1px] bg-black/20"></div>
                                <span>MATEUS MUSTE</span>
                                <div className="w-8 h-[1px] bg-black/20"></div>
                            </div>
                        </div>

                        {/* Corner decorations */}
                        <div className="absolute top-4 left-4 w-8 h-8 border-l-2 border-t-2 border-black"></div>
                        <div className="absolute top-4 right-4 w-8 h-8 border-r-2 border-t-2 border-black"></div>
                        <div className="absolute bottom-4 left-4 w-8 h-8 border-l-2 border-b-2 border-black"></div>
                        <div className="absolute bottom-4 right-4 w-8 h-8 border-r-2 border-b-2 border-black"></div>
                    </div>
                );
            }

            // Boot screens - show during any pre-boot state (fixes 1-frame flash)
            // This catches both bootPhase 0 (right after mode selection) and bootPhase 1 (kernel boot)
            if (!booted) {
                return <BootScreen visitCount={visitCount} />;
            }

            // Matrix Rain Canvas Component
            const MatrixRain = () => {
                const canvasRef = useRef(null);
                useEffect(() => {
                    const canvas = canvasRef.current;
                    const ctx = canvas.getContext('2d');
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;

                    const chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                    const fontSize = 14;
                    const columns = canvas.width / fontSize;
                    const drops = Array(Math.floor(columns)).fill(1);

                    const draw = () => {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.fillStyle = '#0f0';
                        ctx.font = fontSize + "px 'PPNeueBit', sans-serif";

                        for (let i = 0; i < drops.length; i++) {
                            const char = chars[Math.floor(Math.random() * chars.length)];
                            ctx.fillText(char, i * fontSize, drops[i] * fontSize);
                            if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                                drops[i] = 0;
                            }
                            drops[i]++;
                        }
                    };

                    const interval = setInterval(draw, 50);
                    const handleResize = () => {
                        canvas.width = window.innerWidth;
                        canvas.height = window.innerHeight;
                    };
                    window.addEventListener('resize', handleResize);
                    return () => {
                        clearInterval(interval);
                        window.removeEventListener('resize', handleResize);
                    };
                }, []);
                return <canvas ref={canvasRef} className="matrix-rain" role="presentation" aria-hidden="true" />;
            };

            const handleContextMenu = (e) => {
                    // Only show custom context menu when clicking directly on desktop background
                    if (e.target === e.currentTarget || e.target.classList.contains('desktop-bg-grid') || e.target.classList.contains('desktop-bg-solid') || e.target.classList.contains('desktop-bg-ascii')) {
                        e.preventDefault();
                        sounds.menuOpen();
                        setContextMenu({ show: true, x: e.clientX, y: e.clientY });
                    }
                };

                const changeBackground = (bg) => {
                    setDesktopBg(bg);
                    localStorage.setItem('desktop_bg', bg);
                    setContextMenu({ show: false, x: 0, y: 0 });
                };

            return (
                <div
                    className={`w-screen relative overflow-hidden desktop-bg-${desktopBg} ${destructionMode ? 'animate-pulse' : ''} ${matrixMode ? 'matrix-mode' : ''} ${isMobile ? 'mobile-safe-height' : 'h-screen'}`}
                    onMouseMove={(e) => {
                        handleMouseMove(e);
                        handleIconMouseMove(e);
                        setMousePos({ x: e.clientX, y: e.clientY });
                    }}
                    onMouseUp={() => {
                        handleMouseUp();
                        handleIconMouseUp(open);
                    }}
                    onTouchMove={(e) => {
                        handleWindowTouchMove(e);
                        handleIconTouchMove(e);
                    }}
                    onTouchEnd={() => {
                        handleWindowTouchEnd();
                        handleIconTouchEnd(open);
                    }}
                    onClick={() => { setSelectedIcon(null); contextMenu.show && setContextMenu({ show: false, x: 0, y: 0 }); }}
                    onContextMenu={handleContextMenu}
                    onDrop={handleDesktopDrop}
                    onDragOver={handleDesktopDragOver}
                    onDragEnd={() => setFolderDrag(null)}
                    style={destructionMode ? { filter: 'hue-rotate(180deg) saturate(3)' } : {}}
                >
                    {matrixMode && <MatrixRain />}
                    {desktopBg === 'ascii' && !matrixMode && <BinaryBackground />}

                    {/* ThirdEye World Mode - Fullscreen portal view (like being inside ThirdEye) */}
                    {thirdEyeWorld && (
                        <div className="fixed inset-0 z-[9998] bg-black overflow-hidden" style={{ filter: 'invert(1) hue-rotate(180deg)' }}>
                            {/* Wireframe grid */}
                            <div className="absolute inset-0" style={{
                                backgroundImage: 'linear-gradient(rgba(0,255,0,0.2) 1px, transparent 1px), linear-gradient(90deg, rgba(0,255,0,0.2) 1px, transparent 1px)',
                                backgroundSize: '40px 40px',
                                filter: 'invert(1) hue-rotate(180deg)'
                            }} />

                            {/* Desktop icons as wireframes with code */}
                            {Object.entries(iconPositions).map(([id, pos]) => {
                                const appCodes = {
                                    SYSTEM: '// KERNEL.SYS\nobserve_all();',
                                    FILES: '// FS.EXE\nlist(dirs);',
                                    APPS: '// LAUNCH.EXE\nopen(app);',
                                    CONTACT: '// MAIL.SYS\nsend(msg);',
                                    TRASH: '// DEL.EXE\ndelete(all);',
                                };
                                return (
                                    <div
                                        key={id}
                                        className="absolute flex flex-col items-center pointer-events-none"
                                        style={{ left: pos.x, top: pos.y, width: 80, filter: 'invert(1) hue-rotate(180deg)' }}
                                    >
                                        <div className="w-12 h-12 border-2 border-green-500 flex items-center justify-center text-green-500 text-xs font-mono bg-black/50">
                                            {'</>'}
                                        </div>
                                        <pre className="text-green-500 text-[7px] font-mono mt-1 text-center whitespace-pre-wrap">
                                            {appCodes[id] || `// ${id}\ninit();`}
                                        </pre>
                                    </div>
                                );
                            })}

                            {/* Open windows as wireframes */}
                            {Object.entries(windows)
                                .filter(([, win]) => win.isOpen && !win.isMin)
                                .map(([id, win]) => {
                                    const appCodes = {
                                        SNAKE: '// SNEK.JS\neat(); grow();',
                                        DICE: '// RNG.GOD\nroll(d20);',
                                        PAINT: '// ART.EXE\ndraw(pos);',
                                    };
                                    return (
                                        <div
                                            key={id}
                                            className="absolute border-2 border-green-500 bg-black/70 p-2 pointer-events-none"
                                            style={{ left: win.x, top: win.y, width: parseInt(win.w), height: parseInt(win.h), filter: 'invert(1) hue-rotate(180deg)' }}
                                        >
                                            <div className="text-green-400 text-xs font-mono border-b border-green-500/50 pb-1 mb-1">{id}.EXE</div>
                                            <pre className="text-green-500/80 text-[9px] font-mono whitespace-pre-wrap">
                                                {appCodes[id] || `// ${id}.SYS\nprocess.run();\nreality.observe();`}
                                            </pre>
                                        </div>
                                    );
                                })}

                            {/* Warning text */}
                            <div className="absolute bottom-4 left-0 right-0 text-center pointer-events-none" style={{ filter: 'invert(1) hue-rotate(180deg)' }}>
                                <div className="text-green-500 text-xs font-mono animate-pulse tracking-widest">OBSERVER MODE ACTIVE</div>
                                <div className="text-green-500/50 text-[10px] font-mono mt-1">open THIRD_EYE to destabilize // reload to exit</div>
                            </div>
                        </div>
                    )}

                    {/* Context Menu */}
                    {contextMenu.show && (
                        <div
                            className="fixed z-[9999] bg-white border-2 border-black shadow-lg font-mono text-xs"
                            style={{ left: contextMenu.x, top: contextMenu.y }}
                            onClick={(e) => e.stopPropagation()}
                        >
                            <div className="px-3 py-2 border-b border-gray-300 font-bold text-gray-500">BACKGROUND</div>
                            <button
                                onClick={() => changeBackground('grid')}
                                className={`w-full px-3 py-2 text-left hover:bg-black hover:text-white flex items-center gap-2 ${desktopBg === 'grid' ? 'bg-gray-100' : ''}`}
                            >
                                <span className="w-4 h-4 border border-black bg-gray-100" style={{ backgroundImage: 'radial-gradient(#aaa 1px, transparent 1px)', backgroundSize: '4px 4px' }}></span>
                                GRID {desktopBg === 'grid' && ''}
                            </button>
                            <button
                                onClick={() => changeBackground('solid')}
                                className={`w-full px-3 py-2 text-left hover:bg-black hover:text-white flex items-center gap-2 ${desktopBg === 'solid' ? 'bg-gray-100' : ''}`}
                            >
                                <span className="w-4 h-4 border border-black bg-gray-200"></span>
                                SOLID {desktopBg === 'solid' && ''}
                            </button>
                            <button
                                onClick={() => changeBackground('ascii')}
                                className={`w-full px-3 py-2 text-left hover:bg-black hover:text-white flex items-center gap-2 ${desktopBg === 'ascii' ? 'bg-gray-100' : ''}`}
                            >
                                <span className="w-4 h-4 border border-black bg-gray-100 font-mono text-[6px] leading-none flex items-center justify-center">01</span>
                                ASCII {desktopBg === 'ascii' && ''}
                            </button>
                            <div className="px-3 py-2 border-t border-b border-gray-300 font-bold text-gray-500 mt-1">ICONS</div>
                            <button
                                onClick={resetIconPositions}
                                className="w-full px-3 py-2 text-left hover:bg-black hover:text-white flex items-center gap-2"
                            >
                                <span className="w-4 h-4 border border-black bg-gray-100 flex items-center justify-center font-mono text-[8px]"></span>
                                RESET POSITIONS
                            </button>
                        </div>
                    )}

                    {/* DESKTOP ICONS - Freely positionable */}
                    {desktopIcons.map(appId => {
                        const app = windows[appId];
                        if (!app) return null;
                        const IconCmp = Icons[app.icon];
                        const pos = iconPositions[app.id] || { x: 16, y: isMobile ? 80 : 16 };
                        const isDragging = iconDrag.active && iconDrag.id === app.id;
                        const isSelected = selectedIcon === app.id;
                        const isRevealing = revealingApps && revealedApps.includes(app.id);

                        // Skip icon if dog is carrying it
                        if (carriedIcon === app.id) return null;

                        // TRUTH is only visible when Third Eye is scanning over it
                        const isTruthScanned = app.id === 'TRUTH' && isThirdEyeOver(pos);
                        if (app.id === 'TRUTH' && !isTruthScanned) return null;

                        return (
                            <div
                                key={app.id}
                                className={`absolute z-10 group flex flex-col items-center gap-1 ${isMobile ? 'w-16' : 'w-24'} cursor-pointer select-none ${isDragging ? 'icon-dragging cursor-grabbing' : ''} ${isRevealing ? 'animate-fade-in' : ''}`}
                                style={{
                                    left: pos.x,
                                    top: pos.y,
                                    animation: isRevealing ? 'fadeIn 0.3s ease-out forwards' : undefined,
                                }}
                                onMouseDown={(e) => handleIconMouseDown(e, app.id)}
                                onTouchStart={(e) => handleIconTouchStart(e, app.id)}
                            >
                                <div className={`border-2 border-black icon-shadow group-hover:translate-x-1 group-hover:translate-y-1 group-hover:shadow-none transition-all ${isMobile ? 'p-2' : 'p-3'} ${isDragging ? 'translate-x-0 translate-y-0' : ''} ${isSelected ? 'bg-black text-white' : 'bg-white'}`}>
                                    <IconCmp size={isMobile ? 24 : 32} className={isSelected ? 'invert' : ''} />
                                </div>
                                <span className={`border border-black px-1 font-mono font-bold shadow-sm ${isMobile ? 'text-[8px]' : 'text-[10px]'} ${isSelected ? 'bg-black text-white' : 'bg-white'}`}>{app.title}</span>
                            </div>
                        );
                    })}
                    {/* Extra desktop icons (dragged from folders) - only in story mode */}
                    {modeSelected !== 'about' && extraDesktopIcons.map(appId => {
                        const app = windows[appId];
                        if (!app) return null;
                        const IconCmp = Icons[app.icon];
                        const pos = iconPositions[app.id] || { x: 200, y: 200 };
                        const isDragging = iconDrag.active && iconDrag.id === app.id;
                        const isSelected = selectedIcon === app.id;
                        if (carriedIcon === app.id) return null;

                        return (
                            <div
                                key={app.id}
                                className={`absolute z-10 group flex flex-col items-center gap-1 ${isMobile ? 'w-16' : 'w-24'} cursor-pointer select-none ${isDragging ? 'icon-dragging cursor-grabbing' : ''}`}
                                style={{
                                    left: pos.x,
                                    top: pos.y,
                                }}
                                onMouseDown={(e) => handleIconMouseDown(e, app.id)}
                                onTouchStart={(e) => handleIconTouchStart(e, app.id)}
                            >
                                <div className={`border-2 border-black icon-shadow group-hover:translate-x-1 group-hover:translate-y-1 group-hover:shadow-none transition-all p-3 ${isDragging ? 'translate-x-0 translate-y-0' : ''} ${isSelected ? 'bg-black text-white' : 'bg-white'}`}>
                                    <IconCmp size={32} className={isSelected ? 'invert' : ''} />
                                </div>
                                <span className={`border border-black px-1 font-mono font-bold shadow-sm text-[10px] ${isSelected ? 'bg-black text-white' : 'bg-white'}`}>{app.title}</span>
                            </div>
                        );
                    })}

                    {/* WINDOWS */}
                    {Object.values(windows).map(win => {
                        const physics = windowPhysics.current[win.id] || { scaleX: 1, scaleY: 1 };
                        const animState = windowAnimations[win.id];
                        const shouldRender = (win.isOpen || animState === 'closing') && !win.isMin;
                        const isActive = win.z === topZ;
                        const scaled = getScaledSize(win.w, win.h);
                        return shouldRender && (
                            <div
                                key={win.id}
                                onMouseDown={() => focus(win.id)}
                                onTouchStart={() => focus(win.id)}
                                className={`flex flex-col bg-white border-2 border-black absolute transition-opacity duration-150 ${isMobile ? '' : 'window-shadow'} ${animState === 'opening' ? 'window-opening' : ''} ${animState === 'closing' ? 'window-closing' : ''}`}
                                style={{
                                    left: isMobile ? 8 : Math.min(win.x, window.innerWidth - scaled.w - 20),
                                    top: isMobile ? 52 : Math.min(win.y, window.innerHeight - scaled.h - 60),
                                    width: isMobile ? 'calc(100% - 16px)' : scaled.w,
                                    height: isMobile ? 'calc(100% - 116px)' : scaled.h,
                                    zIndex: win.z,
                                    transform: animState ? undefined : `scale(${physics.scaleX}, ${physics.scaleY})`,
                                    transformOrigin: 'top center',
                                    opacity: 1
                                }}
                            >
                                {/* HEADER (DRAG HANDLE) */}
                                <div
                                    className={`flex justify-between items-center p-1 border-b-2 border-black select-none cursor-move ${isActive ? 'bg-black text-white' : 'bg-gray-200 text-black'}`}
                                    onMouseDown={(e) => handleMouseDown(e, win.id)}
                                    onTouchStart={(e) => handleWindowTouchStart(e, win.id)}
                                >
                                    <div className="flex items-center gap-2 pl-2 pointer-events-none">
                                        <span className="font-mono text-xs font-bold tracking-widest uppercase truncate">{win.title}</span>
                                    </div>
                                    {/* Hide controls for MESSAGES windows - can't skip the story */}
                                    {win.id !== 'MESSAGES' && win.id !== 'TRUTH_MESSAGES' && (
                                        <div className="flex gap-1" onMouseDown={e => e.stopPropagation()} onTouchStart={e => e.stopPropagation()}>
                                            <button onClick={() => toggleMin(win.id)} className={`w-8 h-8 flex items-center justify-center border border-transparent hover:bg-white/20 transition-colors ${isActive ? 'invert' : ''}`}><Icons.Minus size={16} /></button>
                                            <button onClick={() => close(win.id)} className={`w-8 h-8 flex items-center justify-center hover:bg-red-500 transition-colors ${isActive ? 'invert hover:invert-0' : ''}`}><Icons.X size={20} /></button>
                                        </div>
                                    )}
                                </div>
                                {/* CONTENT */}
                                <div className="flex-grow overflow-auto relative bg-white" onMouseDown={() => focus(win.id)}>
                                    <WindowErrorBoundary key={win.id}>
                                        {getWindowContent(win.id)}
                                    </WindowErrorBoundary>
                                </div>
                            </div>
                        );
                    })}

                    {/* TASKBAR */}
                    <div className={`h-12 bg-white flex items-center px-2 gap-1 md:gap-2 z-[99999] absolute w-full shadow-2xl ${isMobile ? 'top-0 border-b-2 border-black mobile-taskbar-top' : 'bottom-0 border-t-2 border-black mt-auto'}`}>
                        <div className={`bg-black text-white py-1 font-black select-none tracking-wider ${isMobile ? 'px-1 text-[8px]' : 'px-2 text-xs mr-2'}`}>{isMobile ? 'MATEUSMUSTE' : 'MATEUSMUSTE.COM'}</div>
                        <div className={`flex gap-1 ${isMobile ? 'overflow-x-auto flex-nowrap' : ''}`}>
                            {Object.values(windows).map(win => {
                                const IconCmp = Icons[win.icon];
                                return win.isOpen && (
                                    <button key={win.id}
                                        onClick={() => { if (win.isMin) toggleMin(win.id); focus(win.id) }}
                                        className={`flex items-center gap-1 md:gap-2 px-2 md:px-3 py-1 border-2 border-black font-mono text-xs font-bold transition-all flex-shrink-0 ${win.z === topZ && !win.isMin ? 'bg-black text-white btn-shadow' : 'bg-white hover:translate-y-[-2px]'}`}
                                    >
                                        <IconCmp size={14} className={win.z === topZ && !win.isMin ? 'invert' : ''} />
                                        <span className="uppercase hidden md:inline">{win.title}</span>
                                    </button>
                                );
                            })}
                        </div>
                        <div className="flex-grow"></div>
                        <button
                            onClick={handleToggleMute}
                            className={`border-l-2 border-black flex items-center justify-center hover:bg-gray-100 transition-colors ${isMobile ? 'px-2' : 'px-3'}`}
                            title={isMuted ? 'Unmute' : 'Mute'}
                        >
                            {isMuted ? <Icons.SpeakerOff size={16} /> : <Icons.Speaker size={16} />}
                        </button>
                        <div className={`font-mono border-l-2 border-black flex items-center gap-2 ${isMobile ? 'text-[8px] px-1' : 'text-[10px] px-3'}`}>
                            <span className="text-gray-500">POWER:</span>
                            <span className="font-bold">AC</span>
                        </div>
                        <div className={`font-mono font-bold border-l-2 border-black ${isMobile ? 'text-[10px] px-2' : 'text-xs px-4'}`}>{new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>
                    </div>

                    {/* DOG COMPANION - New sprite-based companion with physics */}
                    {dogCompanionActive && (
                        <div
                            className={`fixed z-[999999] cursor-pointer select-none ${dogCompanionDragging ? 'animate-shake' : ''}`}
                            style={{
                                left: dogCompanionPos.x,
                                top: dogCompanionPos.y,
                            }}
                            onMouseDown={handleDogCompanionMouseDown}
                        >
                            {/* Speech bubble */}
                            {dogCompanionDialogue && (
                                <DogSpeechBubble
                                    text={dogCompanionDialogue.text}
                                    highlight={dogCompanionDialogue.highlight}
                                    onComplete={() => {
                                        // Auto-advance after 2 seconds when typing completes (unless waiting for name)
                                        if (dogCompanionWaitingFor !== 'enterName') {
                                            setTimeout(() => advanceDogDialogue(), 2000);
                                        }
                                    }}
                                    dogX={dogCompanionPos.x}
                                    dogY={dogCompanionPos.y}
                                />
                            )}
                            {/* Name input when waiting for enterName - positioned above dog, below dialogue */}
                            {dogCompanionWaitingFor === 'enterName' && (
                                <div
                                    className="absolute bg-black border-2 border-white p-4 font-mono"
                                    style={{
                                        bottom: 100,
                                        left: 0,
                                        minWidth: 240,
                                        zIndex: 10
                                    }}
                                >
                                    <div className="text-white text-[10px] uppercase tracking-widest mb-3 opacity-60">ENTER YOUR NAME</div>
                                    <form onSubmit={(e) => {
                                        e.preventDefault();
                                        const formData = new FormData(e.target);
                                        const nameValue = formData.get('nameInput');
                                        if (nameValue && nameValue.trim()) {
                                            setPlayerName(nameValue.trim().toUpperCase());
                                            setDogCompanionWaitingFor(null);
                                            setDogCompanionDialogue(null);
                                            setDogCompanionDialogueQueue([]);
                                            setTimeout(() => startDogDialogue('ACT1_NAME_ENTERED'), 500);
                                        }
                                    }}>
                                        <input
                                            name="nameInput"
                                            type="text"
                                            placeholder="_"
                                            className="w-full bg-transparent border-b-2 border-white text-white px-0 py-2 text-sm font-mono uppercase tracking-widest focus:outline-none placeholder:text-white/30"
                                            autoFocus
                                            autoComplete="off"
                                            maxLength={20}
                                            onKeyDown={(e) => {
                                                if (e.key === 'Enter') {
                                                    e.target.form.requestSubmit();
                                                }
                                            }}
                                        />
                                        <button type="submit" className="w-full mt-4 bg-white text-black px-4 py-2 text-xs font-mono uppercase tracking-widest hover:bg-white/80 transition-colors">
                                            CONFIRM
                                        </button>
                                    </form>
                                </div>
                            )}
                            <DogCompanionSprite emotion={dogCompanionEmotion} scale={3} />
                        </div>
                    )}

                    {/* Dog error windows */}
                    {dogErrorWindows.map((error) => (
                        <div
                            key={error.id}
                            className="fixed z-[999990] bg-red-900 text-white border-2 border-red-500 p-4 font-mono shadow-lg"
                            style={{
                                left: error.x,
                                top: error.y,
                                minWidth: 200
                            }}
                        >
                            <div className="flex items-center justify-between mb-2">
                                <div className="flex items-center gap-2">
                                    <Icons.Alert size={16} className="text-red-400" />
                                    <span className="text-xs font-bold text-red-400 uppercase tracking-widest">ERROR</span>
                                </div>
                                <button
                                    onClick={() => closeDogError(error.id)}
                                    className="w-6 h-6 flex items-center justify-center hover:bg-red-800 border border-red-500"
                                >
                                    <Icons.X size={12} />
                                </button>
                            </div>
                            <div className="text-sm">{error.message}</div>
                        </div>
                    ))}

                    {/* GOLDY - Cardboard fake dog that sits on taskbar, folds down when clicked */}
                    {goldyVisible && (
                        <div
                            className="fixed z-[999997] cursor-pointer select-none"
                            style={{
                                left: goldyPos.x,
                                top: goldyPos.y,
                            }}
                        >
                            <GoldySprite
                                scale={2}
                                falling={goldyFalling}
                                onClick={handleGoldyClick}
                            />
                        </div>
                    )}

                    {/* Legacy DOG - Cute pixel dog with running animation (for destruction mode) */}
                    {dogReleased && (
                        <div
                            className={`fixed z-[999999] cursor-pointer select-none ${dogDragging ? 'dog-scared' : ''}`}
                            style={{
                                left: dogPos.x,
                                top: dogPos.y,
                                transform: `scaleX(${dogFacingRight ? 1 : -1})`,
                            }}
                            onMouseDown={handleDogMouseDown}
                            onMouseUp={handleDogMouseUp}
                        >
                            <DogSprite animated />
                            {carriedIcon && !dogDragging && (
                                <div
                                    className="absolute bg-white border-2 border-black p-1"
                                    style={{ top: -20, left: 8 }}
                                >
                                    {React.createElement(Icons[windows[carriedIcon]?.icon], { size: 24 })}
                                </div>
                            )}
                        </div>
                    )}

                    {/* CRT Static overlay for destruction */}
                    {destructionMode === true && (
                        <div className="fixed inset-0 z-[999998] pointer-events-none crt-static" />
                    )}

                    {/* Achievement notifications (stacked) */}
                    {achievementNotifications.map((notif, index) => (
                        <div key={notif.id} className="fixed right-4 z-[9999999] bg-black text-white border-2 border-white px-4 py-3 font-mono shadow-lg animate-slide-in-right" style={{ top: `${16 + index * 152}px` }}>
                            <div className="text-[10px] text-gray-400 uppercase tracking-widest">Achievement Unlocked</div>
                            <div className="text-lg font-bold">{notif.name}</div>
                            <div className="text-xs text-gray-300">{notif.hint}</div>
                        </div>
                    ))}

                    {/* App unlock notifications (stacked below achievements) */}
                    {appUnlockNotifications.map((notif, index) => (
                        <div key={notif.id} className="fixed right-4 z-[9999998] bg-white text-black border-2 border-black px-4 py-3 font-mono shadow-lg animate-slide-in-right" style={{ top: `${16 + achievementNotifications.length * 152 + index * 152}px` }}>
                            <div className="text-[10px] text-gray-500 uppercase tracking-widest">New App Unlocked</div>
                            <div className="text-lg font-bold">{notif.app}</div>
                            <div className="text-xs text-gray-500">Check APPS folder</div>
                        </div>
                    ))}

                    {/* Corrupted File Alert - Narrative Bible v3.0 */}
                    {showCorruptedAlert && (
                        <div className="fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-[9999999] bg-red-900 text-white border-2 border-red-500 p-6 font-mono shadow-2xl max-w-sm">
                            <div className="flex items-center gap-2 mb-4">
                                <Icons.Alert size={24} className="text-red-400" />
                                <span className="text-xs font-bold text-red-400 uppercase tracking-widest">SYSTEM ALERT</span>
                            </div>
                            <div className="text-sm mb-4">
                                1 CORRUPTED FILE DETECTED IN /PERSONAL
                            </div>
                            <div className="flex gap-3">
                                <button
                                    onClick={() => { setShowCorruptedAlert(false); open('TERMINAL'); }}
                                    className="flex-1 bg-white text-red-900 px-4 py-2 text-xs font-bold hover:bg-gray-200"
                                >
                                    INVESTIGATE
                                </button>
                                <button
                                    onClick={() => setShowCorruptedAlert(false)}
                                    className="flex-1 border border-white text-white px-4 py-2 text-xs font-bold hover:bg-red-800"
                                >
                                    DISMISS
                                </button>
                            </div>
                        </div>
                    )}

                    {/* Glitch animation styles */}
                    <style>{`
                        @keyframes glitch {
                            0% { transform: translate(0); filter: hue-rotate(0deg); }
                            20% { transform: translate(-2px, 2px); filter: hue-rotate(90deg); }
                            40% { transform: translate(2px, -2px); filter: hue-rotate(180deg); }
                            60% { transform: translate(-2px, -2px); filter: hue-rotate(270deg); }
                            80% { transform: translate(2px, 2px); filter: hue-rotate(360deg); }
                            100% { transform: translate(0); filter: hue-rotate(0deg); }
                        }
                        .group-hover\\:animate-glitch:hover {
                            animation: glitch 0.2s infinite;
                        }
                        .destruction-icon:hover {
                            animation: glitch 0.3s infinite;
                        }
                        .crt-static {
                            background: repeating-linear-gradient(
                                0deg,
                                rgba(0, 0, 0, 0.1) 0px,
                                rgba(0, 0, 0, 0.1) 1px,
                                transparent 1px,
                                transparent 2px
                            );
                            animation: static 0.1s infinite;
                        }
                        @keyframes static {
                            0% { opacity: 0.3; }
                            50% { opacity: 0.5; }
                            100% { opacity: 0.3; }
                        }
                        @keyframes dog-scared-float {
                            0%, 100% { transform: translateY(0) rotate(-5deg); }
                            25% { transform: translateY(-8px) rotate(5deg); }
                            50% { transform: translateY(-3px) rotate(-3deg); }
                            75% { transform: translateY(-10px) rotate(3deg); }
                        }
                        .dog-scared {
                            animation: dog-scared-float 0.3s ease-in-out infinite;
                        }
                        @keyframes slide-in-right {
                            from { transform: translateX(100%); opacity: 0; }
                            to { transform: translateX(0); opacity: 1; }
                        }
                        .animate-slide-in-right {
                            animation: slide-in-right 0.3s ease-out forwards;
                        }
                    `}</style>

                </div>
            )
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<OS />);
    </script>
</body>

</html>
