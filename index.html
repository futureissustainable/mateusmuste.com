<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MATEUSMUSTE // OS</title>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script src="https://cdn.tailwindcss.com"></script>

    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Geist:wght@400;700;900&family=Geist+Mono:wght@400;700&display=swap"
        rel="stylesheet">

    <style>
        :root {
            --bg: #e5e5e5;
            --fg: #000000;
        }

        body {
            background-color: var(--bg);
            color: var(--fg);
            font-family: 'Geist', sans-serif;
            overflow: hidden;
            margin: 0;
            padding: 0;
            user-select: none;
            -webkit-font-smoothing: antialiased;
        }

        .font-mono {
            font-family: 'Geist Mono', monospace;
        }

        /* Brutalist Styles */
        .window-shadow {
            box-shadow: 10px 10px 0px 0px #000000;
        }

        .icon-shadow {
            box-shadow: 4px 4px 0px 0px #000000;
        }

        .btn-shadow {
            box-shadow: 2px 2px 0px 0px #000000;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }

        ::-webkit-scrollbar-track {
            background: #fff;
            border-left: 2px solid #000;
            border-top: 2px solid #000;
        }

        ::-webkit-scrollbar-thumb {
            background: #000;
            border: 2px solid #fff;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #333;
        }

        /* Background Pattern */
        .desktop-bg {
            background-color: #f0f0f0;
            background-image: radial-gradient(#aaa 1px, transparent 1px);
            background-size: 20px 20px;
        }

        canvas {
            touch-action: none;
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            10%,
            30%,
            50%,
            70%,
            90% {
                transform: translateX(-5px);
            }

            20%,
            40%,
            60%,
            80% {
                transform: translateX(5px);
            }
        }

        .animate-shake {
            animation: shake 0.5s ease-in-out;
        }
    </style>
</head>

<body>

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- IP-BASED HIGH SCORE SYSTEM ---
        const HighScoreManager = {
            userIP: null,

            async fetchIP() {
                if (this.userIP) return this.userIP;
                try {
                    const res = await fetch('https://api.ipify.org?format=json');
                    const data = await res.json();
                    this.userIP = data.ip;
                    return this.userIP;
                } catch (e) {
                    // Fallback to anonymous if IP fetch fails
                    this.userIP = 'anonymous';
                    return this.userIP;
                }
            },

            getStorageKey(game) {
                return `highscore_${game}_${this.userIP || 'anonymous'}`;
            },

            saveHighScore(game, score) {
                const key = this.getStorageKey(game);
                const current = localStorage.getItem(key);
                if (!current || score > parseInt(current, 10)) {
                    localStorage.setItem(key, score.toString());
                    return true;
                }
                return false;
            },

            getHighScore(game) {
                const key = this.getStorageKey(game);
                return parseInt(localStorage.getItem(key) || '0', 10);
            }
        };

        // Initialize IP on load
        HighScoreManager.fetchIP();

        // --- PIXEL ART ICONS (64x64) ---
        const PixelIcon = ({ children, size = 64, ...props }) => (
            <svg {...props} width={size} height={size} viewBox="0 0 64 64" fill="none" style={{ imageRendering: 'pixelated' }}>
                {children}
            </svg>
        );

        const Icons = {
            // System Info - Monitor with info screen
            Terminal: (p) => (
                <PixelIcon {...p}>
                    <rect x="8" y="8" width="48" height="36" fill="#000" />
                    <rect x="12" y="12" width="40" height="28" fill="#fff" />
                    <rect x="16" y="16" width="32" height="4" fill="#000" />
                    <rect x="16" y="24" width="24" height="4" fill="#000" />
                    <rect x="16" y="32" width="16" height="4" fill="#000" />
                    <rect x="24" y="44" width="16" height="4" fill="#000" />
                    <rect x="20" y="48" width="24" height="8" fill="#000" />
                </PixelIcon>
            ),
            // Media Library - Stack of folders
            Folder: (p) => (
                <PixelIcon {...p}>
                    <rect x="8" y="20" width="48" height="36" fill="#000" />
                    <rect x="12" y="24" width="40" height="28" fill="#fff" />
                    <rect x="8" y="16" width="20" height="8" fill="#000" />
                    <rect x="12" y="12" width="12" height="8" fill="#000" />
                    <rect x="16" y="32" width="28" height="4" fill="#000" />
                    <rect x="16" y="40" width="20" height="4" fill="#000" />
                </PixelIcon>
            ),
            // Paint - Paint bucket icon
            Palette: (p) => (
                <PixelIcon {...p}>
                    {/* Bucket body */}
                    <rect x="12" y="20" width="40" height="32" fill="#000" />
                    <rect x="16" y="24" width="32" height="24" fill="#fff" />
                    {/* Handle */}
                    <rect x="8" y="8" width="4" height="16" fill="#000" />
                    <rect x="8" y="4" width="24" height="4" fill="#000" />
                    <rect x="28" y="8" width="4" height="8" fill="#000" />
                    {/* Paint drip */}
                    <rect x="44" y="28" width="8" height="12" fill="#000" />
                    <rect x="48" y="40" width="8" height="8" fill="#000" />
                    <rect x="52" y="48" width="8" height="8" fill="#000" />
                    {/* Rim */}
                    <rect x="8" y="16" width="48" height="4" fill="#000" />
                </PixelIcon>
            ),
            // Snake Game - Pixel snake
            Snek: (p) => (
                <PixelIcon {...p}>
                    <rect x="8" y="24" width="8" height="8" fill="#000" />
                    <rect x="16" y="24" width="8" height="8" fill="#000" />
                    <rect x="24" y="24" width="8" height="8" fill="#000" />
                    <rect x="32" y="24" width="8" height="8" fill="#000" />
                    <rect x="32" y="32" width="8" height="8" fill="#000" />
                    <rect x="32" y="40" width="8" height="8" fill="#000" />
                    <rect x="40" y="40" width="8" height="8" fill="#000" />
                    <rect x="48" y="40" width="8" height="8" fill="#000" />
                    <rect x="4" y="20" width="4" height="4" fill="#000" />
                    <rect x="4" y="28" width="4" height="4" fill="#000" />
                    <rect x="52" y="48" width="8" height="8" fill="#fff" stroke="#000" strokeWidth="2" />
                </PixelIcon>
            ),
            // Trash Can - Desktop trash
            TrashCan: (p) => (
                <PixelIcon {...p}>
                    <rect x="12" y="8" width="40" height="8" fill="#000" />
                    <rect x="20" y="4" width="24" height="8" fill="#000" />
                    <rect x="16" y="16" width="32" height="40" fill="#000" />
                    <rect x="20" y="20" width="24" height="32" fill="#fff" />
                    <rect x="24" y="24" width="4" height="24" fill="#000" />
                    <rect x="30" y="24" width="4" height="24" fill="#000" />
                    <rect x="36" y="24" width="4" height="24" fill="#000" />
                </PixelIcon>
            ),
            // Undo arrow
            Undo: (p) => (
                <PixelIcon {...p}>
                    <rect x="8" y="24" width="8" height="8" fill="#000" />
                    <rect x="16" y="16" width="8" height="8" fill="#000" />
                    <rect x="24" y="8" width="8" height="8" fill="#000" />
                    <rect x="16" y="32" width="32" height="8" fill="#000" />
                    <rect x="40" y="40" width="8" height="16" fill="#000" />
                </PixelIcon>
            ),
            // Redo arrow
            Redo: (p) => (
                <PixelIcon {...p}>
                    <rect x="48" y="24" width="8" height="8" fill="#000" />
                    <rect x="40" y="16" width="8" height="8" fill="#000" />
                    <rect x="32" y="8" width="8" height="8" fill="#000" />
                    <rect x="16" y="32" width="32" height="8" fill="#000" />
                    <rect x="16" y="40" width="8" height="16" fill="#000" />
                </PixelIcon>
            ),
            // File icon for trash items
            FileDoc: (p) => (
                <PixelIcon {...p}>
                    <rect x="12" y="4" width="32" height="56" fill="#000" />
                    <rect x="16" y="8" width="24" height="48" fill="#fff" />
                    <rect x="20" y="16" width="16" height="4" fill="#000" />
                    <rect x="20" y="24" width="16" height="4" fill="#000" />
                    <rect x="20" y="32" width="12" height="4" fill="#000" />
                </PixelIcon>
            ),
            X: ({ size = 24, ...p }) => <svg width={size} height={size} {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>,
            Minus: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="5" y1="12" x2="19" y2="12"></line></svg>,
            Square: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect></svg>,
            Trash: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>,
            Send: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>,
            // Media folder icons
            Movies: (p) => (
                <PixelIcon {...p}>
                    <rect x="8" y="12" width="48" height="40" fill="#000" />
                    <rect x="12" y="16" width="40" height="32" fill="#fff" />
                    <rect x="8" y="8" width="12" height="8" fill="#000" />
                    <polygon points="24,24 24,40 40,32" fill="#000" />
                </PixelIcon>
            ),
            Books: (p) => (
                <PixelIcon {...p}>
                    <rect x="8" y="12" width="48" height="40" fill="#000" />
                    <rect x="12" y="16" width="40" height="32" fill="#fff" />
                    <rect x="8" y="8" width="12" height="8" fill="#000" />
                    <rect x="20" y="22" width="24" height="4" fill="#000" />
                    <rect x="20" y="30" width="16" height="4" fill="#000" />
                    <rect x="20" y="38" width="20" height="4" fill="#000" />
                </PixelIcon>
            ),
            Games: (p) => (
                <PixelIcon {...p}>
                    <rect x="8" y="12" width="48" height="40" fill="#000" />
                    <rect x="12" y="16" width="40" height="32" fill="#fff" />
                    <rect x="8" y="8" width="12" height="8" fill="#000" />
                    <rect x="20" y="24" width="8" height="8" fill="#000" />
                    <rect x="36" y="24" width="8" height="8" fill="#000" />
                    <rect x="24" y="36" width="16" height="4" fill="#000" />
                </PixelIcon>
            ),
            Music: (p) => (
                <PixelIcon {...p}>
                    <rect x="8" y="12" width="48" height="40" fill="#000" />
                    <rect x="12" y="16" width="40" height="32" fill="#fff" />
                    <rect x="8" y="8" width="12" height="8" fill="#000" />
                    <rect x="36" y="20" width="4" height="20" fill="#000" />
                    <rect x="28" y="36" width="12" height="8" fill="#000" />
                    <rect x="36" y="20" width="12" height="8" fill="#000" />
                </PixelIcon>
            ),
            Back: (p) => <svg {...p} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M19 12H5M12 19l-7-7 7-7" /></svg>,
            // New App Icons
            Void: (p) => (
                <PixelIcon {...p}>
                    <rect x="8" y="8" width="48" height="48" fill="#000" />
                    <rect x="12" y="12" width="40" height="40" fill="#fff" />
                    <rect x="16" y="16" width="32" height="4" fill="#000" />
                    <rect x="16" y="24" width="24" height="4" fill="#333" />
                    <rect x="16" y="32" width="28" height="4" fill="#666" />
                    <rect x="16" y="40" width="16" height="4" fill="#999" />
                </PixelIcon>
            ),
            Oracle: (p) => (
                <PixelIcon {...p}>
                    <rect x="20" y="4" width="24" height="8" fill="#000" />
                    <rect x="16" y="12" width="32" height="8" fill="#000" />
                    <rect x="12" y="20" width="40" height="24" fill="#000" />
                    <rect x="16" y="24" width="32" height="16" fill="#fff" />
                    <rect x="24" y="28" width="6" height="6" fill="#000" />
                    <rect x="34" y="28" width="6" height="6" fill="#000" />
                    <rect x="12" y="44" width="12" height="12" fill="#000" />
                    <rect x="40" y="44" width="12" height="12" fill="#000" />
                </PixelIcon>
            ),
            Radio: (p) => (
                <PixelIcon {...p}>
                    <rect x="8" y="16" width="48" height="36" fill="#000" />
                    <rect x="12" y="20" width="40" height="28" fill="#fff" />
                    <rect x="16" y="24" width="16" height="16" fill="#000" />
                    <rect x="20" y="28" width="8" height="8" fill="#fff" />
                    <rect x="36" y="24" width="12" height="4" fill="#000" />
                    <rect x="36" y="32" width="12" height="4" fill="#000" />
                    <rect x="28" y="4" width="4" height="16" fill="#000" />
                    <rect x="24" y="4" width="12" height="4" fill="#000" />
                </PixelIcon>
            ),
            Dice: (p) => (
                <PixelIcon {...p}>
                    <rect x="8" y="8" width="48" height="48" fill="#000" />
                    <rect x="12" y="12" width="40" height="40" fill="#fff" />
                    <rect x="20" y="20" width="8" height="8" fill="#000" />
                    <rect x="36" y="20" width="8" height="8" fill="#000" />
                    <rect x="28" y="28" width="8" height="8" fill="#000" />
                    <rect x="20" y="36" width="8" height="8" fill="#000" />
                    <rect x="36" y="36" width="8" height="8" fill="#000" />
                </PixelIcon>
            ),
            Labyrinth: (p) => (
                <PixelIcon {...p}>
                    {/* Border */}
                    <rect x="4" y="4" width="56" height="56" fill="#000" />
                    <rect x="8" y="8" width="48" height="48" fill="#fff" />
                    {/* Maze walls - proper labyrinth pattern */}
                    <rect x="8" y="8" width="48" height="4" fill="#000" />
                    <rect x="8" y="8" width="4" height="48" fill="#000" />
                    <rect x="52" y="8" width="4" height="48" fill="#000" />
                    <rect x="8" y="52" width="48" height="4" fill="#000" />
                    {/* Inner walls */}
                    <rect x="16" y="16" width="32" height="4" fill="#000" />
                    <rect x="16" y="16" width="4" height="24" fill="#000" />
                    <rect x="44" y="16" width="4" height="32" fill="#000" />
                    <rect x="24" y="24" width="4" height="20" fill="#000" />
                    <rect x="24" y="40" width="20" height="4" fill="#000" />
                    <rect x="32" y="28" width="4" height="12" fill="#000" />
                    <rect x="32" y="28" width="12" height="4" fill="#000" />
                    {/* Entry gap top */}
                    <rect x="28" y="8" width="8" height="4" fill="#fff" />
                    {/* Exit gap bottom */}
                    <rect x="28" y="52" width="8" height="4" fill="#fff" />
                </PixelIcon>
            ),
            Minesweeper: (p) => (
                <PixelIcon {...p}>
                    {/* Grid background */}
                    <rect x="4" y="4" width="56" height="56" fill="#000" />
                    <rect x="8" y="8" width="48" height="48" fill="#fff" />
                    {/* Grid lines */}
                    <rect x="8" y="20" width="48" height="2" fill="#ccc" />
                    <rect x="8" y="34" width="48" height="2" fill="#ccc" />
                    <rect x="8" y="48" width="48" height="2" fill="#ccc" />
                    <rect x="20" y="8" width="2" height="48" fill="#ccc" />
                    <rect x="34" y="8" width="2" height="48" fill="#ccc" />
                    <rect x="48" y="8" width="2" height="48" fill="#ccc" />
                    {/* Pixel mine */}
                    <rect x="24" y="38" width="8" height="8" fill="#000" />
                    <rect x="26" y="36" width="4" height="2" fill="#000" />
                    <rect x="26" y="46" width="4" height="2" fill="#000" />
                    <rect x="22" y="40" width="2" height="4" fill="#000" />
                    <rect x="32" y="40" width="2" height="4" fill="#000" />
                    {/* Pixel 1 */}
                    <rect x="12" y="10" width="4" height="2" fill="#000" />
                    <rect x="14" y="10" width="2" height="8" fill="#000" />
                    <rect x="10" y="18" width="8" height="2" fill="#000" />
                    {/* Pixel flag */}
                    <rect x="40" y="10" width="2" height="10" fill="#000" />
                    <rect x="42" y="10" width="4" height="2" fill="#000" />
                    <rect x="42" y="12" width="2" height="2" fill="#000" />
                </PixelIcon>
            ),
            Starship: (p) => (
                <PixelIcon {...p}>
                    {/* Space background */}
                    <rect x="4" y="4" width="56" height="56" fill="#000" />
                    {/* Stars */}
                    <rect x="10" y="10" width="2" height="2" fill="#fff" />
                    <rect x="50" y="15" width="2" height="2" fill="#fff" />
                    <rect x="25" y="8" width="2" height="2" fill="#fff" />
                    <rect x="45" y="45" width="2" height="2" fill="#fff" />
                    <rect x="12" y="50" width="2" height="2" fill="#fff" />
                    {/* Pixel ship - top down view */}
                    <rect x="30" y="12" width="4" height="4" fill="#fff" />
                    <rect x="28" y="16" width="8" height="4" fill="#fff" />
                    <rect x="26" y="20" width="12" height="8" fill="#fff" />
                    <rect x="24" y="28" width="16" height="8" fill="#fff" />
                    {/* Wings */}
                    <rect x="16" y="32" width="8" height="4" fill="#fff" />
                    <rect x="40" y="32" width="8" height="4" fill="#fff" />
                    <rect x="12" y="36" width="8" height="4" fill="#fff" />
                    <rect x="44" y="36" width="8" height="4" fill="#fff" />
                    {/* Cockpit */}
                    <rect x="30" y="20" width="4" height="4" fill="#000" />
                    {/* Engine */}
                    <rect x="28" y="36" width="8" height="6" fill="#888" />
                    <rect x="30" y="42" width="4" height="4" fill="#888" />
                </PixelIcon>
            ),
            Synth: (p) => (
                <PixelIcon {...p}>
                    <rect x="4" y="16" width="56" height="36" fill="#000" />
                    <rect x="8" y="20" width="48" height="28" fill="#333" />
                    <rect x="12" y="24" width="8" height="16" fill="#fff" />
                    <rect x="22" y="24" width="8" height="16" fill="#fff" />
                    <rect x="32" y="24" width="8" height="16" fill="#fff" />
                    <rect x="42" y="24" width="8" height="16" fill="#fff" />
                    <rect x="16" y="24" width="4" height="10" fill="#000" />
                    <rect x="26" y="24" width="4" height="10" fill="#000" />
                    <rect x="46" y="24" width="4" height="10" fill="#000" />
                </PixelIcon>
            ),
            Destruction: (p) => (
                <PixelIcon {...p}>
                    {/* Power button icon */}
                    {/* Outer circle - pixelated */}
                    <rect x="20" y="12" width="24" height="4" fill="#000" />
                    <rect x="16" y="16" width="8" height="4" fill="#000" />
                    <rect x="40" y="16" width="8" height="4" fill="#000" />
                    <rect x="12" y="20" width="8" height="4" fill="#000" />
                    <rect x="44" y="20" width="8" height="4" fill="#000" />
                    <rect x="8" y="24" width="8" height="12" fill="#000" />
                    <rect x="48" y="24" width="8" height="12" fill="#000" />
                    <rect x="12" y="36" width="8" height="4" fill="#000" />
                    <rect x="44" y="36" width="8" height="4" fill="#000" />
                    <rect x="16" y="40" width="8" height="4" fill="#000" />
                    <rect x="40" y="40" width="8" height="4" fill="#000" />
                    <rect x="20" y="44" width="24" height="4" fill="#000" />
                    {/* Power line on top */}
                    <rect x="28" y="4" width="8" height="24" fill="#000" />
                </PixelIcon>
            ),
            Tarot: (p) => (
                <PixelIcon {...p}>
                    <rect x="16" y="4" width="32" height="56" fill="#000" />
                    <rect x="20" y="8" width="24" height="48" fill="#fff" />
                    <rect x="24" y="12" width="16" height="4" fill="#000" />
                    <rect x="28" y="20" width="8" height="8" fill="#000" />
                    <rect x="24" y="32" width="16" height="16" fill="#000" />
                    <rect x="28" y="36" width="8" height="8" fill="#fff" />
                </PixelIcon>
            ),
            Dog: (p) => (
                <PixelIcon {...p}>
                    {/* Cute dog - full black */}
                    {/* Body */}
                    <rect x="16" y="20" width="32" height="16" fill="#000" />
                    {/* Head - rounder, cuter */}
                    <rect x="4" y="16" width="16" height="16" fill="#000" />
                    {/* Floppy ears */}
                    <rect x="2" y="8" width="6" height="14" fill="#000" />
                    <rect x="14" y="8" width="6" height="14" fill="#000" />
                    {/* Eye - big cute eye */}
                    <rect x="8" y="20" width="6" height="6" fill="#fff" />
                    <rect x="10" y="22" width="3" height="3" fill="#000" />
                    {/* Nose */}
                    <rect x="4" y="26" width="4" height="4" fill="#000" />
                    {/* Tail - wagging up */}
                    <rect x="48" y="16" width="12" height="4" fill="#000" />
                    <rect x="56" y="12" width="4" height="8" fill="#000" />
                    {/* Legs */}
                    <rect x="16" y="36" width="8" height="16" fill="#000" />
                    <rect x="38" y="36" width="8" height="16" fill="#000" />
                </PixelIcon>
            ),
            // Email icon
            Email: (p) => (
                <PixelIcon {...p}>
                    {/* Envelope */}
                    <rect x="4" y="12" width="56" height="40" fill="#000" />
                    <rect x="8" y="16" width="48" height="32" fill="#fff" />
                    {/* Flap */}
                    <polygon points="8,16 32,36 56,16" fill="#000" />
                    <polygon points="12,20 32,32 52,20" fill="#fff" />
                    {/* Bottom fold */}
                    <polygon points="8,48 32,32 56,48" fill="#000" stroke="#fff" strokeWidth="2" />
                </PixelIcon>
            ),
            // Apps folder icon
            Apps: (p) => (
                <PixelIcon {...p}>
                    {/* Folder base */}
                    <rect x="4" y="16" width="56" height="40" fill="#000" />
                    <rect x="8" y="20" width="48" height="32" fill="#fff" />
                    {/* Folder tab */}
                    <rect x="4" y="12" width="24" height="8" fill="#000" />
                    {/* Grid of apps inside */}
                    <rect x="12" y="24" width="8" height="8" fill="#000" />
                    <rect x="24" y="24" width="8" height="8" fill="#000" />
                    <rect x="36" y="24" width="8" height="8" fill="#000" />
                    <rect x="12" y="36" width="8" height="8" fill="#000" />
                    <rect x="24" y="36" width="8" height="8" fill="#000" />
                    <rect x="36" y="36" width="8" height="8" fill="#000" />
                </PixelIcon>
            ),
            Gallery: (p) => (
                <PixelIcon {...p}>
                    {/* Photo frame */}
                    <rect x="8" y="12" width="48" height="40" fill="#000" />
                    <rect x="12" y="16" width="40" height="32" fill="#fff" />
                    {/* Pixel mountain left */}
                    <rect x="12" y="40" width="4" height="8" fill="#000" />
                    <rect x="16" y="36" width="4" height="12" fill="#000" />
                    <rect x="20" y="32" width="4" height="16" fill="#000" />
                    <rect x="24" y="36" width="4" height="12" fill="#000" />
                    <rect x="28" y="40" width="4" height="8" fill="#000" />
                    {/* Pixel mountain right */}
                    <rect x="32" y="44" width="4" height="4" fill="#000" />
                    <rect x="36" y="40" width="4" height="8" fill="#000" />
                    <rect x="40" y="36" width="4" height="12" fill="#000" />
                    <rect x="44" y="40" width="4" height="8" fill="#000" />
                    <rect x="48" y="44" width="4" height="4" fill="#000" />
                    {/* Sun */}
                    <rect x="40" y="20" width="8" height="8" fill="#000" />
                </PixelIcon>
            ),
            Globe: (p) => (
                <PixelIcon {...p}>
                    {/* Pixel globe - octagon shape */}
                    <rect x="20" y="8" width="24" height="4" fill="#000" />
                    <rect x="12" y="12" width="8" height="4" fill="#000" />
                    <rect x="44" y="12" width="8" height="4" fill="#000" />
                    <rect x="8" y="16" width="4" height="8" fill="#000" />
                    <rect x="52" y="16" width="4" height="8" fill="#000" />
                    <rect x="8" y="36" width="4" height="8" fill="#000" />
                    <rect x="52" y="36" width="4" height="8" fill="#000" />
                    <rect x="12" y="44" width="8" height="4" fill="#000" />
                    <rect x="44" y="44" width="8" height="4" fill="#000" />
                    <rect x="20" y="48" width="24" height="4" fill="#000" />
                    {/* Fill */}
                    <rect x="20" y="12" width="24" height="36" fill="#fff" />
                    <rect x="12" y="16" width="8" height="28" fill="#fff" />
                    <rect x="44" y="16" width="8" height="28" fill="#fff" />
                    {/* Continents */}
                    <rect x="18" y="18" width="8" height="10" fill="#000" />
                    <rect x="34" y="14" width="10" height="6" fill="#000" />
                    <rect x="38" y="20" width="8" height="12" fill="#000" />
                    <rect x="22" y="32" width="10" height="8" fill="#000" />
                    {/* Grid lines */}
                    <rect x="12" y="24" width="40" height="2" fill="#888" />
                    <rect x="12" y="34" width="40" height="2" fill="#888" />
                    {/* Stand */}
                    <rect x="28" y="52" width="8" height="4" fill="#000" />
                    <rect x="22" y="56" width="20" height="4" fill="#000" />
                </PixelIcon>
            ),
            Pomodoro: (p) => (
                <PixelIcon {...p}>
                    {/* Pot */}
                    <rect x="16" y="44" width="32" height="16" fill="#000" />
                    <rect x="20" y="48" width="24" height="8" fill="#fff" />
                    {/* Stem */}
                    <rect x="30" y="24" width="4" height="20" fill="#000" />
                    {/* Leaves */}
                    <rect x="22" y="28" width="8" height="6" fill="#000" />
                    <rect x="34" y="20" width="8" height="6" fill="#000" />
                    <rect x="26" y="12" width="12" height="8" fill="#000" />
                    {/* Timer - pixel square */}
                    <rect x="26" y="4" width="12" height="12" fill="#000" />
                    <rect x="28" y="6" width="8" height="8" fill="#fff" />
                    <rect x="31" y="8" width="2" height="4" fill="#000" />
                </PixelIcon>
            ),
            HealthScanner: (p) => (
                <PixelIcon {...p}>
                    {/* Monitor frame */}
                    <rect x="8" y="8" width="48" height="40" fill="#000" />
                    <rect x="12" y="12" width="40" height="32" fill="#fff" />
                    {/* Pixel heart rate - stepped line */}
                    <rect x="14" y="28" width="6" height="2" fill="#000" />
                    <rect x="20" y="26" width="2" height="4" fill="#000" />
                    <rect x="22" y="20" width="2" height="8" fill="#000" />
                    <rect x="24" y="18" width="2" height="4" fill="#000" />
                    <rect x="26" y="32" width="2" height="8" fill="#000" />
                    <rect x="28" y="38" width="2" height="4" fill="#000" />
                    <rect x="30" y="28" width="6" height="2" fill="#000" />
                    <rect x="36" y="26" width="2" height="4" fill="#000" />
                    <rect x="38" y="20" width="2" height="8" fill="#000" />
                    <rect x="40" y="18" width="2" height="4" fill="#000" />
                    <rect x="42" y="28" width="6" height="2" fill="#000" />
                    {/* Stand */}
                    <rect x="24" y="48" width="16" height="4" fill="#000" />
                    <rect x="20" y="52" width="24" height="4" fill="#000" />
                </PixelIcon>
            ),
            // Lock icon for Personal.exe
            Lock: (p) => (
                <PixelIcon {...p}>
                    {/* Shackle */}
                    <rect x="20" y="8" width="4" height="20" fill="#f00" />
                    <rect x="40" y="8" width="4" height="20" fill="#f00" />
                    <rect x="20" y="4" width="24" height="4" fill="#f00" />
                    {/* Lock body */}
                    <rect x="12" y="28" width="40" height="28" fill="#f00" />
                    <rect x="16" y="32" width="32" height="20" fill="#300" />
                    {/* Keyhole */}
                    <rect x="28" y="38" width="8" height="8" fill="#f00" />
                    <rect x="30" y="46" width="4" height="6" fill="#f00" />
                </PixelIcon>
            ),
            // Folder icon for app categories
            FolderClosed: (p) => (
                <PixelIcon {...p}>
                    <rect x="4" y="16" width="56" height="40" fill="#000" />
                    <rect x="8" y="20" width="48" height="32" fill="#fff" />
                    <rect x="4" y="12" width="24" height="8" fill="#000" />
                    <rect x="8" y="8" width="16" height="8" fill="#000" />
                </PixelIcon>
            ),
            // Games folder - folder with controller
            GamesFolder: (p) => (
                <PixelIcon {...p}>
                    {/* Folder base */}
                    <rect x="4" y="16" width="56" height="40" fill="#000" />
                    <rect x="8" y="20" width="48" height="32" fill="#fff" />
                    <rect x="4" y="12" width="24" height="8" fill="#000" />
                    {/* Controller icon inside */}
                    <rect x="18" y="30" width="28" height="14" fill="#000" />
                    <rect x="20" y="32" width="24" height="10" fill="#fff" />
                    <rect x="22" y="34" width="4" height="6" fill="#000" />
                    <rect x="24" y="36" width="6" height="2" fill="#000" />
                    <rect x="36" y="35" width="3" height="3" fill="#000" />
                    <rect x="40" y="35" width="3" height="3" fill="#000" />
                </PixelIcon>
            ),
            // Productivity folder - folder with gear
            ProductivityFolder: (p) => (
                <PixelIcon {...p}>
                    {/* Folder base */}
                    <rect x="4" y="16" width="56" height="40" fill="#000" />
                    <rect x="8" y="20" width="48" height="32" fill="#fff" />
                    <rect x="4" y="12" width="24" height="8" fill="#000" />
                    {/* Gear icon inside */}
                    <rect x="28" y="28" width="8" height="8" fill="#000" />
                    <rect x="30" y="26" width="4" height="12" fill="#000" />
                    <rect x="26" y="30" width="12" height="4" fill="#000" />
                    <rect x="27" y="27" width="2" height="2" fill="#000" />
                    <rect x="35" y="27" width="2" height="2" fill="#000" />
                    <rect x="27" y="35" width="2" height="2" fill="#000" />
                    <rect x="35" y="35" width="2" height="2" fill="#000" />
                    <rect x="30" y="30" width="4" height="4" fill="#fff" />
                </PixelIcon>
            ),
            // About folder - folder with person
            AboutFolder: (p) => (
                <PixelIcon {...p}>
                    {/* Folder base */}
                    <rect x="4" y="16" width="56" height="40" fill="#000" />
                    <rect x="8" y="20" width="48" height="32" fill="#fff" />
                    <rect x="4" y="12" width="24" height="8" fill="#000" />
                    {/* Person icon inside */}
                    <rect x="29" y="26" width="6" height="6" fill="#000" />
                    <rect x="26" y="34" width="12" height="10" fill="#000" />
                    <rect x="28" y="36" width="8" height="6" fill="#fff" />
                </PixelIcon>
            )
        };

        // --- DATA ---
        const MEDIA_DB = {
            "CINEMA_TV": [
                { title: "Blade Runner 2049" },
                { title: "Mr. Robot" },
                { title: "True Detective S1" },
                { title: "Succession" },
                { title: "The Bear" },
                { title: "Ex Machina" },
                { title: "Fight Club" },
                { title: "Arcane" },
                { title: "Interstellar" },
                { title: "Chernobyl" },
                { title: "Better Call Saul" },
                { title: "Atlanta" },
                { title: "Whiplash" },
                { title: "There Will Be Blood" },
                { title: "Sicario" },
                { title: "Black Mirror" }
            ],
            "LITERATURE": [
                { title: "Brothers Karamazov", rating: "10/10" },
                { title: "Looking for Alaska", rating: "10/10" },
                { title: "Atlas Shrugged", rating: "10/10" },
                { title: "Pale Blue Dot", rating: "10/10" },
                { title: "Lean Startup", rating: "9/10" },
                { title: "Fight Club", rating: "9/10" },
                { title: "Principles by Ray Dalio", rating: "9/10" },
                { title: "The Fountainhead", rating: "9/10" },
                { title: "Crime & Punishment", rating: "8/10" },
                { title: "1984", rating: "8/10" },
                { title: "Master & Margarita", rating: "8/10" },
                { title: "American Psycho", rating: "8/10" },
                { title: "Elon Musk Biography", rating: "8/10" },
                { title: "How to Get Filthy Rich in Rising Asia", rating: "8/10" },
                { title: "Fathers and Sons", rating: "8/10" },
                { title: "The Long Walk", rating: "8/10" },
                { title: "What's Our Problem?", rating: "7/10" },
                { title: "The Alchemist", rating: "7/10" },
                { title: "Kafka on the Shore", rating: "6/10" },
                { title: "Geometry for Ocelots", rating: "READING" }
            ],
            "GAMES": [
                { title: "Dark Souls III", rating: "10/10" },
                { title: "The Last of Us Pt II", rating: "10/10" },
                { title: "Outer Wilds", rating: "10/10" },
                { title: "God of War Ragnarok", rating: "10/10" },
                { title: "Blue Prince", rating: "10/10" },
                { title: "Cyberpunk 2077", rating: "9.5/10" },
                { title: "Night in the Woods", rating: "9.5/10" },
                { title: "Silent Hill 2", rating: "8/10" },
                { title: "Returnal", rating: "8/10" },
                { title: "Hollow Knight (Silksong)", rating: "8/10" },
                { title: "Deltarune", rating: "9/10" }
            ],
            "AUDIO": [
                { title: "Ison", artist: "Sevdaliza" },
                { title: "Mr. Morale...", artist: "Kendrick Lamar" },
                { title: "LP!", artist: "JPEGMAFIA" },
                { title: "Take Care", artist: "Drake" },
                { title: "The Life of Pablo", artist: "Kanye West" },
                { title: "Miss Anthropocene", artist: "Grimes" },
                { title: "The Eminem Show", artist: "Eminem" },
                { title: "4 Your Eyez Only", artist: "J. Cole" },
                { title: "Yeezus", artist: "Kanye West" },
                { title: "This story is dedicated...", artist: "Grimes" }
            ]
        };

        // --- APP COMPONENTS ---

        const PaintApp = () => {
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const [tool, setTool] = useState('brush');
            const [color, setColor] = useState('#000000');
            const [size, setSize] = useState(4);
            const [isDrawing, setIsDrawing] = useState(false);
            const [status, setStatus] = useState("READY");
            const [startPos, setStartPos] = useState({ x: 0, y: 0 });
            const [textInput, setTextInput] = useState('');
            const [showTextInput, setShowTextInput] = useState(false);
            const [textPos, setTextPos] = useState({ x: 0, y: 0 });
            const snapshotRef = useRef(null);
            const historyRef = useRef([]);
            const historyIndexRef = useRef(-1);

            // Get accurate mouse/touch position relative to canvas
            const getMousePos = (e) => {
                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                // Handle both mouse and touch events
                let clientX, clientY;
                if (e.touches && e.touches.length > 0) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else if (e.changedTouches && e.changedTouches.length > 0) {
                    clientX = e.changedTouches[0].clientX;
                    clientY = e.changedTouches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                return {
                    x: (clientX - rect.left) * scaleX,
                    y: (clientY - rect.top) * scaleY
                };
            };

            // Touch event handlers
            const handleTouchStart = (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    startDraw(e);
                }
            };
            const handleTouchMove = (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    draw(e);
                }
            };
            const handleTouchEnd = (e) => {
                e.preventDefault();
                endDraw();
            };

            const saveToHistory = () => {
                const canvas = canvasRef.current;
                const data = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
                historyRef.current = historyRef.current.slice(0, historyIndexRef.current + 1);
                historyRef.current.push(data);
                if (historyRef.current.length > 50) historyRef.current.shift();
                historyIndexRef.current = historyRef.current.length - 1;
            };

            const undo = () => {
                if (historyIndexRef.current > 0) {
                    historyIndexRef.current--;
                    canvasRef.current.getContext('2d').putImageData(historyRef.current[historyIndexRef.current], 0, 0);
                    setStatus("UNDO");
                }
            };

            const redo = () => {
                if (historyIndexRef.current < historyRef.current.length - 1) {
                    historyIndexRef.current++;
                    canvasRef.current.getContext('2d').putImageData(historyRef.current[historyIndexRef.current], 0, 0);
                    setStatus("REDO");
                }
            };

            useEffect(() => {
                const initCanvas = () => {
                    if (!containerRef.current) return;
                    const canvas = canvasRef.current;
                    const container = containerRef.current;
                    // Set fixed canvas size for proper pixel drawing
                    canvas.width = container.clientWidth - 4;
                    canvas.height = container.clientHeight - 4;
                    const ctx = canvas.getContext("2d");
                    ctx.fillStyle = "#ffffff";
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    saveToHistory();
                };
                initCanvas();
                window.addEventListener('resize', initCanvas);
                return () => window.removeEventListener('resize', initCanvas);
            }, []);

            const floodFill = (x, y, fillColor) => {
                const ctx = canvasRef.current.getContext('2d');
                const w = ctx.canvas.width;
                const h = ctx.canvas.height;
                const imgData = ctx.getImageData(0, 0, w, h);
                const data = imgData.data;
                const r = parseInt(fillColor.slice(1, 3), 16);
                const g = parseInt(fillColor.slice(3, 5), 16);
                const b = parseInt(fillColor.slice(5, 7), 16);
                const startIdx = (y * w + x) * 4;
                const sr = data[startIdx], sg = data[startIdx + 1], sb = data[startIdx + 2];
                if (sr === r && sg === g && sb === b) return;
                const stack = [[x, y]];
                while (stack.length) {
                    const [cx, cy] = stack.pop();
                    const idx = (cy * w + cx) * 4;
                    if (cx < 0 || cx >= w || cy < 0 || cy >= h) continue;
                    if (data[idx] === sr && data[idx + 1] === sg && data[idx + 2] === sb) {
                        data[idx] = r; data[idx + 1] = g; data[idx + 2] = b; data[idx + 3] = 255;
                        stack.push([cx + 1, cy], [cx - 1, cy], [cx, cy + 1], [cx, cy - 1]);
                    }
                }
                ctx.putImageData(imgData, 0, 0);
                saveToHistory();
            };

            const saveSnapshot = () => {
                const canvas = canvasRef.current;
                snapshotRef.current = canvas.getContext('2d').getImageData(0, 0, canvas.width, canvas.height);
            };

            const restoreSnapshot = () => {
                if (snapshotRef.current) {
                    canvasRef.current.getContext('2d').putImageData(snapshotRef.current, 0, 0);
                }
            };

            const startDraw = (e) => {
                const pos = getMousePos(e);
                if (tool === 'bucket') {
                    floodFill(Math.floor(pos.x), Math.floor(pos.y), color);
                    setStatus("FILLED");
                } else if (tool === 'text') {
                    setTextPos(pos);
                    setShowTextInput(true);
                    setStatus("TYPE TEXT");
                } else if (['rect', 'circle', 'line'].includes(tool)) {
                    setIsDrawing(true);
                    setStartPos(pos);
                    saveSnapshot();
                } else {
                    setIsDrawing(true);
                    setStartPos(pos);
                    const ctx = canvasRef.current.getContext('2d');
                    ctx.beginPath();
                    ctx.moveTo(pos.x, pos.y);
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.lineWidth = size;
                    ctx.strokeStyle = tool === 'eraser' ? '#ffffff' : color;
                }
            };

            const draw = (e) => {
                if (!isDrawing) return;
                const ctx = canvasRef.current.getContext('2d');
                const pos = getMousePos(e);

                if (tool === 'brush' || tool === 'eraser') {
                    ctx.lineTo(pos.x, pos.y);
                    ctx.stroke();
                } else if (['rect', 'circle', 'line'].includes(tool)) {
                    restoreSnapshot();
                    ctx.strokeStyle = color;
                    ctx.fillStyle = color;
                    ctx.lineWidth = size;

                    if (tool === 'rect') {
                        ctx.strokeRect(startPos.x, startPos.y, pos.x - startPos.x, pos.y - startPos.y);
                    } else if (tool === 'circle') {
                        const rx = Math.abs(pos.x - startPos.x) / 2;
                        const ry = Math.abs(pos.y - startPos.y) / 2;
                        const cx = startPos.x + (pos.x - startPos.x) / 2;
                        const cy = startPos.y + (pos.y - startPos.y) / 2;
                        ctx.beginPath();
                        ctx.ellipse(cx, cy, rx, ry, 0, 0, 2 * Math.PI);
                        ctx.stroke();
                    } else if (tool === 'line') {
                        ctx.beginPath();
                        ctx.moveTo(startPos.x, startPos.y);
                        ctx.lineTo(pos.x, pos.y);
                        ctx.stroke();
                    }
                }
            };

            const endDraw = () => {
                if (isDrawing) {
                    setIsDrawing(false);
                    if (tool === 'brush' || tool === 'eraser') {
                        canvasRef.current.getContext('2d').closePath();
                    }
                    saveToHistory();
                }
            };

            const placeText = () => {
                if (textInput.trim()) {
                    const ctx = canvasRef.current.getContext('2d');
                    ctx.fillStyle = color;
                    ctx.font = `${size * 4}px 'Geist Mono', monospace`;
                    ctx.fillText(textInput, textPos.x, textPos.y);
                    setStatus("TEXT PLACED");
                    saveToHistory();
                }
                setShowTextInput(false);
                setTextInput('');
            };

            const send = () => {
                setStatus("ENCRYPTING...");
                setTimeout(() => setStatus("UPLOADING..."), 500);
                setTimeout(() => setStatus("SENT TO MATEUS"), 1200);
            };

            const clear = () => {
                const ctx = canvasRef.current.getContext('2d');
                ctx.fillStyle = "#ffffff";
                ctx.fillRect(0, 0, canvasRef.current.width, canvasRef.current.height);
                setStatus("CLEARED");
                saveToHistory();
            };

            // Pixel knob component
            const PixelKnob = ({ value, onChange, min, max }) => {
                const knobSize = 24;
                const rotation = ((value - min) / (max - min)) * 270 - 135;
                return (
                    <div
                        className="relative cursor-pointer select-none"
                        style={{ width: knobSize, height: knobSize }}
                        onMouseDown={(e) => {
                            e.preventDefault();
                            const startY = e.clientY;
                            const startVal = value;
                            const onMove = (ev) => {
                                const diff = startY - ev.clientY;
                                const newVal = Math.min(max, Math.max(min, startVal + Math.floor(diff / 5)));
                                onChange(newVal);
                            };
                            const onUp = () => {
                                window.removeEventListener('mousemove', onMove);
                                window.removeEventListener('mouseup', onUp);
                            };
                            window.addEventListener('mousemove', onMove);
                            window.addEventListener('mouseup', onUp);
                        }}
                    >
                        <svg width={knobSize} height={knobSize} viewBox="0 0 24 24" style={{ imageRendering: 'pixelated' }}>
                            <rect x="4" y="4" width="16" height="16" fill="#000" />
                            <rect x="6" y="6" width="12" height="12" fill="#fff" />
                            <rect x="10" y="6" width="4" height="6" fill="#000" transform={`rotate(${rotation}, 12, 12)`} />
                        </svg>
                    </div>
                );
            };

            const tools = ['brush', 'eraser', 'bucket', 'line', 'rect', 'circle', 'text'];
            const colors = ['#000000', '#ffffff', '#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ff8800', '#8800ff'];

            return (
                <div className="h-full flex flex-col bg-gray-100 select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex flex-wrap gap-2 items-center">
                        <div className="flex gap-1">
                            <button onClick={undo} className="p-1 border border-black hover:bg-gray-100" title="Undo"><Icons.Undo size={16} /></button>
                            <button onClick={redo} className="p-1 border border-black hover:bg-gray-100" title="Redo"><Icons.Redo size={16} /></button>
                        </div>
                        <div className="w-px h-4 bg-black"></div>
                        <div className="flex gap-1 flex-wrap">
                            {tools.map(t => (
                                <button key={t} onClick={() => setTool(t)} className={`px-2 py-1 text-[10px] font-bold border border-black uppercase ${tool === t ? 'bg-black text-white' : 'bg-white hover:bg-gray-100'}`}>{t}</button>
                            ))}
                        </div>
                        <div className="w-px h-4 bg-black"></div>
                        <div className="flex gap-1 flex-wrap">
                            {colors.map(c => (
                                <button key={c} onClick={() => setColor(c)} className={`w-5 h-5 border border-black ${color === c ? 'ring-2 ring-offset-1 ring-black' : ''}`} style={{ backgroundColor: c }} />
                            ))}
                        </div>
                        <div className="w-px h-4 bg-black"></div>
                        <div className="flex items-center gap-1">
                            <PixelKnob value={size} onChange={setSize} min={1} max={20} />
                            <span className="text-[10px] font-mono w-4">{size}</span>
                        </div>
                        <div className="flex-grow"></div>
                        <button onClick={send} className="px-2 py-1 border border-black bg-black text-white text-xs font-bold hover:invert flex items-center gap-1"><Icons.Send size={12} /> SEND</button>
                    </div>
                    <div className="flex-grow relative cursor-crosshair bg-gray-300 p-[2px] overflow-hidden" ref={containerRef}>
                        <canvas
                            ref={canvasRef}
                            onMouseDown={startDraw}
                            onMouseMove={draw}
                            onMouseUp={endDraw}
                            onMouseLeave={endDraw}
                            onTouchStart={handleTouchStart}
                            onTouchMove={handleTouchMove}
                            onTouchEnd={handleTouchEnd}
                            className="block bg-white border border-gray-400 touch-none"
                            style={{ width: '100%', height: '100%' }}
                        />
                        {showTextInput && (
                            <div className="absolute top-2 left-2 bg-white border-2 border-black p-2 flex gap-2">
                                <input
                                    type="text"
                                    value={textInput}
                                    onChange={(e) => setTextInput(e.target.value)}
                                    onKeyDown={(e) => e.key === 'Enter' && placeText()}
                                    placeholder="Type text..."
                                    className="border border-black px-2 py-1 text-xs font-mono"
                                    autoFocus
                                />
                                <button onClick={placeText} className="bg-black text-white px-2 text-xs font-bold">OK</button>
                            </div>
                        )}
                        <div className="absolute bottom-1 left-1 bg-black text-white text-[10px] px-2 font-mono">{status}</div>
                    </div>
                </div>
            )
        }

        const FileExplorer = () => {
            const [selectedFolder, setSelectedFolder] = useState(null);

            const folders = [
                { key: 'CINEMA_TV', name: 'TV', icon: 'Movies' },
                { key: 'LITERATURE', name: 'BOOKS', icon: 'Books' },
                { key: 'GAMES', name: 'GAMES', icon: 'Games' },
                { key: 'AUDIO', name: 'MUSIC', icon: 'Music' }
            ];

            if (selectedFolder) {
                const FolderIcon = Icons[folders.find(f => f.key === selectedFolder)?.icon || 'Folder'];
                return (
                    <div className="h-full flex flex-col bg-white select-none">
                        <div className="p-2 border-b-2 border-black bg-white flex items-center gap-3">
                            <button onClick={() => setSelectedFolder(null)} className="p-1 border-2 border-black hover:bg-black hover:text-white">
                                <Icons.Back size={16} />
                            </button>
                            <FolderIcon size={24} />
                            <span className="font-mono text-xs font-bold uppercase">{folders.find(f => f.key === selectedFolder)?.name}</span>
                            <span className="font-mono text-[10px] text-gray-500">({MEDIA_DB[selectedFolder].length} ITEMS)</span>
                        </div>
                        <div className="flex-grow overflow-auto">
                            <table className="w-full text-left border-collapse">
                                <thead className="bg-black text-white text-xs font-mono sticky top-0">
                                    <tr><th className="p-2">TITLE</th><th className="p-2 border-l border-gray-600">NOTE</th></tr>
                                </thead>
                                <tbody className="font-mono text-xs">
                                    {MEDIA_DB[selectedFolder].map((i, idx) => (
                                        <tr key={idx} className="border-b border-gray-200 hover:bg-yellow-100">
                                            <td className="p-2 font-bold">{i.title}</td>
                                            <td className="p-2 border-l border-gray-200">{i.rating || i.artist}</td>
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                        <div className="p-2 border-t-2 border-black bg-white text-center">
                            <span className="font-mono text-[10px] text-gray-500">CLICK TO VIEW  HOVER TO PREVIEW</span>
                        </div>
                    </div>
                );
            }

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex items-center gap-2">
                        <Icons.Folder size={24} />
                        <span className="font-mono text-xs font-bold">MEDIA_LIB</span>
                        <span className="font-mono text-[10px] text-gray-500">/ROOT/MEDIA</span>
                    </div>
                    <div className="flex-grow p-6 flex items-start justify-center bg-gray-50">
                        <div className="grid grid-cols-4 gap-8">
                            {folders.map(folder => {
                                const FolderIcon = Icons[folder.icon];
                                return (
                                    <button
                                        key={folder.key}
                                        onClick={() => setSelectedFolder(folder.key)}
                                        className="group flex flex-col items-center gap-2 p-4 hover:bg-white border-2 border-transparent hover:border-black transition-all"
                                    >
                                        <div className="bg-white border-2 border-black p-3 icon-shadow group-hover:translate-x-1 group-hover:translate-y-1 group-hover:shadow-none transition-all">
                                            <FolderIcon size={48} />
                                        </div>
                                        <span className="font-mono text-xs font-bold uppercase">{folder.name}</span>
                                        <span className="font-mono text-[10px] text-gray-500">{MEDIA_DB[folder.key].length} ITEMS</span>
                                    </button>
                                );
                            })}
                        </div>
                    </div>
                    <div className="p-2 border-t-2 border-black bg-white text-center">
                        <span className="font-mono text-[10px] text-gray-500">MOVIES  BOOKS  GAMES  MUSIC</span>
                    </div>
                </div>
            );
        }

        const SystemInfo = () => (
            <div className="p-6 md:p-12 font-sans select-text">
                <header className="mb-12 border-b-4 border-black pb-8">
                    <h1 className="text-6xl md:text-8xl font-black uppercase tracking-tighter leading-none">Mateus<br />Muste</h1>
                    <div className="mt-4 flex flex-wrap gap-4 font-mono text-sm">
                        <span className="bg-black text-white px-2 py-1">DIGITAL DESIGNER</span>
                        <span className="bg-black text-white px-2 py-1">RADICAL OPTIMIST</span>
                        <span className="border border-black px-2 py-1">ROMANIA</span>
                    </div>
                </header>
                <div className="grid md:grid-cols-2 gap-12">
                    <div className="space-y-8">
                        <section>
                            <h3 className="text-2xl font-black uppercase mb-4 border-b-2 border-black">App Stack</h3>
                            <div className="grid grid-cols-4 gap-1">
                                {[
                                    { name: 'PS', full: 'Photoshop', yrs: 9 },
                                    { name: 'PR', full: 'Premiere', yrs: 8 },
                                    { name: 'AE', full: 'After Effects', yrs: 6 },
                                    { name: 'XL', full: 'Excel', yrs: 5 },
                                    { name: 'MA', full: 'Meta Ads', yrs: 5 },
                                    { name: 'DV', full: 'DaVinci', yrs: 4 },
                                    { name: 'AC', full: 'ArchiCAD', yrs: 3 },
                                    { name: 'SQ', full: 'Squarespace', yrs: 3 },
                                    { name: 'UE', full: 'Unreal', yrs: 3 },
                                    { name: 'WF', full: 'Webflow', yrs: 3 },
                                    { name: 'MJ', full: 'Midjourney', yrs: 2 },
                                    { name: 'GA', full: 'Google Ads', yrs: 2 },
                                    { name: 'BL', full: 'Blender', yrs: 1 },
                                    { name: 'CR', full: 'Cursor', yrs: 1 },
                                    { name: 'CF', full: 'ComfyUI', yrs: 1 },
                                    { name: 'N8', full: 'n8n', yrs: 1 }
                                ].map((app, i) => (
                                    <div key={i} className="group relative border-2 border-black aspect-square flex flex-col items-center justify-center hover:bg-black hover:text-white transition-all cursor-default">
                                        <span className="font-black text-lg">{app.name}</span>
                                        <span className="font-mono text-[10px]">{app.yrs}Y</span>
                                        <div className="absolute inset-0 bg-black text-white opacity-0 group-hover:opacity-100 flex flex-col items-center justify-center transition-opacity">
                                            <span className="font-mono text-[9px] text-center px-1">{app.full}</span>
                                            <span className="font-black">{app.yrs} YRS</span>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        </section>
                        <section><h3 className="text-2xl font-black uppercase mb-4 border-b-2 border-black">Metrics</h3>
                            <div className="flex gap-4">
                                <div className="p-4 border-2 border-black text-center"><div className="text-3xl font-black">C2</div><div className="font-mono text-[10px]">CAMBRIDGE</div></div>
                                <div className="p-4 border-2 border-black text-center"><div className="text-3xl font-black">1570</div><div className="font-mono text-[10px]">SAT</div></div>
                            </div>
                        </section>
                    </div>
                    <div className="space-y-4">
                        <h3 className="text-2xl font-black uppercase mb-4 border-b-2 border-black">Projects</h3>
                        {[
                            { t: "BIOBUILDS", num: "01", s: "Web / Video / Marketing", d: "Sustainable construction across Europe. Entered 3 markets." },
                            { t: "ROMANIA OLYMPICS 2024", num: "02", s: "Premiere / After Effects", d: "National contest winner. Cluj-Napoca." },
                            { t: "ULT", num: "03", s: "Documentary / Editing", d: "Self-directed channel. Skill laboratory." }
                        ].map((p, i) => (
                            <div key={i} className="group border-2 border-black p-4 hover:bg-black hover:text-white cursor-pointer">
                                <div className="flex justify-between mb-1"><h4 className="font-bold uppercase">{p.t}</h4><span className="font-mono text-xs">{p.num}</span></div>
                                <p className="font-mono text-xs opacity-70 mb-1">{p.s}</p><p className="text-sm italic">{p.d}</p>
                            </div>
                        ))}
                    </div>
                </div>
            </div>
        )

        const TrashApp = () => {
            const [shakingFile, setShakingFile] = useState(null);

            const trashFiles = [
                { name: 'MY_BITCOIN_WALLET.txt', icon: 'FileDoc' },
                { name: 'sleep_schedule.ics', icon: 'FileDoc' },
                { name: 'NYU_acceptance_letter.pdf', icon: 'FileDoc' }
            ];

            const handleFileClick = (fileName) => {
                setShakingFile(fileName);
                setTimeout(() => setShakingFile(null), 500);
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-3 border-b-2 border-black bg-gray-50 flex items-center gap-2">
                        <Icons.TrashCan size={24} />
                        <span className="font-mono text-sm font-bold uppercase">RECYCLE BIN</span>
                        <span className="font-mono text-xs text-gray-400">({trashFiles.length} items)</span>
                    </div>
                    <div className="flex-grow p-6">
                        <div className="grid grid-cols-3 gap-6">
                            {trashFiles.map(file => (
                                <button
                                    key={file.name}
                                    onClick={() => handleFileClick(file.name)}
                                    className="group flex flex-col items-center gap-2 p-4 cursor-not-allowed"
                                    style={{
                                        animation: shakingFile === file.name ? 'shake 0.5s ease-in-out' : 'none'
                                    }}
                                >
                                    <div className="bg-white border-2 border-black p-3 icon-shadow opacity-50">
                                        <Icons.FileDoc size={32} />
                                    </div>
                                    <span className="font-mono text-[10px] font-bold text-center break-all opacity-70">{file.name}</span>
                                </button>
                            ))}
                        </div>
                        <div className="mt-8 p-4 border-2 border-dashed border-gray-300 text-center">
                            <span className="font-mono text-xs text-gray-400">ITEMS CANNOT BE RECOVERED</span>
                        </div>
                    </div>
                    <style>{`
                        @keyframes shake {
                            0%, 100% { transform: translateX(0); }
                            10%, 30%, 50%, 70%, 90% { transform: translateX(-4px); }
                            20%, 40%, 60%, 80% { transform: translateX(4px); }
                        }
                    `}</style>
                </div>
            );
        }

        // --- VOID.TXT - Text encrypts then fades into the void ---
        const VoidApp = () => {
            // Each char: { id, char, timestamp, phase: 'visible'|'encrypting'|'fading', opacity }
            const [chars, setChars] = useState([]);
            const inputRef = useRef(null);
            const charIdRef = useRef(0);

            const encryptChar = () => {
                const symbols = '@#$%&*';
                return symbols[Math.floor(Math.random() * symbols.length)];
            };

            // Process loop - runs every 50ms to update char states
            useEffect(() => {
                const interval = setInterval(() => {
                    const now = Date.now();
                    setChars(prev => {
                        let updated = false;
                        const newChars = prev.map(c => {
                            // After 1.5s, start encrypting
                            if (c.phase === 'visible' && now - c.timestamp >= 1500) {
                                updated = true;
                                return { ...c, phase: 'encrypting', displayChar: encryptChar() };
                            }
                            // After encrypting for 300ms, start fading
                            if (c.phase === 'encrypting' && now - c.timestamp >= 1800) {
                                updated = true;
                                return { ...c, phase: 'fading', opacity: 0.8 };
                            }
                            // Fade out
                            if (c.phase === 'fading') {
                                const newOpacity = c.opacity - 0.15;
                                if (newOpacity <= 0) {
                                    updated = true;
                                    return null; // Mark for removal
                                }
                                updated = true;
                                return { ...c, opacity: newOpacity, displayChar: encryptChar() };
                            }
                            return c;
                        }).filter(Boolean);
                        return updated ? newChars : prev;
                    });
                }, 50);
                return () => clearInterval(interval);
            }, []);

            const handleKeyDown = (e) => {
                if (e.key === 'Backspace') {
                    // Remove most recent visible char
                    setChars(prev => {
                        const visibleChars = prev.filter(c => c.phase === 'visible');
                        if (visibleChars.length === 0) return prev;
                        const lastVisible = visibleChars[visibleChars.length - 1];
                        return prev.filter(c => c.id !== lastVisible.id);
                    });
                    e.preventDefault();
                } else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
                    // Add new character
                    const newChar = {
                        id: charIdRef.current++,
                        char: e.key,
                        displayChar: e.key,
                        timestamp: Date.now(),
                        phase: 'visible',
                        opacity: 1
                    };
                    setChars(prev => [...prev, newChar]);
                    e.preventDefault();
                }
            };

            // Render chars grouped - visible chars are white, encrypting are green
            const renderChars = () => {
                return chars.map(c => (
                    <span
                        key={c.id}
                        style={{
                            color: c.phase === 'encrypting' ? '#0f0' :
                                c.phase === 'fading' ? `rgba(0,255,0,${c.opacity})` : 'white',
                            textShadow: c.phase !== 'visible' ? '0 0 5px #0f0' : 'none'
                        }}
                    >
                        {c.displayChar}
                    </span>
                ));
            };

            return (
                <div
                    className="h-full flex flex-col bg-black select-none cursor-text"
                    onClick={() => inputRef.current?.focus()}
                    onCopy={(e) => e.preventDefault()}
                    onCut={(e) => e.preventDefault()}
                >
                    <div className="p-2 border-b border-gray-800 bg-black flex justify-between items-center">
                        <span className="font-mono text-xs font-bold text-white">VOID.TXT</span>
                        <span className="font-mono text-[10px] text-gray-600">NO SAVE // NO COPY // JUST VOID</span>
                    </div>
                    <div className="flex-grow p-4 overflow-auto font-mono text-sm">
                        <div className="flex flex-wrap items-start">
                            <span className="mr-2 text-gray-600">{'>'}</span>
                            <div className="flex-grow">
                                {renderChars()}
                                <span className="animate-pulse text-white">_</span>
                            </div>
                        </div>
                        <input
                            ref={inputRef}
                            type="text"
                            className="absolute opacity-0 pointer-events-none"
                            onKeyDown={handleKeyDown}
                            onPaste={(e) => e.preventDefault()}
                            autoFocus
                        />
                    </div>
                    <div className="p-2 border-t border-gray-800 bg-black text-center">
                        <span className="font-mono text-[10px] text-gray-600">TYPE INTO THE VOID. WATCH IT DISAPPEAR BEHIND YOU.</span>
                    </div>
                </div>
            );
        };

        // --- ORACLE.EXE - Philosophical quotes ---
        const OracleApp = () => {
            const quotes = [
                "The soul is healed by being with children.",
                "Man is condemned to be free.",
                "He who has a why to live can bear almost any how.",
                "The question isn't who is going to let me; it's who is going to stop me.",
                "One must imagine Sisyphus happy.",
                "Pain and suffering are always inevitable for a large intelligence and a deep heart.",
                "God is dead. God remains dead. And we have killed him.",
                "I swear by my life and my love of it that I will never live for the sake of another man.",
                "In the depth of winter, I finally learned that within me there lay an invincible summer.",
                "The higher we soar the smaller we appear to those who cannot fly.",
                "The soul that sees beauty may sometimes walk alone.",
                "Should I kill myself, or have a cup of coffee?",
                "To live is to suffer, to survive is to find some meaning in the suffering.",
                "The only thing I know is that I know nothing.",
                "Beauty will save the world.",
                "There is always some madness in love. But there is also always some reason in madness.",
                "Man is the only creature who refuses to be what he is.",
                "A is A. A thing is itself.",
                "What does not kill me makes me stronger.",
                "The absurd is born of the confrontation between the human call and the unreasonable silence of the world.",
                "The best way to find yourself is to lose yourself in the service of others.",
                "Every deep thinker is more afraid of being understood than of being misunderstood.",
                "Money is only a tool. It will take you wherever you wish, but it will not replace you as the driver.",
                "We are all in the gutter, but some of us are looking at the stars.",
                "The only way to deal with an unfree world is to become so absolutely free that your very existence is an act of rebellion.",
                "Above all, don't lie to yourself.",
                "Whoever fights monsters should see to it that in the process he does not become a monster.",
                "I rebel; therefore I exist.",
                "The secret of happiness is freedom, the secret of freedom is courage.",
                "There is but one truly serious philosophical problem, and that is suicide."
            ];

            const [question, setQuestion] = useState('');
            const [answer, setAnswer] = useState(null);
            const [isThinking, setIsThinking] = useState(false);

            const askOracle = () => {
                if (!question.trim()) return;
                setIsThinking(true);
                setAnswer(null);

                setTimeout(() => {
                    const randomQuote = quotes[Math.floor(Math.random() * quotes.length)];
                    setAnswer(randomQuote);
                    setIsThinking(false);
                    setQuestion('');
                }, 1500 + Math.random() * 1000);
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex justify-between items-center">
                        <span className="font-mono text-xs font-bold">ORACLE.EXE</span>
                        <span className="font-mono text-[10px] text-gray-500">ASK THE DEAD</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-8 bg-gray-50">
                        {answer && (
                            <div className="mb-8 text-center max-w-lg">
                                <div className="text-xl font-serif italic leading-relaxed mb-4 text-black">"{answer}"</div>
                                <div className="text-xs text-gray-500 font-mono"> THE ORACLE HAS SPOKEN</div>
                            </div>
                        )}
                        {isThinking && (
                            <div className="mb-8 text-center">
                                <div className="font-mono text-sm text-gray-500 animate-pulse">
                                    CONSULTING THE VOID...
                                </div>
                            </div>
                        )}
                        <div className="w-full max-w-md">
                            <input
                                type="text"
                                value={question}
                                onChange={(e) => setQuestion(e.target.value)}
                                onKeyDown={(e) => e.key === 'Enter' && askOracle()}
                                placeholder="ASK YOUR QUESTION..."
                                className="w-full bg-white border-2 border-black px-4 py-3 font-mono text-sm text-black placeholder-gray-400 focus:ring-2 focus:ring-black outline-none"
                                disabled={isThinking}
                            />
                            <button
                                onClick={askOracle}
                                disabled={isThinking}
                                className="w-full mt-2 bg-black text-white py-3 font-mono font-bold text-sm hover:invert border-2 border-black disabled:opacity-50"
                            >
                                SEEK TRUTH
                            </button>
                        </div>
                    </div>
                    <div className="p-2 border-t-2 border-black bg-white text-center">
                        <span className="font-mono text-[10px] text-gray-500">DOSTOEVSKY  NIETZSCHE  RAND  CAMUS</span>
                    </div>
                </div>
            );
        };

        // --- RADIO.WAV - Playlist link ---
        const RadioApp = () => {
            const [isPlaying, setIsPlaying] = useState(false);
            const [visualizer, setVisualizer] = useState([]);

            useEffect(() => {
                const interval = setInterval(() => {
                    if (isPlaying) {
                        setVisualizer(Array(16).fill(0).map(() => Math.random() * 100));
                    }
                }, 100);
                return () => clearInterval(interval);
            }, [isPlaying]);

            const openPlaylist = () => {
                window.open('https://music.youtube.com/playlist?list=PLeIQRsOWZUhKaD53FTvwZCxsNWzjq0lfO&si=92O5A6kAPjk8Vzmg', '_blank');
                setIsPlaying(true);
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex justify-between items-center">
                        <span className="font-mono text-xs font-bold">RADIO.WAV</span>
                        <span className="font-mono text-[10px] text-gray-500">MATEUS_PLAYLIST</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-8 bg-gray-50">
                        <div className="flex items-end justify-center gap-1 h-32 mb-8 p-4 border-2 border-black bg-white">
                            {(isPlaying ? visualizer : Array(16).fill(10)).map((h, i) => (
                                <div
                                    key={i}
                                    className="w-3 bg-black transition-all duration-100"
                                    style={{ height: `${h}%`, minHeight: '4px' }}
                                />
                            ))}
                        </div>
                        <button
                            onClick={openPlaylist}
                            className="bg-black text-white px-8 py-4 font-mono font-bold text-lg hover:invert border-2 border-black transition-all"
                        >
                            {isPlaying ? ' NOW PLAYING' : ' TUNE IN'}
                        </button>
                        <div className="mt-4 font-mono text-xs text-gray-500">
                            OPENS YOUTUBE MUSIC
                        </div>
                    </div>
                    <div className="p-2 border-t-2 border-black bg-white">
                        <div className="font-mono text-[10px] text-gray-500 text-center">
                            BROADCASTING FROM THE VOID
                        </div>
                    </div>
                </div>
            );
        };

        // --- DICE.EXE - D20 Roller with Three.js ---
        const DiceApp = () => {
            const [result, setResult] = useState(null);
            const [isRolling, setIsRolling] = useState(false);
            const containerRef = useRef(null);
            const sceneRef = useRef(null);
            const diceRef = useRef(null);
            const animationRef = useRef(null);

            const getResultStyle = () => {
                if (!result) return '';
                if (result === 20) return 'bg-black text-white';
                if (result === 1) return 'border-2 border-black';
                return '';
            };

            // Initialize Three.js scene
            useEffect(() => {
                if (!containerRef.current || sceneRef.current) return;

                const width = 200;
                const height = 200;

                // Scene
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xffffff);

                // Camera
                const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
                camera.position.z = 4;

                // Renderer
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                renderer.setPixelRatio(window.devicePixelRatio);
                containerRef.current.appendChild(renderer.domElement);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(2, 2, 2);
                scene.add(directionalLight);

                const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
                backLight.position.set(-2, -2, -2);
                scene.add(backLight);

                // D20 (Icosahedron)
                const geometry = new THREE.IcosahedronGeometry(1.2, 0);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x111111,
                    metalness: 0.1,
                    roughness: 0.4,
                    flatShading: true
                });
                const dice = new THREE.Mesh(geometry, material);
                scene.add(dice);

                // Edge lines
                const edges = new THREE.EdgesGeometry(geometry);
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0x444444 });
                const wireframe = new THREE.LineSegments(edges, lineMaterial);
                dice.add(wireframe);

                diceRef.current = dice;
                sceneRef.current = { scene, camera, renderer };

                // Initial render
                renderer.render(scene, camera);

                // Idle animation
                const idleAnimate = () => {
                    if (!isRolling) {
                        dice.rotation.x += 0.003;
                        dice.rotation.y += 0.005;
                    }
                    renderer.render(scene, camera);
                    animationRef.current = requestAnimationFrame(idleAnimate);
                };
                idleAnimate();

                return () => {
                    cancelAnimationFrame(animationRef.current);
                    renderer.dispose();
                    if (containerRef.current && renderer.domElement) {
                        containerRef.current.removeChild(renderer.domElement);
                    }
                };
            }, []);

            const rollDice = () => {
                if (isRolling || !diceRef.current || !sceneRef.current) return;
                setIsRolling(true);
                setResult(null);

                const dice = diceRef.current;
                const { renderer, scene, camera } = sceneRef.current;

                // Random target rotation
                const targetRotX = dice.rotation.x + Math.PI * (4 + Math.random() * 4);
                const targetRotY = dice.rotation.y + Math.PI * (4 + Math.random() * 4);
                const targetRotZ = dice.rotation.z + Math.PI * (2 + Math.random() * 2);

                const startRotX = dice.rotation.x;
                const startRotY = dice.rotation.y;
                const startRotZ = dice.rotation.z;

                const duration = 1500;
                const startTime = Date.now();

                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    // Easing - decelerate
                    const eased = 1 - Math.pow(1 - progress, 3);

                    dice.rotation.x = startRotX + (targetRotX - startRotX) * eased;
                    dice.rotation.y = startRotY + (targetRotY - startRotY) * eased;
                    dice.rotation.z = startRotZ + (targetRotZ - startRotZ) * eased;

                    renderer.render(scene, camera);

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        setResult(Math.floor(Math.random() * 20) + 1);
                        setIsRolling(false);
                    }
                };

                animate();
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-2 border-b border-gray-200 bg-white flex justify-between items-center">
                        <span className="font-mono text-[10px] font-bold tracking-wider">DICE.EXE</span>
                        <span className="font-mono text-[10px] text-gray-400">D20</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-8 bg-white">
                        <div className="mb-8" ref={containerRef} style={{ width: 200, height: 200 }} />
                        {result && !isRolling && (
                            <div className={`font-mono text-[10px] tracking-widest mb-6 px-4 py-2 ${getResultStyle()}`}>
                                {result === 20 ? 'CRITICAL' : result === 1 ? 'FAIL' : `RESULT: ${result}`}
                            </div>
                        )}
                        <button
                            onClick={rollDice}
                            disabled={isRolling}
                            className="bg-black text-white px-6 py-2 font-mono text-[10px] tracking-widest hover:bg-gray-800 disabled:bg-gray-300 transition-colors"
                        >
                            {isRolling ? 'ROLLING' : 'ROLL'}
                        </button>
                    </div>
                    <div className="p-2 border-t border-gray-200 bg-white">
                        <div className="flex justify-between font-mono text-[10px] text-gray-400">
                            <span>20 = CRIT</span>
                            <span>1 = FAIL</span>
                        </div>
                    </div>
                </div>
            );
        };

        // --- SNEK.EXE ---
        const SnakeAppNew = () => {
            const canvasRef = useRef(null);
            const [score, setScore] = useState(0);
            const [highScore, setHighScore] = useState(() => HighScoreManager.getHighScore('snake'));
            const [gameOver, setGameOver] = useState(false);
            const [gameStarted, setGameStarted] = useState(false);
            const snake = useRef([{ x: 15, y: 10 }]);
            const food = useRef({ x: 20, y: 10 });
            const dir = useRef({ x: 1, y: 0 });
            const nextDir = useRef({ x: 1, y: 0 });
            const runningRef = useRef(false);
            const lastTimeRef = useRef(0);
            const frameRef = useRef(null);

            const GRID_W = 30;
            const GRID_H = 20;
            const CELL = 20;

            // Load high score from storage when IP is ready
            useEffect(() => {
                const loadHighScore = async () => {
                    await HighScoreManager.fetchIP();
                    setHighScore(HighScoreManager.getHighScore('snake'));
                };
                loadHighScore();
            }, []);

            const start = () => {
                snake.current = [{ x: 15, y: 10 }, { x: 14, y: 10 }, { x: 13, y: 10 }];
                dir.current = { x: 1, y: 0 };
                nextDir.current = { x: 1, y: 0 };
                food.current = { x: Math.floor(Math.random() * GRID_W), y: Math.floor(Math.random() * GRID_H) };
                setScore(0);
                setGameOver(false);
                setGameStarted(true);
                runningRef.current = true;
                lastTimeRef.current = 0;
            };

            const update = () => {
                const ctx = canvasRef.current?.getContext('2d');
                if (!ctx) return;

                dir.current = nextDir.current;
                const head = {
                    x: snake.current[0].x + dir.current.x,
                    y: snake.current[0].y + dir.current.y
                };

                // Wall collision
                if (head.x < 0 || head.x >= GRID_W || head.y < 0 || head.y >= GRID_H) {
                    endGame();
                    return;
                }

                // Self collision
                if (snake.current.some(s => s.x === head.x && s.y === head.y)) {
                    endGame();
                    return;
                }

                snake.current.unshift(head);

                // Eat food
                if (head.x === food.current.x && head.y === food.current.y) {
                    setScore(s => {
                        const newScore = s + 10;
                        setHighScore(h => {
                            const newHigh = Math.max(h, newScore);
                            HighScoreManager.saveHighScore('snake', newHigh);
                            return newHigh;
                        });
                        return newScore;
                    });
                    food.current = {
                        x: Math.floor(Math.random() * GRID_W),
                        y: Math.floor(Math.random() * GRID_H)
                    };
                } else {
                    snake.current.pop();
                }

                // Draw - light theme
                ctx.fillStyle = '#f5f5f5';
                ctx.fillRect(0, 0, GRID_W * CELL, GRID_H * CELL);

                // Grid lines (subtle)
                ctx.strokeStyle = '#e0e0e0';
                for (let i = 0; i <= GRID_W; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i * CELL, 0);
                    ctx.lineTo(i * CELL, GRID_H * CELL);
                    ctx.stroke();
                }
                for (let i = 0; i <= GRID_H; i++) {
                    ctx.beginPath();
                    ctx.moveTo(0, i * CELL);
                    ctx.lineTo(GRID_W * CELL, i * CELL);
                    ctx.stroke();
                }

                // Snake - black
                snake.current.forEach((s, i) => {
                    ctx.fillStyle = i === 0 ? '#000' : '#333';
                    ctx.fillRect(s.x * CELL + 1, s.y * CELL + 1, CELL - 2, CELL - 2);
                });

                // Food - black dot
                ctx.fillStyle = '#000';
                ctx.fillRect(food.current.x * CELL + 6, food.current.y * CELL + 6, CELL - 12, CELL - 12);
            };

            const endGame = () => {
                runningRef.current = false;
                setGameOver(true);
                setGameStarted(false);
            };

            // Game loop using requestAnimationFrame
            useEffect(() => {
                const gameLoop = (timestamp) => {
                    if (!runningRef.current) {
                        frameRef.current = requestAnimationFrame(gameLoop);
                        return;
                    }

                    if (timestamp - lastTimeRef.current >= 100) {
                        lastTimeRef.current = timestamp;
                        update();
                    }

                    frameRef.current = requestAnimationFrame(gameLoop);
                };

                frameRef.current = requestAnimationFrame(gameLoop);

                return () => {
                    if (frameRef.current) cancelAnimationFrame(frameRef.current);
                };
            }, []);

            useEffect(() => {
                const handle = (e) => {
                    if (!runningRef.current) return;
                    if (e.key === 'ArrowUp' && dir.current.y === 0) nextDir.current = { x: 0, y: -1 };
                    if (e.key === 'ArrowDown' && dir.current.y === 0) nextDir.current = { x: 0, y: 1 };
                    if (e.key === 'ArrowLeft' && dir.current.x === 0) nextDir.current = { x: -1, y: 0 };
                    if (e.key === 'ArrowRight' && dir.current.x === 0) nextDir.current = { x: 1, y: 0 };
                };
                window.addEventListener('keydown', handle);
                return () => window.removeEventListener('keydown', handle);
            }, []);

            // Initial canvas draw - light theme
            useEffect(() => {
                const ctx = canvasRef.current?.getContext('2d');
                if (ctx) {
                    ctx.fillStyle = '#f5f5f5';
                    ctx.fillRect(0, 0, GRID_W * CELL, GRID_H * CELL);

                    // Draw grid lines
                    ctx.strokeStyle = '#e0e0e0';
                    for (let i = 0; i <= GRID_W; i++) {
                        ctx.beginPath();
                        ctx.moveTo(i * CELL, 0);
                        ctx.lineTo(i * CELL, GRID_H * CELL);
                        ctx.stroke();
                    }
                    for (let i = 0; i <= GRID_H; i++) {
                        ctx.beginPath();
                        ctx.moveTo(0, i * CELL);
                        ctx.lineTo(GRID_W * CELL, i * CELL);
                        ctx.stroke();
                    }
                }
            }, []);

            // Touch controls for mobile
            const handleDirection = (newDir) => {
                if (!runningRef.current) return;
                if (newDir === 'up' && dir.current.y === 0) nextDir.current = { x: 0, y: -1 };
                if (newDir === 'down' && dir.current.y === 0) nextDir.current = { x: 0, y: 1 };
                if (newDir === 'left' && dir.current.x === 0) nextDir.current = { x: -1, y: 0 };
                if (newDir === 'right' && dir.current.x === 0) nextDir.current = { x: 1, y: 0 };
            };

            // Swipe detection
            const touchStartRef = useRef({ x: 0, y: 0 });
            const handleTouchStart = (e) => {
                touchStartRef.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            };
            const handleTouchEnd = (e) => {
                if (!runningRef.current) return;
                const dx = e.changedTouches[0].clientX - touchStartRef.current.x;
                const dy = e.changedTouches[0].clientY - touchStartRef.current.y;
                if (Math.abs(dx) > Math.abs(dy)) {
                    if (dx > 30) handleDirection('right');
                    else if (dx < -30) handleDirection('left');
                } else {
                    if (dy > 30) handleDirection('down');
                    else if (dy < -30) handleDirection('up');
                }
            };

            return (
                <div className="h-full flex flex-col bg-white select-none" onTouchStart={handleTouchStart} onTouchEnd={handleTouchEnd}>
                    <div className="p-2 border-b-2 border-black bg-white flex justify-between items-center">
                        <span className="font-mono text-xs font-bold">SNEK.EXE</span>
                        <div className="flex gap-4 font-mono text-xs">
                            <span>SCORE: <span className="font-bold">{score}</span></span>
                            <span>HIGH: <span className="font-bold">{highScore}</span></span>
                            <span className={gameOver ? 'text-red-600' : gameStarted ? 'text-green-600' : 'text-gray-500'}>
                                {gameOver ? 'DEAD' : gameStarted ? 'ALIVE' : 'READY'}
                            </span>
                        </div>
                    </div>
                    <div className="flex-grow flex items-center justify-center p-2 md:p-4 bg-gray-50 overflow-hidden">
                        <div className="relative border-2 border-black" style={{ width: 'min(100%, 600px)', aspectRatio: '3/2' }}>
                            <canvas ref={canvasRef} width={600} height={400} className="block w-full h-full" style={{ imageRendering: 'pixelated' }} />
                            {!gameStarted && (
                                <div className="absolute inset-0 bg-white/95 flex flex-col items-center justify-center">
                                    <div className="text-4xl font-black mb-2 tracking-widest">SNEK</div>
                                    {gameOver && <p className="text-red-600 mb-4 font-mono text-sm">GAME OVER</p>}
                                    <button
                                        onClick={start}
                                        className="bg-black text-white px-6 py-3 font-mono font-bold text-sm hover:invert border-2 border-black"
                                    >
                                        {gameOver ? 'RETRY' : 'START'}
                                    </button>
                                    <p className="mt-4 text-gray-500 font-mono text-xs text-center px-4 hidden md:block">ARROW KEYS TO MOVE</p>
                                    <p className="mt-4 text-gray-500 font-mono text-xs text-center px-4 md:hidden">SWIPE TO MOVE</p>
                                </div>
                            )}
                        </div>
                    </div>
                    <div className="p-2 border-t-2 border-black bg-white text-center">
                        <span className="font-mono text-[10px] text-gray-500">EAT FOOD  GROW LONGER  DON'T DIE</span>
                    </div>
                </div>
            );
        };

        // --- LABYRINTH.EXE - Procedural Maze ---
        const LabyrinthApp = () => {
            const canvasRef = useRef(null);
            const [level, setLevel] = useState(1);
            const [score, setScore] = useState(0);
            const [highScore, setHighScore] = useState(() => HighScoreManager.getHighScore('labyrinth'));
            const [won, setWon] = useState(false);
            const [showingMaze, setShowingMaze] = useState(false);
            const mazeRef = useRef(null);
            const playerRef = useRef({ x: 1, y: 1 });
            const exitRef = useRef({ x: 0, y: 0 });

            const CELL_SIZE = 8; // Thinner walls

            // Load high score from storage when IP is ready
            useEffect(() => {
                const loadHighScore = async () => {
                    await HighScoreManager.fetchIP();
                    setHighScore(HighScoreManager.getHighScore('labyrinth'));
                };
                loadHighScore();
            }, []);

            const generateMaze = (width, height) => {
                const maze = Array(height).fill(null).map(() => Array(width).fill(1));

                const carve = (x, y) => {
                    maze[y][x] = 0;
                    const directions = [[0, -2], [0, 2], [-2, 0], [2, 0]].sort(() => Math.random() - 0.5);

                    for (const [dx, dy] of directions) {
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx > 0 && nx < width - 1 && ny > 0 && ny < height - 1 && maze[ny][nx] === 1) {
                            maze[y + dy / 2][x + dx / 2] = 0;
                            carve(nx, ny);
                        }
                    }
                };

                carve(1, 1);
                return maze;
            };

            const startLevel = (lvl) => {
                // Start big and get MUCH harder - exponential growth
                const size = 31 + Math.floor(lvl * lvl * 4);
                const cappedSize = Math.min(size, 151); // Cap at 151 for performance
                const maze = generateMaze(cappedSize | 1, cappedSize | 1);
                mazeRef.current = maze;
                playerRef.current = { x: 1, y: 1 };

                // Find exit (bottom-right area)
                for (let y = maze.length - 2; y > maze.length / 2; y--) {
                    for (let x = maze[0].length - 2; x > maze[0].length / 2; x--) {
                        if (maze[y][x] === 0) {
                            exitRef.current = { x, y };
                            break;
                        }
                    }
                    if (exitRef.current.x !== 0) break;
                }

                setWon(false);
                setShowingMaze(false);
                draw();
            };

            const draw = () => {
                const canvas = canvasRef.current;
                if (!canvas || !mazeRef.current) return;
                const ctx = canvas.getContext('2d');
                const maze = mazeRef.current;

                canvas.width = maze[0].length * CELL_SIZE;
                canvas.height = maze.length * CELL_SIZE;

                // Draw maze - clean minimal style
                for (let y = 0; y < maze.length; y++) {
                    for (let x = 0; x < maze[0].length; x++) {
                        ctx.fillStyle = maze[y][x] === 1 ? '#111' : '#fafafa';
                        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }

                // Draw exit - simple square
                const ex = exitRef.current.x * CELL_SIZE;
                const ey = exitRef.current.y * CELL_SIZE;
                ctx.fillStyle = '#fafafa';
                ctx.fillRect(ex, ey, CELL_SIZE, CELL_SIZE);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(ex + 2, ey + 2, CELL_SIZE - 4, CELL_SIZE - 4);

                // Draw player - simple filled square
                const px = playerRef.current.x * CELL_SIZE;
                const py = playerRef.current.y * CELL_SIZE;
                ctx.fillStyle = '#000';
                ctx.fillRect(px + 2, py + 2, CELL_SIZE - 4, CELL_SIZE - 4);
            };

            const move = (dx, dy) => {
                if (won || showingMaze) return;
                const maze = mazeRef.current;
                if (!maze) return;

                const nx = playerRef.current.x + dx;
                const ny = playerRef.current.y + dy;

                if (nx >= 0 && nx < maze[0].length && ny >= 0 && ny < maze.length && maze[ny][nx] === 0) {
                    playerRef.current = { x: nx, y: ny };
                    draw();

                    if (nx === exitRef.current.x && ny === exitRef.current.y) {
                        const points = level * 100;
                        setScore(s => {
                            const newScore = s + points;
                            setHighScore(h => {
                                const newHigh = Math.max(h, newScore);
                                HighScoreManager.saveHighScore('labyrinth', newHigh);
                                return newHigh;
                            });
                            return newScore;
                        });
                        setWon(true);

                        // Show full maze then start next level
                        setTimeout(() => {
                            setShowingMaze(true);
                            setTimeout(() => {
                                setLevel(l => l + 1);
                                startLevel(level + 1);
                            }, 2000);
                        }, 1000);
                    }
                }
            };

            const giveUp = () => {
                setLevel(1);
                setScore(0);
                startLevel(1);
            };

            useEffect(() => {
                const handle = (e) => {
                    if (e.key === 'ArrowUp') move(0, -1);
                    if (e.key === 'ArrowDown') move(0, 1);
                    if (e.key === 'ArrowLeft') move(-1, 0);
                    if (e.key === 'ArrowRight') move(1, 0);
                };
                window.addEventListener('keydown', handle);
                startLevel(1);
                return () => window.removeEventListener('keydown', handle);
            }, []);

            // Touch/swipe controls for mobile
            const touchStartRef = useRef({ x: 0, y: 0 });
            const handleTouchStart = (e) => {
                touchStartRef.current = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            };
            const handleTouchEnd = (e) => {
                const dx = e.changedTouches[0].clientX - touchStartRef.current.x;
                const dy = e.changedTouches[0].clientY - touchStartRef.current.y;
                const threshold = 20;
                if (Math.abs(dx) > Math.abs(dy)) {
                    if (dx > threshold) move(1, 0);
                    else if (dx < -threshold) move(-1, 0);
                } else {
                    if (dy > threshold) move(0, 1);
                    else if (dy < -threshold) move(0, -1);
                }
            };

            return (
                <div className="h-full flex flex-col bg-white select-none" onTouchStart={handleTouchStart} onTouchEnd={handleTouchEnd}>
                    <div className="h-8 px-3 flex justify-between items-center">
                        <span className="font-mono text-[10px] font-bold tracking-widest text-black">LABYRINTH</span>
                        <div className="flex gap-6 font-mono text-[10px]">
                            <span className="text-gray-400">LVL <span className="text-black font-bold">{level}</span></span>
                            <span className="text-gray-400">PTS <span className="text-black font-bold">{score}</span></span>
                        </div>
                    </div>
                    <div className="flex-grow flex items-center justify-center relative bg-white">
                        {won && !showingMaze && (
                            <div className="absolute inset-0 bg-white/95 flex items-center justify-center z-10">
                                <div className="text-center">
                                    <div className="text-2xl font-black tracking-widest">CLEAR</div>
                                    <div className="font-mono text-[10px] text-gray-400 mt-1">+{level * 100}</div>
                                </div>
                            </div>
                        )}
                        {showingMaze && (
                            <div className="absolute inset-0 bg-white flex items-center justify-center z-10">
                                <div className="font-mono text-[10px] text-gray-400 tracking-widest animate-pulse">
                                    GENERATING LEVEL {level}
                                </div>
                            </div>
                        )}
                        <canvas ref={canvasRef} className="block" style={{ imageRendering: 'pixelated' }} />
                    </div>
                    <div className="h-8 px-3 flex justify-between items-center">
                        <span className="font-mono text-[10px] text-gray-300 hidden md:inline"></span>
                        <span className="font-mono text-[10px] text-gray-300 md:hidden">SWIPE TO MOVE</span>
                        <button
                            onClick={giveUp}
                            className="font-mono text-[10px] text-gray-300 hover:text-black transition-colors"
                        >
                            RESTART
                        </button>
                    </div>
                </div>
            );
        };

        // --- MINESWEEPER.EXE - Ultra Clean Minesweeper ---
        const MinesweeperApp = () => {
            const [grid, setGrid] = useState([]);
            const [revealed, setRevealed] = useState([]);
            const [flagged, setFlagged] = useState([]);
            const [gameOver, setGameOver] = useState(false);
            const [won, setWon] = useState(false);
            const [mineCount, setMineCount] = useState(0);
            const [time, setTime] = useState(0);
            const [started, setStarted] = useState(false);
            const timerRef = useRef(null);

            const ROWS = 12;
            const COLS = 16;
            const MINES = 30;

            const initGame = () => {
                // Create empty grid
                const newGrid = Array(ROWS).fill(null).map(() => Array(COLS).fill(0));
                const newRevealed = Array(ROWS).fill(null).map(() => Array(COLS).fill(false));
                const newFlagged = Array(ROWS).fill(null).map(() => Array(COLS).fill(false));

                // Place mines
                let placed = 0;
                while (placed < MINES) {
                    const r = Math.floor(Math.random() * ROWS);
                    const c = Math.floor(Math.random() * COLS);
                    if (newGrid[r][c] !== -1) {
                        newGrid[r][c] = -1;
                        placed++;
                    }
                }

                // Calculate numbers
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        if (newGrid[r][c] === -1) continue;
                        let count = 0;
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                const nr = r + dr, nc = c + dc;
                                if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && newGrid[nr][nc] === -1) {
                                    count++;
                                }
                            }
                        }
                        newGrid[r][c] = count;
                    }
                }

                setGrid(newGrid);
                setRevealed(newRevealed);
                setFlagged(newFlagged);
                setGameOver(false);
                setWon(false);
                setMineCount(MINES);
                setTime(0);
                setStarted(false);
                if (timerRef.current) clearInterval(timerRef.current);
            };

            useEffect(() => {
                initGame();
                return () => { if (timerRef.current) clearInterval(timerRef.current); };
            }, []);

            useEffect(() => {
                if (started && !gameOver && !won) {
                    timerRef.current = setInterval(() => setTime(t => t + 1), 1000);
                }
                return () => { if (timerRef.current) clearInterval(timerRef.current); };
            }, [started, gameOver, won]);

            const reveal = (r, c) => {
                if (gameOver || won || revealed[r][c] || flagged[r][c]) return;

                if (!started) setStarted(true);

                const newRevealed = revealed.map(row => [...row]);

                if (grid[r][c] === -1) {
                    // Hit mine - reveal all mines
                    for (let i = 0; i < ROWS; i++) {
                        for (let j = 0; j < COLS; j++) {
                            if (grid[i][j] === -1) newRevealed[i][j] = true;
                        }
                    }
                    setRevealed(newRevealed);
                    setGameOver(true);
                    return;
                }

                // Flood fill for empty cells
                const flood = (row, col) => {
                    if (row < 0 || row >= ROWS || col < 0 || col >= COLS) return;
                    if (newRevealed[row][col] || flagged[row][col]) return;
                    newRevealed[row][col] = true;
                    if (grid[row][col] === 0) {
                        for (let dr = -1; dr <= 1; dr++) {
                            for (let dc = -1; dc <= 1; dc++) {
                                flood(row + dr, col + dc);
                            }
                        }
                    }
                };

                flood(r, c);
                setRevealed(newRevealed);

                // Check win
                let unrevealed = 0;
                for (let i = 0; i < ROWS; i++) {
                    for (let j = 0; j < COLS; j++) {
                        if (!newRevealed[i][j]) unrevealed++;
                    }
                }
                if (unrevealed === MINES) setWon(true);
            };

            const flag = (e, r, c) => {
                e.preventDefault();
                if (gameOver || won || revealed[r][c]) return;
                if (!started) setStarted(true);

                const newFlagged = flagged.map(row => [...row]);
                newFlagged[r][c] = !newFlagged[r][c];
                setFlagged(newFlagged);
                setMineCount(m => newFlagged[r][c] ? m - 1 : m + 1);
            };

            const getCellContent = (r, c) => {
                if (flagged[r][c]) return '';
                if (!revealed[r][c]) return '';
                if (grid[r][c] === -1) return '';
                if (grid[r][c] === 0) return '';
                return grid[r][c];
            };

            const getCellStyle = (r, c) => {
                if (flagged[r][c]) return 'bg-gray-100 text-black';
                if (!revealed[r][c]) return 'bg-gray-200 hover:bg-gray-300';
                if (grid[r][c] === -1) return 'bg-black text-white';
                return 'bg-white text-black';
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="h-10 px-4 flex justify-between items-center border-b border-gray-100">
                        <span className="font-mono text-[10px] font-bold tracking-widest text-black">MINESWEEPER</span>
                        <div className="flex gap-8 font-mono text-[10px]">
                            <span className="text-gray-400">MINES <span className="text-black font-bold">{mineCount.toString().padStart(3, '0')}</span></span>
                            <span className="text-gray-400">TIME <span className="text-black font-bold">{time.toString().padStart(3, '0')}</span></span>
                        </div>
                    </div>

                    <div className="flex-grow flex items-center justify-center relative bg-gray-50 p-4">
                        {(gameOver || won) && (
                            <div className="absolute inset-0 bg-white/95 flex items-center justify-center z-10">
                                <div className="text-center">
                                    <div className="text-2xl font-black tracking-widest">{won ? 'CLEARED' : 'DETONATED'}</div>
                                    <div className="font-mono text-[10px] text-gray-400 mt-2">{time}s</div>
                                    <button
                                        onClick={initGame}
                                        className="mt-4 px-4 py-2 bg-black text-white font-mono text-[10px] tracking-widest hover:bg-gray-800"
                                    >
                                        RETRY
                                    </button>
                                </div>
                            </div>
                        )}

                        <div className="border border-gray-200">
                            {grid.map((row, r) => (
                                <div key={r} className="flex">
                                    {row.map((cell, c) => (
                                        <button
                                            key={c}
                                            onClick={() => reveal(r, c)}
                                            onContextMenu={(e) => flag(e, r, c)}
                                            className={`w-6 h-6 border border-gray-100 font-mono text-[10px] font-bold flex items-center justify-center transition-colors ${getCellStyle(r, c)}`}
                                        >
                                            {getCellContent(r, c)}
                                        </button>
                                    ))}
                                </div>
                            ))}
                        </div>
                    </div>

                    <div className="h-8 px-4 flex justify-between items-center border-t border-gray-100">
                        <span className="font-mono text-[10px] text-gray-300">LEFT CLICK REVEAL  RIGHT CLICK FLAG</span>
                        <button
                            onClick={initGame}
                            className="font-mono text-[10px] text-gray-300 hover:text-black transition-colors"
                        >
                            NEW GAME
                        </button>
                    </div>
                </div>
            );
        };

        // --- STARSHIP.EXE - Low Poly Star Fox Style Game ---
        const StarshipApp = () => {
            const containerRef = useRef(null);
            const gameRef = useRef(null);
            const keysRef = useRef({ left: false, right: false, up: false, down: false, shoot: false });
            const touchRef = useRef({ startX: 0, startY: 0, startTime: 0, isDragging: false });
            const [score, setScore] = useState(0);
            const [highScore, setHighScore] = useState(() => HighScoreManager.getHighScore('starship'));
            const [gameOver, setGameOver] = useState(false);
            const [started, setStarted] = useState(false);

            // Load high score from storage when IP is ready
            useEffect(() => {
                const loadHighScore = async () => {
                    await HighScoreManager.fetchIP();
                    setHighScore(HighScoreManager.getHighScore('starship'));
                };
                loadHighScore();
            }, []);

            // Mobile control handlers
            const handleStart = () => {
                if (gameRef.current) {
                    if (gameOver) gameRef.current.restart();
                    else gameRef.current.start();
                }
            };

            // Touch-based drag controls
            const handleTouchStart = (e) => {
                const touch = e.touches[0];
                touchRef.current = {
                    startX: touch.clientX,
                    startY: touch.clientY,
                    startTime: Date.now(),
                    isDragging: false
                };
            };

            const handleTouchMove = (e) => {
                if (!started || gameOver) return;
                e.preventDefault();
                const touch = e.touches[0];
                const dx = touch.clientX - touchRef.current.startX;
                const dy = touch.clientY - touchRef.current.startY;
                touchRef.current.isDragging = true;

                // Set movement based on drag position (relative to start)
                const threshold = 20;
                keysRef.current.left = dx < -threshold;
                keysRef.current.right = dx > threshold;
                keysRef.current.up = dy < -threshold;
                keysRef.current.down = dy > threshold;
            };

            const handleTouchEnd = (e) => {
                // Reset all movement
                keysRef.current.left = false;
                keysRef.current.right = false;
                keysRef.current.up = false;
                keysRef.current.down = false;

                // Tap to shoot (short touch without much movement)
                const elapsed = Date.now() - touchRef.current.startTime;
                if (elapsed < 200 && !touchRef.current.isDragging) {
                    if (!started && !gameOver) {
                        handleStart();
                    } else if (gameRef.current && started && !gameOver) {
                        gameRef.current.shoot();
                    }
                }
            };

            useEffect(() => {
                if (!containerRef.current || gameRef.current) return;

                const width = 500;
                const height = 350;

                // Scene
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xffffff);
                scene.fog = new THREE.Fog(0xffffff, 20, 80);

                // Camera
                const camera = new THREE.PerspectiveCamera(60, width / height, 0.1, 1000);
                camera.position.set(0, 2, 0);
                camera.lookAt(0, 0, -20);

                // Renderer
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                containerRef.current.appendChild(renderer.domElement);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
                scene.add(ambientLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(5, 10, 5);
                scene.add(dirLight);

                // Create low-poly ship
                const createShip = () => {
                    const group = new THREE.Group();

                    // Main body - elongated pyramid
                    const bodyGeo = new THREE.ConeGeometry(0.3, 1.2, 4);
                    bodyGeo.rotateX(Math.PI / 2);
                    const bodyMat = new THREE.MeshStandardMaterial({ color: 0x000000, flatShading: true });
                    const body = new THREE.Mesh(bodyGeo, bodyMat);
                    group.add(body);

                    // Wings
                    const wingGeo = new THREE.BoxGeometry(1.8, 0.05, 0.4);
                    const wingMat = new THREE.MeshStandardMaterial({ color: 0x111111, flatShading: true });
                    const wings = new THREE.Mesh(wingGeo, wingMat);
                    wings.position.z = 0.2;
                    group.add(wings);

                    // Tail fins
                    const tailGeo = new THREE.BoxGeometry(0.05, 0.4, 0.3);
                    const tail1 = new THREE.Mesh(tailGeo, wingMat);
                    tail1.position.set(0, 0.15, 0.4);
                    group.add(tail1);

                    // Edges
                    const edges = new THREE.EdgesGeometry(bodyGeo);
                    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x444444 }));
                    group.add(line);

                    return group;
                };

                const ship = createShip();
                ship.position.set(0, 0, -5);
                scene.add(ship);

                // Ground grid
                const gridSize = 100;
                const gridGeo = new THREE.PlaneGeometry(gridSize, gridSize, 20, 20);
                gridGeo.rotateX(-Math.PI / 2);
                const gridMat = new THREE.MeshBasicMaterial({ color: 0xeeeeee, wireframe: true });
                const grid = new THREE.Mesh(gridGeo, gridMat);
                grid.position.y = -3;
                scene.add(grid);

                // Obstacles array
                const obstacles = [];
                const lasers = [];

                const createObstacle = () => {
                    const types = ['asteroid', 'enemy'];
                    const type = types[Math.floor(Math.random() * types.length)];
                    let mesh;

                    if (type === 'asteroid') {
                        const geo = new THREE.IcosahedronGeometry(0.5 + Math.random() * 0.5, 0);
                        const mat = new THREE.MeshStandardMaterial({ color: 0x222222, flatShading: true });
                        mesh = new THREE.Mesh(geo, mat);
                        const edges = new THREE.EdgesGeometry(geo);
                        mesh.add(new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 })));
                    } else {
                        const geo = new THREE.OctahedronGeometry(0.4, 0);
                        const mat = new THREE.MeshStandardMaterial({ color: 0x000000, flatShading: true });
                        mesh = new THREE.Mesh(geo, mat);
                        const edges = new THREE.EdgesGeometry(geo);
                        mesh.add(new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x666666 })));
                    }

                    mesh.position.set(
                        (Math.random() - 0.5) * 8,
                        (Math.random() - 0.5) * 4,
                        -60 - Math.random() * 20
                    );
                    mesh.userData = { type, speed: 0.3 + Math.random() * 0.2 };
                    scene.add(mesh);
                    obstacles.push(mesh);
                };

                const createLaser = () => {
                    const geo = new THREE.BoxGeometry(0.05, 0.05, 0.8);
                    const mat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                    const laser = new THREE.Mesh(geo, mat);
                    laser.position.copy(ship.position);
                    laser.position.z -= 0.8;
                    scene.add(laser);
                    lasers.push(laser);
                };

                // Controls - using ref so mobile can update too
                const keys = keysRef.current;
                let canShoot = true;
                let scoreVal = 0;
                let isGameOver = false;
                let isStarted = false;

                const doShoot = () => {
                    if (canShoot && isStarted && !isGameOver) {
                        createLaser();
                        canShoot = false;
                        setTimeout(() => canShoot = true, 150);
                    }
                };

                const onKeyDown = (e) => {
                    if (!isStarted && e.code === 'Space') {
                        isStarted = true;
                        setStarted(true);
                        return;
                    }
                    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = true;
                    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = true;
                    if (e.code === 'ArrowUp' || e.code === 'KeyW') keys.up = true;
                    if (e.code === 'ArrowDown' || e.code === 'KeyS') keys.down = true;
                    if (e.code === 'Space') doShoot();
                };
                const onKeyUp = (e) => {
                    if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.left = false;
                    if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.right = false;
                    if (e.code === 'ArrowUp' || e.code === 'KeyW') keys.up = false;
                    if (e.code === 'ArrowDown' || e.code === 'KeyS') keys.down = false;
                };

                window.addEventListener('keydown', onKeyDown);
                window.addEventListener('keyup', onKeyUp);

                // Spawn obstacles
                let spawnTimer = 0;

                // Animation loop
                let animationId;
                const animate = () => {
                    animationId = requestAnimationFrame(animate);

                    if (!isStarted || isGameOver) {
                        ship.rotation.z = Math.sin(Date.now() * 0.002) * 0.1;
                        renderer.render(scene, camera);
                        return;
                    }

                    // Move ship
                    const moveSpeed = 0.12;
                    if (keys.left) ship.position.x -= moveSpeed;
                    if (keys.right) ship.position.x += moveSpeed;
                    if (keys.up) ship.position.y += moveSpeed;
                    if (keys.down) ship.position.y -= moveSpeed;

                    // Clamp ship position
                    ship.position.x = Math.max(-4, Math.min(4, ship.position.x));
                    ship.position.y = Math.max(-2, Math.min(2, ship.position.y));

                    // Tilt ship based on movement
                    ship.rotation.z = -keys.left * 0.3 + keys.right * 0.3;
                    ship.rotation.x = keys.down * 0.2 - keys.up * 0.2;

                    // Move grid for speed effect
                    grid.position.z = (grid.position.z + 0.5) % 5;

                    // Spawn obstacles
                    spawnTimer++;
                    if (spawnTimer > 30) {
                        createObstacle();
                        spawnTimer = 0;
                    }

                    // Update obstacles
                    for (let i = obstacles.length - 1; i >= 0; i--) {
                        const obs = obstacles[i];
                        obs.position.z += obs.userData.speed;
                        obs.rotation.x += 0.02;
                        obs.rotation.y += 0.01;

                        // Remove if passed
                        if (obs.position.z > 5) {
                            scene.remove(obs);
                            obstacles.splice(i, 1);
                            scoreVal += 10;
                            setScore(scoreVal);
                        }

                        // Collision with ship
                        const dist = ship.position.distanceTo(obs.position);
                        if (dist < 1) {
                            isGameOver = true;
                            setGameOver(true);
                            // Save high score on game over
                            setHighScore(h => {
                                const newHigh = Math.max(h, scoreVal);
                                HighScoreManager.saveHighScore('starship', newHigh);
                                return newHigh;
                            });
                        }
                    }

                    // Update lasers
                    for (let i = lasers.length - 1; i >= 0; i--) {
                        const laser = lasers[i];
                        laser.position.z -= 1.5;

                        // Remove if too far
                        if (laser.position.z < -80) {
                            scene.remove(laser);
                            lasers.splice(i, 1);
                            continue;
                        }

                        // Check collision with obstacles
                        for (let j = obstacles.length - 1; j >= 0; j--) {
                            const obs = obstacles[j];
                            if (laser.position.distanceTo(obs.position) < 0.8) {
                                scene.remove(laser);
                                scene.remove(obs);
                                lasers.splice(i, 1);
                                obstacles.splice(j, 1);
                                scoreVal += 50;
                                setScore(scoreVal);
                                break;
                            }
                        }
                    }

                    renderer.render(scene, camera);
                };
                animate();

                gameRef.current = {
                    restart: () => {
                        obstacles.forEach(o => scene.remove(o));
                        lasers.forEach(l => scene.remove(l));
                        obstacles.length = 0;
                        lasers.length = 0;
                        ship.position.set(0, 0, -5);
                        scoreVal = 0;
                        isGameOver = false;
                        isStarted = true;
                        setScore(0);
                        setGameOver(false);
                        setStarted(true);
                    },
                    start: () => {
                        if (!isStarted) {
                            isStarted = true;
                            setStarted(true);
                        }
                    },
                    shoot: doShoot
                };

                return () => {
                    cancelAnimationFrame(animationId);
                    window.removeEventListener('keydown', onKeyDown);
                    window.removeEventListener('keyup', onKeyUp);
                    renderer.dispose();
                    if (containerRef.current && renderer.domElement) {
                        containerRef.current.removeChild(renderer.domElement);
                    }
                };
            }, []);

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="h-10 px-4 flex justify-between items-center border-b border-gray-100">
                        <span className="font-mono text-[10px] font-bold tracking-widest text-black">STARSHIP</span>
                        <div className="flex gap-4">
                            <span className="font-mono text-[10px] text-gray-400">HI <span className="text-gray-600 font-bold">{highScore.toString().padStart(6, '0')}</span></span>
                            <span className="font-mono text-[10px] text-gray-400">SCORE <span className="text-black font-bold">{score.toString().padStart(6, '0')}</span></span>
                        </div>
                    </div>

                    <div className="flex-grow flex items-center justify-center relative bg-gray-50 overflow-hidden">
                        {!started && !gameOver && (
                            <div className="absolute inset-0 bg-white/90 flex items-center justify-center z-10">
                                <div className="text-center">
                                    <div className="text-2xl font-black tracking-widest mb-2">STARSHIP</div>
                                    <div className="font-mono text-[10px] text-gray-400 mb-4">LOW POLY COMBAT</div>
                                    <button onClick={handleStart} className="px-4 py-2 bg-black text-white font-mono text-[10px] tracking-widest hover:bg-gray-800">
                                        TAP TO START
                                    </button>
                                </div>
                            </div>
                        )}
                        {gameOver && (
                            <div className="absolute inset-0 bg-white/95 flex items-center justify-center z-10">
                                <div className="text-center">
                                    <div className="text-2xl font-black tracking-widest">DESTROYED</div>
                                    <div className="font-mono text-[10px] text-gray-400 mt-2">SCORE: {score}</div>
                                    <div className="font-mono text-[10px] text-gray-500 mt-1">HIGH: {highScore}</div>
                                    <button
                                        onClick={() => gameRef.current?.restart()}
                                        className="mt-4 px-4 py-2 bg-black text-white font-mono text-[10px] tracking-widest hover:bg-gray-800"
                                    >
                                        RETRY
                                    </button>
                                </div>
                            </div>
                        )}
                        <div
                            ref={containerRef}
                            className="w-full h-full flex items-center justify-center touch-none"
                            onTouchStart={handleTouchStart}
                            onTouchMove={handleTouchMove}
                            onTouchEnd={handleTouchEnd}
                        />
                    </div>

                    <div className="h-8 px-4 flex justify-between items-center border-t border-gray-100">
                        <span className="font-mono text-[10px] text-gray-300 hidden md:inline">WASD/ARROWS MOVE  SPACE SHOOT</span>
                        <span className="font-mono text-[10px] text-gray-300 md:hidden">DRAG TO MOVE  TAP TO SHOOT</span>
                        <button
                            onClick={() => gameRef.current?.restart()}
                            className="font-mono text-[10px] text-gray-300 hover:text-black transition-colors"
                        >
                            RESTART
                        </button>
                    </div>
                </div>
            );
        };

        // --- SYNTH_001.WAV - Brutalist Synthesizer ---
        const SynthApp = () => {
            const [tempo, setTempo] = useState(120);
            const [filter, setFilter] = useState(1000);
            const [isPlaying, setIsPlaying] = useState(false);
            const [currentStep, setCurrentStep] = useState(0);
            const [grid, setGrid] = useState(() => {
                return {
                    sine: Array(16).fill(false),
                    square: Array(16).fill(false),
                    saw: Array(16).fill(false),
                    noise: Array(16).fill(false)
                };
            });
            const audioCtxRef = useRef(null);
            const intervalRef = useRef(null);

            const oscillators = ['sine', 'square', 'saw', 'noise'];

            const toggleNote = (osc, step) => {
                setGrid(prev => ({
                    ...prev,
                    [osc]: prev[osc].map((v, i) => i === step ? !v : v)
                }));
            };

            const playSound = (type, filterFreq) => {
                if (!audioCtxRef.current) {
                    audioCtxRef.current = new (window.AudioContext || window.webkitAudioContext)();
                }
                const ctx = audioCtxRef.current;

                let osc;
                const gain = ctx.createGain();
                const filt = ctx.createBiquadFilter();
                filt.type = 'lowpass';
                filt.frequency.value = filterFreq;

                if (type === 'noise') {
                    const bufferSize = ctx.sampleRate * 0.1;
                    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        data[i] = Math.random() * 2 - 1;
                    }
                    osc = ctx.createBufferSource();
                    osc.buffer = buffer;
                } else {
                    osc = ctx.createOscillator();
                    osc.type = type === 'saw' ? 'sawtooth' : type;
                    osc.frequency.value = 220 + Math.random() * 110;
                }

                gain.gain.setValueAtTime(0.3, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);

                osc.connect(filt);
                filt.connect(gain);
                gain.connect(ctx.destination);
                osc.start(ctx.currentTime);
                osc.stop(ctx.currentTime + 0.1);
            };

            const togglePlay = () => {
                if (isPlaying) {
                    clearInterval(intervalRef.current);
                    setIsPlaying(false);
                    setCurrentStep(0);
                } else {
                    setIsPlaying(true);
                    let step = 0;
                    intervalRef.current = setInterval(() => {
                        setCurrentStep(step);
                        oscillators.forEach(osc => {
                            if (grid[osc][step]) {
                                playSound(osc, filter);
                            }
                        });
                        step = (step + 1) % 16;
                    }, (60 / tempo) * 250);
                }
            };

            useEffect(() => {
                return () => clearInterval(intervalRef.current);
            }, []);

            useEffect(() => {
                if (isPlaying) {
                    clearInterval(intervalRef.current);
                    let step = currentStep;
                    intervalRef.current = setInterval(() => {
                        setCurrentStep(step);
                        oscillators.forEach(osc => {
                            if (grid[osc][step]) {
                                playSound(osc, filter);
                            }
                        });
                        step = (step + 1) % 16;
                    }, (60 / tempo) * 250);
                }
            }, [tempo, filter, grid]);

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex justify-between items-center">
                        <span className="font-mono text-xs font-bold">SYNTH_001.WAV</span>
                        <button
                            onClick={togglePlay}
                            className={`px-4 py-1 font-mono text-xs font-bold border-2 border-black ${isPlaying ? 'bg-black text-white' : 'bg-white text-black hover:bg-black hover:text-white'}`}
                        >
                            {isPlaying ? ' STOP' : ' PLAY'}
                        </button>
                    </div>
                    <div className="flex-grow p-4 overflow-auto bg-gray-50">
                        <div className="space-y-2">
                            {oscillators.map(osc => (
                                <div key={osc} className="flex items-center gap-2">
                                    <span className="font-mono text-[10px] w-12 text-gray-500 uppercase">{osc}</span>
                                    <div className="flex gap-1">
                                        {grid[osc].map((active, i) => (
                                            <button
                                                key={i}
                                                onClick={() => toggleNote(osc, i)}
                                                className={`w-6 h-8 border-2 transition-all ${active
                                                    ? 'bg-black border-black'
                                                    : 'bg-white border-gray-300 hover:border-black'
                                                    } ${currentStep === i && isPlaying ? 'ring-2 ring-black ring-offset-1' : ''}`}
                                            />
                                        ))}
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                    <div className="p-4 border-t-2 border-black bg-white flex gap-8">
                        <div className="flex items-center gap-2">
                            <span className="font-mono text-[10px] text-gray-500">TEMPO</span>
                            <input
                                type="range"
                                min="60"
                                max="200"
                                value={tempo}
                                onChange={(e) => setTempo(Number(e.target.value))}
                                className="w-24 accent-black"
                            />
                            <span className="font-mono text-xs w-8 text-black">{tempo}</span>
                        </div>
                        <div className="flex items-center gap-2">
                            <span className="font-mono text-[10px] text-gray-500">FILTER</span>
                            <input
                                type="range"
                                min="100"
                                max="5000"
                                value={filter}
                                onChange={(e) => setFilter(Number(e.target.value))}
                                className="w-24 accent-black"
                            />
                            <span className="font-mono text-xs w-12 text-black">{filter}Hz</span>
                        </div>
                    </div>
                </div>
            );
        };

        // --- DESTRUCTION.EXE - Screen destroyer with confirmations ---
        const DestructionApp = ({ onDogSteal }) => {
            const [confirmStep, setConfirmStep] = useState(0);
            const [buttonPos, setButtonPos] = useState({ x: 0, y: 0 });
            const [dogStealing, setDogStealing] = useState(false);
            const [dogPos, setDogPos] = useState({ x: -100, y: 200 });
            const [buttonGone, setButtonGone] = useState(false);

            const confirmMessages = [
                { prompt: "EXECUTE", response: "You want to do it?" },
                { prompt: "YES", response: "Are you sure?" },
                { prompt: "I'M SURE", response: "Really though?" },
                { prompt: "REALLY", response: "Really, really though?" },
                { prompt: "YES REALLY", response: "Like... REALLY really?" },
                { prompt: "DO IT", response: "You know this destroys EVERYTHING?" },
                { prompt: "I KNOW", response: "There's no going back..." },
                { prompt: "I DON'T CARE", response: "Final warning..." },
                { prompt: "JUST DO IT", response: "Okay... last chance to back out..." },
                { prompt: "DESTROY IT ALL", response: "..." }
            ];

            const handleClick = () => {
                if (confirmStep < 9) {
                    setConfirmStep(prev => prev + 1);
                } else {
                    // Final click - dog steals the button!
                    setDogStealing(true);

                    // Animate dog running in
                    let dogX = -100;
                    const dogRun = setInterval(() => {
                        dogX += 15;
                        setDogPos({ x: dogX, y: 150 + Math.sin(dogX / 20) * 10 });

                        if (dogX >= 120) {
                            clearInterval(dogRun);
                            setButtonGone(true);

                            // Dog runs away with button
                            const dogEscape = setInterval(() => {
                                dogX += 20;
                                setDogPos({ x: dogX, y: 150 + Math.sin(dogX / 15) * 15 });

                                if (dogX > window.innerWidth + 100) {
                                    clearInterval(dogEscape);
                                    if (onDogSteal) onDogSteal();
                                }
                            }, 30);
                        }
                    }, 30);
                }
            };

            return (
                <div className="h-full flex flex-col bg-white select-none relative overflow-hidden">
                    <div className="p-2 border-b-2 border-black bg-white flex justify-between items-center">
                        <span className="font-mono text-xs font-bold">DESTRUCTION.EXE</span>
                        <span className="font-mono text-[10px] text-gray-500">DANGER ZONE</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center bg-gray-50 relative z-10">
                        <div className="text-center">
                            <svg width="64" height="64" viewBox="0 0 64 64" className="mx-auto mb-4" style={{ imageRendering: 'pixelated' }}>
                                <rect x="16" y="4" width="32" height="8" fill="#000" />
                                <rect x="12" y="12" width="40" height="8" fill="#000" />
                                <rect x="8" y="20" width="48" height="16" fill="#000" />
                                <rect x="14" y="22" width="12" height="10" fill="#fff" />
                                <rect x="38" y="22" width="12" height="10" fill="#fff" />
                                <rect x="28" y="34" width="8" height="6" fill="#fff" />
                                <rect x="12" y="40" width="40" height="8" fill="#000" />
                                <rect x="16" y="42" width="4" height="6" fill="#fff" />
                                <rect x="24" y="42" width="4" height="6" fill="#fff" />
                                <rect x="36" y="42" width="4" height="6" fill="#fff" />
                                <rect x="44" y="42" width="4" height="6" fill="#fff" />
                                <rect x="16" y="48" width="32" height="8" fill="#000" />
                            </svg>
                            <div className="font-mono text-sm mb-2 text-black">DESTRUCTION.EXE</div>
                            <div className="font-mono text-xs text-gray-500 mb-6">
                                {confirmStep === 0 ? "WARNING: WILL DESTROY EVERYTHING" : confirmMessages[confirmStep - 1]?.response || "..."}
                            </div>
                            {!buttonGone && (
                                <button
                                    onClick={handleClick}
                                    className={`px-8 py-4 bg-black text-white font-mono font-bold text-sm hover:invert border-2 border-black transition-all ${confirmStep > 5 ? 'animate-pulse' : ''}`}
                                    style={{
                                        transform: `translate(${buttonPos.x}px, ${buttonPos.y}px)`,
                                    }}
                                >
                                    {confirmMessages[confirmStep].prompt}
                                </button>
                            )}
                            {buttonGone && !dogStealing && (
                                <div className="font-mono text-sm text-gray-500">
                                    The button is gone...
                                </div>
                            )}
                        </div>
                    </div>

                    {/* Dog stealing animation - cute dog matching the main sprite */}
                    {dogStealing && (
                        <div
                            className="absolute z-20"
                            style={{ left: dogPos.x, top: dogPos.y }}
                        >
                            <svg width="64" height="48" viewBox="0 0 64 48" style={{ imageRendering: 'pixelated' }}>
                                {/* Cute dog - full black, same as released dog */}
                                {/* Body */}
                                <rect x="16" y="16" width="32" height="16" fill="#000" />
                                {/* Head - rounder, cuter */}
                                <rect x="4" y="12" width="16" height="16" fill="#000" />
                                {/* Floppy ears */}
                                <rect x="2" y="4" width="6" height="14" fill="#000" />
                                <rect x="14" y="4" width="6" height="14" fill="#000" />
                                {/* Eye - big cute eye */}
                                <rect x="8" y="16" width="6" height="6" fill="#fff" />
                                <rect x="10" y="18" width="3" height="3" fill="#000" />
                                {/* Nose */}
                                <rect x="4" y="22" width="4" height="4" fill="#000" />
                                {/* Running legs */}
                                <rect x="16" y="32" width="6" height="12" fill="#000" />
                                <rect x="26" y="32" width="6" height="10" fill="#000" />
                                <rect x="34" y="32" width="6" height="12" fill="#000" />
                                <rect x="42" y="32" width="6" height="10" fill="#000" />
                                {/* Tail - wagging */}
                                <rect x="48" y="12" width="12" height="4" fill="#000" />
                                <rect x="58" y="8" width="4" height="6" fill="#000" />
                            </svg>
                            {buttonGone && (
                                <div className="absolute -top-4 left-10 px-2 py-1 bg-black text-white font-mono text-[8px] border-2 border-black">
                                    DESTROY
                                </div>
                            )}
                        </div>
                    )}

                    {dogStealing && buttonGone && (
                        <div className="absolute bottom-4 w-full text-center">
                            <div className="font-mono text-xs text-gray-600">
                                *dog runs away with the button*
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // --- TAROT.DAT - Tarot card pull ---
        // Pixel art tarot card component with card frame
        const PixelTarotCard = ({ pixels, width = 24, height = 32, scale = 3 }) => {
            const cardWidth = width + 4;
            const cardHeight = height + 6;

            return (
                <div className="relative" style={{ width: cardWidth * scale, height: cardHeight * scale }}>
                    {/* Card frame - thin border */}
                    <div
                        className="absolute inset-0 bg-white"
                        style={{
                            borderRadius: '2px',
                            border: '1px solid #666',
                            boxShadow: '1px 1px 0 rgba(0,0,0,0.15)'
                        }}
                    />
                    {/* Pixel art area */}
                    <div
                        className="absolute flex items-center justify-center"
                        style={{
                            top: scale,
                            left: scale,
                            right: scale,
                            bottom: scale * 2,
                        }}
                    >
                        <svg width={width * scale} height={height * scale} viewBox={`0 0 ${width} ${height}`} style={{ imageRendering: 'pixelated' }}>
                            <rect width={width} height={height} fill="#000" />
                            {pixels.map((row, y) =>
                                row.split('').map((pixel, x) =>
                                    pixel === '#' ? <rect key={`${x}-${y}`} x={x} y={y} width={1} height={1} fill="#fff" /> : null
                                )
                            )}
                        </svg>
                    </div>
                </div>
            );
        };

        const TarotApp = () => {
            const [cards, setCards] = useState([]);
            const [revealed, setRevealed] = useState(false);
            const [alreadyPulled, setAlreadyPulled] = useState(false);
            const [isShuffling, setIsShuffling] = useState(false);
            const [shuffleFrame, setShuffleFrame] = useState(0);

            const tarotCards = [
                {
                    name: 'THE FOOL', num: '0', meaning: 'New beginnings, innocence, spontaneity', pixels: [
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '........#######.........',
                        '.........#####..........',
                        '..........###...........',
                        '...........#............',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '........#.....#.........',
                        '........................',
                        '....##..................',
                        '...####.................',
                        '...#..#.................',
                        '....##..................',
                        '........................',
                        '########################',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE MAGICIAN', num: 'I', meaning: 'Manifestation, resourcefulness, power', pixels: [
                        '........................',
                        '.........#...#..........',
                        '..........#.#...........',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...........#............',
                        '..........#.#...........',
                        '........................',
                        '..##..##..##..##........',
                        '..##..##..##..##........',
                        '........................',
                        '########################',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE HIGH PRIESTESS', num: 'II', meaning: 'Intuition, mystery, inner knowledge', pixels: [
                        '........................',
                        '....##..........##......',
                        '...#..#........#..#.....',
                        '....##..........##......',
                        '..........##............',
                        '.........####...........',
                        '..........##............',
                        '..........##............',
                        '.........####...........',
                        '........##..##..........',
                        '.........####...........',
                        '..........##............',
                        '..........##............',
                        '.........####...........',
                        '........######..........',
                        '........................',
                        '...##..........##.......',
                        '...##..........##.......',
                        '...##..........##.......',
                        '........................',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE EMPRESS', num: 'III', meaning: 'Abundance, nurturing, fertility', pixels: [
                        '........................',
                        '.........#####..........',
                        '........#######.........',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '.........#####..........',
                        '........#######.........',
                        '.......#########........',
                        '........#######.........',
                        '.........#####..........',
                        '..........###...........',
                        '..........#.#...........',
                        '.........#...#..........',
                        '........................',
                        '...#..#..#..#..#..#.....',
                        '...#..#..#..#..#..#.....',
                        '...#..#..#..#..#..#.....',
                        '........................',
                        '########################',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE EMPEROR', num: 'IV', meaning: 'Authority, structure, control', pixels: [
                        '........................',
                        '.........#####..........',
                        '........#.#.#.#.........',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '........#######.........',
                        '........#.###.#.........',
                        '........#.###.#.........',
                        '........#######.........',
                        '..........###...........',
                        '..........###...........',
                        '.........##.##..........',
                        '........##...##.........',
                        '........................',
                        '.......########.........',
                        '.......#......#.........',
                        '.......#......#.........',
                        '.......########.........',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE HIEROPHANT', num: 'V', meaning: 'Tradition, conformity, spirituality', pixels: [
                        '........................',
                        '...........##...........',
                        '..........####..........',
                        '...........##...........',
                        '.........######.........',
                        '..........####..........',
                        '..........####..........',
                        '.........######.........',
                        '........########........',
                        '.........######.........',
                        '..........####..........',
                        '..........####..........',
                        '.........##..##.........',
                        '........##....##........',
                        '........................',
                        '....##....##....##......',
                        '...####..####..####.....',
                        '....##....##....##......',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE LOVERS', num: 'VI', meaning: 'Love, harmony, relationships', pixels: [
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '........#######.........',
                        '.........#####..........',
                        '..........###...........',
                        '........................',
                        '....###........###......',
                        '...#####......#####.....',
                        '....###........###......',
                        '....###........###......',
                        '.....#..........#.......',
                        '....#.#........#.#......',
                        '...#...#......#...#.....',
                        '........................',
                        '.........####...........',
                        '........##..##..........',
                        '.........####...........',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE CHARIOT', num: 'VII', meaning: 'Willpower, determination, success', pixels: [
                        '........................',
                        '........#.#.#.#.........',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '.........#####..........',
                        '........#######.........',
                        '.......#########........',
                        '.......#.#####.#........',
                        '.......#########........',
                        '........#######.........',
                        '..........###...........',
                        '......###.###.###.......',
                        '.....##.........##......',
                        '....##...........##.....',
                        '...####.........####....',
                        '...#..#.........#..#....',
                        '...####.........####....',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'STRENGTH', num: 'VIII', meaning: 'Courage, persuasion, inner strength', pixels: [
                        '........................',
                        '.........#...#..........',
                        '..........#.#...........',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###....###....',
                        '...........#....#####...',
                        '..........#.#...#.#.#...',
                        '.........#...#..#####...',
                        '................#...#...',
                        '...............##...##..',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE HERMIT', num: 'IX', meaning: 'Soul-searching, introspection, solitude', pixels: [
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '...###...#####..........',
                        '..#####...###...........',
                        '...###...#.#.#..........',
                        '....#.....###...........',
                        '....#......#............',
                        '....#.....#.#...........',
                        '....#....#...#..........',
                        '....#...#.....#.........',
                        '....#...................',
                        '........................',
                        '..######................',
                        '.########...............',
                        '##########..............',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'WHEEL OF FORTUNE', num: 'X', meaning: 'Change, cycles, destiny', pixels: [
                        '........................',
                        '........................',
                        '.......########.........',
                        '......#........#........',
                        '.....#..........#.......',
                        '....#....####....#......',
                        '....#...#....#...#......',
                        '...#....#....#....#.....',
                        '...#....#....#....#.....',
                        '....#...#....#...#......',
                        '....#....####....#......',
                        '.....#..........#.......',
                        '......#........#........',
                        '.......########.........',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'JUSTICE', num: 'XI', meaning: 'Fairness, truth, law', pixels: [
                        '........................',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...####....#....####....',
                        '...#..#....#....#..#....',
                        '...####....#....####....',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '........#.....#.........',
                        '........................',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE HANGED MAN', num: 'XII', meaning: 'Surrender, letting go, new perspective', pixels: [
                        '........................',
                        '########################',
                        '...........#............',
                        '...........#............',
                        '...........#............',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'DEATH', num: 'XIII', meaning: 'Endings, change, transformation', pixels: [
                        '........................',
                        '..........###...........',
                        '.........#...#..........',
                        '........#.....#.........',
                        '........#.#.#.#.........',
                        '........#.....#.........',
                        '.........#...#..........',
                        '..........###...........',
                        '...........#............',
                        '.........#####..........',
                        '........#..#..#.........',
                        '.........#####..........',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '........#.....#.........',
                        '........................',
                        '...##..........##.......',
                        '..####........####......',
                        '...##..........##.......',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'TEMPERANCE', num: 'XIV', meaning: 'Balance, moderation, patience', pixels: [
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '....###....#....###.....',
                        '....#.#....#....#.#.....',
                        '....###..#####..###.....',
                        '...........#............',
                        '..........#.#...........',
                        '.........#...#..........',
                        '........#.....#.........',
                        '........................',
                        '########################',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE DEVIL', num: 'XV', meaning: 'Shadow self, attachment, addiction', pixels: [
                        '........................',
                        '........#......#........',
                        '.......##......##.......',
                        '........########........',
                        '.........#....#.........',
                        '.........#.##.#.........',
                        '.........######.........',
                        '..........####..........',
                        '..........####..........',
                        '.........######.........',
                        '........#.####.#........',
                        '........#.#..#.#........',
                        '.........#....#.........',
                        '..........#..#..........',
                        '........................',
                        '...###..........###.....',
                        '...#.#..........#.#.....',
                        '...###..........###.....',
                        '........................',
                        '...####........####.....',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE TOWER', num: 'XVI', meaning: 'Sudden change, upheaval, revelation', pixels: [
                        '........................',
                        '....##..........##......',
                        '.....##........##.......',
                        '......##..##..##........',
                        '.........####...........',
                        '.........#..#...........',
                        '.........#..#...........',
                        '........######..........',
                        '........#....#..........',
                        '........#....#..........',
                        '........######..........',
                        '........#....#..........',
                        '........#....#..........',
                        '.......########.........',
                        '......##########........',
                        '........................',
                        '...##....##....##.......',
                        '...##....##....##.......',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE STAR', num: 'XVII', meaning: 'Hope, faith, renewal', pixels: [
                        '........................',
                        '...........#............',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '...........#............',
                        '....#.....#.#.....#.....',
                        '...###...#...#...###....',
                        '....#.............#.....',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...###.....#.....###....',
                        '...#.#....#.#....#.#....',
                        '...###...#...#...###....',
                        '........................',
                        '########################',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE MOON', num: 'XVIII', meaning: 'Illusion, fear, subconscious', pixels: [
                        '........................',
                        '.........#####..........',
                        '........##...##.........',
                        '.......##.....##........',
                        '.......#.......#........',
                        '.......##.....##........',
                        '........##...##.........',
                        '.........#####..........',
                        '........................',
                        '....###........###......',
                        '...#.#.#......#.#.#.....',
                        '...#####......#####.....',
                        '...#...#......#...#.....',
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '........................',
                        '########################',
                        '########################',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE SUN', num: 'XIX', meaning: 'Joy, success, celebration', pixels: [
                        '........................',
                        '....#......#......#.....',
                        '.....#.....#.....#......',
                        '......#...###...#.......',
                        '.......#.#####.#........',
                        '...#####.#####.#####....',
                        '.......#.#####.#........',
                        '......#...###...#.......',
                        '.....#.....#.....#......',
                        '....#......#......#.....',
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...........#............',
                        '..........#.#...........',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'JUDGEMENT', num: 'XX', meaning: 'Reflection, reckoning, awakening', pixels: [
                        '........................',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '.........#.#.#..........',
                        '..........###...........',
                        '...........#............',
                        '..........###...........',
                        '.........#####..........',
                        '..........###...........',
                        '........................',
                        '....###..###..###.......',
                        '....#.#..#.#..#.#.......',
                        '....###..###..###.......',
                        '....#.#..#.#..#.#.......',
                        '....###..###..###.......',
                        '........................',
                        '.......########.........',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                },
                {
                    name: 'THE WORLD', num: 'XXI', meaning: 'Completion, accomplishment, travel', pixels: [
                        '........................',
                        '....##..........##......',
                        '........................',
                        '.......########.........',
                        '......#........#........',
                        '.....#..........#.......',
                        '....#....####....#......',
                        '....#...#....#...#......',
                        '...#....#....#....#.....',
                        '...#....#....#....#.....',
                        '....#...#....#...#......',
                        '....#....####....#......',
                        '.....#..........#.......',
                        '......#........#........',
                        '.......########.........',
                        '........................',
                        '....##..........##......',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................',
                        '........................'
                    ]
                }
            ];

            useEffect(() => {
                // Check localStorage for existing pull (simulating IP-based storage)
                const savedCards = localStorage.getItem('tarot_cards_3');
                if (savedCards) {
                    const parsed = JSON.parse(savedCards);
                    if (Array.isArray(parsed) && parsed.length === 3 && parsed[0].pixels) {
                        setCards(parsed);
                        setRevealed(true);
                        setAlreadyPulled(true);
                    } else {
                        localStorage.removeItem('tarot_cards_3');
                    }
                }
            }, []);

            const shufflePixels = [
                [
                    '........................',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#'
                ],
                [
                    '........................',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.',
                    '.#.#.#.#.#.#.#.#.#.#.#.#',
                    '#.#.#.#.#.#.#.#.#.#.#.#.'
                ]
            ];

            const pullCards = () => {
                if (alreadyPulled || isShuffling) return;

                setIsShuffling(true);
                let frame = 0;
                const shuffleInterval = setInterval(() => {
                    setShuffleFrame(f => f + 1);
                    frame++;
                    if (frame >= 20) {
                        clearInterval(shuffleInterval);
                        setIsShuffling(false);
                        // Pick 3 unique random cards
                        const shuffled = [...tarotCards].sort(() => Math.random() - 0.5);
                        const selectedCards = shuffled.slice(0, 3);
                        setCards(selectedCards);
                        localStorage.setItem('tarot_cards_3', JSON.stringify(selectedCards));
                        setTimeout(() => setRevealed(true), 500);
                        setAlreadyPulled(true);
                    }
                }, 80);
            };

            const questionPixels = [
                '........................',
                '........########........',
                '.......##......##.......',
                '......##........##......',
                '......##........##......',
                '..............##........',
                '............##..........',
                '..........##............',
                '.........##.............',
                '.........##.............',
                '.........##.............',
                '........................',
                '.........##.............',
                '.........##.............',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................',
                '........................'
            ];

            return (
                <div className="h-full flex flex-col bg-black text-white select-none">
                    <div className="p-2 border-b border-gray-800">
                        <span className="font-mono text-[10px] text-gray-500">TAROT.DAT</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-4">
                        {isShuffling ? (
                            <div className="text-center">
                                <div className="relative w-24 h-32 mb-4">
                                    {/* Deck shuffle animation - multiple cards moving */}
                                    {[0, 1, 2, 3, 4].map((i) => (
                                        <div
                                            key={i}
                                            className="absolute inset-0 border border-gray-700 bg-black"
                                            style={{
                                                transform: `
                                                    translateX(${Math.sin((shuffleFrame + i) * 1.5) * (15 + i * 3)}px)
                                                    translateY(${i * 2}px)
                                                    rotate(${Math.sin((shuffleFrame + i) * 0.8) * 8}deg)
                                                `,
                                                transition: 'transform 0.1s ease-out',
                                                zIndex: 5 - i
                                            }}
                                        >
                                            <PixelTarotCard pixels={shufflePixels[shuffleFrame % 2]} />
                                        </div>
                                    ))}
                                </div>
                                <div className="font-mono text-[10px] text-gray-500 animate-pulse">SHUFFLING...</div>
                            </div>
                        ) : cards.length === 0 ? (
                            <div className="text-center">
                                <div className="mb-6 flex gap-2 justify-center">
                                    <PixelTarotCard pixels={questionPixels} scale={2} />
                                    <PixelTarotCard pixels={questionPixels} scale={2} />
                                    <PixelTarotCard pixels={questionPixels} scale={2} />
                                </div>
                                <button
                                    onClick={pullCards}
                                    className="px-6 py-2 bg-white text-black font-mono text-[10px] font-bold hover:invert transition-all"
                                >
                                    DRAW 3 CARDS
                                </button>
                                <p className="mt-4 font-mono text-[10px] text-gray-600">ONE READING PER VISITOR</p>
                            </div>
                        ) : (
                            <div className={`text-center transition-all duration-500 ${revealed ? 'opacity-100' : 'opacity-0'}`}>
                                <div className="flex gap-3 justify-center mb-4">
                                    {cards.map((card, idx) => (
                                        <div key={idx} className="flex flex-col items-center">
                                            <div className="text-[8px] text-gray-600 mb-1">{['PAST', 'PRESENT', 'FUTURE'][idx]}</div>
                                            <PixelTarotCard pixels={card.pixels} scale={2} />
                                            <div className="font-mono text-[8px] text-gray-500 mt-1">{card.num}</div>
                                            <div className="text-[9px] font-bold mt-1 max-w-[80px]">{card.name}</div>
                                        </div>
                                    ))}
                                </div>
                                <div className="font-mono text-[9px] text-gray-400 max-w-md mx-auto">
                                    {cards.map((c, i) => <span key={i}>{c.meaning}{i < 2 ? '  ' : ''}</span>)}
                                </div>
                                {alreadyPulled && (
                                    <p className="mt-3 font-mono text-[10px] text-gray-700">FATE SEALED</p>
                                )}
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // --- GALLERY.EXE - Photo gallery with 9 placeholder photos ---
        const GalleryApp = () => {
            const [selectedPhoto, setSelectedPhoto] = useState(null);

            const photos = [
                { id: 1, title: 'ME_001.JPG', category: 'SELF', desc: 'Profile shot' },
                { id: 2, title: 'ME_002.JPG', category: 'SELF', desc: 'Another one' },
                { id: 3, title: 'DOG_001.JPG', category: 'DOGS', desc: 'Good boy' },
                { id: 4, title: 'DOG_002.JPG', category: 'DOGS', desc: 'Best friend' },
                { id: 5, title: 'DOG_003.JPG', category: 'DOGS', desc: 'Sleeping' },
                { id: 6, title: 'WORK_001.JPG', category: 'WORK', desc: 'Office vibes' },
                { id: 7, title: 'WORK_002.JPG', category: 'WORK', desc: 'Late night coding' },
                { id: 8, title: 'WORK_003.JPG', category: 'WORK', desc: 'Setup tour' },
                { id: 9, title: 'RANDOM_001.JPG', category: 'MISC', desc: 'Life moment' }
            ];

            // Generate placeholder image pattern based on id
            const getPlaceholderPattern = (id) => {
                const patterns = [
                    // Person silhouette
                    [[0, 0, 1, 1, 0, 0], [0, 1, 1, 1, 1, 0], [0, 0, 1, 1, 0, 0], [0, 1, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1], [1, 0, 1, 1, 0, 1], [0, 0, 1, 1, 0, 0], [0, 1, 0, 0, 1, 0]],
                    // Another person
                    [[0, 1, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1], [0, 1, 0, 0, 1, 0], [0, 0, 1, 1, 0, 0], [0, 1, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1], [0, 1, 0, 0, 1, 0], [1, 1, 0, 0, 1, 1]],
                    // Dog sitting
                    [[1, 1, 0, 0, 1, 1], [1, 1, 1, 1, 1, 1], [0, 1, 0, 0, 1, 0], [0, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 1], [1, 1, 0, 0, 1, 1]],
                    // Dog lying
                    [[0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1], [0, 1, 1, 1, 1, 0], [1, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0]],
                    // Dog running
                    [[0, 1, 1, 0, 0, 0], [1, 1, 1, 1, 1, 0], [0, 1, 1, 1, 1, 1], [0, 0, 1, 1, 1, 0], [0, 1, 0, 0, 1, 0], [1, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 1], [0, 0, 0, 0, 0, 0]],
                    // Computer/desk
                    [[0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1], [0, 0, 1, 1, 0, 0], [0, 1, 1, 1, 1, 0]],
                    // Code screen
                    [[1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 1], [1, 0, 1, 1, 0, 1], [1, 0, 1, 0, 0, 1], [1, 0, 0, 1, 1, 1], [1, 0, 1, 1, 0, 1], [1, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1]],
                    // Setup
                    [[0, 0, 0, 0, 0, 0], [1, 1, 1, 0, 1, 1], [1, 0, 1, 0, 1, 0], [1, 1, 1, 0, 1, 0], [0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 0], [0, 1, 0, 0, 1, 0], [0, 1, 1, 1, 1, 0]],
                    // Abstract/random
                    [[1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1], [1, 1, 0, 0, 1, 1], [0, 0, 1, 1, 0, 0], [1, 0, 0, 0, 0, 1], [0, 1, 1, 1, 1, 0], [1, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1]]
                ];
                return patterns[(id - 1) % patterns.length];
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex justify-between items-center">
                        <div className="flex items-center gap-2">
                            <Icons.Gallery size={24} />
                            <span className="font-mono text-xs font-bold">GALLERY.EXE</span>
                        </div>
                        <span className="font-mono text-[10px] text-gray-500">{photos.length} PHOTOS</span>
                    </div>

                    {selectedPhoto ? (
                        <div className="flex-grow flex flex-col bg-black">
                            <div className="flex-grow flex items-center justify-center p-8">
                                <div className="bg-gray-900 border-2 border-white p-4">
                                    <svg width="240" height="240" viewBox="0 0 6 8" style={{ imageRendering: 'pixelated' }}>
                                        <rect width="6" height="8" fill="#222" />
                                        {getPlaceholderPattern(selectedPhoto.id).map((row, y) =>
                                            row.map((cell, x) =>
                                                cell ? <rect key={`${x}-${y}`} x={x} y={y} width="1" height="1" fill="#fff" /> : null
                                            )
                                        )}
                                    </svg>
                                </div>
                            </div>
                            <div className="p-4 bg-gray-900 border-t-2 border-white">
                                <div className="flex justify-between items-center">
                                    <div>
                                        <div className="font-mono text-white text-sm font-bold">{selectedPhoto.title}</div>
                                        <div className="font-mono text-gray-400 text-[10px]">{selectedPhoto.category} / {selectedPhoto.desc}</div>
                                    </div>
                                    <button
                                        onClick={() => setSelectedPhoto(null)}
                                        className="px-4 py-2 bg-white text-black font-mono text-xs font-bold hover:invert"
                                    >
                                        BACK
                                    </button>
                                </div>
                            </div>
                        </div>
                    ) : (
                        <div className="flex-grow p-4 overflow-auto bg-gray-100">
                            <div className="grid grid-cols-3 gap-3">
                                {photos.map(photo => (
                                    <button
                                        key={photo.id}
                                        onClick={() => setSelectedPhoto(photo)}
                                        className="group aspect-square bg-white border-2 border-black hover:bg-black transition-all flex flex-col items-center justify-center p-2"
                                    >
                                        <svg width="48" height="64" viewBox="0 0 6 8" style={{ imageRendering: 'pixelated' }} className="group-hover:invert">
                                            <rect width="6" height="8" fill="#eee" />
                                            {getPlaceholderPattern(photo.id).map((row, y) =>
                                                row.map((cell, x) =>
                                                    cell ? <rect key={`${x}-${y}`} x={x} y={y} width="1" height="1" fill="#000" /> : null
                                                )
                                            )}
                                        </svg>
                                        <div className="font-mono text-[8px] mt-1 text-gray-600 group-hover:text-white truncate w-full text-center">{photo.title}</div>
                                    </button>
                                ))}
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // --- MAP.EXE - Low poly Three.js globe with accurate map ---
        const MapApp = () => {
            const containerRef = useRef(null);
            const sceneRef = useRef(null);
            const rendererRef = useRef(null);
            const cameraRef = useRef(null);
            const globeRef = useRef(null);
            const cloudsRef = useRef(null);
            const clouds2Ref = useRef(null);
            const bgGridRef = useRef(null);
            const ringsRef = useRef([]);
            const satellitesRef = useRef([]);
            const gemsRef = useRef([]);
            const rotationRef = useRef({ x: 0, y: 0, autoRotate: true });
            const dragRef = useRef({ isDragging: false, prevX: 0, prevY: 0 });
            const [loading, setLoading] = useState(true);
            const [gameStarted, setGameStarted] = useState(false);
            const [showShop, setShowShop] = useState(false);
            const [clickEffect, setClickEffect] = useState(null);
            const [popScale, setPopScale] = useState(1);

            // Game state with defaults
            const defaultGameState = {
                clicks: 0,
                totalClicks: 0,
                clickPower: 1,
                satellites: 0,
                clickMultiplier: 1,
                popStrength: 0.005, // 0.5% base pop, upgrades add more
                upgrades: {
                    // Click power - increases pop effect
                    power1: false,     // +1 power, +0.5% pop - 50
                    power2: false,     // +2 power, +0.5% pop - 200
                    power3: false,     // +5 power, +1% pop - 1000
                    power4: false,     // +10 power, +1% pop - 5000
                    power5: false,     // +25 power, +1% pop - 25000
                    power6: false,     // +50 power, +1% pop - 100000
                    // Satellites - visible orbiting + auto clicks
                    sat1: false,       // 1 satellite, 1/sec - 100
                    sat2: false,       // +1 satellite, +2/sec - 500
                    sat3: false,       // +2 satellites, +5/sec - 2500
                    sat4: false,       // +3 satellites, +10/sec - 10000
                    sat5: false,       // +4 satellites, +25/sec - 50000
                    sat6: false,       // +5 satellites, +50/sec - 200000
                    // Multipliers - add glowing rings
                    multi1: false,     // 2x, inner ring - 2000
                    multi2: false,     // 2x (4x), middle ring - 15000
                    multi3: false,     // 2x (8x), outer ring - 75000
                    // God mode - unlocks at 2M total clicks
                    godMode: false,     // Dark mode + crimson grid - 1000000
                    // Dog mode - unlocks at 100M, resets game with 1M multiplier
                    dogMode: false
                },
                dogModeMultiplier: 1  // All costs and clicks multiplied by this
            };

            const [showCorrupted, setShowCorrupted] = useState(true);

            const [gameState, setGameState] = useState(() => {
                const saved = localStorage.getItem(HighScoreManager.getStorageKey('mapclicker'));
                if (saved) {
                    try {
                        const parsed = JSON.parse(saved);
                        return { ...defaultGameState, ...parsed, upgrades: { ...defaultGameState.upgrades, ...parsed.upgrades } };
                    } catch (e) {
                        return defaultGameState;
                    }
                }
                return defaultGameState;
            });

            // Load game state when IP is ready
            useEffect(() => {
                const loadGame = async () => {
                    await HighScoreManager.fetchIP();
                    const saved = localStorage.getItem(HighScoreManager.getStorageKey('mapclicker'));
                    if (saved) {
                        try {
                            const parsed = JSON.parse(saved);
                            setGameState({ ...defaultGameState, ...parsed, upgrades: { ...defaultGameState.upgrades, ...parsed.upgrades } });
                        } catch (e) { }
                    }
                };
                loadGame();
            }, []);

            // Save game state whenever it changes
            useEffect(() => {
                localStorage.setItem(HighScoreManager.getStorageKey('mapclicker'), JSON.stringify(gameState));
            }, [gameState]);

            // Satellite auto-clicker interval
            useEffect(() => {
                if (gameState.satellites > 0) {
                    const interval = setInterval(() => {
                        const autoAmount = gameState.satellites * gameState.clickMultiplier * gameState.dogModeMultiplier;
                        setGameState(prev => ({
                            ...prev,
                            clicks: prev.clicks + autoAmount,
                            totalClicks: prev.totalClicks + autoAmount
                        }));
                    }, 1000);
                    return () => clearInterval(interval);
                }
            }, [gameState.satellites, gameState.clickMultiplier, gameState.dogModeMultiplier]);

            // Count satellites for visual
            const getSatelliteCount = () => {
                let count = 0;
                if (gameState.upgrades.sat1) count += 1;
                if (gameState.upgrades.sat2) count += 1;
                if (gameState.upgrades.sat3) count += 2;
                if (gameState.upgrades.sat4) count += 3;
                if (gameState.upgrades.sat5) count += 4;
                if (gameState.upgrades.sat6) count += 5;
                return count;
            };

            // Count multiplier rings
            const getRingCount = () => {
                let count = 0;
                if (gameState.upgrades.multi1) count++;
                if (gameState.upgrades.multi2) count++;
                if (gameState.upgrades.multi3) count++;
                return count;
            };

            // Shop items - all visually impactful
            const shopItems = [
                {
                    category: 'CLICK POWER', desc: 'Increases tap power & earth pulse', items: [
                        { id: 'power1', name: 'TREMOR I', desc: '+1 power, +0.5% pulse', cost: 50, effect: () => ({ clickPower: gameState.clickPower + 1, popStrength: gameState.popStrength + 0.005 }) },
                        { id: 'power2', name: 'TREMOR II', desc: '+2 power, +0.5% pulse', cost: 200, effect: () => ({ clickPower: gameState.clickPower + 2, popStrength: gameState.popStrength + 0.005 }), requires: 'power1' },
                        { id: 'power3', name: 'QUAKE I', desc: '+5 power, +1% pulse', cost: 1000, effect: () => ({ clickPower: gameState.clickPower + 5, popStrength: gameState.popStrength + 0.01 }), requires: 'power2' },
                        { id: 'power4', name: 'QUAKE II', desc: '+10 power, +1% pulse', cost: 5000, effect: () => ({ clickPower: gameState.clickPower + 10, popStrength: gameState.popStrength + 0.01 }), requires: 'power3' },
                        { id: 'power5', name: 'CATACLYSM I', desc: '+25 power, +1% pulse', cost: 25000, effect: () => ({ clickPower: gameState.clickPower + 25, popStrength: gameState.popStrength + 0.01 }), requires: 'power4' },
                        { id: 'power6', name: 'CATACLYSM II', desc: '+50 power, +1% pulse', cost: 100000, effect: () => ({ clickPower: gameState.clickPower + 50, popStrength: gameState.popStrength + 0.01 }), requires: 'power5' },
                    ]
                },
                {
                    category: 'SATELLITES', desc: 'Orbiting satellites that auto-click', items: [
                        { id: 'sat1', name: 'SPUTNIK', desc: '+1 satellite, 1/sec', cost: 100, effect: () => ({ satellites: gameState.satellites + 1 }) },
                        { id: 'sat2', name: 'EXPLORER', desc: '+1 satellite, +2/sec', cost: 500, effect: () => ({ satellites: gameState.satellites + 2 }), requires: 'sat1' },
                        { id: 'sat3', name: 'VOYAGER', desc: '+2 satellites, +5/sec', cost: 2500, effect: () => ({ satellites: gameState.satellites + 5 }), requires: 'sat2' },
                        { id: 'sat4', name: 'HUBBLE', desc: '+3 satellites, +10/sec', cost: 10000, effect: () => ({ satellites: gameState.satellites + 10 }), requires: 'sat3' },
                        { id: 'sat5', name: 'JAMES WEBB', desc: '+4 satellites, +25/sec', cost: 50000, effect: () => ({ satellites: gameState.satellites + 25 }), requires: 'sat4' },
                        { id: 'sat6', name: 'DYSON SWARM', desc: '+5 satellites, +50/sec', cost: 200000, effect: () => ({ satellites: gameState.satellites + 50 }), requires: 'sat5' },
                    ]
                },
                {
                    category: 'MULTIPLIERS', desc: 'Energy rings that multiply all clicks', items: [
                        { id: 'multi1', name: 'INNER RING', desc: '2x all clicks', cost: 2000, effect: () => ({ clickMultiplier: gameState.clickMultiplier * 2 }) },
                        { id: 'multi2', name: 'MIDDLE RING', desc: '2x (4x total)', cost: 15000, effect: () => ({ clickMultiplier: gameState.clickMultiplier * 2 }), requires: 'multi1' },
                        { id: 'multi3', name: 'OUTER RING', desc: '2x (8x total)', cost: 75000, effect: () => ({ clickMultiplier: gameState.clickMultiplier * 2 }), requires: 'multi2' },
                    ]
                },
                {
                    category: 'ASCENSION', desc: 'Ultimate power', items: [
                        { id: 'godMode', name: 'GOD MODE', desc: 'Dark crimson grid, 1M/click', cost: 1000000 },
                        { id: 'dogMode', name: 'DOG MODE', desc: 'RESET: 1M costs & clicks', cost: 100000000, requires: 'godMode' },
                    ]
                },
            ];

            const getActualCost = (baseCost) => baseCost * gameState.dogModeMultiplier;

            const buyUpgrade = (item) => {
                const actualCost = getActualCost(item.cost);
                if (gameState.clicks >= actualCost && !gameState.upgrades[item.id]) {
                    if (item.requires && !gameState.upgrades[item.requires]) return;

                    // DOG MODE: Reset game with 1M multiplier
                    if (item.id === 'dogMode') {
                        const newMultiplier = gameState.dogModeMultiplier * 1000000;
                        setGameState({
                            ...defaultGameState,
                            dogModeMultiplier: newMultiplier,
                            upgrades: { ...defaultGameState.upgrades, dogMode: true }
                        });
                        return;
                    }

                    const effectResult = item.effect ? item.effect() : {};
                    setGameState(prev => ({
                        ...prev,
                        clicks: prev.clicks - actualCost,
                        ...effectResult,
                        upgrades: { ...prev.upgrades, [item.id]: true }
                    }));
                }
            };

            const canBuy = (item) => {
                if (gameState.upgrades[item.id]) return false;
                if (gameState.clicks < getActualCost(item.cost)) return false;
                if (item.requires && !gameState.upgrades[item.requires]) return false;
                return true;
            };

            const isLocked = (item) => {
                return item.requires && !gameState.upgrades[item.requires];
            };

            // Spawn gem that flies from earth and falls
            const spawnGem = () => {
                if (!sceneRef.current) return;
                const scene = sceneRef.current;

                // Random position on globe surface
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const x = Math.sin(phi) * Math.cos(theta);
                const y = Math.cos(phi);
                const z = Math.sin(phi) * Math.sin(theta);

                // Monochrome minerals - white/gray crystals
                const brightness = 0.7 + Math.random() * 0.3; // 0.7 to 1.0
                const color = new THREE.Color(brightness, brightness, brightness);

                // Create small gem geometry
                const gemGeo = new THREE.OctahedronGeometry(0.02 + Math.random() * 0.015, 0);
                const gemMat = new THREE.MeshBasicMaterial({ color });
                const gem = new THREE.Mesh(gemGeo, gemMat);

                // Start at earth surface
                gem.position.set(x * 1.02, y * 1.02, z * 1.02);

                // Velocity - outward from center + slight random + gravity will pull down
                const speed = 0.02 + Math.random() * 0.02;
                const velocity = {
                    x: x * speed + (Math.random() - 0.5) * 0.01,
                    y: y * speed + (Math.random() - 0.5) * 0.01 + 0.01, // slight upward
                    z: z * speed + (Math.random() - 0.5) * 0.01
                };

                scene.add(gem);
                gemsRef.current.push({
                    mesh: gem,
                    velocity,
                    life: 0
                });
            };

            // Handle click on globe
            const handleGlobeClick = () => {
                const clickValue = gameState.clickPower * gameState.clickMultiplier * gameState.dogModeMultiplier;
                setGameState(prev => ({
                    ...prev,
                    clicks: prev.clicks + clickValue,
                    totalClicks: prev.totalClicks + clickValue
                }));
                setClickEffect({ value: clickValue, id: Date.now() });
                setTimeout(() => setClickEffect(null), 500);

                // Pop effect based on popStrength
                setPopScale(1 + gameState.popStrength);
                setTimeout(() => setPopScale(1), 100);

                // Spawn gems - more gems as you progress (1-5 based on power)
                const gemCount = Math.min(5, 1 + Math.floor(gameState.clickPower / 20));
                for (let i = 0; i < gemCount; i++) {
                    spawnGem();
                }
            };

            // Apply pop scale to globe
            useEffect(() => {
                if (globeRef.current) {
                    globeRef.current.scale.set(popScale, popScale, popScale);
                }
            }, [popScale]);

            const formatNumber = (num) => {
                if (num >= 1e12) return (num / 1e12).toFixed(1) + 'T';
                if (num >= 1e9) return (num / 1e9).toFixed(1) + 'B';
                if (num >= 1e6) return (num / 1e6).toFixed(1) + 'M';
                if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
                return Math.floor(num).toString();
            };

            // Calculate earth redness based on total clicks (0 to 2M)
            const getRedProgress = () => {
                return Math.min(1, gameState.totalClicks / 1000000);
            };

            useEffect(() => {
                if (!containerRef.current) return;

                const width = containerRef.current.clientWidth;
                const height = containerRef.current.clientHeight;

                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xffffff);
                sceneRef.current = scene;

                const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
                camera.position.z = 3;
                cameraRef.current = camera;

                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                containerRef.current.appendChild(renderer.domElement);
                rendererRef.current = renderer;

                // Very high resolution globe (subdivision 8 for maximum detail)
                const globeGeometry = new THREE.IcosahedronGeometry(1, 8);

                // Highly detailed land detection with accurate continent shapes
                const isLandAt = (lat, lon) => {
                    // NORTH AMERICA
                    // Alaska
                    if (lat > 54 && lat < 72 && lon > -170 && lon < -130) return true;
                    if (lat > 60 && lat < 72 && lon > -170 && lon < -140) return true;
                    // Canada - detailed regions
                    if (lat > 60 && lat < 75 && lon > -140 && lon < -60) return true;
                    if (lat > 49 && lat < 60 && lon > -140 && lon < -52) return true;
                    // US West Coast - California shape
                    if (lat > 32 && lat < 42 && lon > -125 && lon < -114) {
                        if (lon > -125 && lon < -119) return true;
                        if (lat > 37 && lon > -123 && lon < -117) return true;
                    }
                    // US Pacific Northwest
                    if (lat > 42 && lat < 49 && lon > -125 && lon < -116) return true;
                    // US Mountain/Southwest
                    if (lat > 31 && lat < 49 && lon > -117 && lon < -102) return true;
                    // US Great Plains
                    if (lat > 36 && lat < 49 && lon > -105 && lon < -90) return true;
                    // US Midwest
                    if (lat > 37 && lat < 49 && lon > -97 && lon < -82) return true;
                    // US Northeast
                    if (lat > 39 && lat < 47 && lon > -80 && lon < -67) return true;
                    // US Southeast
                    if (lat > 25 && lat < 39 && lon > -92 && lon < -75) return true;
                    // Florida
                    if (lat > 24 && lat < 31 && lon > -88 && lon < -79) return true;
                    // Texas
                    if (lat > 26 && lat < 37 && lon > -107 && lon < -93) return true;
                    // Mexico - detailed
                    if (lat > 14 && lat < 33 && lon > -118 && lon < -86) {
                        if (lat > 28 && lon > -118 && lon < -104) return true;
                        if (lat > 22 && lat < 30 && lon > -111 && lon < -97) return true;
                        if (lat > 14 && lat < 24 && lon > -106 && lon < -92) return true;
                        if (lat > 17 && lat < 22 && lon > -92 && lon < -86) return true;
                    }
                    // Central America
                    if (lat > 7 && lat < 18 && lon > -92 && lon < -77) return true;
                    // Caribbean Islands
                    if (lat > 18 && lat < 24 && lon > -85 && lon < -74) return true; // Cuba
                    if (lat > 17 && lat < 20 && lon > -73 && lon < -68) return true; // Hispaniola
                    if (lat > 17 && lat < 19 && lon > -67 && lon < -65) return true; // Puerto Rico
                    if (lat > 21 && lat < 27 && lon > -80 && lon < -76) return true; // Bahamas

                    // SOUTH AMERICA - detailed
                    // Colombia/Venezuela
                    if (lat > 0 && lat < 12 && lon > -79 && lon < -60) return true;
                    // Ecuador/Peru coast
                    if (lat > -18 && lat < 2 && lon > -82 && lon < -69) return true;
                    // Brazil - detailed regions
                    if (lat > -5 && lat < 5 && lon > -74 && lon < -35) return true; // Amazon
                    if (lat > -23 && lat < -5 && lon > -65 && lon < -35) return true; // Central
                    if (lat > -33 && lat < -20 && lon > -58 && lon < -40) return true; // South
                    // Bolivia/Paraguay
                    if (lat > -27 && lat < -10 && lon > -69 && lon < -54) return true;
                    // Argentina - detailed
                    if (lat > -55 && lat < -22 && lon > -73 && lon < -53) return true;
                    // Chile - narrow strip
                    if (lat > -56 && lat < -18 && lon > -76 && lon < -67) return true;
                    // Uruguay
                    if (lat > -35 && lat < -30 && lon > -58 && lon < -53) return true;

                    // EUROPE - detailed
                    // Iberian Peninsula
                    if (lat > 36 && lat < 44 && lon > -10 && lon < -1) return true; // Spain/Portugal
                    // France
                    if (lat > 42 && lat < 51 && lon > -5 && lon < 8) return true;
                    // UK
                    if (lat > 50 && lat < 59 && lon > -8 && lon < 2) return true;
                    // Ireland
                    if (lat > 51 && lat < 56 && lon > -11 && lon < -5) return true;
                    // Benelux/Germany
                    if (lat > 47 && lat < 55 && lon > 3 && lon < 15) return true;
                    // Switzerland/Austria
                    if (lat > 45 && lat < 48 && lon > 6 && lon < 17) return true;
                    // Italy
                    if (lat > 36 && lat < 47 && lon > 7 && lon < 19) {
                        if (lat > 43 && lon > 7 && lon < 14) return true;
                        if (lat > 36 && lat < 44 && lon > 12 && lon < 19) return true;
                    }
                    // Scandinavia - Norway
                    if (lat > 58 && lat < 71 && lon > 4 && lon < 32) return true;
                    // Sweden/Finland
                    if (lat > 55 && lat < 70 && lon > 11 && lon < 32) return true;
                    // Denmark
                    if (lat > 54 && lat < 58 && lon > 8 && lon < 15) return true;
                    // Poland
                    if (lat > 49 && lat < 55 && lon > 14 && lon < 24) return true;
                    // Balkans
                    if (lat > 35 && lat < 47 && lon > 13 && lon < 30) return true;
                    // Eastern Europe/Ukraine
                    if (lat > 44 && lat < 56 && lon > 22 && lon < 40) return true;
                    // Russia West
                    if (lat > 45 && lat < 70 && lon > 28 && lon < 60) return true;

                    // AFRICA - detailed
                    // Morocco/Algeria/Tunisia
                    if (lat > 27 && lat < 38 && lon > -13 && lon < 12) return true;
                    // Libya/Egypt
                    if (lat > 20 && lat < 32 && lon > 10 && lon < 35) return true;
                    // West Africa coastal
                    if (lat > 4 && lat < 15 && lon > -18 && lon < 0) return true;
                    // West Africa interior
                    if (lat > 10 && lat < 25 && lon > -18 && lon < 25) return true;
                    // Central Africa
                    if (lat > -5 && lat < 15 && lon > 8 && lon < 32) return true;
                    // Congo basin
                    if (lat > -12 && lat < 5 && lon > 12 && lon < 32) return true;
                    // East Africa - Horn
                    if (lat > 0 && lat < 15 && lon > 32 && lon < 52) return true;
                    // East Africa - Tanzania/Kenya
                    if (lat > -12 && lat < 5 && lon > 29 && lon < 42) return true;
                    // Southern Africa
                    if (lat > -35 && lat < -10 && lon > 10 && lon < 42) return true;
                    // Madagascar
                    if (lat > -26 && lat < -12 && lon > 43 && lon < 51) return true;

                    // MIDDLE EAST - detailed
                    // Turkey
                    if (lat > 36 && lat < 42 && lon > 26 && lon < 45) return true;
                    // Arabian Peninsula
                    if (lat > 12 && lat < 32 && lon > 34 && lon < 60) return true;
                    // Iran
                    if (lat > 25 && lat < 40 && lon > 44 && lon < 64) return true;

                    // ASIA - detailed
                    // Russia/Siberia
                    if (lat > 50 && lat < 78 && lon > 60 && lon < 180) return true;
                    if (lat > 65 && lat < 78 && lon > -180 && lon < -168) return true; // Eastern tip
                    // Central Asia (Kazakhstan, etc)
                    if (lat > 35 && lat < 55 && lon > 46 && lon < 88) return true;
                    // China
                    if (lat > 18 && lat < 54 && lon > 73 && lon < 135) {
                        if (lat > 35 && lon > 73 && lon < 135) return true;
                        if (lat > 20 && lat < 45 && lon > 97 && lon < 123) return true;
                        if (lat > 18 && lat < 26 && lon > 108 && lon < 120) return true;
                    }
                    // Mongolia
                    if (lat > 42 && lat < 52 && lon > 87 && lon < 120) return true;
                    // Japan
                    if (lat > 30 && lat < 46 && lon > 129 && lon < 146) return true;
                    // Korea
                    if (lat > 33 && lat < 43 && lon > 124 && lon < 132) return true;
                    // India subcontinent
                    if (lat > 8 && lat < 35 && lon > 68 && lon < 98) return true;
                    // Sri Lanka
                    if (lat > 5 && lat < 10 && lon > 79 && lon < 82) return true;
                    // Southeast Asia mainland
                    if (lat > 5 && lat < 29 && lon > 92 && lon < 109) return true;
                    // Malaysia/Indonesia
                    if (lat > -8 && lat < 8 && lon > 95 && lon < 141) return true;
                    // Philippines
                    if (lat > 5 && lat < 21 && lon > 116 && lon < 127) return true;
                    // Taiwan
                    if (lat > 22 && lat < 26 && lon > 120 && lon < 122) return true;

                    // OCEANIA
                    // Australia - detailed
                    if (lat > -44 && lat < -10 && lon > 112 && lon < 154) {
                        if (lat > -44 && lat < -32 && lon > 115 && lon < 150) return true;
                        if (lat > -32 && lat < -20 && lon > 113 && lon < 154) return true;
                        if (lat > -20 && lat < -10 && lon > 120 && lon < 150) return true;
                    }
                    // New Zealand
                    if (lat > -47 && lat < -34 && lon > 166 && lon < 179) return true;
                    // Papua New Guinea
                    if (lat > -12 && lat < -1 && lon > 140 && lon < 156) return true;

                    // OTHER
                    // Greenland
                    if (lat > 59 && lat < 84 && lon > -74 && lon < -10) return true;
                    // Iceland
                    if (lat > 63 && lat < 67 && lon > -25 && lon < -13) return true;
                    // Antarctica
                    if (lat < -62) return true;
                    // Svalbard
                    if (lat > 76 && lat < 81 && lon > 10 && lon < 35) return true;

                    return false;
                };

                const positions = globeGeometry.attributes.position;
                const colors = new Float32Array(positions.count * 3);

                for (let i = 0; i < positions.count; i++) {
                    const x = positions.getX(i);
                    const y = positions.getY(i);
                    const z = positions.getZ(i);
                    const lat = Math.asin(y) * (180 / Math.PI);
                    const lon = Math.atan2(x, z) * (180 / Math.PI);
                    const isLand = isLandAt(lat, lon);
                    if (isLand) {
                        colors[i * 3] = 0.15;
                        colors[i * 3 + 1] = 0.15;
                        colors[i * 3 + 2] = 0.15;
                    } else {
                        colors[i * 3] = 0.5;
                        colors[i * 3 + 1] = 0.5;
                        colors[i * 3 + 2] = 0.5;
                    }
                }

                globeGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                const globeMaterial = new THREE.MeshBasicMaterial({ vertexColors: true });
                const globe = new THREE.Mesh(globeGeometry, globeMaterial);
                scene.add(globe);
                globeRef.current = globe;

                // Multiple cloud layers for realistic atmosphere
                const cloudGeometry = new THREE.IcosahedronGeometry(1.03, 4);
                const cloudMaterial = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    transparent: true,
                    opacity: 0.2,
                    wireframe: true
                });
                const clouds = new THREE.Mesh(cloudGeometry, cloudMaterial);
                scene.add(clouds);
                cloudsRef.current = clouds;

                // Second cloud layer (opposite rotation for depth)
                const cloud2Geometry = new THREE.IcosahedronGeometry(1.06, 3);
                const cloud2Material = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    transparent: true,
                    opacity: 0.15,
                    wireframe: true
                });
                const clouds2 = new THREE.Mesh(cloud2Geometry, cloud2Material);
                scene.add(clouds2);
                clouds2Ref.current = clouds2;

                // Background Grid - replaces stars for retro "White Grid" look
                const bgGeo = new THREE.IcosahedronGeometry(20, 2);
                const bgMat = new THREE.MeshBasicMaterial({
                    color: 0x000000,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.15,
                    side: THREE.BackSide
                });
                const backgroundGrid = new THREE.Mesh(bgGeo, bgMat);
                scene.add(backgroundGrid);
                bgGridRef.current = backgroundGrid;

                // Plane system - rare flying planes
                const planes = [];
                const createPlane = () => {
                    const planeGroup = new THREE.Group();
                    // Fuselage
                    const bodyGeo = new THREE.ConeGeometry(0.015, 0.08, 4);
                    bodyGeo.rotateX(Math.PI / 2);
                    const bodyMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                    const body = new THREE.Mesh(bodyGeo, bodyMat);
                    planeGroup.add(body);
                    // Wings
                    const wingGeo = new THREE.BoxGeometry(0.1, 0.005, 0.02);
                    const wing = new THREE.Mesh(wingGeo, bodyMat);
                    wing.position.z = 0.01;
                    planeGroup.add(wing);
                    // Tail
                    const tailGeo = new THREE.BoxGeometry(0.03, 0.005, 0.015);
                    const tail = new THREE.Mesh(tailGeo, bodyMat);
                    tail.position.z = 0.035;
                    tail.position.y = 0.01;
                    planeGroup.add(tail);
                    // Contrail (white line behind plane)
                    const trailGeo = new THREE.BufferGeometry();
                    const trailPositions = new Float32Array(60);
                    trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
                    const trailMat = new THREE.LineBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.5 });
                    const trail = new THREE.Line(trailGeo, trailMat);
                    trail.frustumCulled = false;
                    planeGroup.add(trail);

                    // Random orbit parameters
                    const startAngle = Math.random() * Math.PI * 2;
                    const orbitTilt = (Math.random() - 0.5) * Math.PI * 0.6;
                    const orbitRadius = 1.15 + Math.random() * 0.1;
                    const speed = 0.003 + Math.random() * 0.002;
                    const direction = Math.random() > 0.5 ? 1 : -1;

                    scene.add(planeGroup);
                    return {
                        mesh: planeGroup,
                        trail: trail,
                        trailPositions: [],
                        angle: startAngle,
                        tilt: orbitTilt,
                        radius: orbitRadius,
                        speed: speed * direction,
                        life: 0,
                        maxLife: 600 + Math.random() * 400
                    };
                };

                let lastPlaneSpawn = 0;
                setLoading(false);

                // Mouse/touch interaction for rotation and zoom
                let lastPinchDist = 0;

                const onMouseDown = (e) => {
                    dragRef.current.isDragging = true;
                    dragRef.current.prevX = e.clientX;
                    dragRef.current.prevY = e.clientY;
                    rotationRef.current.autoRotate = false;
                };

                const onMouseMove = (e) => {
                    if (!dragRef.current.isDragging) return;
                    const deltaX = e.clientX - dragRef.current.prevX;
                    const deltaY = e.clientY - dragRef.current.prevY;
                    rotationRef.current.y += deltaX * 0.005;
                    rotationRef.current.x += deltaY * 0.005;
                    rotationRef.current.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotationRef.current.x));
                    dragRef.current.prevX = e.clientX;
                    dragRef.current.prevY = e.clientY;
                };

                const onMouseUp = () => {
                    dragRef.current.isDragging = false;
                    // Resume auto-rotate after 2 seconds of no interaction
                    setTimeout(() => {
                        if (!dragRef.current.isDragging) {
                            rotationRef.current.autoRotate = true;
                        }
                    }, 2000);
                };

                const onWheel = (e) => {
                    e.preventDefault();
                    camera.position.z += e.deltaY * 0.002;
                    camera.position.z = Math.max(1.5, Math.min(6, camera.position.z));
                };

                const onTouchStart = (e) => {
                    if (e.touches.length === 1) {
                        dragRef.current.isDragging = true;
                        dragRef.current.prevX = e.touches[0].clientX;
                        dragRef.current.prevY = e.touches[0].clientY;
                        rotationRef.current.autoRotate = false;
                    } else if (e.touches.length === 2) {
                        lastPinchDist = Math.hypot(
                            e.touches[0].clientX - e.touches[1].clientX,
                            e.touches[0].clientY - e.touches[1].clientY
                        );
                    }
                };

                const onTouchMove = (e) => {
                    e.preventDefault();
                    if (e.touches.length === 1 && dragRef.current.isDragging) {
                        const deltaX = e.touches[0].clientX - dragRef.current.prevX;
                        const deltaY = e.touches[0].clientY - dragRef.current.prevY;
                        rotationRef.current.y += deltaX * 0.005;
                        rotationRef.current.x += deltaY * 0.005;
                        rotationRef.current.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotationRef.current.x));
                        dragRef.current.prevX = e.touches[0].clientX;
                        dragRef.current.prevY = e.touches[0].clientY;
                    } else if (e.touches.length === 2) {
                        const pinchDist = Math.hypot(
                            e.touches[0].clientX - e.touches[1].clientX,
                            e.touches[0].clientY - e.touches[1].clientY
                        );
                        const delta = lastPinchDist - pinchDist;
                        camera.position.z += delta * 0.01;
                        camera.position.z = Math.max(1.5, Math.min(6, camera.position.z));
                        lastPinchDist = pinchDist;
                    }
                };

                const onTouchEnd = () => {
                    dragRef.current.isDragging = false;
                    setTimeout(() => {
                        if (!dragRef.current.isDragging) {
                            rotationRef.current.autoRotate = true;
                        }
                    }, 2000);
                };

                renderer.domElement.addEventListener('mousedown', onMouseDown);
                renderer.domElement.addEventListener('mousemove', onMouseMove);
                renderer.domElement.addEventListener('mouseup', onMouseUp);
                renderer.domElement.addEventListener('mouseleave', onMouseUp);
                renderer.domElement.addEventListener('wheel', onWheel, { passive: false });
                renderer.domElement.addEventListener('touchstart', onTouchStart, { passive: false });
                renderer.domElement.addEventListener('touchmove', onTouchMove, { passive: false });
                renderer.domElement.addEventListener('touchend', onTouchEnd);

                let animationId;
                const animate = () => {
                    animationId = requestAnimationFrame(animate);

                    // Auto-rotate when not dragging
                    if (rotationRef.current.autoRotate) {
                        rotationRef.current.y += 0.00075;
                    }

                    globe.rotation.x = rotationRef.current.x;
                    globe.rotation.y = rotationRef.current.y;

                    if (cloudsRef.current) {
                        cloudsRef.current.rotation.x = rotationRef.current.x;
                        cloudsRef.current.rotation.y = rotationRef.current.y + 0.05;
                    }

                    // Second cloud layer rotates opposite
                    if (clouds2Ref.current) {
                        clouds2Ref.current.rotation.x = rotationRef.current.x * 0.8;
                        clouds2Ref.current.rotation.y = -rotationRef.current.y * 0.7 + 0.1;
                    }

                    // Rare plane spawning (average every 15-30 seconds, max 2 planes)
                    if (planes.length < 2 && Math.random() < 0.001) {
                        planes.push(createPlane());
                    }

                    // Update planes
                    for (let i = planes.length - 1; i >= 0; i--) {
                        const p = planes[i];
                        p.angle += p.speed;
                        p.life++;

                        // Position on tilted orbit
                        const x = Math.cos(p.angle) * p.radius;
                        const y = Math.sin(p.angle) * Math.sin(p.tilt) * p.radius;
                        const z = Math.sin(p.angle) * Math.cos(p.tilt) * p.radius;
                        p.mesh.position.set(x, y, z);

                        // Point plane in direction of travel
                        const nextAngle = p.angle + p.speed * 10;
                        const nx = Math.cos(nextAngle) * p.radius;
                        const ny = Math.sin(nextAngle) * Math.sin(p.tilt) * p.radius;
                        const nz = Math.sin(nextAngle) * Math.cos(p.tilt) * p.radius;
                        p.mesh.lookAt(nx, ny, nz);

                        // Update contrail
                        p.trailPositions.unshift({ x, y, z });
                        if (p.trailPositions.length > 20) p.trailPositions.pop();
                        const trailArr = p.trail.geometry.attributes.position.array;
                        for (let j = 0; j < 20; j++) {
                            const tp = p.trailPositions[j] || p.trailPositions[p.trailPositions.length - 1] || { x: 0, y: 0, z: 0 };
                            trailArr[j * 3] = tp.x;
                            trailArr[j * 3 + 1] = tp.y;
                            trailArr[j * 3 + 2] = tp.z;
                        }
                        p.trail.geometry.attributes.position.needsUpdate = true;

                        // Remove old planes
                        if (p.life > p.maxLife) {
                            scene.remove(p.mesh);
                            planes.splice(i, 1);
                        }
                    }

                    // Animate satellites
                    satellitesRef.current.forEach(sat => {
                        sat.angle += sat.speed;
                        const x = Math.cos(sat.angle) * sat.radius;
                        const y = Math.sin(sat.angle) * Math.sin(sat.tilt) * sat.radius;
                        const z = Math.sin(sat.angle) * Math.cos(sat.tilt) * sat.radius;
                        sat.mesh.position.set(x, y, z);
                        sat.mesh.rotation.y = sat.angle;
                    });

                    // Animate multiplier rings - orbit around planet
                    ringsRef.current.forEach((ringData) => {
                        // Rotate around Y axis (orbit the planet)
                        ringData.mesh.rotation.y += ringData.speed;
                    });

                    // Animate falling gems
                    const gravity = -0.001;
                    for (let i = gemsRef.current.length - 1; i >= 0; i--) {
                        const gem = gemsRef.current[i];
                        gem.life++;

                        // Apply gravity
                        gem.velocity.y += gravity;

                        // Move gem
                        gem.mesh.position.x += gem.velocity.x;
                        gem.mesh.position.y += gem.velocity.y;
                        gem.mesh.position.z += gem.velocity.z;

                        // Spin the gem
                        gem.mesh.rotation.x += 0.1;
                        gem.mesh.rotation.z += 0.05;

                        // Remove if fallen off screen or too old
                        if (gem.mesh.position.y < -3 || gem.life > 180) {
                            scene.remove(gem.mesh);
                            gem.mesh.geometry.dispose();
                            gem.mesh.material.dispose();
                            gemsRef.current.splice(i, 1);
                        }
                    }

                    renderer.render(scene, camera);
                };
                animate();

                return () => {
                    cancelAnimationFrame(animationId);
                    planes.forEach(p => scene.remove(p.mesh));
                    satellitesRef.current.forEach(s => scene.remove(s.mesh));
                    ringsRef.current.forEach(r => scene.remove(r.mesh));
                    gemsRef.current.forEach(g => scene.remove(g.mesh));
                    if (clouds2Ref.current) scene.remove(clouds2Ref.current);
                    renderer.domElement.removeEventListener('mousedown', onMouseDown);
                    renderer.domElement.removeEventListener('mousemove', onMouseMove);
                    renderer.domElement.removeEventListener('mouseup', onMouseUp);
                    renderer.domElement.removeEventListener('mouseleave', onMouseUp);
                    renderer.domElement.removeEventListener('wheel', onWheel);
                    renderer.domElement.removeEventListener('touchstart', onTouchStart);
                    renderer.domElement.removeEventListener('touchmove', onTouchMove);
                    renderer.domElement.removeEventListener('touchend', onTouchEnd);
                    renderer.dispose();
                    if (containerRef.current && renderer.domElement) {
                        containerRef.current.removeChild(renderer.domElement);
                    }
                };
            }, []);

            // Update visuals when upgrades/clicks change
            useEffect(() => {
                if (!globeRef.current || !sceneRef.current) return;
                const globe = globeRef.current;
                const scene = sceneRef.current;
                const positions = globe.geometry.attributes.position;
                const colors = globe.geometry.attributes.color;

                const redProgress = getRedProgress();
                // Apply visual corruption only if God Mode is owned AND toggled on
                const isGodMode = gameState.upgrades.godMode && showCorrupted;

                // Simplified but accurate land detection for visual updates
                const isLandAt = (lat, lon) => {
                    if (lat > 49 && lat < 75 && lon > -170 && lon < -52) return true;
                    if (lat > 24 && lat < 50 && lon > -130 && lon < -65) return true;
                    if (lat > 14 && lat < 33 && lon > -118 && lon < -86) return true;
                    if (lat > 7 && lat < 22 && lon > -92 && lon < -77) return true;
                    if (lat > -5 && lat < 12 && lon > -82 && lon < -35) return true;
                    if (lat > -56 && lat < 0 && lon > -82 && lon < -35) return true;
                    if (lat > 35 && lat < 72 && lon > -12 && lon < 60) return true;
                    if (lat > -35 && lat < 38 && lon > -18 && lon < 52) return true;
                    if (lat > 12 && lat < 55 && lon > 34 && lon < 88) return true;
                    if (lat > 5 && lat < 78 && lon > 60 && lon < 180) return true;
                    if (lat > 65 && lat < 78 && lon > -180 && lon < -168) return true;
                    if (lat > -47 && lat < -10 && lon > 112 && lon < 180) return true;
                    if (lat > -12 && lat < 10 && lon > 95 && lon < 156) return true;
                    if (lat > 59 && lat < 84 && lon > -74 && lon < -10) return true;
                    if (lat < -62) return true;
                    return false;
                };

                // Update globe colors based on progression
                for (let i = 0; i < positions.count; i++) {
                    const x = positions.getX(i);
                    const y = positions.getY(i);
                    const z = positions.getZ(i);
                    const lat = Math.asin(y) * (180 / Math.PI);
                    const lon = Math.atan2(x, z) * (180 / Math.PI);
                    const isLand = isLandAt(lat, lon);

                    let landR, landG, landB, oceanR, oceanG, oceanB;

                    if (isGodMode) {
                        // CORRUPTED MODE - Inverted colors (dark bg, light planet)
                        landR = 0.9; landG = 0.9; landB = 0.9;  // Light land
                        oceanR = 0.5; oceanG = 0.5; oceanB = 0.5;  // Mid-gray ocean
                    } else {
                        // Normal mode - progressive monochrome
                        const lightness = redProgress;

                        // Land gets lighter as progress increases
                        landR = 0.15 + (lightness * 0.7);
                        landG = 0.15 + (lightness * 0.7);
                        landB = 0.15 + (lightness * 0.7);

                        // Ocean stays mid-gray range
                        oceanR = 0.5 + (lightness * 0.3);
                        oceanG = 0.5 + (lightness * 0.3);
                        oceanB = 0.5 + (lightness * 0.3);
                    }

                    if (isLand) {
                        colors.array[i * 3] = landR;
                        colors.array[i * 3 + 1] = landG;
                        colors.array[i * 3 + 2] = landB;
                    } else {
                        colors.array[i * 3] = oceanR;
                        colors.array[i * 3 + 1] = oceanG;
                        colors.array[i * 3 + 2] = oceanB;
                    }
                }
                colors.needsUpdate = true;

                // Update scene background for corrupted mode
                if (sceneRef.current) {
                    if (isGodMode) {
                        sceneRef.current.background = new THREE.Color(0x000000); // Black background
                    } else {
                        sceneRef.current.background = new THREE.Color(0xffffff); // White background
                    }
                }

                // Update cloud wireframe color for god mode (inverted)
                if (cloudsRef.current) {
                    if (isGodMode) {
                        cloudsRef.current.material.color.setHex(0xffffff); // White clouds in corrupted mode
                        cloudsRef.current.material.opacity = 0.4;
                    } else {
                        cloudsRef.current.material.color.setHex(0x000000); // Black clouds in normal mode
                        cloudsRef.current.material.opacity = 0.2;
                    }
                }

                // Update second cloud layer for corrupted mode
                if (clouds2Ref.current) {
                    if (isGodMode) {
                        clouds2Ref.current.material.color.setHex(0xffffff);
                        clouds2Ref.current.material.opacity = 0.25;
                    } else {
                        clouds2Ref.current.material.color.setHex(0x000000);
                        clouds2Ref.current.material.opacity = 0.15;
                    }
                }

                // Update background grid for corrupted mode
                if (bgGridRef.current) {
                    if (isGodMode) {
                        bgGridRef.current.material.color.setHex(0xffffff);
                        bgGridRef.current.material.opacity = 0.2;
                    } else {
                        bgGridRef.current.material.color.setHex(0x000000);
                        bgGridRef.current.material.opacity = 0.15;
                    }
                }

                // Manage multiplier rings - clean orbital rings
                const ringCount = getRingCount();

                // Remove extra rings
                while (ringsRef.current.length > ringCount) {
                    const ringData = ringsRef.current.pop();
                    scene.remove(ringData.mesh);
                }

                // Add missing rings - simple rotating orbital rings
                while (ringsRef.current.length < ringCount) {
                    const idx = ringsRef.current.length;
                    const ringGroup = new THREE.Group();

                    // Create ring as a simple circle line
                    const radius = 1.3 + idx * 0.2;
                    const segments = 128;
                    const ringPoints = [];
                    for (let i = 0; i <= segments; i++) {
                        const angle = (i / segments) * Math.PI * 2;
                        ringPoints.push(new THREE.Vector3(
                            Math.cos(angle) * radius,
                            0,
                            Math.sin(angle) * radius
                        ));
                    }
                    const ringGeo = new THREE.BufferGeometry().setFromPoints(ringPoints);
                    const ringMat = new THREE.LineBasicMaterial({
                        color: 0x000000,
                        transparent: true,
                        opacity: 0.8 - idx * 0.15
                    });
                    const ring = new THREE.Line(ringGeo, ringMat);
                    ringGroup.add(ring);

                    // Tilt each ring differently
                    const tilts = [
                        { x: Math.PI * 0.1, z: 0 },
                        { x: Math.PI * 0.15, z: Math.PI * 0.1 },
                        { x: Math.PI * 0.05, z: -Math.PI * 0.15 }
                    ];
                    const tilt = tilts[idx] || tilts[0];
                    ringGroup.rotation.x = tilt.x;
                    ringGroup.rotation.z = tilt.z;

                    scene.add(ringGroup);
                    ringsRef.current.push({
                        mesh: ringGroup,
                        tiltX: tilt.x,
                        tiltZ: tilt.z,
                        speed: 0.01 + idx * 0.005
                    });
                }

                // Update ring colors for corrupted mode
                ringsRef.current.forEach((ringData, idx) => {
                    const ring = ringData.mesh.children[0];
                    if (ring && ring.material) {
                        ring.material.color.setHex(isGodMode ? 0xffffff : 0x000000);
                    }
                });

                // Manage satellites
                const satCount = getSatelliteCount();

                // Remove extra satellites
                while (satellitesRef.current.length > satCount) {
                    const sat = satellitesRef.current.pop();
                    scene.remove(sat.mesh);
                }

                // Add missing satellites
                while (satellitesRef.current.length < satCount) {
                    const idx = satellitesRef.current.length;
                    const satGroup = new THREE.Group();

                    // Satellite body
                    const bodyGeo = new THREE.BoxGeometry(0.03, 0.02, 0.02);
                    const bodyMat = new THREE.MeshBasicMaterial({ color: 0x333333 });
                    const body = new THREE.Mesh(bodyGeo, bodyMat);
                    satGroup.add(body);

                    // Solar panels - monochrome dark gray
                    const panelGeo = new THREE.BoxGeometry(0.08, 0.002, 0.025);
                    const panelMat = new THREE.MeshBasicMaterial({ color: 0x666666 });
                    const panel = new THREE.Mesh(panelGeo, panelMat);
                    satGroup.add(panel);

                    // Random orbit parameters
                    const orbitRadius = 1.25 + (idx % 4) * 0.08;
                    const orbitTilt = (idx * 0.4) % Math.PI;
                    const orbitSpeed = 0.01 + (idx % 3) * 0.005;
                    const startAngle = (idx * 1.3) % (Math.PI * 2);

                    scene.add(satGroup);
                    satellitesRef.current.push({
                        mesh: satGroup,
                        radius: orbitRadius,
                        tilt: orbitTilt,
                        speed: orbitSpeed,
                        angle: startAngle
                    });
                }

                // Update satellite colors for corrupted mode
                satellitesRef.current.forEach((satData) => {
                    const bodyColor = isGodMode ? 0xcccccc : 0x333333;
                    const panelColor = isGodMode ? 0x999999 : 0x666666;
                    if (satData.mesh.children[0]) satData.mesh.children[0].material.color.setHex(bodyColor);
                    if (satData.mesh.children[1]) satData.mesh.children[1].material.color.setHex(panelColor);
                });

            }, [gameState.upgrades, gameState.totalClicks, showCorrupted]);

            // HSL to RGB helper
            const hslToRgb = (h, s, l) => {
                let r, g, b;
                if (s === 0) { r = g = b = l; }
                else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1 / 6) return p + (q - p) * 6 * t;
                        if (t < 1 / 2) return q;
                        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                        return p;
                    };
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1 / 3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1 / 3);
                }
                return [r, g, b];
            };

            const purchasedCount = Object.values(gameState.upgrades).filter(Boolean).length;
            const totalUpgrades = Object.keys(gameState.upgrades).length;

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex justify-between items-center">
                        <div className="flex items-center gap-2">
                            <Icons.Globe size={24} color="black" />
                            <span className="font-mono text-xs font-bold text-black">{gameStarted ? 'PLANET CLICKER' : 'MAP.EXE'}</span>
                        </div>
                        {gameStarted ? (
                            <div className="flex items-center gap-3">
                                <span className="font-mono text-xs text-black font-bold">{formatNumber(gameState.clicks)}</span>
                                <button
                                    onClick={() => setShowShop(!showShop)}
                                    className="px-2 py-1 bg-black text-white font-mono text-[10px] font-bold hover:bg-gray-800 border border-black"
                                >
                                    SHOP
                                </button>
                            </div>
                        ) : (
                            <span className="font-mono text-[10px] text-gray-400">DRAG TO ROTATE  SCROLL TO ZOOM</span>
                        )}
                    </div>

                    <div className="flex-grow relative">
                        <div
                            ref={containerRef}
                            className={`absolute inset-0 ${gameStarted ? 'cursor-pointer' : 'cursor-grab active:cursor-grabbing'}`}
                            onClick={gameStarted ? handleGlobeClick : undefined}
                        >
                            {loading && (
                                <div className="absolute inset-0 flex items-center justify-center bg-black">
                                    <span className="font-mono text-white animate-pulse">LOADING...</span>
                                </div>
                            )}
                        </div>

                        {/* START MINING button - exploration mode */}
                        {!gameStarted && !loading && (
                            <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                                <button
                                    onClick={() => setGameStarted(true)}
                                    className="pointer-events-auto px-6 py-3 bg-red-600 hover:bg-red-500 text-white font-mono text-sm font-bold border-2 border-red-400 shadow-lg transition-all hover:scale-105"
                                >
                                    START MINING
                                </button>
                            </div>
                        )}

                        {/* Click effect - game mode only */}
                        {gameStarted && clickEffect && (
                            <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 pointer-events-none animate-ping">
                                <span className="font-mono text-2xl font-bold text-white">+{formatNumber(clickEffect.value)}</span>
                            </div>
                        )}

                        {/* Stats overlay - game mode only */}
                        {gameStarted && (
                            <div className={`absolute top-2 left-2 border p-2 font-mono text-[10px] ${gameState.upgrades.godMode && showCorrupted ? 'bg-black/80 border-white/30' : 'bg-white/80 border-black/30'}`}>
                                {gameState.dogModeMultiplier > 1 && (
                                    <div className="text-yellow-500 font-bold mb-1">DOG MODE x{formatNumber(gameState.dogModeMultiplier)}</div>
                                )}
                                <div className={gameState.upgrades.godMode && showCorrupted ? 'text-gray-400' : 'text-gray-600'}>POWER: <span className={gameState.upgrades.godMode && showCorrupted ? 'text-white' : 'text-black'}>{gameState.clickPower}x{gameState.clickMultiplier}{gameState.dogModeMultiplier > 1 ? `x${formatNumber(gameState.dogModeMultiplier)}` : ''}</span></div>
                                <div className={gameState.upgrades.godMode && showCorrupted ? 'text-gray-400' : 'text-gray-600'}>PULSE: <span className={gameState.upgrades.godMode && showCorrupted ? 'text-white' : 'text-black'}>{(gameState.popStrength * 100).toFixed(1)}%</span></div>
                                <div className={gameState.upgrades.godMode && showCorrupted ? 'text-gray-400' : 'text-gray-600'}>SATS: <span className={gameState.upgrades.godMode && showCorrupted ? 'text-white' : 'text-black'}>{getSatelliteCount()} ({formatNumber(gameState.satellites * gameState.clickMultiplier * gameState.dogModeMultiplier)}/s)</span></div>
                                <div className={gameState.upgrades.godMode && showCorrupted ? 'text-gray-400' : 'text-gray-600'}>RINGS: <span className={gameState.upgrades.godMode && showCorrupted ? 'text-white' : 'text-black'}>{getRingCount()}/3</span></div>
                                <div className={gameState.upgrades.godMode && showCorrupted ? 'text-gray-400' : 'text-gray-600'}>TOTAL: <span className={gameState.upgrades.godMode ? 'text-red-500' : 'text-black'}>{formatNumber(gameState.totalClicks)}</span></div>
                                <div className={gameState.upgrades.godMode && showCorrupted ? 'text-gray-400' : 'text-gray-600'}>HEAT: <span className={gameState.upgrades.godMode && showCorrupted ? 'text-white' : 'text-black'}>{(getRedProgress() * 100).toFixed(1)}%</span></div>
                            </div>
                        )}

                        {/* Shop panel */}
                        {showShop && (
                            <div className="absolute inset-0 bg-white/95 overflow-auto">
                                <div className="p-4">
                                    <div className="flex justify-between items-center mb-4">
                                        <div className="flex flex-col">
                                            <span className="font-mono text-lg font-bold text-black">UPGRADE SHOP</span>
                                            {gameState.upgrades.godMode && (
                                                <button
                                                    onClick={() => setShowCorrupted(!showCorrupted)}
                                                    className={`mt-1 text-[10px] font-mono px-2 py-0.5 border ${showCorrupted ? 'bg-black text-white border-black' : 'bg-white text-black border-black/50'}`}
                                                >
                                                    MODE: {showCorrupted ? 'CORRUPTED' : 'NORMAL'}
                                                </button>
                                            )}
                                        </div>
                                        <button
                                            onClick={() => setShowShop(false)}
                                            className="px-3 py-1 bg-black text-white font-mono text-xs hover:bg-gray-800"
                                        >
                                            CLOSE
                                        </button>
                                    </div>
                                    <div className="font-mono text-xs text-gray-500 mb-4">
                                        BALANCE: <span className="text-black font-bold">{formatNumber(gameState.clicks)}</span>
                                    </div>

                                    {shopItems.map(category => (
                                        <div key={category.category} className="mb-4">
                                            <div className="font-mono text-xs font-bold text-black border-b border-black/30 pb-1 mb-1">
                                                {category.category}
                                            </div>
                                            {category.desc && <div className="font-mono text-[9px] text-gray-500 mb-2">{category.desc}</div>}
                                            <div className="grid grid-cols-2 gap-2">
                                                {category.items.map(item => (
                                                    <button
                                                        key={item.id}
                                                        onClick={() => buyUpgrade(item)}
                                                        disabled={!canBuy(item)}
                                                        className={`p-2 border text-left font-mono text-[10px] transition-all ${gameState.upgrades[item.id]
                                                            ? 'bg-white border-black text-black'
                                                            : isLocked(item)
                                                                ? 'bg-white border-gray-200 text-gray-300 cursor-not-allowed'
                                                                : canBuy(item)
                                                                    ? 'bg-black border-black text-white hover:bg-gray-800 cursor-pointer'
                                                                    : 'bg-white border-gray-400 text-gray-500'
                                                            }`}
                                                    >
                                                        <div className="font-bold">{item.name}</div>
                                                        <div className="text-[8px] opacity-70">{item.desc}</div>
                                                        <div className={`mt-1 ${gameState.upgrades[item.id] ? 'text-black' : canBuy(item) ? 'text-white' : 'text-gray-400'}`}>
                                                            {gameState.upgrades[item.id] ? 'OWNED' : isLocked(item) ? 'LOCKED' : formatNumber(getActualCost(item.cost))}
                                                        </div>
                                                    </button>
                                                ))}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}
                    </div>

                    <div className="p-2 border-t-2 border-white bg-black text-center">
                        <span className="font-mono text-[10px] text-gray-500">
                            {gameStarted ? 'TAP PLANET TO EARN  BUY UPGRADES IN SHOP' : 'EXPLORE THE GLOBE  CLICK BUTTON TO START MINING'}
                        </span>
                    </div>
                </div>
            );
        };

        // --- POMODORO.EXE - Timer with growing plant ---
        const PomodoroApp = () => {
            const [mode, setMode] = useState('work'); // 'work' or 'break'
            const [timeLeft, setTimeLeft] = useState(25 * 60); // 25 minutes
            const [isRunning, setIsRunning] = useState(false);
            const [sessions, setSessions] = useState(0);
            const [view, setView] = useState('timer'); // 'timer' or 'room'
            const [totalTime, setTotalTime] = useState(0); // total seconds spent
            const [flowers, setFlowers] = useState([]); // collected flowers
            const [currentFlower, setCurrentFlower] = useState(null); // flower for current session

            const WORK_TIME = 25 * 60;
            const BREAK_TIME = 5 * 60;

            // 5 pot styles, 5 stem/leaf types, 5 flower types = 125 combinations
            const POT_STYLES = [
                { color: '#8B4513', rimColor: '#654321', shape: 'classic' },
                { color: '#4a4a4a', rimColor: '#2a2a2a', shape: 'modern' },
                { color: '#CD853F', rimColor: '#8B4513', shape: 'terracotta' },
                { color: '#1a1a1a', rimColor: '#000000', shape: 'sleek' },
                { color: '#708090', rimColor: '#4a4a4a', shape: 'stone' }
            ];
            const STEM_TYPES = [
                { leafStyle: 'round', stemColor: '#228B22' },
                { leafStyle: 'pointed', stemColor: '#006400' },
                { leafStyle: 'droopy', stemColor: '#32CD32' },
                { leafStyle: 'spiral', stemColor: '#2E8B57' },
                { leafStyle: 'minimal', stemColor: '#3CB371' }
            ];
            const FLOWER_TYPES = [
                { petalColor: '#FF69B4', centerColor: '#FFD700', shape: 'tulip' },
                { petalColor: '#FF4500', centerColor: '#FFA500', shape: 'rose' },
                { petalColor: '#9370DB', centerColor: '#FFD700', shape: 'daisy' },
                { petalColor: '#00CED1', centerColor: '#FFFFFF', shape: 'lotus' },
                { petalColor: '#FFD700', centerColor: '#8B4513', shape: 'sunflower' }
            ];

            // Load saved data on mount
            useEffect(() => {
                const saved = localStorage.getItem('pomodoro_data');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        setTotalTime(data.totalTime || 0);
                        setFlowers(data.flowers || []);
                        setSessions(data.sessions || 0);
                    } catch (e) {}
                }
                // Generate flower for this session
                setCurrentFlower({
                    pot: Math.floor(Math.random() * 5),
                    stem: Math.floor(Math.random() * 5),
                    flower: Math.floor(Math.random() * 5),
                    id: Date.now()
                });
            }, []);

            // Save data whenever it changes
            useEffect(() => {
                localStorage.setItem('pomodoro_data', JSON.stringify({
                    totalTime, flowers, sessions
                }));
            }, [totalTime, flowers, sessions]);

            useEffect(() => {
                if (!isRunning) return;

                const interval = setInterval(() => {
                    if (mode === 'work') {
                        setTotalTime(t => t + 1); // Track total time
                    }
                    setTimeLeft(prev => {
                        if (prev <= 1) {
                            if (mode === 'work') {
                                setMode('break');
                                setSessions(s => s + 1);
                                // Add completed flower to collection
                                if (currentFlower) {
                                    setFlowers(f => [...f, { ...currentFlower, completedAt: Date.now() }]);
                                    // Generate new flower for next session
                                    setCurrentFlower({
                                        pot: Math.floor(Math.random() * 5),
                                        stem: Math.floor(Math.random() * 5),
                                        flower: Math.floor(Math.random() * 5),
                                        id: Date.now()
                                    });
                                }
                                return BREAK_TIME;
                            } else {
                                setMode('work');
                                return WORK_TIME;
                            }
                        }
                        return prev - 1;
                    });
                }, 1000);

                return () => clearInterval(interval);
            }, [isRunning, mode, currentFlower]);

            const progress = mode === 'work'
                ? 1 - (timeLeft / WORK_TIME)
                : 1 - (timeLeft / BREAK_TIME);

            const formatTime = (seconds) => {
                const m = Math.floor(seconds / 60);
                const s = seconds % 60;
                return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
            };

            const formatTotalTime = (seconds) => {
                const h = Math.floor(seconds / 3600);
                const m = Math.floor((seconds % 3600) / 60);
                return `${h}h ${m}m`;
            };

            const reset = () => {
                setIsRunning(false);
                setMode('work');
                setTimeLeft(WORK_TIME);
            };

            // Render a flower with specific style indices
            const renderFlower = (potIdx, stemIdx, flowerIdx, growth = 1, size = 1, isSleeping = false) => {
                const pot = POT_STYLES[potIdx];
                const stem = STEM_TYPES[stemIdx];
                const flowerType = FLOWER_TYPES[flowerIdx];
                const w = 24 * size;
                const h = 32 * size;

                return (
                    <svg width={w * 5} height={h * 5} viewBox="0 0 24 32" style={{ imageRendering: 'pixelated' }}>
                        {/* Pot based on style */}
                        <rect x="6" y="26" width="12" height="6" fill="#000" />
                        <rect x="7" y="27" width="10" height="4" fill={pot.color} />
                        <rect x="6" y="26" width="12" height="1" fill={pot.rimColor} />

                        {/* Soil */}
                        <rect x="7" y="25" width="10" height="2" fill="#333" />

                        {/* Stem */}
                        {growth > 0 && <rect x="11" y={25 - Math.floor(growth * 12)} width="2" height={Math.floor(growth * 12)} fill={stem.stemColor} />}

                        {/* Leaves based on stem type */}
                        {growth > 0.2 && stem.leafStyle === 'round' && (
                            <><rect x="9" y="21" width="2" height="2" fill={stem.stemColor} /><rect x="8" y="20" width="2" height="2" fill={stem.stemColor} /></>
                        )}
                        {growth > 0.2 && stem.leafStyle === 'pointed' && (
                            <><rect x="9" y="21" width="2" height="1" fill={stem.stemColor} /><rect x="8" y="20" width="2" height="1" fill={stem.stemColor} /></>
                        )}
                        {growth > 0.2 && stem.leafStyle === 'droopy' && (
                            <><rect x="9" y="22" width="2" height="2" fill={stem.stemColor} /><rect x="7" y="23" width="2" height="1" fill={stem.stemColor} /></>
                        )}
                        {growth > 0.2 && stem.leafStyle === 'spiral' && (
                            <><rect x="9" y="21" width="1" height="2" fill={stem.stemColor} /><rect x="8" y="22" width="1" height="1" fill={stem.stemColor} /></>
                        )}
                        {growth > 0.2 && stem.leafStyle === 'minimal' && (
                            <rect x="9" y="21" width="2" height="1" fill={stem.stemColor} />
                        )}

                        {growth > 0.4 && (
                            <><rect x="13" y="18" width="2" height="2" fill={stem.stemColor} /><rect x="14" y="17" width="2" height="2" fill={stem.stemColor} /></>
                        )}
                        {growth > 0.6 && (
                            <><rect x="8" y="15" width="2" height="2" fill={stem.stemColor} /><rect x="7" y="14" width="2" height="2" fill={stem.stemColor} /></>
                        )}
                        {growth > 0.8 && (
                            <><rect x="13" y="12" width="2" height="2" fill={stem.stemColor} /><rect x="14" y="11" width="2" height="2" fill={stem.stemColor} /></>
                        )}

                        {/* Flower head based on type */}
                        {growth >= 1 && flowerType.shape === 'tulip' && (
                            <><rect x="10" y="9" width="4" height="4" fill={flowerType.petalColor} /><rect x="11" y="8" width="2" height="1" fill={flowerType.petalColor} /><rect x="11" y="10" width="2" height="2" fill={flowerType.centerColor} /></>
                        )}
                        {growth >= 1 && flowerType.shape === 'rose' && (
                            <><rect x="9" y="9" width="6" height="4" fill={flowerType.petalColor} /><rect x="10" y="8" width="4" height="1" fill={flowerType.petalColor} /><rect x="11" y="10" width="2" height="2" fill={flowerType.centerColor} /></>
                        )}
                        {growth >= 1 && flowerType.shape === 'daisy' && (
                            <><rect x="11" y="7" width="2" height="6" fill={flowerType.petalColor} /><rect x="9" y="9" width="6" height="2" fill={flowerType.petalColor} /><rect x="11" y="9" width="2" height="2" fill={flowerType.centerColor} /></>
                        )}
                        {growth >= 1 && flowerType.shape === 'lotus' && (
                            <><rect x="10" y="8" width="4" height="5" fill={flowerType.petalColor} /><rect x="9" y="10" width="6" height="2" fill={flowerType.petalColor} /><rect x="11" y="10" width="2" height="2" fill={flowerType.centerColor} /></>
                        )}
                        {growth >= 1 && flowerType.shape === 'sunflower' && (
                            <><rect x="9" y="8" width="6" height="5" fill={flowerType.petalColor} /><rect x="10" y="9" width="4" height="3" fill={flowerType.centerColor} /></>
                        )}

                        {/* Sleeping ZZZ */}
                        {isSleeping && (
                            <><rect x="16" y="6" width="4" height="1" fill="#000" /><rect x="19" y="5" width="1" height="2" fill="#000" /><rect x="17" y="4" width="3" height="1" fill="#000" /></>
                        )}
                    </svg>
                );
            };

            // Render current growing plant
            const renderPlant = () => {
                const isSleeping = mode === 'break';
                const growth = mode === 'work' ? progress : 1;
                if (!currentFlower) return null;
                return renderFlower(currentFlower.pot, currentFlower.stem, currentFlower.flower, growth, 1, isSleeping);
            };

            // Flower Room view
            const renderFlowerRoom = () => {
                const shelves = [];
                const flowersPerShelf = 5;
                const shelfCount = Math.ceil(flowers.length / flowersPerShelf);
                for (let i = 0; i < shelfCount; i++) {
                    shelves.push(flowers.slice(i * flowersPerShelf, (i + 1) * flowersPerShelf));
                }

                return (
                    <div className="flex-grow overflow-auto bg-gray-100 p-4">
                        <div className="text-center mb-4">
                            <div className="font-mono text-xs text-gray-500">TOTAL FOCUS TIME</div>
                            <div className="font-mono text-2xl font-bold">{formatTotalTime(totalTime)}</div>
                        </div>
                        {flowers.length === 0 ? (
                            <div className="text-center py-12">
                                <div className="font-mono text-gray-500 text-sm">Empty so far, get productive!</div>
                            </div>
                        ) : (
                            shelves.map((shelf, shelfIdx) => (
                                <div key={shelfIdx} className="mb-2">
                                    <div className="flex justify-center gap-1 pb-1">
                                        {shelf.map((f, idx) => (
                                            <div key={f.id} className="w-16 h-20 flex items-end justify-center">
                                                <svg width="48" height="64" viewBox="0 0 24 32" style={{ imageRendering: 'pixelated' }}>
                                                    {/* Mini flower */}
                                                    <rect x="6" y="26" width="12" height="6" fill="#000" />
                                                    <rect x="7" y="27" width="10" height="4" fill={POT_STYLES[f.pot].color} />
                                                    <rect x="7" y="25" width="10" height="2" fill="#333" />
                                                    <rect x="11" y="13" width="2" height="12" fill={STEM_TYPES[f.stem].stemColor} />
                                                    <rect x="9" y="17" width="2" height="2" fill={STEM_TYPES[f.stem].stemColor} />
                                                    <rect x="13" y="20" width="2" height="2" fill={STEM_TYPES[f.stem].stemColor} />
                                                    <rect x="9" y="9" width="6" height="5" fill={FLOWER_TYPES[f.flower].petalColor} />
                                                    <rect x="10" y="10" width="4" height="3" fill={FLOWER_TYPES[f.flower].centerColor} />
                                                </svg>
                                            </div>
                                        ))}
                                    </div>
                                    <div className="h-2 bg-gradient-to-b from-amber-800 to-amber-900 border-t-2 border-amber-700 mx-4" />
                                </div>
                            ))
                        )}
                        <div className="text-center mt-4 font-mono text-[10px] text-gray-400">
                            {flowers.length} FLOWER{flowers.length !== 1 ? 'S' : ''} COLLECTED  125 POSSIBLE VARIETIES
                        </div>
                    </div>
                );
            };

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex justify-between items-center">
                        <div className="flex items-center gap-2">
                            <Icons.Pomodoro size={24} />
                            <span className="font-mono text-xs font-bold">POMODORO.EXE</span>
                        </div>
                        <div className="flex items-center gap-2">
                            <span className="font-mono text-[10px] text-gray-500">SESSIONS: {sessions}</span>
                            <button
                                onClick={() => setView(view === 'timer' ? 'room' : 'timer')}
                                className={`px-2 py-1 font-mono text-[10px] border-2 border-black ${view === 'room' ? 'bg-black text-white' : 'bg-white text-black hover:bg-gray-100'}`}
                            >
                                {view === 'timer' ? 'ROOM' : 'TIMER'}
                            </button>
                        </div>
                    </div>

                    {view === 'room' ? renderFlowerRoom() : (
                        <div className="flex-grow flex flex-col items-center justify-center bg-gray-50 p-6">
                            {/* Mode indicator */}
                            <div className={`px-4 py-1 mb-4 font-mono text-xs font-bold ${mode === 'work' ? 'bg-black text-white' : 'bg-gray-300 text-black'}`}>
                                {mode === 'work' ? 'FOCUS TIME' : 'BREAK TIME'}
                            </div>

                            {/* Plant */}
                            <div className="mb-6">
                                {renderPlant()}
                            </div>

                            {/* Timer */}
                            <div className="font-mono text-5xl font-black mb-6 tracking-wider">
                                {formatTime(timeLeft)}
                            </div>

                            {/* Progress bar */}
                            <div className="w-48 h-2 bg-gray-200 border-2 border-black mb-6">
                                <div
                                    className="h-full bg-black transition-all duration-1000"
                                    style={{ width: `${progress * 100}%` }}
                                />
                            </div>

                            {/* Controls */}
                            <div className="flex gap-4">
                                <button
                                    onClick={() => setIsRunning(!isRunning)}
                                    className="px-6 py-3 bg-black text-white font-mono font-bold text-sm hover:invert border-2 border-black"
                                >
                                    {isRunning ? 'PAUSE' : 'START'}
                                </button>
                                <button
                                    onClick={reset}
                                    className="px-6 py-3 bg-white text-black font-mono font-bold text-sm hover:bg-black hover:text-white border-2 border-black"
                                >
                                    RESET
                                </button>
                            </div>
                        </div>
                    )}

                    <div className="p-2 border-t-2 border-black bg-white text-center">
                        <span className="font-mono text-[10px] text-gray-500">
                            {view === 'room' ? `TOTAL: ${formatTotalTime(totalTime)}` : (mode === 'work' ? 'GROW YOUR FOCUS' : 'PLANT IS RESTING')}
                        </span>
                    </div>
                </div>
            );
        };

        // --- SCANNER.EXE - Embedded health score app ---
        const HealthScannerApp = () => {
            const [booting, setBooting] = useState(true);
            const [bootText, setBootText] = useState('');

            useEffect(() => {
                const bootSequence = [
                    'HEALTH SCANNER INDUSTRIES',
                    '',
                    'INITIALIZING BIOMETRIC SENSORS...',
                    'LOADING NEURAL INTERFACE...',
                    'CALIBRATING HEALTH MATRIX...',
                    '',
                    'SYSTEM READY'
                ];

                let lineIndex = 0;
                let charIndex = 0;
                let currentText = '';

                const typeInterval = setInterval(() => {
                    if (lineIndex >= bootSequence.length) {
                        clearInterval(typeInterval);
                        setTimeout(() => setBooting(false), 500);
                        return;
                    }

                    const currentLine = bootSequence[lineIndex];
                    if (charIndex < currentLine.length) {
                        currentText += currentLine[charIndex];
                        setBootText(currentText);
                        charIndex++;
                    } else {
                        currentText += '\n';
                        setBootText(currentText);
                        lineIndex++;
                        charIndex = 0;
                    }
                }, 30);

                return () => clearInterval(typeInterval);
            }, []);

            if (booting) {
                return (
                    <div className="h-full flex flex-col bg-black select-none">
                        <div className="flex-grow flex flex-col items-center justify-center p-8 font-mono">
                            <div className="text-green-500 text-center whitespace-pre-line text-sm mb-8">
                                {bootText}
                                <span className="animate-pulse">_</span>
                            </div>
                            <div className="flex gap-2">
                                <div className="w-3 h-3 bg-green-500 animate-pulse" style={{ animationDelay: '0ms' }}></div>
                                <div className="w-3 h-3 bg-green-500 animate-pulse" style={{ animationDelay: '150ms' }}></div>
                                <div className="w-3 h-3 bg-green-500 animate-pulse" style={{ animationDelay: '300ms' }}></div>
                            </div>
                        </div>
                        <div className="p-2 border-t border-green-900 text-center">
                            <span className="font-mono text-[10px] text-green-700"> HEALTH SCANNER INDUSTRIES 2077</span>
                        </div>
                    </div>
                );
            }

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <iframe
                        src="https://healthscore-2-0.vercel.app/"
                        className="w-full h-full border-0"
                        title="Health Scanner"
                        allow="camera; microphone"
                    />
                </div>
            );
        };

        // --- PERSONAL.EXE - Password Protected (never opens) ---
        const PersonalApp = () => {
            const [password, setPassword] = useState('');
            const [attempts, setAttempts] = useState(0);
            const [error, setError] = useState('');
            const [shaking, setShaking] = useState(false);

            const handleSubmit = (e) => {
                e.preventDefault();
                setAttempts(a => a + 1);
                setShaking(true);
                setTimeout(() => setShaking(false), 500);

                const errors = [
                    'ACCESS DENIED',
                    'INVALID CREDENTIALS',
                    'AUTHENTICATION FAILED',
                    'PERMISSION DENIED',
                    'UNAUTHORIZED ACCESS',
                    'INCORRECT PASSWORD',
                    'SECURITY VIOLATION',
                    'ACCESS RESTRICTED',
                    'VERIFICATION FAILED',
                    'ENTRY PROHIBITED'
                ];
                setError(errors[Math.floor(Math.random() * errors.length)]);
                setPassword('');
            };

            return (
                <div className="h-full flex flex-col bg-black select-none">
                    <div className="p-2 border-b border-red-900 bg-black flex items-center gap-2">
                        <Icons.Lock size={20} />
                        <span className="font-mono text-xs font-bold text-red-500">PERSONAL.EXE</span>
                        <span className="font-mono text-[10px] text-red-700">ENCRYPTED</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center p-8">
                        <div className="mb-8">
                            <Icons.Lock size={64} />
                        </div>
                        <div className="font-mono text-red-500 text-lg font-bold mb-2">SECURE AREA</div>
                        <div className="font-mono text-red-700 text-[10px] mb-6">AUTHORIZATION REQUIRED</div>

                        <form onSubmit={handleSubmit} className={`w-64 ${shaking ? 'animate-shake' : ''}`}>
                            <div className="mb-4">
                                <input
                                    type="password"
                                    value={password}
                                    onChange={(e) => setPassword(e.target.value)}
                                    placeholder="ENTER PASSWORD"
                                    className="w-full px-4 py-2 bg-black border-2 border-red-800 text-red-500 font-mono text-sm placeholder-red-900 focus:outline-none focus:border-red-500"
                                />
                            </div>
                            <button
                                type="submit"
                                className="w-full px-4 py-2 bg-red-900 text-red-100 font-mono text-sm font-bold hover:bg-red-800 border-2 border-red-700"
                            >
                                AUTHENTICATE
                            </button>
                        </form>

                        {error && (
                            <div className="mt-6 p-3 border border-red-800 bg-red-950">
                                <div className="font-mono text-red-500 text-sm font-bold">{error}</div>
                            </div>
                        )}

                        {attempts > 0 && (
                            <div className="mt-4 font-mono text-red-800 text-[10px]">
                                FAILED ATTEMPTS: {attempts}
                            </div>
                        )}

                        {attempts >= 5 && (
                            <div className="mt-2 font-mono text-red-600 text-[10px] animate-pulse">
                                WARNING: SECURITY PROTOCOL ACTIVATED
                            </div>
                        )}
                    </div>
                    <div className="p-2 border-t border-red-900 text-center">
                        <span className="font-mono text-[10px] text-red-800">CLASSIFIED  TOP SECRET  EYES ONLY</span>
                    </div>
                </div>
            );
        };

        // --- APPS Folder - Grid of all apps organized in folders ---
        const AppsFolder = ({ onOpenApp }) => {
            const [selectedFolder, setSelectedFolder] = useState(null);

            const folders = [
                { key: 'GAMES', name: 'GAMES', icon: 'GamesFolder' },
                { key: 'PRODUCTIVITY', name: 'PRODUCTIVITY', icon: 'ProductivityFolder' },
                { key: 'ABOUT', name: 'ABOUT', icon: 'AboutFolder' }
            ];

            const APP_CATEGORIES = {
                GAMES: [
                    { id: 'SNAKE', title: 'SNEK.EXE', icon: 'Snek' },
                    { id: 'LABYRINTH', title: 'LABYRINTH.EXE', icon: 'Labyrinth' },
                    { id: 'MINESWEEPER', title: 'MINESWEEPER.EXE', icon: 'Minesweeper' },
                    { id: 'STARSHIP', title: 'STARSHIP.EXE', icon: 'Starship' },
                    { id: 'DICE', title: 'DICE.EXE', icon: 'Dice' }
                ],
                PRODUCTIVITY: [
                    { id: 'PAINT', title: 'PAINT.EXE', icon: 'Palette' },
                    { id: 'POMODORO', title: 'POMODORO.EXE', icon: 'Pomodoro' },
                    { id: 'SYNTH', title: 'SYNTH_001.WAV', icon: 'Synth' },
                    { id: 'RADIO', title: 'RADIO.WAV', icon: 'Radio' },
                    { id: 'SCANNER', title: 'SCANNER.EXE', icon: 'HealthScanner' },
                    { id: 'ORACLE', title: 'ORACLE.EXE', icon: 'Oracle' },
                    { id: 'TAROT', title: 'TAROT.DAT', icon: 'Tarot' },
                    { id: 'VOID', title: 'VOID.TXT', icon: 'Void' }
                ],
                ABOUT: [
                    { id: 'SYSTEM', title: 'ABOUT_SHORTCUT.EXE', icon: 'Terminal', isShortcut: true },
                    { id: 'GALLERY', title: 'GALLERY.EXE', icon: 'Gallery' },
                    { id: 'MAP', title: 'MAP.EXE', icon: 'Globe' },
                    { id: 'PERSONAL', title: 'PERSONAL.EXE', icon: 'Lock' },
                    { id: 'DESTRUCTION', title: 'DESTRUCTION.EXE', icon: 'Destruction' },
                    { id: 'TRASH', title: 'TRASH.BIN', icon: 'TrashCan' }
                ]
            };

            if (selectedFolder) {
                const FolderIcon = Icons[folders.find(f => f.key === selectedFolder)?.icon || 'FolderClosed'];
                const apps = APP_CATEGORIES[selectedFolder];
                return (
                    <div className="h-full flex flex-col bg-white select-none">
                        <div className="p-2 border-b-2 border-black bg-white flex items-center gap-3">
                            <button onClick={() => setSelectedFolder(null)} className="p-1 border-2 border-black hover:bg-black hover:text-white">
                                <Icons.Back size={16} />
                            </button>
                            <FolderIcon size={24} />
                            <span className="font-mono text-xs font-bold uppercase">{folders.find(f => f.key === selectedFolder)?.name}</span>
                            <span className="font-mono text-[10px] text-gray-500">({apps.length} ITEMS)</span>
                        </div>
                        <div className="flex-grow overflow-auto">
                            <table className="w-full text-left border-collapse">
                                <thead className="bg-black text-white text-xs font-mono sticky top-0">
                                    <tr><th className="p-2">NAME</th><th className="p-2 border-l border-gray-600">TYPE</th></tr>
                                </thead>
                                <tbody className="font-mono text-xs">
                                    {apps.map((app, idx) => {
                                        const AppIcon = Icons[app.icon];
                                        return (
                                            <tr key={idx}
                                                onClick={() => onOpenApp(app.id)}
                                                className="border-b border-gray-200 hover:bg-yellow-100 cursor-pointer"
                                            >
                                                <td className="p-2 font-bold flex items-center gap-2">
                                                    <AppIcon size={20} />
                                                    {app.title}
                                                    {app.isShortcut && <span className="text-[8px] text-gray-400 ml-1">(SHORTCUT)</span>}
                                                </td>
                                                <td className="p-2 border-l border-gray-200 text-gray-500">
                                                    {app.title.split('.').pop()}
                                                </td>
                                            </tr>
                                        );
                                    })}
                                </tbody>
                            </table>
                        </div>
                        <div className="p-2 border-t-2 border-black bg-white text-center">
                            <span className="font-mono text-[10px] text-gray-500">CLICK TO OPEN  DOUBLE-CLICK TO RUN</span>
                        </div>
                    </div>
                );
            }

            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex items-center gap-2">
                        <Icons.Apps size={24} />
                        <span className="font-mono text-xs font-bold">APPS</span>
                        <span className="font-mono text-[10px] text-gray-500">/ROOT/APPS</span>
                    </div>
                    <div className="flex-grow p-6 flex items-start justify-center bg-gray-50">
                        <div className="grid grid-cols-3 gap-8">
                            {folders.map(folder => {
                                const FolderIcon = Icons[folder.icon];
                                return (
                                    <button
                                        key={folder.key}
                                        onClick={() => setSelectedFolder(folder.key)}
                                        className="group flex flex-col items-center gap-2 p-4 hover:bg-white border-2 border-transparent hover:border-black transition-all"
                                    >
                                        <div className="bg-white border-2 border-black p-3 icon-shadow group-hover:translate-x-1 group-hover:translate-y-1 group-hover:shadow-none transition-all">
                                            <FolderIcon size={48} />
                                        </div>
                                        <span className="font-mono text-xs font-bold uppercase">{folder.name}</span>
                                        <span className="font-mono text-[10px] text-gray-500">{APP_CATEGORIES[folder.key].length} ITEMS</span>
                                    </button>
                                );
                            })}
                        </div>
                    </div>
                    <div className="p-2 border-t-2 border-black bg-white text-center">
                        <span className="font-mono text-[10px] text-gray-500">GAMES  PRODUCTIVITY  ABOUT</span>
                    </div>
                </div>
            );
        };

        // --- CONTACT - Email via Paint ---
        const ContactApp = ({ onOpenPaint }) => {
            return (
                <div className="h-full flex flex-col bg-white select-none">
                    <div className="p-2 border-b-2 border-black bg-white flex items-center gap-2">
                        <Icons.Email size={24} />
                        <span className="font-mono text-xs font-bold">CONTACT</span>
                    </div>
                    <div className="flex-grow flex flex-col items-center justify-center bg-gray-50 p-8">
                        <Icons.Email size={64} />
                        <div className="font-mono text-lg font-bold mt-4 mb-2">GET IN TOUCH</div>
                        <div className="font-mono text-sm text-gray-500 mb-6">mateusmuste9@gmail.com</div>
                        <button
                            onClick={onOpenPaint}
                            className="px-6 py-3 bg-black text-white font-mono font-bold text-sm hover:invert border-2 border-black"
                        >
                            DRAW YOUR MESSAGE
                        </button>
                        <div className="font-mono text-[10px] text-gray-400 mt-4">
                            Opens PAINT.EXE
                        </div>
                    </div>
                </div>
            );
        };

        // --- OS SHELL ---

        const OS = () => {
            const [booted, setBooted] = useState(false);
            const [bootPhase, setBootPhase] = useState(0); // 0: kernel, 1: mobile warning, 2: ready
            const [isMobile, setIsMobile] = useState(false);
            const [topZ, setTopZ] = useState(100);
            const topZRef = useRef(100);
            const [destructionMode, setDestructionMode] = useState(false);
            const [dogReleased, setDogReleased] = useState(false);
            const [dogPos, setDogPos] = useState({ x: 100, y: 300 });
            const [dogVel, setDogVel] = useState({ x: 4, y: 3 });
            const [dogOnGround, setDogOnGround] = useState(true);
            const [dogFacingRight, setDogFacingRight] = useState(true);
            const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
            const [carriedIcon, setCarriedIcon] = useState(null);
            const [iconPositions, setIconPositions] = useState({});
            const [destructionDogGone, setDestructionDogGone] = useState(false);

            // Physics constants
            const GRAVITY = 0.8;
            const JUMP_FORCE = -12;
            const GROUND_Y = window.innerHeight - 120;
            const FRICTION = 0.95;

            // Handle dog stealing the destruction button - dog starts running around!
            const handleDogSteal = () => {
                setDestructionDogGone(true);
                setDogReleased(true); // Dog starts running around the screen
                // Close the destruction window
                setWindows(prev => ({
                    ...prev,
                    DESTRUCTION: { ...prev.DESTRUCTION, isOpen: false }
                }));
            };

            // Dog AI - DVD logo style bouncing
            useEffect(() => {
                if (!dogReleased) return;

                const DOG_SPEED_X = 4;
                const DOG_SPEED_Y = 3;

                const dogInterval = setInterval(() => {
                    setDogVel(prevVel => {
                        let newVelX = prevVel.x;
                        let newVelY = prevVel.y;

                        // Initialize velocity if zero
                        if (newVelX === 0) newVelX = DOG_SPEED_X;
                        if (newVelY === 0) newVelY = DOG_SPEED_Y;

                        return { x: newVelX, y: newVelY };
                    });

                    setDogPos(prev => {
                        let newX = prev.x + dogVel.x;
                        let newY = prev.y + dogVel.y;

                        // Bounce off walls - DVD style
                        if (newX >= window.innerWidth - 80) {
                            newX = window.innerWidth - 80;
                            setDogVel(v => ({ ...v, x: -Math.abs(v.x) }));
                            setDogFacingRight(false);
                        }
                        if (newX <= 0) {
                            newX = 0;
                            setDogVel(v => ({ ...v, x: Math.abs(v.x) }));
                            setDogFacingRight(true);
                        }
                        if (newY >= window.innerHeight - 100) {
                            newY = window.innerHeight - 100;
                            setDogVel(v => ({ ...v, y: -Math.abs(v.y) }));
                        }
                        if (newY <= 60) {
                            newY = 60;
                            setDogVel(v => ({ ...v, y: Math.abs(v.y) }));
                        }

                        return { x: newX, y: newY };
                    });

                    // Randomly grab icons
                    if (!carriedIcon && Math.random() < 0.003) {
                        const iconKeys = Object.keys(windows);
                        const randomIcon = iconKeys[Math.floor(Math.random() * iconKeys.length)];
                        setCarriedIcon(randomIcon);

                        setTimeout(() => {
                            setCarriedIcon(null);
                        }, 3000 + Math.random() * 4000);
                    }
                }, 30);

                return () => clearInterval(dogInterval);
            }, [dogReleased, dogVel, carriedIcon]);

            // Desktop icons - only show main folders
            const desktopIcons = ["SYSTEM", "FILES", "APPS", "CONTACT"];

            // Window State (Position x/y added for dragging) - content rendered separately
            const [windows, setWindows] = useState({
                "SYSTEM": { id: "SYSTEM", title: "SYSTEM_INFO", icon: "Terminal", x: 400, y: 50, w: '1000px', h: '800px', isOpen: true, isMin: false, z: 10, isDesktop: true },
                "FILES": { id: "FILES", title: "MEDIA_LIB", icon: "Folder", x: 100, y: 80, w: '800px', h: '500px', isOpen: false, isMin: false, z: 11, isDesktop: true },
                "APPS": { id: "APPS", title: "APPS", icon: "Apps", x: 150, y: 110, w: '700px', h: '500px', isOpen: false, isMin: false, z: 12, isDesktop: true },
                "CONTACT": { id: "CONTACT", title: "CONTACT", icon: "Email", x: 200, y: 140, w: '400px', h: '350px', isOpen: false, isMin: false, z: 13, isDesktop: true },
                "PAINT": { id: "PAINT", title: "PAINT.EXE", icon: "Palette", x: 150, y: 110, w: '700px', h: '600px', isOpen: false, isMin: false, z: 14 },
                "SNAKE": { id: "SNAKE", title: "SNEK.EXE", icon: "Snek", x: 200, y: 140, w: '640px', h: '520px', isOpen: false, isMin: false, z: 15 },
                "TRASH": { id: "TRASH", title: "TRASH.BIN", icon: "TrashCan", x: 250, y: 170, w: '500px', h: '400px', isOpen: false, isMin: false, z: 16 },
                "VOID": { id: "VOID", title: "VOID.TXT", icon: "Void", x: 300, y: 50, w: '500px', h: '400px', isOpen: false, isMin: false, z: 17 },
                "ORACLE": { id: "ORACLE", title: "ORACLE.EXE", icon: "Oracle", x: 350, y: 80, w: '500px', h: '450px', isOpen: false, isMin: false, z: 18 },
                "RADIO": { id: "RADIO", title: "RADIO.WAV", icon: "Radio", x: 400, y: 110, w: '400px', h: '400px', isOpen: false, isMin: false, z: 19 },
                "DICE": { id: "DICE", title: "DICE.EXE", icon: "Dice", x: 450, y: 140, w: '350px', h: '450px', isOpen: false, isMin: false, z: 20 },
                "LABYRINTH": { id: "LABYRINTH", title: "LABYRINTH.EXE", icon: "Labyrinth", x: 100, y: 50, w: '600px', h: '500px', isOpen: false, isMin: false, z: 21 },
                "MINESWEEPER": { id: "MINESWEEPER", title: "MINESWEEPER.EXE", icon: "Minesweeper", x: 120, y: 40, w: '500px', h: '560px', isOpen: false, isMin: false, z: 26 },
                "STARSHIP": { id: "STARSHIP", title: "STARSHIP.EXE", icon: "Starship", x: 80, y: 40, w: '540px', h: '480px', isOpen: false, isMin: false, z: 27 },
                "SYNTH": { id: "SYNTH", title: "SYNTH_001.WAV", icon: "Synth", x: 150, y: 80, w: '500px', h: '350px', isOpen: false, isMin: false, z: 22 },
                "DESTRUCTION": { id: "DESTRUCTION", title: "DESTRUCTION.EXE", icon: "Destruction", x: 200, y: 110, w: '400px', h: '400px', isOpen: false, isMin: false, z: 23 },
                "TAROT": { id: "TAROT", title: "TAROT.DAT", icon: "Tarot", x: 250, y: 140, w: '350px', h: '450px', isOpen: false, isMin: false, z: 24 },
                "GALLERY": { id: "GALLERY", title: "GALLERY.EXE", icon: "Gallery", x: 100, y: 80, w: '500px', h: '500px', isOpen: false, isMin: false, z: 28 },
                "MAP": { id: "MAP", title: "MAP.EXE", icon: "Globe", x: 150, y: 100, w: '550px', h: '500px', isOpen: false, isMin: false, z: 29 },
                "POMODORO": { id: "POMODORO", title: "POMODORO.EXE", icon: "Pomodoro", x: 200, y: 60, w: '350px', h: '620px', isOpen: false, isMin: false, z: 30 },
                "SCANNER": { id: "SCANNER", title: "SCANNER.EXE", icon: "HealthScanner", x: 150, y: 50, w: '600px', h: '700px', isOpen: false, isMin: false, z: 31 },
                "PERSONAL": { id: "PERSONAL", title: "PERSONAL.EXE", icon: "Lock", x: 200, y: 80, w: '400px', h: '500px', isOpen: false, isMin: false, z: 32 }
            });

            // Render window content based on ID
            const getWindowContent = (id) => {
                switch (id) {
                    case "SYSTEM": return <SystemInfo />;
                    case "FILES": return <FileExplorer />;
                    case "APPS": return <AppsFolder onOpenApp={open} />;
                    case "CONTACT": return <ContactApp onOpenPaint={() => open("PAINT")} />;
                    case "PAINT": return <PaintApp />;
                    case "SNAKE": return <SnakeAppNew />;
                    case "TRASH": return <TrashApp />;
                    case "VOID": return <VoidApp />;
                    case "ORACLE": return <OracleApp />;
                    case "RADIO": return <RadioApp />;
                    case "DICE": return <DiceApp />;
                    case "LABYRINTH": return <LabyrinthApp />;
                    case "MINESWEEPER": return <MinesweeperApp />;
                    case "STARSHIP": return <StarshipApp />;
                    case "SYNTH": return <SynthApp />;
                    case "DESTRUCTION": return <DestructionApp onDogSteal={handleDogSteal} />;
                    case "TAROT": return <TarotApp />;
                    case "GALLERY": return <GalleryApp />;
                    case "MAP": return <MapApp />;
                    case "POMODORO": return <PomodoroApp />;
                    case "SCANNER": return <HealthScannerApp />;
                    case "PERSONAL": return <PersonalApp />;
                    default: return null;
                }
            };

            // Dragging State
            const [drag, setDrag] = useState({ id: null, offsetX: 0, offsetY: 0 });

            // Boot sequence with mobile detection
            useEffect(() => {
                const checkMobile = window.innerWidth < 768 || /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                setIsMobile(checkMobile);

                // Close SYSTEM window on mobile by default
                if (checkMobile) {
                    setWindows(prev => ({
                        ...prev,
                        SYSTEM: { ...prev.SYSTEM, isOpen: false }
                    }));
                }

                // Phase 0: Show "BOOTING_KERNEL..." for 600ms
                setTimeout(() => {
                    if (checkMobile) {
                        // Phase 1: Show mobile warning for 3 seconds
                        setBootPhase(1);
                        setTimeout(() => {
                            setBootPhase(2);
                            setBooted(true);
                        }, 3000);
                    } else {
                        setBootPhase(2);
                        setBooted(true);
                    }
                }, 600);

                // Handle resize
                const handleResize = () => {
                    setIsMobile(window.innerWidth < 768);
                };
                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, []);

            // Window Ops
            const focus = (id) => {
                topZRef.current += 1;
                const newZ = topZRef.current;
                setWindows(p => ({ ...p, [id]: { ...p[id], z: newZ } }));
                setTopZ(newZ);
            }
            const open = (id) => {
                topZRef.current += 1;
                const newZ = topZRef.current;
                setWindows(p => ({ ...p, [id]: { ...p[id], isOpen: true, isMin: false, z: newZ } }));
                setTopZ(newZ);
            }
            const close = (id) => setWindows(p => ({ ...p, [id]: { ...p[id], isOpen: false } }));
            const toggleMin = (id) => setWindows(p => ({ ...p, [id]: { ...p[id], isMin: !p[id].isMin } }));

            // Drag Handlers
            const handleMouseDown = (e, id) => {
                e.preventDefault();
                focus(id); // bring to front
                const win = windows[id];
                const rect = e.currentTarget.getBoundingClientRect(); // click target is header
                // Calculate offset from the window's top-left corner
                // However, we track window X/Y which is top/left style. 
                // Simple math: MouseX - WindowX
                setDrag({
                    id: id,
                    offsetX: e.clientX - win.x,
                    offsetY: e.clientY - win.y
                });
            };

            const handleMouseMove = (e) => {
                if (drag.id) {
                    setWindows(prev => ({
                        ...prev,
                        [drag.id]: {
                            ...prev[drag.id],
                            x: e.clientX - drag.offsetX,
                            y: e.clientY - drag.offsetY
                        }
                    }));
                }
            };

            const handleMouseUp = () => setDrag({ id: null, offsetX: 0, offsetY: 0 });

            // Boot screens
            if (!booted) {
                if (bootPhase === 0) {
                    return <div className="h-screen w-screen bg-black text-white font-mono flex items-center justify-center">BOOTING_KERNEL...</div>;
                }
                if (bootPhase === 1) {
                    return (
                        <div className="h-screen w-screen bg-black text-white font-mono flex flex-col items-center justify-center p-8">
                            <div className="text-center">
                                <div className="text-2xl font-bold mb-4 animate-pulse">NOTICE</div>
                                <div className="text-lg mb-2">BEST VIEWED ON DESKTOP</div>
                                <div className="text-xs text-gray-500 mt-4">Mobile experience may be limited...</div>
                                <div className="mt-8 flex gap-1 justify-center">
                                    <div className="w-2 h-2 bg-white animate-pulse" style={{ animationDelay: '0ms' }}></div>
                                    <div className="w-2 h-2 bg-white animate-pulse" style={{ animationDelay: '200ms' }}></div>
                                    <div className="w-2 h-2 bg-white animate-pulse" style={{ animationDelay: '400ms' }}></div>
                                </div>
                            </div>
                        </div>
                    );
                }
            }

            // Destruction overlay
            if (destructionMode === 'black') {
                return <div className="h-screen w-screen bg-black" />;
            }
            if (destructionMode === 'reboot') {
                return (
                    <div className="h-screen w-screen bg-black text-green-500 font-mono flex flex-col items-center justify-center">
                        <pre className="text-xs mb-4">
                            {`
      
  
          
            
              
                 
`}
                        </pre>
                        <div className="animate-pulse">REBOOTING...</div>
                        <div className="mt-4 text-xs text-green-700">DESTRUCTION COMPLETE</div>
                    </div>
                );
            }

            return (
                <div
                    className={`h-screen w-screen relative overflow-hidden desktop-bg ${destructionMode ? 'animate-pulse' : ''}`}
                    onMouseMove={(e) => {
                        handleMouseMove(e);
                        setMousePos({ x: e.clientX, y: e.clientY });
                    }}
                    onMouseUp={handleMouseUp}
                    style={destructionMode ? { filter: 'hue-rotate(180deg) saturate(3)' } : {}}
                >
                    {/* DESKTOP ICONS - Only show main folders */}
                    <div className={`absolute z-0 ${isMobile ? 'top-4 left-0 right-0 flex flex-row justify-center gap-4 px-2' : 'top-4 left-4 flex flex-col gap-6'}`}>
                        {desktopIcons.map(appId => {
                            const app = windows[appId];
                            if (!app) return null;
                            const IconCmp = Icons[app.icon];
                            const iconOffset = iconPositions[app.id] || { x: 0, y: 0 };

                            // Skip icon if dog is carrying it
                            if (carriedIcon === app.id) return null;

                            return (
                                <button
                                    key={app.id}
                                    onClick={() => open(app.id)}
                                    className={`group flex flex-col items-center gap-1 ${isMobile ? 'w-16' : 'w-24 gap-2'}`}
                                    style={{
                                        transform: isMobile ? 'none' : `translate(${iconOffset.x}px, ${iconOffset.y}px)`,
                                        transition: 'transform 0.3s ease'
                                    }}
                                >
                                    <div className={`bg-white border-2 border-black icon-shadow group-hover:translate-x-1 group-hover:translate-y-1 group-hover:shadow-none transition-all ${isMobile ? 'p-2' : 'p-3'}`}>
                                        <IconCmp size={isMobile ? 24 : 32} />
                                    </div>
                                    <span className={`bg-white border border-black px-1 font-mono font-bold shadow-sm ${isMobile ? 'text-[8px]' : 'text-[10px]'}`}>{isMobile ? app.title.split('_')[0] : app.title}</span>
                                </button>
                            );
                        })}
                    </div>

                    {/* WINDOWS */}
                    {Object.values(windows).map(win => (
                        win.isOpen && !win.isMin && (
                            <div
                                key={win.id}
                                onMouseDown={() => focus(win.id)}
                                className={`flex flex-col bg-white border-2 border-black ${isMobile ? 'fixed inset-0 top-12 bottom-0' : 'absolute window-shadow'}`}
                                style={isMobile ? {
                                    zIndex: win.z
                                } : {
                                    left: win.x,
                                    top: win.y,
                                    width: win.w,
                                    height: win.h,
                                    zIndex: win.z
                                }}
                            >
                                {/* HEADER (DRAG HANDLE) */}
                                <div
                                    className={`flex justify-between items-center p-1 border-b-2 border-black select-none ${isMobile ? '' : 'cursor-move'} ${win.z === topZ ? 'bg-black text-white' : 'bg-gray-200 text-black'}`}
                                    onMouseDown={(e) => !isMobile && handleMouseDown(e, win.id)}
                                >
                                    <div className="flex items-center gap-2 pl-2 pointer-events-none">
                                        <Icons.Square size={10} className="fill-current" />
                                        <span className="font-mono text-xs font-bold tracking-widest uppercase truncate">{win.title}</span>
                                    </div>
                                    <div className="flex gap-1" onMouseDown={e => e.stopPropagation()} onTouchStart={e => e.stopPropagation()}>
                                        {!isMobile && <button onClick={() => toggleMin(win.id)} className="w-6 h-6 flex items-center justify-center border border-transparent hover:bg-white/20"><Icons.Minus size={14} /></button>}
                                        <button onClick={() => close(win.id)} className={`w-10 h-10 md:w-6 md:h-6 flex items-center justify-center hover:bg-red-500 ${win.z === topZ ? 'text-white hover:text-white' : 'text-black hover:text-white'}`}><Icons.X size={24} /></button>
                                    </div>
                                </div>
                                {/* CONTENT */}
                                <div className="flex-grow overflow-auto relative bg-white" onMouseDown={() => focus(win.id)}>
                                    {getWindowContent(win.id)}
                                </div>
                            </div>
                        )
                    ))}

                    {/* TASKBAR */}
                    <div className={`h-12 bg-white flex items-center px-2 gap-1 md:gap-2 z-[99999] absolute w-full shadow-2xl ${isMobile ? 'top-0 border-b-2 border-black' : 'bottom-0 border-t-2 border-black mt-auto'}`}>
                        <div className={`bg-black text-white py-1 font-black select-none tracking-wider ${isMobile ? 'px-1 text-[8px]' : 'px-2 text-xs mr-2'}`}>{isMobile ? 'MM.COM' : 'MATEUSMUSTE.COM'}</div>
                        <div className={`flex gap-1 ${isMobile ? 'overflow-x-auto flex-nowrap' : ''}`}>
                            {Object.values(windows).map(win => {
                                const IconCmp = Icons[win.icon];
                                return win.isOpen && (
                                    <button key={win.id}
                                        onClick={() => { if (win.isMin) toggleMin(win.id); focus(win.id) }}
                                        className={`flex items-center gap-1 md:gap-2 px-2 md:px-3 py-1 border-2 border-black font-mono text-xs font-bold transition-all flex-shrink-0 ${win.z === topZ && !win.isMin ? 'bg-black text-white btn-shadow' : 'bg-white hover:translate-y-[-2px]'}`}
                                    >
                                        <IconCmp size={14} />
                                        <span className="uppercase hidden md:inline">{win.title}</span>
                                    </button>
                                );
                            })}
                        </div>
                        <div className="flex-grow"></div>
                        <div className={`font-mono font-bold border-l-2 border-black ${isMobile ? 'text-[10px] px-2' : 'text-xs px-4'}`}>{new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>
                    </div>

                    {/* DOG - Cute pixel dog with running animation */}
                    {dogReleased && (
                        <div
                            className="fixed z-[999999] cursor-pointer select-none"
                            style={{
                                left: dogPos.x,
                                top: dogPos.y,
                                transform: `scaleX(${dogFacingRight ? 1 : -1})`,
                            }}
                            onClick={() => setDogReleased(false)}
                        >
                            <svg width="64" height="48" viewBox="0 0 64 48" style={{ imageRendering: 'pixelated' }}>
                                {/* Cute dog - full black, running animation */}
                                {/* Body */}
                                <rect x="16" y="16" width="32" height="16" fill="#000" />
                                {/* Head - rounder, cuter */}
                                <rect x="4" y="12" width="16" height="16" fill="#000" />
                                {/* Floppy ears */}
                                <rect x="2" y="4" width="6" height="14" fill="#000" />
                                <rect x="14" y="4" width="6" height="14" fill="#000" />
                                {/* Eye - big cute eye */}
                                <rect x="8" y="16" width="6" height="6" fill="#fff" />
                                <rect x="10" y="18" width="3" height="3" fill="#000" />
                                {/* Nose */}
                                <rect x="4" y="22" width="4" height="4" fill="#000" />
                                {/* Tongue when running */}
                                <rect x="2" y="26" width="4" height="2" fill="#000" />
                                {/* Running legs animation using frame counter */}
                                <rect x="16" y="32" width="6" height={Math.sin(Date.now() / 100) > 0 ? 10 : 14} fill="#000" />
                                <rect x="26" y="32" width="6" height={Math.sin(Date.now() / 100) > 0 ? 14 : 10} fill="#000" />
                                <rect x="34" y="32" width="6" height={Math.sin(Date.now() / 100) > 0 ? 10 : 14} fill="#000" />
                                <rect x="42" y="32" width="6" height={Math.sin(Date.now() / 100) > 0 ? 14 : 10} fill="#000" />
                                {/* Tail - wagging */}
                                <rect x="48" y={12 + Math.sin(Date.now() / 150) * 4} width="12" height="4" fill="#000" />
                                <rect x="58" y={8 + Math.sin(Date.now() / 150) * 4} width="4" height="6" fill="#000" />
                            </svg>
                            {carriedIcon && (
                                <div
                                    className="absolute bg-white border-2 border-black p-1"
                                    style={{ top: -20, left: 8 }}
                                >
                                    {React.createElement(Icons[windows[carriedIcon]?.icon], { size: 24 })}
                                </div>
                            )}
                        </div>
                    )}

                    {/* CRT Static overlay for destruction */}
                    {destructionMode === true && (
                        <div className="fixed inset-0 z-[999998] pointer-events-none crt-static" />
                    )}

                    {/* Glitch animation styles */}
                    <style>{`
                        @keyframes glitch {
                            0% { transform: translate(0); filter: hue-rotate(0deg); }
                            20% { transform: translate(-2px, 2px); filter: hue-rotate(90deg); }
                            40% { transform: translate(2px, -2px); filter: hue-rotate(180deg); }
                            60% { transform: translate(-2px, -2px); filter: hue-rotate(270deg); }
                            80% { transform: translate(2px, 2px); filter: hue-rotate(360deg); }
                            100% { transform: translate(0); filter: hue-rotate(0deg); }
                        }
                        .group-hover\\:animate-glitch:hover {
                            animation: glitch 0.2s infinite;
                        }
                        .destruction-icon:hover {
                            animation: glitch 0.3s infinite;
                        }
                        .crt-static {
                            background: repeating-linear-gradient(
                                0deg,
                                rgba(0, 0, 0, 0.1) 0px,
                                rgba(0, 0, 0, 0.1) 1px,
                                transparent 1px,
                                transparent 2px
                            );
                            animation: static 0.1s infinite;
                        }
                        @keyframes static {
                            0% { opacity: 0.3; }
                            50% { opacity: 0.5; }
                            100% { opacity: 0.3; }
                        }
                    `}</style>

                </div>
            )
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<OS />);
    </script>
</body>

</html>
